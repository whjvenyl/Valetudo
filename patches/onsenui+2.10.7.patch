diff --git a/node_modules/onsenui/js/onsenui.js b/node_modules/onsenui/js/onsenui.js
new file mode 100644
index 0000000..4bb1a11
--- /dev/null
+++ b/node_modules/onsenui/js/onsenui.js
@@ -0,0 +1,31911 @@
+/* onsenui v2.10.7 - 2019-04-01 */
+
+(function (global, factory) {
+	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
+	typeof define === 'function' && define.amd ? define(factory) :
+	(global.ons = factory());
+}(this, (function () { 'use strict';
+
+var onsElements = {};
+
+/*
+Copyright 2013-2015 ASIAL CORPORATION
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+   http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+*/
+
+/**
+ * Add vendor prefix.
+ *
+ * @param {String} name
+ * @return {String}
+ */
+var prefix = function () {
+  var styles = window.getComputedStyle(document.documentElement, '');
+  var prefix = (Array.prototype.slice.call(styles).join('').match(/-(moz|webkit|ms)-/) || styles.OLink === '' && ['', 'o'])[1];
+
+  return function (name) {
+    return '-' + prefix + '-' + util$1.hyphenate(name);
+  };
+}();
+
+/**
+ * Minimal utility library for manipulating element's style.
+ * Set element's style.
+ *
+ * @param {Element} element
+ * @param {Object} styles
+ * @return {Element}
+ */
+var styler = function styler(element, style) {
+  Object.keys(style).forEach(function (key) {
+    if (key in element.style) {
+      element.style[key] = style[key];
+    } else if (prefix(key) in element.style) {
+      element.style[prefix(key)] = style[key];
+    } else {
+      util$1.warn('No such style property: ' + key);
+    }
+  });
+  return element;
+};
+
+/**
+ * @param {Element} element
+ * @param {String} styles Space-separated CSS properties to remove
+ */
+styler.clear = function (element) {
+  var styles = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
+
+  var clearlist = styles.split(/\s+/).reduce(function (r, s) {
+    return r.concat([util$1.hyphenate(s), prefix(s)]);
+  }, []),
+      keys = [];
+
+  var _loop = function _loop(i) {
+    var key = element.style[i];
+    if (clearlist.length === 0 || clearlist.some(function (s) {
+      return key.indexOf(s) === 0;
+    })) {
+      keys.push(key); // Store the key to fix Safari style indexes
+    }
+  };
+
+  for (var i = element.style.length - 1; i >= 0; i--) {
+    _loop(i);
+  }
+
+  keys.forEach(function (key) {
+    return element.style[key] = '';
+  });
+  element.getAttribute('style') === '' && element.removeAttribute('style');
+};
+
+var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
+  return typeof obj;
+} : function (obj) {
+  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
+};
+
+
+
+
+
+
+
+
+
+
+
+var classCallCheck = function (instance, Constructor) {
+  if (!(instance instanceof Constructor)) {
+    throw new TypeError("Cannot call a class as a function");
+  }
+};
+
+var createClass = function () {
+  function defineProperties(target, props) {
+    for (var i = 0; i < props.length; i++) {
+      var descriptor = props[i];
+      descriptor.enumerable = descriptor.enumerable || false;
+      descriptor.configurable = true;
+      if ("value" in descriptor) descriptor.writable = true;
+      Object.defineProperty(target, descriptor.key, descriptor);
+    }
+  }
+
+  return function (Constructor, protoProps, staticProps) {
+    if (protoProps) defineProperties(Constructor.prototype, protoProps);
+    if (staticProps) defineProperties(Constructor, staticProps);
+    return Constructor;
+  };
+}();
+
+
+
+
+
+var defineProperty = function (obj, key, value) {
+  if (key in obj) {
+    Object.defineProperty(obj, key, {
+      value: value,
+      enumerable: true,
+      configurable: true,
+      writable: true
+    });
+  } else {
+    obj[key] = value;
+  }
+
+  return obj;
+};
+
+var _extends = Object.assign || function (target) {
+  for (var i = 1; i < arguments.length; i++) {
+    var source = arguments[i];
+
+    for (var key in source) {
+      if (Object.prototype.hasOwnProperty.call(source, key)) {
+        target[key] = source[key];
+      }
+    }
+  }
+
+  return target;
+};
+
+var get = function get(object, property, receiver) {
+  if (object === null) object = Function.prototype;
+  var desc = Object.getOwnPropertyDescriptor(object, property);
+
+  if (desc === undefined) {
+    var parent = Object.getPrototypeOf(object);
+
+    if (parent === null) {
+      return undefined;
+    } else {
+      return get(parent, property, receiver);
+    }
+  } else if ("value" in desc) {
+    return desc.value;
+  } else {
+    var getter = desc.get;
+
+    if (getter === undefined) {
+      return undefined;
+    }
+
+    return getter.call(receiver);
+  }
+};
+
+var inherits = function (subClass, superClass) {
+  if (typeof superClass !== "function" && superClass !== null) {
+    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
+  }
+
+  subClass.prototype = Object.create(superClass && superClass.prototype, {
+    constructor: {
+      value: subClass,
+      enumerable: false,
+      writable: true,
+      configurable: true
+    }
+  });
+  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
+};
+
+
+
+
+
+
+
+
+
+var objectWithoutProperties = function (obj, keys) {
+  var target = {};
+
+  for (var i in obj) {
+    if (keys.indexOf(i) >= 0) continue;
+    if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;
+    target[i] = obj[i];
+  }
+
+  return target;
+};
+
+var possibleConstructorReturn = function (self, call) {
+  if (!self) {
+    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
+  }
+
+  return call && (typeof call === "object" || typeof call === "function") ? call : self;
+};
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+var toConsumableArray = function (arr) {
+  if (Array.isArray(arr)) {
+    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];
+
+    return arr2;
+  } else {
+    return Array.from(arr);
+  }
+};
+
+/*
+Copyright 2013-2015 ASIAL CORPORATION
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+   http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+*/
+
+// Save HTMLElement object before Custom Elements polyfill patch global HTMLElement.
+var NativeHTMLElement = window.HTMLElement;
+
+/**
+ * @object ons.platform
+ * @category util
+ * @description
+ *   [en]Utility methods to detect current platform.[/en]
+ *   [ja]現在実行されているプラットフォームを検知するためのユーティリティメソッドを収めたオブジェクトです。[/ja]
+ */
+
+var Platform = function () {
+
+  /**
+   * All elements will be rendered as if the app was running on this platform.
+   * @type {String}
+   */
+  function Platform() {
+    classCallCheck(this, Platform);
+
+    this._selectedPlatform = null;
+    this._ignorePlatformSelect = false;
+  }
+
+  /**
+   * @method select
+   * @signature select(platform)
+   * @param  {string} platform Name of the platform.
+   *   [en]Possible values are: "opera", "firefox", "safari", "chrome", "ie", "android", "blackberry", "ios" or "wp".[/en]
+   *   [ja]"opera", "firefox", "safari", "chrome", "ie", "android", "blackberry", "ios", "wp"のいずれかを指定します。[/ja]
+   * @description
+   *   [en]Sets the platform used to render the elements. Useful for testing.[/en]
+   *   [ja]要素を描画するために利用するプラットフォーム名を設定します。テストに便利です。[/ja]
+   */
+
+
+  createClass(Platform, [{
+    key: 'select',
+    value: function select(platform) {
+      if (typeof platform === 'string') {
+        this._selectedPlatform = platform.trim().toLowerCase();
+      }
+    }
+  }, {
+    key: '_getSelectedPlatform',
+    value: function _getSelectedPlatform() {
+      return this._ignorePlatformSelect ? null : this._selectedPlatform;
+    }
+  }, {
+    key: '_runOnActualPlatform',
+    value: function _runOnActualPlatform(fn) {
+      this._ignorePlatformSelect = true;
+      var result = fn();
+      this._ignorePlatformSelect = false;
+
+      return result;
+    }
+
+    //----------------
+    // General
+    //----------------
+    /**
+     * @method isWebView
+     * @signature isWebView()
+     * @description
+     *   [en]Returns whether app is running in Cordova.[/en]
+     *   [ja]Cordova内で実行されているかどうかを返します。[/ja]
+     * @return {Boolean}
+     */
+
+  }, {
+    key: 'isWebView',
+    value: function isWebView() {
+      if (document.readyState === 'loading' || document.readyState == 'uninitialized') {
+        throw new Error('isWebView() method is available after dom contents loaded.');
+      }
+
+      return !!(window.cordova || window.phonegap || window.PhoneGap);
+    }
+
+    //----------------
+    // iOS devices
+    //----------------
+    /**
+     * @method isIPhone
+     * @signature isIPhone()
+     * @description
+     *   [en]Returns whether the device is iPhone.[/en]
+     *   [ja]iPhone上で実行されているかどうかを返します。[/ja]
+     * @return {Boolean}
+     */
+
+  }, {
+    key: 'isIPhone',
+    value: function isIPhone() {
+      return (/iPhone/i.test(navigator.userAgent)
+      );
+    }
+
+    /**
+     * @method isIPhoneX
+     * @signature isIPhoneX()
+     * @description
+     *   [en]Returns whether the device is iPhone X, XS, XS Max, or XR.[/en]
+     *   [ja]iPhone X や XS、XS Max、または XR 上で実行されているかどうかを返します。[/ja]
+     * @return {Boolean}
+     */
+
+  }, {
+    key: 'isIPhoneX',
+    value: function isIPhoneX() {
+      // iOS WebViews on the same iOS version have the same user agent.
+      // We cannot avoid using window.screen.
+      // We also cannot use cordova-plugin-device since its behavior is different between simulators and real devices.
+      // This works well both in iOS Safari and (UI|WK)WebView of iPhone X.
+      return this.isIPhone() && (window.screen.width === 375 && window.screen.height === 812 || // X, XS portrait
+      window.screen.width === 812 && window.screen.height === 375 || // X, XS landscape
+      window.screen.width === 414 && window.screen.height === 896 || // XS Max, XR portrait
+      window.screen.width === 896 && window.screen.height === 414); // XS Max, XR landscape
+    }
+
+    /**
+     * @method isIPad
+     * @signature isIPad()
+     * @description
+     *   [en]Returns whether the device is iPad.[/en]
+     *   [ja]iPad上で実行されているかどうかを返します。[/ja]
+     * @return {Boolean}
+     */
+
+  }, {
+    key: 'isIPad',
+    value: function isIPad() {
+      return (/iPad/i.test(navigator.userAgent)
+      );
+    }
+
+    /**
+     * @return {Boolean}
+     */
+
+  }, {
+    key: 'isIPod',
+    value: function isIPod() {
+      return (/iPod/i.test(navigator.userAgent)
+      );
+    }
+
+    //----------------
+    // iOS versions
+    //----------------
+    /**
+     * @method isIOS
+     * @signature isIOS([forceActualPlatform])
+     * @param {Boolean} forceActualPlatform
+     *   [en]If true, selected platform is ignored and the actual platform is returned.[/en]
+     *   [ja][/ja]
+     * @description
+     *   [en]Returns whether the OS is iOS. By default will return manually selected platform if it is set.[/en]
+     *   [ja]iOS上で実行されているかどうかを返します。[/ja]
+     * @return {Boolean}
+     */
+
+  }, {
+    key: 'isIOS',
+    value: function isIOS(forceActualPlatform) {
+      if (!forceActualPlatform && this._getSelectedPlatform()) {
+        return this._getSelectedPlatform() === 'ios';
+      }
+
+      if ((typeof device === 'undefined' ? 'undefined' : _typeof(device)) === 'object' && !/browser/i.test(device.platform)) {
+        return (/iOS/i.test(device.platform)
+        );
+      } else {
+        return (/iPhone|iPad|iPod/i.test(navigator.userAgent)
+        );
+      }
+    }
+
+    /**
+     * @method isIOS7above
+     * @signature isIOS7above()
+     * @description
+     *   [en]Returns whether the iOS version is 7 or above.[/en]
+     *   [ja]iOS7以上で実行されているかどうかを返します。[/ja]
+     * @return {Boolean}
+     */
+
+  }, {
+    key: 'isIOS7above',
+    value: function isIOS7above() {
+      if ((typeof device === 'undefined' ? 'undefined' : _typeof(device)) === 'object' && !/browser/i.test(device.platform)) {
+        return (/iOS/i.test(device.platform) && parseInt(device.version.split('.')[0]) >= 7
+        );
+      } else if (/iPhone|iPad|iPod/i.test(navigator.userAgent)) {
+        var ver = (navigator.userAgent.match(/\b[0-9]+_[0-9]+(?:_[0-9]+)?\b/) || [''])[0].replace(/_/g, '.');
+        return parseInt(ver.split('.')[0]) >= 7;
+      }
+      return false;
+    }
+
+    //----------------
+    // iOS browsers
+    //----------------
+    /**
+     * @method isIOSSafari
+     * @signature isIOSSafari()
+     * @description
+     *   [en]Returns whether app is running in iOS Safari.[/en]
+     *   [ja]iOS Safariで実行されているかどうかを返します。[/ja]
+     * @return {Boolean}
+     */
+
+  }, {
+    key: 'isIOSSafari',
+    value: function isIOSSafari() {
+      var navigator = window.navigator;
+      var ua = navigator.userAgent;
+
+      return !!(this.isIOS() && ua.indexOf('Safari') !== -1 && ua.indexOf('Version') !== -1 && !navigator.standalone);
+    }
+
+    /**
+     * @method isWKWebView
+     * @signature isWKWebView()
+     * @description
+     *   [en]Returns whether app is running in WKWebView.[/en]
+     *   [ja]WKWebViewで実行されているかどうかを返します。[/ja]
+     * @return {Boolean}
+     */
+
+  }, {
+    key: 'isWKWebView',
+    value: function isWKWebView() {
+      var lte9 = /constructor/i.test(NativeHTMLElement);
+      return !!(this.isIOS() && window.webkit && window.webkit.messageHandlers && window.indexedDB && !lte9);
+    }
+
+    /**
+     * @method isUIWebView
+     * @signature isUIWebView()
+     * @description
+     *   [en]Returns whether app is running in UIWebView.[/en]
+     *   [ja]UIWebViewで実行されているかどうかを返します。[/ja]
+     * @return {Boolean}
+     */
+
+  }, {
+    key: 'isUIWebView',
+    value: function isUIWebView() {
+      return !!(this.isIOS() && !this.isIOSSafari() && !this.isWKWebView());
+    }
+
+    //----------------
+    // Android devices
+    //----------------
+    /**
+     * @method isAndroidPhone
+     * @signature isAndroidPhone()
+     * @description
+     *   [en]Returns whether the device is Android phone.[/en]
+     *   [ja]Android携帯上で実行されているかどうかを返します。[/ja]
+     * @return {Boolean}
+     */
+
+  }, {
+    key: 'isAndroidPhone',
+    value: function isAndroidPhone() {
+      return (/Android/i.test(navigator.userAgent) && /Mobile/i.test(navigator.userAgent)
+      );
+    }
+
+    /**
+     * @method isAndroidTablet
+     * @signature isAndroidTablet()
+     * @description
+     *   [en]Returns whether the device is Android tablet.[/en]
+     *   [ja]Androidタブレット上で実行されているかどうかを返します。[/ja]
+     * @return {Boolean}
+     */
+
+  }, {
+    key: 'isAndroidTablet',
+    value: function isAndroidTablet() {
+      return (/Android/i.test(navigator.userAgent) && !/Mobile/i.test(navigator.userAgent)
+      );
+    }
+
+    //----------------
+    // Android versions
+    //----------------
+    /**
+     * @method isAndroid
+     * @signature isAndroid([forceActualPlatform])
+     * @param {Boolean} forceActualPlatform
+     *   [en]If true, selected platform is ignored and the actual platform is returned.[/en]
+     *   [ja][/ja]
+     * @description
+     *   [en]Returns whether the OS is Android. By default will return manually selected platform if it is set.[/en]
+     *   [ja]Android上で実行されているかどうかを返します。[/ja]
+     * @return {Boolean}
+     */
+
+  }, {
+    key: 'isAndroid',
+    value: function isAndroid(forceActualPlatform) {
+      if (!forceActualPlatform && this._getSelectedPlatform()) {
+        return this._getSelectedPlatform() === 'android';
+      }
+
+      if ((typeof device === 'undefined' ? 'undefined' : _typeof(device)) === 'object' && !/browser/i.test(device.platform)) {
+        return (/Android/i.test(device.platform)
+        );
+      } else {
+        return (/Android/i.test(navigator.userAgent)
+        );
+      }
+    }
+
+    //----------------
+    // Other devices
+    //----------------
+    /**
+     * @method isWP
+     * @signature isWP([forceActualPlatform])
+     * @param {Boolean} forceActualPlatform
+     *   [en]If true, selected platform is ignored and the actual platform is returned.[/en]
+     *   [ja][/ja]
+     * @description
+     *   [en]Returns whether the OS is Windows phone. By default will return manually selected platform if it is set.[/en]
+     *   [ja][/ja]
+     * @return {Boolean}
+     */
+
+  }, {
+    key: 'isWP',
+    value: function isWP(forceActualPlatform) {
+      if (!forceActualPlatform && this._getSelectedPlatform()) {
+        return this._getSelectedPlatform() === 'wp';
+      }
+
+      if ((typeof device === 'undefined' ? 'undefined' : _typeof(device)) === 'object' && !/browser/i.test(device.platform)) {
+        return (/Win32NT|WinCE/i.test(device.platform)
+        );
+      } else {
+        return (/Windows Phone|IEMobile|WPDesktop/i.test(navigator.userAgent)
+        );
+      }
+    }
+
+    /**
+     * @method isBlackBerry
+     * @signature isBlackBerry([forceActualPlatform])
+     * @param {Boolean} forceActualPlatform
+     *   [en]If true, selected platform is ignored and the actual platform is returned.[/en]
+     *   [ja][/ja]
+     * @description
+     *   [en]Returns whether the device is BlackBerry. By default will return manually selected platform if it is set.[/en]
+     *   [ja]BlackBerry上で実行されているかどうかを返します。[/ja]
+     * @return {Boolean}
+     */
+
+  }, {
+    key: 'isBlackBerry',
+    value: function isBlackBerry(forceActualPlatform) {
+      if (!forceActualPlatform && this._getSelectedPlatform()) {
+        return this._getSelectedPlatform() === 'blackberry';
+      }
+
+      if ((typeof device === 'undefined' ? 'undefined' : _typeof(device)) === 'object' && !/browser/i.test(device.platform)) {
+        return (/BlackBerry/i.test(device.platform)
+        );
+      } else {
+        return (/BlackBerry|RIM Tablet OS|BB10/i.test(navigator.userAgent)
+        );
+      }
+    }
+
+    //----------------
+    // Other browsers
+    //----------------
+    /**
+     * @method isOpera
+     * @signature isOpera([forceActualPlatform])
+     * @param {Boolean} forceActualPlatform
+     *   [en]If true, selected platform is ignored and the actual platform is returned.[/en]
+     *   [ja][/ja]
+     * @description
+     *   [en]Returns whether the browser is Opera. By default will return manually selected platform if it is set.[/en]
+     *   [ja]Opera上で実行されているかどうかを返します。[/ja]
+     * @return {Boolean}
+     */
+
+  }, {
+    key: 'isOpera',
+    value: function isOpera(forceActualPlatform) {
+      if (!forceActualPlatform && this._getSelectedPlatform()) {
+        return this._getSelectedPlatform() === 'opera';
+      }
+
+      return !!window.opera || navigator.userAgent.indexOf(' OPR/') >= 0;
+    }
+
+    /**
+     * @method isFirefox
+     * @signature isFirefox([forceActualPlatform])
+     * @param {Boolean} forceActualPlatform
+     *   [en]If true, selected platform is ignored and the actual platform is returned.[/en]
+     *   [ja][/ja]
+     * @description
+     *   [en]Returns whether the browser is Firefox. By default will return manually selected platform if it is set.[/en]
+     *   [ja]Firefox上で実行されているかどうかを返します。[/ja]
+     * @return {Boolean}
+     */
+
+  }, {
+    key: 'isFirefox',
+    value: function isFirefox(forceActualPlatform) {
+      if (!forceActualPlatform && this._getSelectedPlatform()) {
+        return this._getSelectedPlatform() === 'firefox';
+      }
+
+      return typeof InstallTrigger !== 'undefined';
+    }
+
+    /**
+     * @method isSafari
+     * @signature isSafari([forceActualPlatform])
+     * @param {Boolean} forceActualPlatform
+     *   [en]If true, selected platform is ignored and the actual platform is returned.[/en]
+     *   [ja][/ja]
+     * @description
+     *   [en]Returns whether the browser is Safari. By default will return manually selected platform if it is set.[/en]
+     *   [ja]Safari上で実行されているかどうかを返します。[/ja]
+     * @return {Boolean}
+     */
+
+  }, {
+    key: 'isSafari',
+    value: function isSafari(forceActualPlatform) {
+      if (!forceActualPlatform && this._getSelectedPlatform()) {
+        return this._getSelectedPlatform() === 'safari';
+      }
+
+      return Object.prototype.toString.call(window.HTMLElement).indexOf('Constructor') > 0 || function (p) {
+        return p.toString() === '[object SafariRemoteNotification]';
+      }(!window['safari'] || safari.pushNotification);
+    }
+
+    /**
+     * @method isChrome
+     * @signature isChrome([forceActualPlatform])
+     * @param {Boolean} forceActualPlatform
+     *   [en]If true, selected platform is ignored and the actual platform is returned.[/en]
+     *   [ja][/ja]
+     * @description
+     *   [en]Returns whether the browser is Chrome. By default will return manually selected platform if it is set.[/en]
+     *   [ja]Chrome上で実行されているかどうかを返します。[/ja]
+     * @return {Boolean}
+     */
+
+  }, {
+    key: 'isChrome',
+    value: function isChrome(forceActualPlatform) {
+      if (!forceActualPlatform && this._getSelectedPlatform()) {
+        return this._getSelectedPlatform() === 'chrome';
+      }
+
+      return !!window.chrome && !(!!window.opera || navigator.userAgent.indexOf(' OPR/') >= 0) && !(navigator.userAgent.indexOf(' Edge/') >= 0);
+    }
+
+    /**
+     * @method isIE
+     * @signature isIE([forceActualPlatform])
+     * @param {Boolean} forceActualPlatform
+     *   [en]If true, selected platform is ignored and the actual platform is returned.[/en]
+     *   [ja][/ja]
+     * @description
+     *   [en]Returns whether the browser is Internet Explorer. By default will return manually selected platform if it is set.[/en]
+     *   [ja]Internet Explorer上で実行されているかどうかを返します。[/ja]
+     * @return {Boolean}
+     */
+
+  }, {
+    key: 'isIE',
+    value: function isIE(forceActualPlatform) {
+      if (!forceActualPlatform && this._getSelectedPlatform()) {
+        return this._getSelectedPlatform() === 'ie';
+      }
+
+      return false || !!document.documentMode;
+    }
+
+    /**
+     * @method isEdge
+     * @signature isEdge([forceActualPlatform])
+     * @param {Boolean} forceActualPlatform
+     *   [en]If true, selected platform is ignored and the actual platform is returned.[/en]
+     *   [ja][/ja]
+     * @description
+     *   [en]Returns whether the browser is Edge. By default will return manually selected platform if it is set.[/en]
+     *   [ja]Edge上で実行されているかどうかを返します。[/ja]
+     * @return {Boolean}
+     */
+
+  }, {
+    key: 'isEdge',
+    value: function isEdge(forceActualPlatform) {
+      if (!forceActualPlatform && this._getSelectedPlatform()) {
+        return this._getSelectedPlatform() === 'edge';
+      }
+
+      return navigator.userAgent.indexOf(' Edge/') >= 0;
+    }
+
+    //----------------
+    // Utility functions
+    //----------------
+    /**
+     * @return {String}
+     */
+
+  }, {
+    key: 'getMobileOS',
+    value: function getMobileOS() {
+      if (this.isAndroid()) {
+        return 'android';
+      } else if (this.isIOS()) {
+        return 'ios';
+      } else if (this.isWP()) {
+        return 'wp';
+      } else {
+        return 'other';
+      }
+    }
+
+    /**
+     * @return {String}
+     */
+
+  }, {
+    key: 'getIOSDevice',
+    value: function getIOSDevice() {
+      if (this.isIPhone()) {
+        return 'iphone';
+      } else if (this.isIPad()) {
+        return 'ipad';
+      } else if (this.isIPod()) {
+        return 'ipod';
+      } else {
+        return 'na';
+      }
+    }
+  }]);
+  return Platform;
+}();
+
+var platform = new Platform();
+
+/*
+Copyright 2013-2015 ASIAL CORPORATION
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+   http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+*/
+
+var error = function error(message) {
+  return util$1.throw('In PageAttributeExpression: ' + message);
+};
+
+var pageAttributeExpression = {
+  _variables: {},
+
+  /**
+   * Define a variable.
+   *
+   * @param {String} name Name of the variable
+   * @param {String|Function} value Value of the variable. Can be a string or a function. The function must return a string.
+   * @param {Boolean} overwrite If this value is false, an error will be thrown when trying to define a variable that has already been defined.
+   */
+  defineVariable: function defineVariable(name, value) {
+    var overwrite = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
+
+    if (typeof name !== 'string') {
+      error('Variable name must be a string');
+    } else if (typeof value !== 'string' && typeof value !== 'function') {
+      error('Variable value must be a string or a function');
+    } else if (this._variables.hasOwnProperty(name) && !overwrite) {
+      error('"' + name + '" is already defined');
+    }
+    this._variables[name] = value;
+  },
+
+  /**
+   * Get a variable.
+   *
+   * @param {String} name Name of the variable.
+   * @return {String|Function|null}
+   */
+  getVariable: function getVariable(name) {
+    if (!this._variables.hasOwnProperty(name)) {
+      return null;
+    }
+
+    return this._variables[name];
+  },
+
+  /**
+   * Remove a variable.
+   *
+   * @param {String} name Name of the varaible.
+   */
+  removeVariable: function removeVariable(name) {
+    delete this._variables[name];
+  },
+
+  /**
+   * Get all variables.
+   *
+   * @return {Object}
+   */
+  getAllVariables: function getAllVariables() {
+    return this._variables;
+  },
+  _parsePart: function _parsePart(part) {
+    var c = void 0,
+        inInterpolation = false,
+        currentIndex = 0;
+
+    var tokens = [];
+
+    if (part.length === 0) {
+      error('Unable to parse empty string');
+    }
+
+    for (var i = 0; i < part.length; i++) {
+      c = part.charAt(i);
+
+      if (c === '$' && part.charAt(i + 1) === '{') {
+        if (inInterpolation) {
+          error('Nested interpolation not supported');
+        }
+
+        var token = part.substring(currentIndex, i);
+        if (token.length > 0) {
+          tokens.push(part.substring(currentIndex, i));
+        }
+
+        currentIndex = i;
+        inInterpolation = true;
+      } else if (c === '}') {
+        if (!inInterpolation) {
+          error('} must be preceeded by ${');
+        }
+
+        var _token = part.substring(currentIndex, i + 1);
+        if (_token.length > 0) {
+          tokens.push(part.substring(currentIndex, i + 1));
+        }
+
+        currentIndex = i + 1;
+        inInterpolation = false;
+      }
+    }
+
+    if (inInterpolation) {
+      error('Unterminated interpolation');
+    }
+
+    tokens.push(part.substring(currentIndex, part.length));
+
+    return tokens;
+  },
+  _replaceToken: function _replaceToken(token) {
+    var re = /^\${(.*?)}$/,
+        match = token.match(re);
+
+    if (match) {
+      var name = match[1].trim();
+      var variable = this.getVariable(name);
+
+      if (variable === null) {
+        error('Variable "' + name + '" does not exist');
+      } else if (typeof variable === 'string') {
+        return variable;
+      } else {
+        var rv = variable();
+
+        if (typeof rv !== 'string') {
+          error('Must return a string');
+        }
+
+        return rv;
+      }
+    } else {
+      return token;
+    }
+  },
+  _replaceTokens: function _replaceTokens(tokens) {
+    return tokens.map(this._replaceToken.bind(this));
+  },
+  _parseExpression: function _parseExpression(expression) {
+    return expression.split(',').map(function (part) {
+      return part.trim();
+    }).map(this._parsePart.bind(this)).map(this._replaceTokens.bind(this)).map(function (part) {
+      return part.join('');
+    });
+  },
+
+  /**
+   * Evaluate an expression.
+   *
+   * @param {String} expression An page attribute expression.
+   * @return {Array}
+   */
+  evaluate: function evaluate(expression) {
+    if (!expression) {
+      return [];
+    }
+
+    return this._parseExpression(expression);
+  }
+};
+
+// Define default variables.
+pageAttributeExpression.defineVariable('mobileOS', platform.getMobileOS());
+pageAttributeExpression.defineVariable('iOSDevice', platform.getIOSDevice());
+pageAttributeExpression.defineVariable('runtime', function () {
+  return platform.isWebView() ? 'cordova' : 'browser';
+});
+
+/*
+Copyright 2013-2015 ASIAL CORPORATION
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+   http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+*/
+
+var internal$1 = {};
+
+internal$1.config = {
+  autoStatusBarFill: true,
+  animationsDisabled: false,
+  warningsDisabled: false
+};
+
+internal$1.nullElement = window.document.createElement('div');
+
+/**
+ * @return {Boolean}
+ */
+internal$1.isEnabledAutoStatusBarFill = function () {
+  return !!internal$1.config.autoStatusBarFill;
+};
+
+/**
+ * @param {String} html
+ * @return {String}
+ */
+internal$1.normalizePageHTML = function (html) {
+  return ('' + html).trim();
+};
+
+internal$1.waitDOMContentLoaded = function (callback) {
+  if (window.document.readyState === 'loading' || window.document.readyState == 'uninitialized') {
+    var wrappedCallback = function wrappedCallback() {
+      callback();
+      window.document.removeEventListener('DOMContentLoaded', wrappedCallback);
+    };
+    window.document.addEventListener('DOMContentLoaded', wrappedCallback);
+  } else {
+    setImmediate(callback);
+  }
+};
+
+internal$1.autoStatusBarFill = function (action) {
+  var onReady = function onReady() {
+    if (internal$1.shouldFillStatusBar()) {
+      action();
+    }
+    document.removeEventListener('deviceready', onReady);
+  };
+
+  if ((typeof device === 'undefined' ? 'undefined' : _typeof(device)) === 'object') {
+    document.addEventListener('deviceready', onReady);
+  } else if (['complete', 'interactive'].indexOf(document.readyState) === -1) {
+    internal$1.waitDOMContentLoaded(onReady);
+  } else {
+    onReady();
+  }
+};
+
+internal$1.shouldFillStatusBar = function () {
+  return internal$1.isEnabledAutoStatusBarFill() && (platform.isWebView() && platform.isIOS7above() && !platform.isIPhoneX() || document.body.querySelector('.ons-status-bar-mock.ios'));
+};
+
+internal$1.templateStore = {
+  _storage: {},
+
+  /**
+   * @param {String} key
+   * @return {String/null} template
+   */
+  get: function get$$1(key) {
+    return internal$1.templateStore._storage[key] || null;
+  },
+
+
+  /**
+   * @param {String} key
+   * @param {String} template
+   */
+  set: function set$$1(key, template) {
+    internal$1.templateStore._storage[key] = template;
+  }
+};
+
+window.document.addEventListener('_templateloaded', function (e) {
+  if (e.target.nodeName.toLowerCase() === 'ons-template') {
+    internal$1.templateStore.set(e.templateId, e.template);
+  }
+}, false);
+
+internal$1.waitDOMContentLoaded(function () {
+  register('script[type="text/ons-template"]');
+  register('script[type="text/template"]');
+  register('script[type="text/ng-template"]');
+  register('template');
+
+  function register(query) {
+    var templates = window.document.querySelectorAll(query);
+    for (var i = 0; i < templates.length; i++) {
+      internal$1.templateStore.set(templates[i].getAttribute('id'), templates[i].textContent || templates[i].content);
+    }
+  }
+});
+
+/**
+ * @param {String} page
+ * @return {Promise}
+ */
+internal$1.getTemplateHTMLAsync = function (page) {
+  return new Promise(function (resolve, reject) {
+    internal$1.waitDOMContentLoaded(function () {
+      var cache = internal$1.templateStore.get(page);
+      if (cache) {
+        if (cache instanceof DocumentFragment) {
+          return resolve(cache);
+        }
+
+        var html = typeof cache === 'string' ? cache : cache[1];
+        return resolve(internal$1.normalizePageHTML(html));
+      }
+
+      var local = window.document.getElementById(page);
+      if (local) {
+        var _html = local.textContent || local.content;
+        return resolve(_html);
+      }
+
+      var xhr = new XMLHttpRequest();
+      xhr.open('GET', page, true);
+      xhr.onload = function () {
+        var html = xhr.responseText;
+        if (xhr.status >= 400 && xhr.status < 600) {
+          reject(html);
+        } else {
+          // Refresh script tags
+          var fragment = util$1.createFragment(html);
+          util$1.arrayFrom(fragment.querySelectorAll('script')).forEach(function (el) {
+            var script = document.createElement('script');
+            script.type = el.type || 'text/javascript';
+            script.appendChild(document.createTextNode(el.text || el.textContent || el.innerHTML));
+            el.parentNode.replaceChild(script, el);
+          });
+
+          internal$1.templateStore.set(page, fragment);
+          resolve(fragment);
+        }
+      };
+      xhr.onerror = function () {
+        util$1.throw('Page template not found: ' + page);
+      };
+      xhr.send(null);
+    });
+  });
+};
+
+/**
+ * @param {String} page
+ * @return {Promise}
+ */
+internal$1.getPageHTMLAsync = function (page) {
+  var pages = pageAttributeExpression.evaluate(page);
+
+  var getPage = function getPage(page) {
+    if (typeof page !== 'string') {
+      return Promise.reject('Must specify a page.');
+    }
+
+    return internal$1.getTemplateHTMLAsync(page).catch(function (error) {
+      if (pages.length === 0) {
+        return Promise.reject(error);
+      }
+
+      return getPage(pages.shift());
+    });
+  };
+
+  return getPage(pages.shift());
+};
+
+/*
+Copyright 2013-2015 ASIAL CORPORATION
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+   http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+*/
+
+var AnimatorFactory = function () {
+
+  /**
+   * @param {Object} opts
+   * @param {Object} opts.animators The dictionary for animator classes
+   * @param {Function} opts.baseClass The base class of animators
+   * @param {String} [opts.baseClassName] The name of the base class of animators
+   * @param {String} [opts.defaultAnimation] The default animation name
+   * @param {Object} [opts.defaultAnimationOptions] The default animation options
+   */
+  function AnimatorFactory(opts) {
+    classCallCheck(this, AnimatorFactory);
+
+    this._animators = opts.animators;
+    this._baseClass = opts.baseClass;
+    this._baseClassName = opts.baseClassName || opts.baseClass.name;
+    this._animation = opts.defaultAnimation || 'default';
+    this._animationOptions = opts.defaultAnimationOptions || {};
+
+    if (!this._animators[this._animation]) {
+      util$1.throw('No such animation: ' + this._animation);
+    }
+  }
+
+  /**
+   * @param {String} jsonString
+   * @return {Object/null}
+   */
+
+
+  createClass(AnimatorFactory, [{
+    key: 'setAnimationOptions',
+
+
+    /**
+     * @param {Object} options
+     */
+    value: function setAnimationOptions(options) {
+      this._animationOptions = options;
+    }
+
+    /**
+     * @param {Object} options
+     * @param {String} [options.animation] The animation name
+     * @param {Object} [options.animationOptions] The animation options
+     * @param {Object} defaultAnimator The default animator instance
+     * @return {Object} An animator instance
+     */
+
+  }, {
+    key: 'newAnimator',
+    value: function newAnimator() {
+      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
+      var defaultAnimator = arguments[1];
+
+
+      var animator = null;
+
+      if (options.animation instanceof this._baseClass) {
+        return options.animation;
+      }
+
+      var Animator = null;
+
+      if (typeof options.animation === 'string') {
+        Animator = this._animators[options.animation];
+      }
+
+      if (!Animator && defaultAnimator) {
+        animator = defaultAnimator;
+      } else {
+        Animator = Animator || this._animators[this._animation];
+
+        var animationOpts = util$1.extend({}, this._animationOptions, options.animationOptions || {}, internal$1.config.animationsDisabled ? { duration: 0, delay: 0 } : {});
+
+        animator = new Animator(animationOpts);
+
+        if (typeof animator === 'function') {
+          animator = new animator(animationOpts); // eslint-disable-line new-cap
+        }
+      }
+
+      if (!(animator instanceof this._baseClass)) {
+        util$1.throw('"animator" is not an instance of ' + this._baseClassName);
+      }
+
+      return animator;
+    }
+  }], [{
+    key: 'parseAnimationOptionsString',
+    value: function parseAnimationOptionsString(jsonString) {
+      try {
+        if (typeof jsonString === 'string') {
+          var result = util$1.animationOptionsParse(jsonString);
+          if ((typeof result === 'undefined' ? 'undefined' : _typeof(result)) === 'object' && result !== null) {
+            return result;
+          } else {
+            console.error('"animation-options" attribute must be a JSON object string: ' + jsonString);
+          }
+        }
+        return {};
+      } catch (e) {
+        console.error('"animation-options" attribute must be a JSON object string: ' + jsonString);
+        return {};
+      }
+    }
+  }]);
+  return AnimatorFactory;
+}();
+
+/*
+Copyright 2013-2015 ASIAL CORPORATION
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+   http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+*/
+
+var autoStyleEnabled = true;
+
+// Modifiers
+var modifiersMap = {
+  'quiet': 'material--flat',
+  'light': 'material--flat',
+  'outline': 'material--flat',
+  'cta': '',
+  'large--quiet': 'material--flat large',
+  'large--cta': 'large',
+  'noborder': '',
+  'tappable': ''
+};
+
+var platforms = {};
+
+platforms.android = function (element) {
+
+  var elementName = element.tagName.toLowerCase();
+
+  if (!util$1.hasModifier(element, 'material')) {
+    var oldModifier = element.getAttribute('modifier') || '';
+
+    var newModifier = oldModifier.trim().split(/\s+/).map(function (e) {
+      return modifiersMap.hasOwnProperty(e) ? modifiersMap[e] : e;
+    });
+    newModifier.unshift('material');
+
+    element.setAttribute('modifier', newModifier.join(' ').trim());
+  }
+
+  var elements = ['ons-alert-dialog-button', 'ons-toolbar-button', 'ons-back-button', 'ons-button', 'ons-list-item', 'ons-fab', 'ons-speed-dial', 'ons-speed-dial-item', 'ons-tab'];
+
+  // Effects
+  if (elements.indexOf(elementName) !== -1 && !element.hasAttribute('ripple') && !element.querySelector('ons-ripple')) {
+
+    if (elementName === 'ons-list-item') {
+      if (element.hasAttribute('tappable')) {
+        element.setAttribute('ripple', '');
+        element.removeAttribute('tappable');
+      }
+    } else {
+      element.setAttribute('ripple', '');
+    }
+  }
+};
+
+platforms.ios = function (element) {
+
+  // Modifiers
+  if (util$1.removeModifier(element, 'material')) {
+    if (util$1.removeModifier(element, 'material--flat')) {
+      util$1.addModifier(element, util$1.removeModifier(element, 'large') ? 'large--quiet' : 'quiet');
+    }
+
+    if (!element.getAttribute('modifier')) {
+      element.removeAttribute('modifier');
+    }
+  }
+
+  // Effects
+  if (element.hasAttribute('ripple')) {
+    if (element.tagName.toLowerCase() === 'ons-list-item') {
+      element.setAttribute('tappable', '');
+    }
+
+    element.removeAttribute('ripple');
+  }
+};
+
+var unlocked = {
+  android: true
+};
+
+var getPlatform = function getPlatform(element, force) {
+  if (autoStyleEnabled && !element.hasAttribute('disable-auto-styling')) {
+    var mobileOS = platform.getMobileOS();
+    if (platforms.hasOwnProperty(mobileOS) && (unlocked.hasOwnProperty(mobileOS) || force)) {
+      return mobileOS;
+    }
+  }
+  return null;
+};
+
+var prepare = function prepare(element, force) {
+  var p = getPlatform(element, force);
+  p && platforms[p](element);
+};
+
+var mapModifier = function mapModifier(modifier, element, force) {
+  if (getPlatform(element, force)) {
+    return modifier.split(/\s+/).map(function (m) {
+      return modifiersMap.hasOwnProperty(m) ? modifiersMap[m] : m;
+    }).join(' ');
+  }
+  return modifier;
+};
+
+var restoreModifier = function restoreModifier(element) {
+  if (getPlatform(element) === 'android') {
+    var modifier = element.getAttribute('modifier') || '';
+    var newModifier = mapModifier(modifier, element);
+
+    if (!/(^|\s+)material($|\s+)/i.test(modifier)) {
+      newModifier = 'material ' + newModifier;
+    }
+
+    if (newModifier !== modifier) {
+      element.setAttribute('modifier', newModifier.trim());
+      return true;
+    }
+  }
+  return false;
+};
+
+var autoStyle = {
+  isEnabled: function isEnabled() {
+    return autoStyleEnabled;
+  },
+  enable: function enable() {
+    return autoStyleEnabled = true;
+  },
+  disable: function disable() {
+    return autoStyleEnabled = false;
+  },
+  prepare: prepare,
+  mapModifier: mapModifier,
+  getPlatform: getPlatform,
+  restoreModifier: restoreModifier
+};
+
+/*
+Copyright 2013-2015 ASIAL CORPORATION
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+   http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+*/
+
+var ModifierUtil = function () {
+  function ModifierUtil() {
+    classCallCheck(this, ModifierUtil);
+  }
+
+  createClass(ModifierUtil, null, [{
+    key: 'diff',
+
+    /**
+     * @param {String} last
+     * @param {String} current
+     */
+    value: function diff(last, current) {
+      last = makeDict(('' + last).trim());
+      current = makeDict(('' + current).trim());
+
+      var removed = Object.keys(last).reduce(function (result, token) {
+        if (!current[token]) {
+          result.push(token);
+        }
+        return result;
+      }, []);
+
+      var added = Object.keys(current).reduce(function (result, token) {
+        if (!last[token]) {
+          result.push(token);
+        }
+        return result;
+      }, []);
+
+      return { added: added, removed: removed };
+
+      function makeDict(modifier) {
+        var dict = {};
+        ModifierUtil.split(modifier).forEach(function (token) {
+          return dict[token] = token;
+        });
+        return dict;
+      }
+    }
+
+    /**
+     * @param {Object} diff
+     * @param {Array} diff.removed
+     * @param {Array} diff.added
+     * @param {Object} classList
+     * @param {String} template
+     */
+
+  }, {
+    key: 'applyDiffToClassList',
+    value: function applyDiffToClassList(diff, classList, template) {
+      diff.added.map(function (modifier) {
+        return template.replace(/\*/g, modifier);
+      }).forEach(function (klass) {
+        return klass.split(/\s+/).forEach(function (k) {
+          return classList.add(k);
+        });
+      });
+
+      diff.removed.map(function (modifier) {
+        return template.replace(/\*/g, modifier);
+      }).forEach(function (klass) {
+        return klass.split(/\s+/).forEach(function (k) {
+          return classList.remove(k);
+        });
+      });
+    }
+
+    /**
+     * @param {Object} diff
+     * @param {Array} diff.removed
+     * @param {Array} diff.added
+     * @param {HTMLElement} element
+     * @param {Object} scheme
+     */
+
+  }, {
+    key: 'applyDiffToElement',
+    value: function applyDiffToElement(diff, element, scheme) {
+      Object.keys(scheme).forEach(function (selector) {
+        var targetElements = !selector || util$1.match(element, selector) ? [element] : Array.prototype.filter.call(element.querySelectorAll(selector), function (targetElement) {
+          return !util$1.findParent(targetElement, element.tagName, function (parent) {
+            return parent === element;
+          });
+        });
+
+        for (var i = 0; i < targetElements.length; i++) {
+          ModifierUtil.applyDiffToClassList(diff, targetElements[i].classList, scheme[selector]);
+        }
+      });
+    }
+
+    /**
+     * @param {String} last
+     * @param {String} current
+     * @param {HTMLElement} element
+     * @param {Object} scheme
+     */
+
+  }, {
+    key: 'onModifierChanged',
+    value: function onModifierChanged(last, current, element, scheme) {
+      ModifierUtil.applyDiffToElement(ModifierUtil.diff(last, current), element, scheme);
+      autoStyle.restoreModifier(element);
+    }
+  }, {
+    key: 'refresh',
+    value: function refresh(element, scheme) {
+      ModifierUtil.applyDiffToElement(ModifierUtil.diff('', element.getAttribute('modifier') || ''), element, scheme);
+    }
+
+    /**
+     * @param {HTMLElement} element
+     * @param {Object} scheme
+     */
+
+  }, {
+    key: 'initModifier',
+    value: function initModifier(element, scheme) {
+      var modifier = element.getAttribute('modifier');
+      if (typeof modifier !== 'string') {
+        return;
+      }
+
+      ModifierUtil.applyDiffToElement({
+        removed: [],
+        added: ModifierUtil.split(modifier)
+      }, element, scheme);
+    }
+  }, {
+    key: 'split',
+    value: function split(modifier) {
+      if (typeof modifier !== 'string') {
+        return [];
+      }
+
+      return modifier.trim().split(/ +/).filter(function (token) {
+        return token !== '';
+      });
+    }
+
+    /**
+     * Add modifier token to an element.
+     */
+
+  }, {
+    key: 'addModifier',
+    value: function addModifier(element, modifierToken) {
+      if (!element.hasAttribute('modifier')) {
+        element.setAttribute('modifier', modifierToken);
+      } else {
+        var tokens = ModifierUtil.split(element.getAttribute('modifier'));
+        if (tokens.indexOf(modifierToken) == -1) {
+          tokens.push(modifierToken);
+          element.setAttribute('modifier', tokens.join(' '));
+        }
+      }
+    }
+
+    /**
+     * Remove modifier token from an element.
+     */
+
+  }, {
+    key: 'removeModifier',
+    value: function removeModifier(element, modifierToken) {
+      if (element.hasAttribute('modifier')) {
+        var tokens = ModifierUtil.split(element.getAttribute('modifier'));
+        var index = tokens.indexOf(modifierToken);
+        if (index !== -1) {
+          tokens.splice(index, 1);
+          element.setAttribute('modifier', tokens.join(' '));
+        }
+      }
+    }
+  }]);
+  return ModifierUtil;
+}();
+
+/*
+Copyright 2013-2015 ASIAL CORPORATION
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+   http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+*/
+
+var util$3 = {
+  _ready: false,
+
+  _domContentLoaded: false,
+
+  _onDOMContentLoaded: function _onDOMContentLoaded() {
+    util$3._domContentLoaded = true;
+
+    if (platform.isWebView()) {
+      window.document.addEventListener('deviceready', function () {
+        util$3._ready = true;
+      }, false);
+    } else {
+      util$3._ready = true;
+    }
+  },
+
+  addBackButtonListener: function addBackButtonListener(fn) {
+    if (!this._domContentLoaded) {
+      throw new Error('This method is available after DOMContentLoaded');
+    }
+
+    if (this._ready) {
+      window.document.addEventListener('backbutton', fn, false);
+    } else {
+      window.document.addEventListener('deviceready', function () {
+        window.document.addEventListener('backbutton', fn, false);
+      });
+    }
+  },
+
+  removeBackButtonListener: function removeBackButtonListener(fn) {
+    if (!this._domContentLoaded) {
+      throw new Error('This method is available after DOMContentLoaded');
+    }
+
+    if (this._ready) {
+      window.document.removeEventListener('backbutton', fn, false);
+    } else {
+      window.document.addEventListener('deviceready', function () {
+        window.document.removeEventListener('backbutton', fn, false);
+      });
+    }
+  }
+};
+window.addEventListener('DOMContentLoaded', function () {
+  return util$3._onDOMContentLoaded();
+}, false);
+
+var HandlerRepository = {
+  _store: {},
+
+  _genId: function () {
+    var i = 0;
+    return function () {
+      return i++;
+    };
+  }(),
+
+  set: function set$$1(element, handler) {
+    if (element.dataset.deviceBackButtonHandlerId) {
+      this.remove(element);
+    }
+    var id = element.dataset.deviceBackButtonHandlerId = HandlerRepository._genId();
+    this._store[id] = handler;
+  },
+
+  remove: function remove(element) {
+    if (element.dataset.deviceBackButtonHandlerId) {
+      delete this._store[element.dataset.deviceBackButtonHandlerId];
+      delete element.dataset.deviceBackButtonHandlerId;
+    }
+  },
+
+  get: function get$$1(element) {
+    if (!element.dataset.deviceBackButtonHandlerId) {
+      return undefined;
+    }
+
+    var id = element.dataset.deviceBackButtonHandlerId;
+
+    if (!this._store[id]) {
+      throw new Error();
+    }
+
+    return this._store[id];
+  },
+
+  has: function has(element) {
+    if (!element.dataset) {
+      return false;
+    }
+
+    var id = element.dataset.deviceBackButtonHandlerId;
+
+    return !!this._store[id];
+  }
+};
+
+var DeviceBackButtonDispatcher = function () {
+  function DeviceBackButtonDispatcher() {
+    classCallCheck(this, DeviceBackButtonDispatcher);
+
+    this._isEnabled = false;
+    this._boundCallback = this._callback.bind(this);
+  }
+
+  /**
+   * Enable to handle 'backbutton' events.
+   */
+
+
+  createClass(DeviceBackButtonDispatcher, [{
+    key: 'enable',
+    value: function enable() {
+      if (!this._isEnabled) {
+        util$3.addBackButtonListener(this._boundCallback);
+        this._isEnabled = true;
+      }
+    }
+
+    /**
+     * Disable to handle 'backbutton' events.
+     */
+
+  }, {
+    key: 'disable',
+    value: function disable() {
+      if (this._isEnabled) {
+        util$3.removeBackButtonListener(this._boundCallback);
+        this._isEnabled = false;
+      }
+    }
+
+    /**
+     * Fire a 'backbutton' event manually.
+     */
+
+  }, {
+    key: 'fireDeviceBackButtonEvent',
+    value: function fireDeviceBackButtonEvent() {
+      var event = document.createEvent('Event');
+      event.initEvent('backbutton', true, true);
+      document.dispatchEvent(event);
+    }
+  }, {
+    key: '_callback',
+    value: function _callback() {
+      this._dispatchDeviceBackButtonEvent();
+    }
+
+    /**
+     * @param {HTMLElement} element
+     * @param {Function} callback
+     */
+
+  }, {
+    key: 'createHandler',
+    value: function createHandler(element, callback) {
+      if (!(element instanceof HTMLElement)) {
+        throw new Error('element must be an instance of HTMLElement');
+      }
+
+      if (!(callback instanceof Function)) {
+        throw new Error('callback must be an instance of Function');
+      }
+
+      var handler = {
+        _callback: callback,
+        _element: element,
+
+        disable: function disable() {
+          HandlerRepository.remove(element);
+        },
+
+        setListener: function setListener(callback) {
+          this._callback = callback;
+        },
+
+        enable: function enable() {
+          HandlerRepository.set(element, this);
+        },
+
+        isEnabled: function isEnabled() {
+          return HandlerRepository.get(element) === this;
+        },
+
+        destroy: function destroy() {
+          HandlerRepository.remove(element);
+          this._callback = this._element = null;
+        }
+      };
+
+      handler.enable();
+
+      return handler;
+    }
+  }, {
+    key: '_dispatchDeviceBackButtonEvent',
+    value: function _dispatchDeviceBackButtonEvent() {
+      var tree = this._captureTree();
+
+      var element = this._findHandlerLeafElement(tree);
+
+      var handler = HandlerRepository.get(element);
+      handler._callback(createEvent(element));
+
+      function createEvent(element) {
+        return {
+          _element: element,
+          callParentHandler: function callParentHandler() {
+            var parent = this._element.parentNode;
+
+            while (parent) {
+              handler = HandlerRepository.get(parent);
+              if (handler) {
+                return handler._callback(createEvent(parent));
+              }
+              parent = parent.parentNode;
+            }
+          }
+        };
+      }
+    }
+
+    /**
+     * @return {Object}
+     */
+
+  }, {
+    key: '_captureTree',
+    value: function _captureTree() {
+      return createTree(document.body);
+
+      function createTree(element) {
+        var tree = {
+          element: element,
+          children: Array.prototype.concat.apply([], arrayOf(element.children).map(function (childElement) {
+
+            if (childElement.style.display === 'none' || childElement._isShown === false) {
+              return [];
+            }
+
+            if (childElement.children.length === 0 && !HandlerRepository.has(childElement)) {
+              return [];
+            }
+
+            var result = createTree(childElement);
+
+            if (result.children.length === 0 && !HandlerRepository.has(result.element)) {
+              return [];
+            }
+
+            return [result];
+          }))
+        };
+
+        if (!HandlerRepository.has(tree.element)) {
+          for (var i = 0; i < tree.children.length; i++) {
+            var subTree = tree.children[i];
+            if (HandlerRepository.has(subTree.element)) {
+              return subTree;
+            }
+          }
+        }
+
+        return tree;
+      }
+
+      function arrayOf(target) {
+        var result = [];
+        for (var i = 0; i < target.length; i++) {
+          result.push(target[i]);
+        }
+        return result;
+      }
+    }
+
+    /**
+     * @param {Object} tree
+     * @return {HTMLElement}
+     */
+
+  }, {
+    key: '_findHandlerLeafElement',
+    value: function _findHandlerLeafElement(tree) {
+      return find(tree);
+
+      function find(node) {
+        if (node.children.length === 0) {
+          return node.element;
+        }
+
+        if (node.children.length === 1) {
+          return find(node.children[0]);
+        }
+
+        return node.children.map(function (childNode) {
+          return childNode.element;
+        }).reduce(function (left, right) {
+          if (!left) {
+            return right;
+          }
+
+          var leftZ = parseInt(window.getComputedStyle(left, '').zIndex, 10);
+          var rightZ = parseInt(window.getComputedStyle(right, '').zIndex, 10);
+
+          if (!isNaN(leftZ) && !isNaN(rightZ)) {
+            return leftZ > rightZ ? left : right;
+          }
+
+          throw new Error('Capturing backbutton-handler is failure.');
+        }, null);
+      }
+    }
+  }]);
+  return DeviceBackButtonDispatcher;
+}();
+
+var deviceBackButtonDispatcher = new DeviceBackButtonDispatcher();
+
+/*
+Copyright 2013-2015 ASIAL CORPORATION
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+   http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+*/
+internal$1.AnimatorFactory = AnimatorFactory;
+internal$1.ModifierUtil = ModifierUtil;
+internal$1.dbbDispatcher = deviceBackButtonDispatcher;
+
+/*
+Copyright 2013-2015 ASIAL CORPORATION
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+   http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+*/
+
+var startsWith = function startsWith(s, c) {
+  return s.substr(0, c.length) === c;
+};
+var endsWith = function endsWith(s, c) {
+  return s.substr(s.length - c.length, c.length) === c;
+};
+var unwrap = function unwrap(s) {
+  return s.slice(1, -1);
+};
+var isObjectString = function isObjectString(s) {
+  return startsWith(s, '{') && endsWith(s, '}');
+};
+var isArrayString = function isArrayString(s) {
+  return startsWith(s, '[') && endsWith(s, ']');
+};
+var isQuotedString = function isQuotedString(s) {
+  return startsWith(s, '\'') && endsWith(s, '\'') || startsWith(s, '"') && endsWith(s, '"');
+};
+
+var error$1 = function error(token, string, originalString) {
+  throw new Error('Unexpected token \'' + token + '\' at position ' + (originalString.length - string.length - 1) + ' in string: \'' + originalString + '\'');
+};
+
+var processToken = function processToken(token, string, originalString) {
+  if (token === 'true' || token === 'false') {
+    return token === 'true';
+  } else if (isQuotedString(token)) {
+    return unwrap(token);
+  } else if (!isNaN(token)) {
+    return +token;
+  } else if (isObjectString(token)) {
+    return parseObject(unwrap(token));
+  } else if (isArrayString(token)) {
+    return parseArray(unwrap(token));
+  } else {
+    error$1(token, string, originalString);
+  }
+};
+
+var nextToken = function nextToken(string) {
+  string = string.trim();
+  var limit = string.length;
+
+  if (string[0] === ':' || string[0] === ',') {
+
+    limit = 1;
+  } else if (string[0] === '{' || string[0] === '[') {
+
+    var c = string.charCodeAt(0);
+    var nestedObject = 1;
+    for (var i = 1; i < string.length; i++) {
+      if (string.charCodeAt(i) === c) {
+        nestedObject++;
+      } else if (string.charCodeAt(i) === c + 2) {
+        nestedObject--;
+        if (nestedObject === 0) {
+          limit = i + 1;
+          break;
+        }
+      }
+    }
+  } else if (string[0] === '\'' || string[0] === '"') {
+
+    for (var _i = 1; _i < string.length; _i++) {
+      if (string[_i] === string[0]) {
+        limit = _i + 1;
+        break;
+      }
+    }
+  } else {
+
+    for (var _i2 = 1; _i2 < string.length; _i2++) {
+      if ([' ', ',', ':'].indexOf(string[_i2]) !== -1) {
+        limit = _i2;
+        break;
+      }
+    }
+  }
+
+  return string.slice(0, limit);
+};
+
+var parseObject = function parseObject(string) {
+  var isValidKey = function isValidKey(key) {
+    return (/^[A-Z_$][A-Z0-9_$]*$/i.test(key)
+    );
+  };
+
+  string = string.trim();
+  var originalString = string;
+  var object = {};
+  var readingKey = true,
+      key = void 0,
+      previousToken = void 0,
+      token = void 0;
+
+  while (string.length > 0) {
+    previousToken = token;
+    token = nextToken(string);
+    string = string.slice(token.length, string.length).trim();
+
+    if (token === ':' && (!readingKey || !previousToken || previousToken === ',') || token === ',' && readingKey || token !== ':' && token !== ',' && previousToken && previousToken !== ',' && previousToken !== ':') {
+      error$1(token, string, originalString);
+    } else if (token === ':' && readingKey && previousToken) {
+      previousToken = isQuotedString(previousToken) ? unwrap(previousToken) : previousToken;
+      if (isValidKey(previousToken)) {
+        key = previousToken;
+        readingKey = false;
+      } else {
+        throw new Error('Invalid key token \'' + previousToken + '\' at position 0 in string: \'' + originalString + '\'');
+      }
+    } else if (token === ',' && !readingKey && previousToken) {
+      object[key] = processToken(previousToken, string, originalString);
+      readingKey = true;
+    }
+  }
+
+  if (token) {
+    object[key] = processToken(token, string, originalString);
+  }
+
+  return object;
+};
+
+var parseArray = function parseArray(string) {
+  string = string.trim();
+  var originalString = string;
+  var array = [];
+  var previousToken = void 0,
+      token = void 0;
+
+  while (string.length > 0) {
+    previousToken = token;
+    token = nextToken(string);
+    string = string.slice(token.length, string.length).trim();
+
+    if (token === ',' && (!previousToken || previousToken === ',')) {
+      error$1(token, string, originalString);
+    } else if (token === ',') {
+      array.push(processToken(previousToken, string, originalString));
+    }
+  }
+
+  if (token) {
+    if (token !== ',') {
+      array.push(processToken(token, string, originalString));
+    } else {
+      error$1(token, string, originalString);
+    }
+  }
+
+  return array;
+};
+
+var parse = function parse(string) {
+  string = string.trim();
+
+  if (isObjectString(string)) {
+    return parseObject(unwrap(string));
+  } else if (isArrayString(string)) {
+    return parseArray(unwrap(string));
+  } else {
+    throw new Error('Provided string must be object or array like: ' + string);
+  }
+};
+
+/*
+Copyright 2013-2015 ASIAL CORPORATION
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+   http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+*/
+
+var util$1 = {};
+var errorPrefix = '[Onsen UI]';
+
+util$1.globals = {
+  fabOffset: 0,
+  errorPrefix: errorPrefix,
+  supportsPassive: false
+};
+
+platform._runOnActualPlatform(function () {
+  util$1.globals.actualMobileOS = platform.getMobileOS();
+  util$1.globals.isUIWebView = platform.isUIWebView();
+  util$1.globals.isWKWebView = platform.isWKWebView();
+});
+
+try {
+  var opts = Object.defineProperty({}, 'passive', {
+    get: function get$$1() {
+      util$1.globals.supportsPassive = true;
+    }
+  });
+  window.addEventListener('testPassive', null, opts);
+  window.removeEventListener('testPassive', null, opts);
+} catch (e) {
+  
+}
+
+/**
+ * @param {Element} el Target
+ * @param {String} name Event name
+ * @param {Function} handler Event handler
+ * @param {Object} [opt] Event options (passive, capture...)
+ * @param {Boolean} [isGD] If comes from GestureDetector. Just for testing.
+ */
+util$1.addEventListener = function (el, name, handler, opt, isGD) {
+  el.addEventListener(name, handler, util$1.globals.supportsPassive ? opt : (opt || {}).capture);
+};
+util$1.removeEventListener = function (el, name, handler, opt, isGD) {
+  el.removeEventListener(name, handler, util$1.globals.supportsPassive ? opt : (opt || {}).capture);
+};
+
+/**
+ * @param {String/Function} query dot class name or node name or matcher function.
+ * @return {Function}
+ */
+util$1.prepareQuery = function (query) {
+  return query instanceof Function ? query : function (element) {
+    return util$1.match(element, query);
+  };
+};
+
+/**
+ * @param {Element} e
+ * @param {String/Function} s CSS Selector.
+ * @return {Boolean}
+ */
+util$1.match = function (e, s) {
+  return (e.matches || e.webkitMatchesSelector || e.mozMatchesSelector || e.msMatchesSelector).call(e, s);
+};
+
+/**
+ * @param {Element} element
+ * @param {String/Function} query dot class name or node name or matcher function.
+ * @return {HTMLElement/null}
+ */
+util$1.findChild = function (element, query) {
+  var match = util$1.prepareQuery(query);
+
+  // Caution: `element.children` is `undefined` in some environments if `element` is `svg`
+  for (var i = 0; i < element.childNodes.length; i++) {
+    var node = element.childNodes[i];
+    if (node.nodeType !== Node.ELEMENT_NODE) {
+      // process only element nodes
+      continue;
+    }
+    if (match(node)) {
+      return node;
+    }
+  }
+  return null;
+};
+
+/**
+ * @param {Element} element
+ * @param {String/Function} query dot class name or node name or matcher function.
+ * @return {HTMLElement/null}
+ */
+util$1.findParent = function (element, query, until) {
+  var match = util$1.prepareQuery(query);
+
+  var parent = element.parentNode;
+  for (;;) {
+    if (!parent || parent === document || parent instanceof DocumentFragment || until && until(parent)) {
+      return null;
+    } else if (match(parent)) {
+      return parent;
+    }
+    parent = parent.parentNode;
+  }
+};
+
+/**
+ * @param {Element} element
+ * @return {boolean}
+ */
+util$1.isAttached = function (element) {
+  return document.body.contains(element);
+};
+
+/**
+ * @param {Element} element
+ * @return {boolean}
+ */
+util$1.hasAnyComponentAsParent = function (element) {
+  while (element && document.documentElement !== element) {
+    element = element.parentNode;
+    if (element && element.nodeName.toLowerCase().match(/(ons-navigator|ons-tabbar|ons-modal)/)) {
+      return true;
+    }
+  }
+  return false;
+};
+
+/**
+ * @param {Object} element
+ * @return {Array}
+ */
+util$1.getAllChildNodes = function (element) {
+  var _ref;
+
+  return (_ref = [element]).concat.apply(_ref, toConsumableArray(Array.from(element.children).map(function (childEl) {
+    return util$1.getAllChildNodes(childEl);
+  })));
+};
+
+/**
+ * @param {Element} element
+ * @return {boolean}
+ */
+util$1.isPageControl = function (element) {
+  return element.nodeName.match(/^ons-(navigator|splitter|tabbar|page)$/i);
+};
+
+/**
+ * @param {Element} element
+ * @param {String} action to propagate
+ */
+util$1.propagateAction = function (element, action) {
+  for (var i = 0; i < element.childNodes.length; i++) {
+    var child = element.childNodes[i];
+    if (child[action] instanceof Function) {
+      child[action]();
+    } else {
+      util$1.propagateAction(child, action);
+    }
+  }
+};
+
+/**
+ * @param {String} string - string to be camelized
+ * @return {String} Camelized string
+ */
+util$1.camelize = function (string) {
+  return string.toLowerCase().replace(/-([a-z])/g, function (m, l) {
+    return l.toUpperCase();
+  });
+};
+
+/**
+ * @param {String} string - string to be hyphenated
+ * @return {String} Hyphenated string
+ */
+util$1.hyphenate = function (string) {
+  return string.replace(/([a-zA-Z])([A-Z])/g, '$1-$2').toLowerCase();
+};
+
+/**
+ * @param {String} selector - tag and class only
+ * @param {Object} style
+ * @param {Element}
+ */
+util$1.create = function () {
+  var selector = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
+  var style = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
+
+  var classList = selector.split('.');
+  var element = document.createElement(classList.shift() || 'div');
+
+  if (classList.length) {
+    element.className = classList.join(' ');
+  }
+
+  styler(element, style);
+
+  return element;
+};
+
+/**
+ * @param {String} html
+ * @return {Element}
+ */
+util$1.createElement = function (html) {
+  var wrapper = document.createElement('div');
+
+  if (html instanceof DocumentFragment) {
+    wrapper.appendChild(document.importNode(html, true));
+  } else {
+    wrapper.innerHTML = html.trim();
+  }
+
+  if (wrapper.children.length > 1) {
+    util$1.throw('HTML template must contain a single root element');
+  }
+
+  var element = wrapper.children[0];
+  wrapper.children[0].remove();
+  return element;
+};
+
+/**
+ * @param {String} html
+ * @return {HTMLFragment}
+ */
+util$1.createFragment = function (html) {
+  var template = document.createElement('template');
+  template.innerHTML = html;
+  return document.importNode(template.content, true);
+};
+
+/*
+ * @param {Object} dst Destination object.
+ * @param {...Object} src Source object(s).
+ * @returns {Object} Reference to `dst`.
+ */
+util$1.extend = function (dst) {
+  for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
+    args[_key - 1] = arguments[_key];
+  }
+
+  for (var i = 0; i < args.length; i++) {
+    if (args[i]) {
+      var keys = Object.keys(args[i]);
+      for (var j = 0; j < keys.length; j++) {
+        var key = keys[j];
+        dst[key] = args[i][key];
+      }
+    }
+  }
+
+  return dst;
+};
+
+/**
+ * @param {Object} arrayLike
+ * @return {Array}
+ */
+util$1.arrayFrom = function (arrayLike) {
+  return Array.prototype.slice.apply(arrayLike);
+};
+
+/**
+ * @param {String} jsonString
+ * @param {Object} [failSafe]
+ * @return {Object}
+ */
+util$1.parseJSONObjectSafely = function (jsonString) {
+  var failSafe = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
+
+  try {
+    var result = JSON.parse('' + jsonString);
+    if ((typeof result === 'undefined' ? 'undefined' : _typeof(result)) === 'object' && result !== null) {
+      return result;
+    }
+  } catch (e) {
+    return failSafe;
+  }
+  return failSafe;
+};
+
+/**
+ * @param {String} path - path such as 'myApp.controllers.data.loadData'
+ * @return {Any} - whatever is located at that path
+ */
+util$1.findFromPath = function (path) {
+  path = path.split('.');
+  var el = window,
+      key;
+  while (key = path.shift()) {
+    // eslint-disable-line no-cond-assign
+    el = el[key];
+  }
+  return el;
+};
+
+/**
+ * @param {HTMLElement} container - Page or page-container that implements 'topPage'
+ * @return {HTMLElement|null} - Visible page element or null if not found.
+ */
+util$1.getTopPage = function (container) {
+  return container && (container.tagName.toLowerCase() === 'ons-page' ? container : container.topPage) || null;
+};
+
+/**
+ * @param {HTMLElement} container - Element where the search begins
+ * @return {HTMLElement|null} - Page element that contains the visible toolbar or null.
+ */
+util$1.findToolbarPage = function (container) {
+  var page = util$1.getTopPage(container);
+
+  if (page) {
+    if (page._canAnimateToolbar()) {
+      return page;
+    }
+
+    for (var i = 0; i < page._contentElement.children.length; i++) {
+      var nextPage = util$1.getTopPage(page._contentElement.children[i]);
+      if (nextPage && !/ons-tabbar/i.test(page._contentElement.children[i].tagName)) {
+        return util$1.findToolbarPage(nextPage);
+      }
+    }
+  }
+
+  return null;
+};
+
+/**
+ * @param {Element} element
+ * @param {String} eventName
+ * @param {Object} [detail]
+ * @return {CustomEvent}
+ */
+util$1.triggerElementEvent = function (target, eventName) {
+  var detail = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
+
+
+  var event = new CustomEvent(eventName, {
+    bubbles: true,
+    cancelable: true,
+    detail: detail
+  });
+
+  Object.keys(detail).forEach(function (key) {
+    event[key] = detail[key];
+  });
+
+  target.dispatchEvent(event);
+
+  return event;
+};
+
+/**
+ * @param {Element} target
+ * @param {String} modifierName
+ * @return {Boolean}
+ */
+util$1.hasModifier = function (target, modifierName) {
+  if (!target.hasAttribute('modifier')) {
+    return false;
+  }
+
+  return RegExp('(^|\\s+)' + modifierName + '($|\\s+)', 'i').test(target.getAttribute('modifier'));
+};
+
+/**
+ * @param {Element} target
+ * @param {String} modifierName
+ * @param {Object} options.autoStyle Maps the modifierName to the corresponding styled modifier.
+ * @param {Object} options.forceAutoStyle Ignores platform limitation.
+ * @return {Boolean} Whether it was added or not.
+ */
+util$1.addModifier = function (target, modifierName) {
+  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
+
+  if (options.autoStyle) {
+    modifierName = autoStyle.mapModifier(modifierName, target, options.forceAutoStyle);
+  }
+
+  if (util$1.hasModifier(target, modifierName)) {
+    return false;
+  }
+
+  target.setAttribute('modifier', ((target.getAttribute('modifier') || '') + ' ' + modifierName).trim());
+  return true;
+};
+
+/**
+ * @param {Element} target
+ * @param {String} modifierName
+ * @param {Object} options.autoStyle Maps the modifierName to the corresponding styled modifier.
+ * @param {Object} options.forceAutoStyle Ignores platform limitation.
+ * @return {Boolean} Whether it was found or not.
+ */
+util$1.removeModifier = function (target, modifierName) {
+  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
+
+  if (options.autoStyle) {
+    modifierName = autoStyle.mapModifier(modifierName, target, options.forceAutoStyle);
+  }
+
+  if (!target.getAttribute('modifier') || !util$1.hasModifier(target, modifierName)) {
+    return false;
+  }
+
+  var newModifiers = target.getAttribute('modifier').split(/\s+/).filter(function (m) {
+    return m && m !== modifierName;
+  });
+  newModifiers.length ? target.setAttribute('modifier', newModifiers.join(' ')) : target.removeAttribute('modifier');
+  return true;
+};
+
+/**
+ * @param {Element} target
+ * @param {String} modifierName
+ * @param {Boolean} options.force Forces modifier to be added or removed.
+ * @param {Object} options.autoStyle Maps the modifierName to the corresponding styled modifier.
+ * @param {Boolean} options.forceAutoStyle Ignores platform limitation.
+ * @return {Boolean} Whether it was found or not.
+ */
+util$1.toggleModifier = function () {
+  var options = arguments.length > 2 ? arguments.length <= 2 ? undefined : arguments[2] : {};
+  var force = typeof options === 'boolean' ? options : options.force;
+
+  var toggle = typeof force === 'boolean' ? force : !util$1.hasModifier.apply(util$1, arguments);
+  toggle ? util$1.addModifier.apply(util$1, arguments) : util$1.removeModifier.apply(util$1, arguments);
+};
+
+/**
+ * @param {Element} el
+ * @param {String} defaultClass
+ * @param {Object} scheme
+ */
+util$1.restoreClass = function (el, defaultClass, scheme) {
+  defaultClass.split(/\s+/).forEach(function (c) {
+    return c !== '' && !el.classList.contains(c) && el.classList.add(c);
+  });
+  el.hasAttribute('modifier') && ModifierUtil.refresh(el, scheme);
+};
+
+// TODO: FIX
+util$1.updateParentPosition = function (el) {
+  if (!el._parentUpdated && el.parentElement) {
+    if (window.getComputedStyle(el.parentElement).getPropertyValue('position') === 'static') {
+      el.parentElement.style.position = 'relative';
+    }
+    el._parentUpdated = true;
+  }
+};
+
+util$1.toggleAttribute = function (element, name, value) {
+  if (value) {
+    element.setAttribute(name, typeof value === 'boolean' ? '' : value);
+  } else {
+    element.removeAttribute(name);
+  }
+};
+
+util$1.bindListeners = function (element, listenerNames) {
+  listenerNames.forEach(function (name) {
+    var boundName = name.replace(/^_[a-z]/, '_bound' + name[1].toUpperCase());
+    element[boundName] = element[boundName] || element[name].bind(element);
+  });
+};
+
+util$1.each = function (obj, f) {
+  return Object.keys(obj).forEach(function (key) {
+    return f(key, obj[key]);
+  });
+};
+
+/**
+ * @param {Element} target
+ * @param {boolean} hasRipple
+ * @param {Object} attrs
+ */
+util$1.updateRipple = function (target, hasRipple) {
+  var attrs = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
+
+  if (hasRipple === undefined) {
+    hasRipple = target.hasAttribute('ripple');
+  }
+
+  var rippleElement = util$1.findChild(target, 'ons-ripple');
+
+  if (hasRipple) {
+    if (!rippleElement) {
+      var element = document.createElement('ons-ripple');
+      Object.keys(attrs).forEach(function (key) {
+        return element.setAttribute(key, attrs[key]);
+      });
+      target.insertBefore(element, target.firstChild);
+    }
+  } else if (rippleElement) {
+    rippleElement.remove();
+  }
+};
+
+/**
+ * @param {String}
+ * @return {Object}
+ */
+util$1.animationOptionsParse = parse;
+
+/**
+ * @param {*} value
+ */
+util$1.isInteger = function (value) {
+  return typeof value === 'number' && isFinite(value) && Math.floor(value) === value;
+};
+
+/**
+ * @return {Object} Deferred promise.
+ */
+util$1.defer = function () {
+  var deferred = {};
+  deferred.promise = new Promise(function (resolve, reject) {
+    deferred.resolve = resolve;
+    deferred.reject = reject;
+  });
+  return deferred;
+};
+
+/**
+ * Show warnings when they are enabled.
+ *
+ * @param {*} arguments to console.warn
+ */
+util$1.warn = function () {
+  for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
+    args[_key2] = arguments[_key2];
+  }
+
+  if (!internal$1.config.warningsDisabled) {
+    var _console;
+
+    (_console = console).warn.apply(_console, [errorPrefix].concat(args));
+  }
+};
+
+util$1.throw = function (message) {
+  throw new Error(errorPrefix + ' ' + message);
+};
+
+util$1.throwAbstract = function () {
+  return util$1.throw('Cannot instantiate abstract class');
+};
+util$1.throwMember = function () {
+  return util$1.throw('Class member must be implemented');
+};
+util$1.throwPageLoader = function () {
+  return util$1.throw('First parameter should be an instance of PageLoader');
+};
+util$1.throwAnimator = function (el) {
+  return util$1.throw('"Animator" param must inherit ' + el + 'Animator');
+};
+
+var prevent = function prevent(e) {
+  return e.cancelable && e.preventDefault();
+};
+
+/**
+ * Prevent scrolling while draging horizontally on iOS.
+ *
+ * @param {gd} GestureDetector instance
+ */
+util$1.iosPreventScroll = function (gd) {
+  if (util$1.globals.actualMobileOS === 'ios') {
+    var clean = function clean(e) {
+      gd.off('touchmove', prevent);
+      gd.off('dragend', clean);
+    };
+
+    gd.on('touchmove', prevent);
+    gd.on('dragend', clean);
+  }
+};
+
+/**
+ * Prevents scroll in underlying pages on iOS. See #2220 #2274 #1949
+ *
+ * @param {el} HTMLElement that prevents the events
+ * @param {add} Boolean Add or remove event listeners
+ */
+util$1.iosPageScrollFix = function (add) {
+  // Full fix - May cause issues with UIWebView's momentum scroll
+  if (util$1.globals.actualMobileOS === 'ios') {
+    document.body.classList.toggle('ons-ios-scroll', add); // Allows custom and localized fixes (#2274)
+    if (!util$1.globals.isUIWebView || internal$1.config.forceUIWebViewScrollFix) {
+      document.body.classList.toggle('ons-ios-scroll-fix', add);
+    }
+  }
+};
+util$1.iosMaskScrollFix = function (el, add) {
+  // Half fix - only prevents scroll on masks
+  if (util$1.globals.isUIWebView) {
+    var action = (add ? 'add' : 'remove') + 'EventListener';
+    el[action]('touchmove', prevent, false);
+  }
+};
+
+/**
+ * Distance and deltaTime filter some weird dragstart events that are not fired immediately.
+ *
+ * @param {event}
+ */
+util$1.isValidGesture = function (event) {
+  return event.gesture !== undefined && (event.gesture.distance <= 15 || event.gesture.deltaTime <= 100);
+};
+
+util$1.checkMissingImport = function () {
+  for (var _len3 = arguments.length, elementNames = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
+    elementNames[_key3] = arguments[_key3];
+  }
+
+  elementNames.forEach(function (name) {
+    if (!onsElements[name]) {
+      util$1.throw('Ons' + name + ' is required but was not imported (Custom Elements)');
+    }
+  });
+};
+
+/*
+Copyright 2013-2015 ASIAL CORPORATION
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+   http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+*/
+
+/**
+ * Minimal animation library for managing css transition on mobile browsers.
+ */
+var TIMEOUT_RATIO = 1.4;
+
+var util$4 = {};
+
+// capitalize string
+util$4.capitalize = function (str) {
+  return str.charAt(0).toUpperCase() + str.slice(1);
+};
+
+/**
+ * @param {Object} params
+ * @param {String} params.property
+ * @param {Float} params.duration
+ * @param {String} params.timing
+ */
+util$4.buildTransitionValue = function (params) {
+  params.property = params.property || 'all';
+  params.duration = params.duration || 0.4;
+  params.timing = params.timing || 'linear';
+
+  var props = params.property.split(/ +/);
+
+  return props.map(function (prop) {
+    return prop + ' ' + params.duration + 's ' + params.timing;
+  }).join(', ');
+};
+
+/**
+ * Add an event handler on "transitionend" event.
+ */
+util$4.onceOnTransitionEnd = function (element, callback) {
+  if (!element) {
+    return function () {};
+  }
+
+  var fn = function fn(event) {
+    if (element == event.target) {
+      event.stopPropagation();
+      removeListeners();
+
+      callback();
+    }
+  };
+
+  var removeListeners = function removeListeners() {
+    util$4._transitionEndEvents.forEach(function (eventName) {
+      element.removeEventListener(eventName, fn, false);
+    });
+  };
+
+  util$4._transitionEndEvents.forEach(function (eventName) {
+    element.addEventListener(eventName, fn, false);
+  });
+
+  return removeListeners;
+};
+
+util$4._transitionEndEvents = function () {
+
+  if ('ontransitionend' in window) {
+    return ['transitionend'];
+  }
+
+  if ('onwebkittransitionend' in window) {
+    return ['webkitTransitionEnd'];
+  }
+
+  if (util$4.vendorPrefix === 'webkit' || util$4.vendorPrefix === 'o' || util$4.vendorPrefix === 'moz' || util$4.vendorPrefix === 'ms') {
+    return [util$4.vendorPrefix + 'TransitionEnd', 'transitionend'];
+  }
+
+  return [];
+}();
+
+util$4._cssPropertyDict = function () {
+  var styles = window.getComputedStyle(document.documentElement, '');
+  var dict = {};
+  var a = 'A'.charCodeAt(0);
+  var z = 'z'.charCodeAt(0);
+
+  var upper = function upper(s) {
+    return s.substr(1).toUpperCase();
+  };
+
+  for (var i = 0; i < styles.length; i++) {
+
+    var key = styles[i].replace(/^[-]+/, '').replace(/[-][a-z]/g, upper).replace(/^moz/, 'Moz');
+
+    if (a <= key.charCodeAt(0) && z >= key.charCodeAt(0)) {
+      if (key !== 'cssText' && key !== 'parentText') {
+        dict[key] = true;
+      }
+    }
+  }
+
+  return dict;
+}();
+
+util$4.hasCssProperty = function (name) {
+  return name in util$4._cssPropertyDict;
+};
+
+/**
+ * Vendor prefix for css property.
+ */
+util$4.vendorPrefix = function () {
+  var styles = window.getComputedStyle(document.documentElement, ''),
+      pre = (Array.prototype.slice.call(styles).join('').match(/-(moz|webkit|ms)-/) || styles.OLink === '' && ['', 'o'])[1];
+  return pre;
+}();
+
+util$4.forceLayoutAtOnce = function (elements, callback) {
+  this.batchImmediate(function () {
+    elements.forEach(function (element) {
+      // force layout
+      element.offsetHeight;
+    });
+    callback();
+  });
+};
+
+util$4.batchImmediate = function () {
+  var callbacks = [];
+
+  return function (callback) {
+    if (callbacks.length === 0) {
+      setImmediate(function () {
+        var concreateCallbacks = callbacks.slice(0);
+        callbacks = [];
+        concreateCallbacks.forEach(function (callback) {
+          callback();
+        });
+      });
+    }
+
+    callbacks.push(callback);
+  };
+}();
+
+util$4.batchAnimationFrame = function () {
+  var callbacks = [];
+
+  var raf = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function (callback) {
+    setTimeout(callback, 1000 / 60);
+  };
+
+  return function (callback) {
+    if (callbacks.length === 0) {
+      raf(function () {
+        var concreateCallbacks = callbacks.slice(0);
+        callbacks = [];
+        concreateCallbacks.forEach(function (callback) {
+          callback();
+        });
+      });
+    }
+
+    callbacks.push(callback);
+  };
+}();
+
+util$4.transitionPropertyName = function () {
+  if (util$4.hasCssProperty('transitionDuration')) {
+    return 'transition';
+  }
+
+  if (util$4.hasCssProperty(util$4.vendorPrefix + 'TransitionDuration')) {
+    return util$4.vendorPrefix + 'Transition';
+  }
+
+  throw new Error('Invalid state');
+}();
+
+/**
+ * @param {HTMLElement} element
+ */
+var Animit = function Animit(element, defaults) {
+  if (!(this instanceof Animit)) {
+    return new Animit(element, defaults);
+  }
+
+  if (element instanceof HTMLElement) {
+    this.elements = [element];
+  } else if (Object.prototype.toString.call(element) === '[object Array]') {
+    this.elements = element;
+  } else {
+    throw new Error('First argument must be an array or an instance of HTMLElement.');
+  }
+
+  this.defaults = defaults;
+  this.transitionQueue = [];
+  this.lastStyleAttributeDict = [];
+};
+
+Animit.prototype = {
+
+  /**
+   * @property {Array}
+   */
+  transitionQueue: undefined,
+
+  /**
+   * @property {Array}
+   */
+  elements: undefined,
+
+  /**
+   * @property {Object}
+   */
+  defaults: undefined,
+
+  /**
+   * Start animation sequence with passed animations.
+   *
+   * @param {Function} callback
+   */
+  play: function play(callback) {
+    if (typeof callback === 'function') {
+      this.transitionQueue.push(function (done) {
+        callback();
+        done();
+      });
+    }
+
+    this.startAnimation();
+
+    return this;
+  },
+
+  /**
+   * Most of the animations follow this default process.
+   *
+   * @param {from} css or options object containing css
+   * @param {to} css or options object containing css
+   * @param {delay} delay to wait
+   */
+  default: function _default(from, to, delay) {
+    function step(params, duration, timing) {
+      if (params.duration !== undefined) {
+        duration = params.duration;
+      }
+      if (params.timing !== undefined) {
+        timing = params.timing;
+      }
+
+      return {
+        css: params.css || params,
+        duration: duration,
+        timing: timing
+      };
+    }
+
+    return this.saveStyle().queue(step(from, 0, this.defaults.timing)).wait(delay === undefined ? this.defaults.delay : delay).queue(step(to, this.defaults.duration, this.defaults.timing)).restoreStyle();
+  },
+
+  /**
+   * Queue transition animations or other function.
+   *
+   * e.g. animit(elt).queue({color: 'red'})
+   * e.g. animit(elt).queue({color: 'red'}, {duration: 0.4})
+   * e.g. animit(elt).queue({css: {color: 'red'}, duration: 0.2})
+   *
+   * @param {Object|Animit.Transition|Function} transition
+   * @param {Object} [options]
+   */
+  queue: function queue(transition, options) {
+    var queue = this.transitionQueue;
+
+    if (transition && options) {
+      options.css = transition;
+      transition = new Animit.Transition(options);
+    }
+
+    if (!(transition instanceof Function || transition instanceof Animit.Transition)) {
+      if (transition.css) {
+        transition = new Animit.Transition(transition);
+      } else {
+        transition = new Animit.Transition({
+          css: transition
+        });
+      }
+    }
+
+    if (transition instanceof Function) {
+      queue.push(transition);
+    } else if (transition instanceof Animit.Transition) {
+      queue.push(transition.build());
+    } else {
+      throw new Error('Invalid arguments');
+    }
+
+    return this;
+  },
+
+  /**
+   * Queue transition animations.
+   *
+   * @param {Float} seconds
+   */
+  wait: function wait(seconds) {
+    if (seconds > 0) {
+      this.transitionQueue.push(function (done) {
+        setTimeout(done, 1000 * seconds);
+      });
+    }
+
+    return this;
+  },
+
+  saveStyle: function saveStyle() {
+
+    this.transitionQueue.push(function (done) {
+      this.elements.forEach(function (element, index) {
+        var css = this.lastStyleAttributeDict[index] = {};
+
+        for (var i = 0; i < element.style.length; i++) {
+          css[element.style[i]] = element.style[element.style[i]];
+        }
+      }.bind(this));
+      done();
+    }.bind(this));
+
+    return this;
+  },
+
+  /**
+   * Restore element's style.
+   *
+   * @param {Object} [options]
+   * @param {Float} [options.duration]
+   * @param {String} [options.timing]
+   * @param {String} [options.transition]
+   */
+  restoreStyle: function restoreStyle(options) {
+    options = options || {};
+    var self = this;
+
+    if (options.transition && !options.duration) {
+      throw new Error('"options.duration" is required when "options.transition" is enabled.');
+    }
+
+    var transitionName = util$4.transitionPropertyName;
+
+    if (options.transition || options.duration && options.duration > 0) {
+      var transitionValue = options.transition || 'all ' + options.duration + 's ' + (options.timing || 'linear');
+
+      this.transitionQueue.push(function (done) {
+        var elements = this.elements;
+        var timeoutId;
+
+        var clearTransition = function clearTransition() {
+          elements.forEach(function (element) {
+            element.style[transitionName] = '';
+          });
+        };
+
+        // add "transitionend" event handler
+        var removeListeners = util$4.onceOnTransitionEnd(elements[0], function () {
+          clearTimeout(timeoutId);
+          clearTransition();
+          done();
+        });
+
+        // for fail safe.
+        timeoutId = setTimeout(function () {
+          removeListeners();
+          clearTransition();
+          done();
+        }, options.duration * 1000 * TIMEOUT_RATIO);
+
+        // transition and style settings
+        elements.forEach(function (element, index) {
+
+          var css = self.lastStyleAttributeDict[index];
+
+          if (!css) {
+            throw new Error('restoreStyle(): The style is not saved. Invoke saveStyle() before.');
+          }
+
+          self.lastStyleAttributeDict[index] = undefined;
+
+          var name;
+          for (var i = 0, len = element.style.length; i < len; i++) {
+            name = element.style[i];
+            if (css[name] === undefined) {
+              css[name] = '';
+            }
+          }
+
+          element.style[transitionName] = transitionValue;
+
+          Object.keys(css).forEach(function (key) {
+            if (key !== transitionName) {
+              element.style[key] = css[key];
+            }
+          });
+
+          element.style[transitionName] = transitionValue;
+        });
+      });
+    } else {
+      this.transitionQueue.push(function (done) {
+        reset();
+        done();
+      });
+    }
+
+    return this;
+
+    function reset() {
+      // Clear transition animation settings.
+      self.elements.forEach(function (element, index) {
+        element.style[transitionName] = 'none';
+
+        var css = self.lastStyleAttributeDict[index];
+
+        if (!css) {
+          throw new Error('restoreStyle(): The style is not saved. Invoke saveStyle() before.');
+        }
+
+        self.lastStyleAttributeDict[index] = undefined;
+
+        for (var i = 0, name = ''; i < element.style.length; i++) {
+          name = element.style[i];
+          if (typeof css[element.style[i]] === 'undefined') {
+            css[element.style[i]] = '';
+          }
+        }
+
+        Object.keys(css).forEach(function (key) {
+          element.style[key] = css[key];
+        });
+      });
+    }
+  },
+
+  /**
+   * Start animation sequence.
+   */
+  startAnimation: function startAnimation() {
+    this._dequeueTransition();
+
+    return this;
+  },
+
+  _dequeueTransition: function _dequeueTransition() {
+    var transition = this.transitionQueue.shift();
+    if (this._currentTransition) {
+      throw new Error('Current transition exists.');
+    }
+    this._currentTransition = transition;
+    var self = this;
+    var called = false;
+
+    var done = function done() {
+      if (!called) {
+        called = true;
+        self._currentTransition = undefined;
+        self._dequeueTransition();
+      } else {
+        throw new Error('Invalid state: This callback is called twice.');
+      }
+    };
+
+    if (transition) {
+      transition.call(this, done);
+    }
+  }
+
+};
+
+/**
+ * @param {Animit} arguments
+ */
+Animit.runAll = function () /* arguments... */{
+  for (var i = 0; i < arguments.length; i++) {
+    arguments[i].play();
+  }
+};
+
+/**
+ * @param {Object} options
+ * @param {Float} [options.duration]
+ * @param {String} [options.property]
+ * @param {String} [options.timing]
+ */
+Animit.Transition = function (options) {
+  this.options = options || {};
+  this.options.duration = this.options.duration || 0;
+  this.options.timing = this.options.timing || 'linear';
+  this.options.css = this.options.css || {};
+  this.options.property = this.options.property || 'all';
+};
+
+Animit.Transition.prototype = {
+
+  /**
+   * @param {HTMLElement} element
+   * @return {Function}
+   */
+  build: function build() {
+
+    if (Object.keys(this.options.css).length === 0) {
+      throw new Error('options.css is required.');
+    }
+
+    var css = createActualCssProps(this.options.css);
+
+    if (this.options.duration > 0) {
+      var transitionValue = util$4.buildTransitionValue(this.options);
+      var self = this;
+
+      return function (callback) {
+        var elements = this.elements;
+        var timeout = self.options.duration * 1000 * TIMEOUT_RATIO;
+        var timeoutId;
+
+        var removeListeners = util$4.onceOnTransitionEnd(elements[0], function () {
+          clearTimeout(timeoutId);
+          callback();
+        });
+
+        timeoutId = setTimeout(function () {
+          removeListeners();
+          callback();
+        }, timeout);
+
+        elements.forEach(function (element) {
+          element.style[util$4.transitionPropertyName] = transitionValue;
+
+          Object.keys(css).forEach(function (name) {
+            element.style[name] = css[name];
+          });
+        });
+      };
+    }
+
+    if (this.options.duration <= 0) {
+      return function (callback) {
+        var elements = this.elements;
+
+        elements.forEach(function (element) {
+          element.style[util$4.transitionPropertyName] = '';
+
+          Object.keys(css).forEach(function (name) {
+            element.style[name] = css[name];
+          });
+        });
+
+        if (elements.length > 0) {
+          util$4.forceLayoutAtOnce(elements, function () {
+            util$4.batchAnimationFrame(callback);
+          });
+        } else {
+          util$4.batchAnimationFrame(callback);
+        }
+      };
+    }
+
+    function createActualCssProps(css) {
+      var result = {};
+
+      Object.keys(css).forEach(function (name) {
+        var value = css[name];
+
+        if (util$4.hasCssProperty(name)) {
+          result[name] = value;
+          return;
+        }
+
+        var prefixed = util$4.vendorPrefix + util$4.capitalize(name);
+        if (util$4.hasCssProperty(prefixed)) {
+          result[prefixed] = value;
+        } else {
+          result[prefixed] = value;
+          result[name] = value;
+        }
+      });
+
+      return result;
+    }
+  }
+};
+
+/*
+ * Gesture detector library that forked from github.com/EightMedia/hammer.js.
+ */
+
+var Event$1;
+var Utils;
+var Detection;
+var PointerEvent;
+
+/**
+ * @object ons.GestureDetector
+ * @category gesture
+ * @description
+ *   [en]Utility class for gesture detection.[/en]
+ *   [ja]ジェスチャを検知するためのユーティリティクラスです。[/ja]
+ */
+
+/**
+ * @method constructor
+ * @signature constructor(element[, options])
+ * @description
+ *  [en]Create a new GestureDetector instance.[/en]
+ *  [ja]GestureDetectorのインスタンスを生成します。[/ja]
+ * @param {Element} element
+ *   [en]Name of the event.[/en]
+ *   [ja]ジェスチャを検知するDOM要素を指定します。[/ja]
+ * @param {Object} [options]
+ *   [en]Options object.[/en]
+ *   [ja]オプションを指定します。[/ja]
+ * @return {ons.GestureDetector.Instance}
+ */
+var GestureDetector = function GestureDetector(element, options) {
+  return new GestureDetector.Instance(element, options || {});
+};
+
+/**
+ * default settings.
+ * more settings are defined per gesture at `/gestures`. Each gesture can be disabled/enabled
+ * by setting it's name (like `swipe`) to false.
+ * You can set the defaults for all instances by changing this object before creating an instance.
+ * @example
+ * ````
+ *  GestureDetector.defaults.drag = false;
+ *  GestureDetector.defaults.behavior.touchAction = 'pan-y';
+ *  delete GestureDetector.defaults.behavior.userSelect;
+ * ````
+ * @property defaults
+ * @type {Object}
+ */
+GestureDetector.defaults = {
+  behavior: {
+    // userSelect: 'none', // Also disables selection in `input` children
+    touchAction: 'pan-y',
+    touchCallout: 'none',
+    contentZooming: 'none',
+    userDrag: 'none',
+    tapHighlightColor: 'rgba(0,0,0,0)'
+  }
+};
+
+/**
+ * GestureDetector document where the base events are added at
+ * @property DOCUMENT
+ * @type {HTMLElement}
+ * @default window.document
+ */
+GestureDetector.DOCUMENT = document;
+
+/**
+ * detect support for pointer events
+ * @property HAS_POINTEREVENTS
+ * @type {Boolean}
+ */
+GestureDetector.HAS_POINTEREVENTS = navigator.pointerEnabled || navigator.msPointerEnabled;
+
+/**
+ * detect support for touch events
+ * @property HAS_TOUCHEVENTS
+ * @type {Boolean}
+ */
+GestureDetector.HAS_TOUCHEVENTS = 'ontouchstart' in window;
+
+/**
+ * detect mobile browsers
+ * @property IS_MOBILE
+ * @type {Boolean}
+ */
+GestureDetector.IS_MOBILE = /mobile|tablet|ip(ad|hone|od)|android|silk/i.test(navigator.userAgent);
+
+/**
+ * detect if we want to support mouseevents at all
+ * @property NO_MOUSEEVENTS
+ * @type {Boolean}
+ */
+GestureDetector.NO_MOUSEEVENTS = GestureDetector.HAS_TOUCHEVENTS && GestureDetector.IS_MOBILE || GestureDetector.HAS_POINTEREVENTS;
+
+/**
+ * interval in which GestureDetector recalculates current velocity/direction/angle in ms
+ * @property CALCULATE_INTERVAL
+ * @type {Number}
+ * @default 25
+ */
+GestureDetector.CALCULATE_INTERVAL = 25;
+
+/**
+ * eventtypes per touchevent (start, move, end) are filled by `Event.determineEventTypes` on `setup`
+ * the object contains the DOM event names per type (`EVENT_START`, `EVENT_MOVE`, `EVENT_END`)
+ * @property EVENT_TYPES
+ * @private
+ * @writeOnce
+ * @type {Object}
+ */
+var EVENT_TYPES = {};
+
+/**
+ * direction strings, for safe comparisons
+ * @property DIRECTION_DOWN|LEFT|UP|RIGHT
+ * @final
+ * @type {String}
+ * @default 'down' 'left' 'up' 'right'
+ */
+var DIRECTION_DOWN = GestureDetector.DIRECTION_DOWN = 'down';
+var DIRECTION_LEFT = GestureDetector.DIRECTION_LEFT = 'left';
+var DIRECTION_UP = GestureDetector.DIRECTION_UP = 'up';
+var DIRECTION_RIGHT = GestureDetector.DIRECTION_RIGHT = 'right';
+
+/**
+ * pointertype strings, for safe comparisons
+ * @property POINTER_MOUSE|TOUCH|PEN
+ * @final
+ * @type {String}
+ * @default 'mouse' 'touch' 'pen'
+ */
+var POINTER_MOUSE = GestureDetector.POINTER_MOUSE = 'mouse';
+var POINTER_TOUCH = GestureDetector.POINTER_TOUCH = 'touch';
+var POINTER_PEN = GestureDetector.POINTER_PEN = 'pen';
+
+/**
+ * eventtypes
+ * @property EVENT_START|MOVE|END|RELEASE|TOUCH
+ * @final
+ * @type {String}
+ * @default 'start' 'change' 'move' 'end' 'release' 'touch'
+ */
+var EVENT_START = GestureDetector.EVENT_START = 'start';
+var EVENT_MOVE = GestureDetector.EVENT_MOVE = 'move';
+var EVENT_END = GestureDetector.EVENT_END = 'end';
+var EVENT_RELEASE = GestureDetector.EVENT_RELEASE = 'release';
+var EVENT_TOUCH = GestureDetector.EVENT_TOUCH = 'touch';
+
+/**
+ * if the window events are set...
+ * @property READY
+ * @writeOnce
+ * @type {Boolean}
+ * @default false
+ */
+GestureDetector.READY = false;
+
+/**
+ * plugins namespace
+ * @property plugins
+ * @type {Object}
+ */
+GestureDetector.plugins = GestureDetector.plugins || {};
+
+/**
+ * gestures namespace
+ * see `/gestures` for the definitions
+ * @property gestures
+ * @type {Object}
+ */
+GestureDetector.gestures = GestureDetector.gestures || {};
+
+/**
+ * setup events to detect gestures on the document
+ * this function is called when creating an new instance
+ * @private
+ */
+function setup(opts) {
+  if (GestureDetector.READY) {
+    return;
+  }
+
+  // find what eventtypes we add listeners to
+  Event$1.determineEventTypes();
+
+  // Register all gestures inside GestureDetector.gestures
+  Utils.each(GestureDetector.gestures, function (gesture) {
+    Detection.register(gesture);
+  });
+
+  // Add touch events on the document
+  Event$1.onTouch(GestureDetector.DOCUMENT, EVENT_MOVE, Detection.detect, opts);
+  Event$1.onTouch(GestureDetector.DOCUMENT, EVENT_END, Detection.detect, opts);
+
+  // GestureDetector is ready...!
+  GestureDetector.READY = true;
+}
+
+/**
+ * @module GestureDetector
+ *
+ * @class Utils
+ * @static
+ */
+Utils = GestureDetector.utils = {
+  /**
+   * extend method, could also be used for cloning when `dest` is an empty object.
+   * changes the dest object
+   * @param {Object} dest
+   * @param {Object} src
+   * @param {Boolean} [merge=false]  do a merge
+   * @return {Object} dest
+   */
+  extend: function extend(dest, src, merge) {
+    for (var key in src) {
+      if (src.hasOwnProperty(key) && (dest[key] === undefined || !merge)) {
+        dest[key] = src[key];
+      }
+    }
+    return dest;
+  },
+
+  /**
+   * simple addEventListener wrapper
+   * @param {HTMLElement} element
+   * @param {String} type
+   * @param {Function} handler
+   */
+  on: function on(element, type, handler, opt) {
+    util$1.addEventListener(element, type, handler, opt, true);
+  },
+
+  /**
+   * simple removeEventListener wrapper
+   * @param {HTMLElement} element
+   * @param {String} type
+   * @param {Function} handler
+   */
+  off: function off(element, type, handler, opt) {
+    util$1.removeEventListener(element, type, handler, opt, true);
+  },
+
+  /**
+   * forEach over arrays and objects
+   * @param {Object|Array} obj
+   * @param {Function} iterator
+   * @param {any} iterator.item
+   * @param {Number} iterator.index
+   * @param {Object|Array} iterator.obj the source object
+   * @param {Object} context value to use as `this` in the iterator
+   */
+  each: function each(obj, iterator, context) {
+    var i, len;
+
+    // native forEach on arrays
+    if ('forEach' in obj) {
+      obj.forEach(iterator, context);
+      // arrays
+    } else if (obj.length !== undefined) {
+      for (i = 0, len = obj.length; i < len; i++) {
+        if (iterator.call(context, obj[i], i, obj) === false) {
+          return;
+        }
+      }
+      // objects
+    } else {
+      for (i in obj) {
+        if (obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj) === false) {
+          return;
+        }
+      }
+    }
+  },
+
+  /**
+   * find if a string contains the string using indexOf
+   * @param {String} src
+   * @param {String} find
+   * @return {Boolean} found
+   */
+  inStr: function inStr(src, find) {
+    return src.indexOf(find) > -1;
+  },
+
+  /**
+   * find if a array contains the object using indexOf or a simple polyfill
+   * @param {String} src
+   * @param {String} find
+   * @return {Boolean|Number} false when not found, or the index
+   */
+  inArray: function inArray(src, find, deep) {
+    if (deep) {
+      for (var i = 0, len = src.length; i < len; i++) {
+        // Array.findIndex
+        if (Object.keys(find).every(function (key) {
+          return src[i][key] === find[key];
+        })) {
+          return i;
+        }
+      }
+      return -1;
+    }
+
+    if (src.indexOf) {
+      return src.indexOf(find);
+    } else {
+      for (var i = 0, len = src.length; i < len; i++) {
+        if (src[i] === find) {
+          return i;
+        }
+      }
+      return -1;
+    }
+  },
+
+  /**
+   * convert an array-like object (`arguments`, `touchlist`) to an array
+   * @param {Object} obj
+   * @return {Array}
+   */
+  toArray: function toArray(obj) {
+    return Array.prototype.slice.call(obj, 0);
+  },
+
+  /**
+   * find if a node is in the given parent
+   * @param {HTMLElement} node
+   * @param {HTMLElement} parent
+   * @return {Boolean} found
+   */
+  hasParent: function hasParent(node, parent) {
+    while (node) {
+      if (node == parent) {
+        return true;
+      }
+      node = node.parentNode;
+    }
+    return false;
+  },
+
+  /**
+   * get the center of all the touches
+   * @param {Array} touches
+   * @return {Object} center contains `pageX`, `pageY`, `clientX` and `clientY` properties
+   */
+  getCenter: function getCenter(touches) {
+    var pageX = [],
+        pageY = [],
+        clientX = [],
+        clientY = [],
+        min = Math.min,
+        max = Math.max;
+
+    // no need to loop when only one touch
+    if (touches.length === 1) {
+      return {
+        pageX: touches[0].pageX,
+        pageY: touches[0].pageY,
+        clientX: touches[0].clientX,
+        clientY: touches[0].clientY
+      };
+    }
+
+    Utils.each(touches, function (touch) {
+      pageX.push(touch.pageX);
+      pageY.push(touch.pageY);
+      clientX.push(touch.clientX);
+      clientY.push(touch.clientY);
+    });
+
+    return {
+      pageX: (min.apply(Math, pageX) + max.apply(Math, pageX)) / 2,
+      pageY: (min.apply(Math, pageY) + max.apply(Math, pageY)) / 2,
+      clientX: (min.apply(Math, clientX) + max.apply(Math, clientX)) / 2,
+      clientY: (min.apply(Math, clientY) + max.apply(Math, clientY)) / 2
+    };
+  },
+
+  /**
+   * calculate the velocity between two points. unit is in px per ms.
+   * @param {Number} deltaTime
+   * @param {Number} deltaX
+   * @param {Number} deltaY
+   * @return {Object} velocity `x` and `y`
+   */
+  getVelocity: function getVelocity(deltaTime, deltaX, deltaY) {
+    return {
+      x: Math.abs(deltaX / deltaTime) || 0,
+      y: Math.abs(deltaY / deltaTime) || 0
+    };
+  },
+
+  /**
+   * calculate the angle between two coordinates
+   * @param {Touch} touch1
+   * @param {Touch} touch2
+   * @return {Number} angle
+   */
+  getAngle: function getAngle(touch1, touch2) {
+    var x = touch2.clientX - touch1.clientX,
+        y = touch2.clientY - touch1.clientY;
+
+    return Math.atan2(y, x) * 180 / Math.PI;
+  },
+
+  /**
+   * do a small comparison to get the direction between two touches.
+   * @param {Touch} touch1
+   * @param {Touch} touch2
+   * @return {String} direction matches `DIRECTION_LEFT|RIGHT|UP|DOWN`
+   */
+  getDirection: function getDirection(touch1, touch2) {
+    var x = Math.abs(touch1.clientX - touch2.clientX),
+        y = Math.abs(touch1.clientY - touch2.clientY);
+
+    if (x >= y) {
+      return touch1.clientX - touch2.clientX > 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
+    }
+    return touch1.clientY - touch2.clientY > 0 ? DIRECTION_UP : DIRECTION_DOWN;
+  },
+
+  /**
+   * calculate the distance between two touches
+   * @param {Touch}touch1
+   * @param {Touch} touch2
+   * @return {Number} distance
+   */
+  getDistance: function getDistance(touch1, touch2) {
+    var x = touch2.clientX - touch1.clientX,
+        y = touch2.clientY - touch1.clientY;
+
+    return Math.sqrt(x * x + y * y);
+  },
+
+  /**
+   * calculate the scale factor between two touchLists
+   * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out
+   * @param {Array} start array of touches
+   * @param {Array} end array of touches
+   * @return {Number} scale
+   */
+  getScale: function getScale(start, end) {
+    // need two fingers...
+    if (start.length >= 2 && end.length >= 2) {
+      return this.getDistance(end[0], end[1]) / this.getDistance(start[0], start[1]);
+    }
+    return 1;
+  },
+
+  /**
+   * calculate the rotation degrees between two touchLists
+   * @param {Array} start array of touches
+   * @param {Array} end array of touches
+   * @return {Number} rotation
+   */
+  getRotation: function getRotation(start, end) {
+    // need two fingers
+    if (start.length >= 2 && end.length >= 2) {
+      return this.getAngle(end[1], end[0]) - this.getAngle(start[1], start[0]);
+    }
+    return 0;
+  },
+
+  /**
+   * find out if the direction is vertical   *
+   * @param {String} direction matches `DIRECTION_UP|DOWN`
+   * @return {Boolean} is_vertical
+   */
+  isVertical: function isVertical(direction) {
+    return direction == DIRECTION_UP || direction == DIRECTION_DOWN;
+  },
+
+  /**
+   * set css properties with their prefixes
+   * @param {HTMLElement} element
+   * @param {String} prop
+   * @param {String} value
+   * @param {Boolean} [toggle=true]
+   * @return {Boolean}
+   */
+  setPrefixedCss: function setPrefixedCss(element, prop, value, toggle) {
+    var prefixes = ['', 'Webkit', 'Moz', 'O', 'ms'];
+    prop = Utils.toCamelCase(prop);
+
+    for (var i = 0; i < prefixes.length; i++) {
+      var p = prop;
+      // prefixes
+      if (prefixes[i]) {
+        p = prefixes[i] + p.slice(0, 1).toUpperCase() + p.slice(1);
+      }
+
+      // test the style
+      if (p in element.style) {
+        element.style[p] = (toggle === null || toggle) && value || '';
+        break;
+      }
+    }
+  },
+
+  /**
+   * toggle browser default behavior by setting css properties.
+   * `userSelect='none'` also sets `element.onselectstart` to false
+   * `userDrag='none'` also sets `element.ondragstart` to false
+   *
+   * @param {HtmlElement} element
+   * @param {Object} props
+   * @param {Boolean} [toggle=true]
+   */
+  toggleBehavior: function toggleBehavior(element, props, toggle) {
+    if (!props || !element || !element.style) {
+      return;
+    }
+
+    // set the css properties
+    Utils.each(props, function (value, prop) {
+      Utils.setPrefixedCss(element, prop, value, toggle);
+    });
+
+    var falseFn = toggle && function () {
+      return false;
+    };
+
+    // also the disable onselectstart
+    if (props.userSelect == 'none') {
+      element.onselectstart = falseFn;
+    }
+    // and disable ondragstart
+    if (props.userDrag == 'none') {
+      element.ondragstart = falseFn;
+    }
+  },
+
+  /**
+   * convert a string with underscores to camelCase
+   * so prevent_default becomes preventDefault
+   * @param {String} str
+   * @return {String} camelCaseStr
+   */
+  toCamelCase: function toCamelCase(str) {
+    return str.replace(/[_-]([a-z])/g, function (s) {
+      return s[1].toUpperCase();
+    });
+  }
+};
+
+/**
+ * @module GestureDetector
+ */
+/**
+ * @class Event
+ * @static
+ */
+Event$1 = GestureDetector.event = {
+  /**
+   * when touch events have been fired, this is true
+   * this is used to stop mouse events
+   * @property prevent_mouseevents
+   * @private
+   * @type {Boolean}
+   */
+  preventMouseEvents: false,
+
+  /**
+   * if EVENT_START has been fired
+   * @property started
+   * @private
+   * @type {Boolean}
+   */
+  started: false,
+
+  /**
+   * when the mouse is hold down, this is true
+   * @property should_detect
+   * @private
+   * @type {Boolean}
+   */
+  shouldDetect: false,
+
+  /**
+   * simple event binder with a hook and support for multiple types
+   * @param {HTMLElement} element
+   * @param {String} type
+   * @param {Function} handler
+   * @param {Object} [opt]
+   * @param {Function} [hook]
+   * @param {Object} hook.type
+   */
+  on: function on(element, type, handler, opt, hook) {
+    var types = type.split(' ');
+    Utils.each(types, function (type) {
+      Utils.on(element, type, handler, opt);
+      hook && hook(type);
+    });
+  },
+
+  /**
+   * simple event unbinder with a hook and support for multiple types
+   * @param {HTMLElement} element
+   * @param {String} type
+   * @param {Function} handler
+   * @param {Object} [opt]
+   * @param {Function} [hook]
+   * @param {Object} hook.type
+   */
+  off: function off(element, type, handler, opt, hook) {
+    var types = type.split(' ');
+    Utils.each(types, function (type) {
+      Utils.off(element, type, handler, opt);
+      hook && hook(type);
+    });
+  },
+
+  /**
+   * the core touch event handler.
+   * this finds out if we should to detect gestures
+   * @param {HTMLElement} element
+   * @param {String} eventType matches `EVENT_START|MOVE|END`
+   * @param {Function} handler
+   * @return onTouchHandler {Function} the core event handler
+   */
+  onTouch: function onTouch(element, eventType, handler, opt) {
+    var self = this;
+
+    var onTouchHandler = function onTouchHandler(ev) {
+      var srcType = ev.type.toLowerCase(),
+          isPointer = GestureDetector.HAS_POINTEREVENTS,
+          isMouse = Utils.inStr(srcType, 'mouse'),
+          triggerType;
+
+      // if we are in a mouseevent, but there has been a touchevent triggered in this session
+      // we want to do nothing. simply break out of the event.
+      if (isMouse && self.preventMouseEvents) {
+        return;
+
+        // mousebutton must be down
+      } else if (isMouse && eventType == EVENT_START && ev.button === 0) {
+        self.preventMouseEvents = false;
+        self.shouldDetect = true;
+      } else if (isPointer && eventType == EVENT_START) {
+        self.shouldDetect = ev.buttons === 1 || PointerEvent.matchType(POINTER_TOUCH, ev);
+        // just a valid start event, but no mouse
+      } else if (!isMouse && eventType == EVENT_START) {
+        self.preventMouseEvents = true;
+        self.shouldDetect = true;
+      }
+
+      // update the pointer event before entering the detection
+      if (isPointer && eventType != EVENT_END) {
+        PointerEvent.updatePointer(eventType, ev);
+      }
+
+      // we are in a touch/down state, so allowed detection of gestures
+      if (self.shouldDetect) {
+        triggerType = self.doDetect.call(self, ev, eventType, element, handler);
+      }
+
+      // ...and we are done with the detection
+      // so reset everything to start each detection totally fresh
+      if (triggerType == EVENT_END) {
+        self.preventMouseEvents = false;
+        self.shouldDetect = false;
+        PointerEvent.reset();
+        // update the pointerevent object after the detection
+      }
+
+      if (isPointer && eventType == EVENT_END) {
+        PointerEvent.updatePointer(eventType, ev);
+      }
+    };
+
+    this.on(element, EVENT_TYPES[eventType], onTouchHandler, opt);
+    return onTouchHandler;
+  },
+
+  /**
+   * the core detection method
+   * this finds out what GestureDetector-touch-events to trigger
+   * @param {Object} ev
+   * @param {String} eventType matches `EVENT_START|MOVE|END`
+   * @param {HTMLElement} element
+   * @param {Function} handler
+   * @return {String} triggerType matches `EVENT_START|MOVE|END`
+   */
+  doDetect: function doDetect(ev, eventType, element, handler) {
+    var touchList = this.getTouchList(ev, eventType);
+    var touchListLength = touchList.length;
+    var triggerType = eventType;
+    var triggerChange = touchList.trigger; // used by fakeMultitouch plugin
+    var changedLength = touchListLength;
+
+    // at each touchstart-like event we want also want to trigger a TOUCH event...
+    if (eventType == EVENT_START) {
+      triggerChange = EVENT_TOUCH;
+      // ...the same for a touchend-like event
+    } else if (eventType == EVENT_END) {
+      triggerChange = EVENT_RELEASE;
+
+      // keep track of how many touches have been removed
+      changedLength = touchList.length - (ev.changedTouches ? ev.changedTouches.length : 1);
+    }
+
+    // after there are still touches on the screen,
+    // we just want to trigger a MOVE event. so change the START or END to a MOVE
+    // but only after detection has been started, the first time we actually want a START
+    if (changedLength > 0 && this.started) {
+      triggerType = EVENT_MOVE;
+    }
+
+    // detection has been started, we keep track of this, see above
+    this.started = true;
+
+    // generate some event data, some basic information
+    var evData = this.collectEventData(element, triggerType, touchList, ev);
+
+    // trigger the triggerType event before the change (TOUCH, RELEASE) events
+    // but the END event should be at last
+    if (eventType != EVENT_END) {
+      handler.call(Detection, evData);
+    }
+
+    // trigger a change (TOUCH, RELEASE) event, this means the length of the touches changed
+    if (triggerChange) {
+      evData.changedLength = changedLength;
+      evData.eventType = triggerChange;
+
+      handler.call(Detection, evData);
+
+      evData.eventType = triggerType;
+      delete evData.changedLength;
+    }
+
+    // trigger the END event
+    if (triggerType == EVENT_END) {
+      handler.call(Detection, evData);
+
+      // ...and we are done with the detection
+      // so reset everything to start each detection totally fresh
+      this.started = false;
+    }
+
+    return triggerType;
+  },
+
+  /**
+   * we have different events for each device/browser
+   * determine what we need and set them in the EVENT_TYPES constant
+   * the `onTouch` method is bind to these properties.
+   * @return {Object} events
+   */
+  determineEventTypes: function determineEventTypes() {
+    var types;
+    if (GestureDetector.HAS_POINTEREVENTS) {
+      if (window.PointerEvent) {
+        types = ['pointerdown', 'pointermove', 'pointerup pointercancel lostpointercapture'];
+      } else {
+        types = ['MSPointerDown', 'MSPointerMove', 'MSPointerUp MSPointerCancel MSLostPointerCapture'];
+      }
+    } else if (GestureDetector.NO_MOUSEEVENTS) {
+      types = ['touchstart', 'touchmove', 'touchend touchcancel'];
+    } else {
+      types = ['touchstart mousedown', 'touchmove mousemove', 'touchend touchcancel mouseup'];
+    }
+
+    EVENT_TYPES[EVENT_START] = types[0];
+    EVENT_TYPES[EVENT_MOVE] = types[1];
+    EVENT_TYPES[EVENT_END] = types[2];
+    return EVENT_TYPES;
+  },
+
+  /**
+   * create touchList depending on the event
+   * @param {Object} ev
+   * @param {String} eventType
+   * @return {Array} touches
+   */
+  getTouchList: function getTouchList(ev, eventType) {
+    // get the fake pointerEvent touchlist
+    if (GestureDetector.HAS_POINTEREVENTS) {
+      return PointerEvent.getTouchList();
+    }
+
+    // get the touchlist
+    if (ev.touches) {
+      if (eventType == EVENT_MOVE) {
+        return ev.touches;
+      }
+
+      var identifiers = [];
+      var concat = [].concat(Utils.toArray(ev.touches), Utils.toArray(ev.changedTouches));
+      var touchList = [];
+
+      Utils.each(concat, function (touch) {
+        if (Utils.inArray(identifiers, touch.identifier) === -1) {
+          touchList.push(touch);
+        }
+        identifiers.push(touch.identifier);
+      });
+
+      return touchList;
+    }
+
+    // make fake touchList from mouse position
+    ev.identifier = 1;
+    return [ev];
+  },
+
+  /**
+   * collect basic event data
+   * @param {HTMLElement} element
+   * @param {String} eventType matches `EVENT_START|MOVE|END`
+   * @param {Array} touches
+   * @param {Object} ev
+   * @return {Object} ev
+   */
+  collectEventData: function collectEventData(element, eventType, touches, ev) {
+    // find out pointerType
+    var pointerType = POINTER_TOUCH;
+    if (Utils.inStr(ev.type, 'mouse') || PointerEvent.matchType(POINTER_MOUSE, ev)) {
+      pointerType = POINTER_MOUSE;
+    } else if (PointerEvent.matchType(POINTER_PEN, ev)) {
+      pointerType = POINTER_PEN;
+    }
+
+    return {
+      center: Utils.getCenter(touches),
+      timeStamp: Date.now(),
+      target: ev.target,
+      touches: touches,
+      eventType: eventType,
+      pointerType: pointerType,
+      srcEvent: ev,
+
+      /**
+       * prevent the browser default actions
+       * mostly used to disable scrolling of the browser
+       */
+      preventDefault: function preventDefault() {
+        var srcEvent = this.srcEvent;
+        srcEvent.preventManipulation && srcEvent.preventManipulation();
+        srcEvent.preventDefault && srcEvent.preventDefault();
+      },
+
+      /**
+       * stop bubbling the event up to its parents
+       */
+      stopPropagation: function stopPropagation() {
+        this.srcEvent.stopPropagation();
+      },
+
+      /**
+       * immediately stop gesture detection
+       * might be useful after a swipe was detected
+       * @return {*}
+       */
+      stopDetect: function stopDetect() {
+        return Detection.stopDetect();
+      }
+    };
+  }
+};
+
+/**
+ * @module GestureDetector
+ *
+ * @class PointerEvent
+ * @static
+ */
+PointerEvent = GestureDetector.PointerEvent = {
+  /**
+   * holds all pointers, by `identifier`
+   * @property pointers
+   * @type {Object}
+   */
+  pointers: {},
+
+  /**
+   * get the pointers as an array
+   * @return {Array} touchlist
+   */
+  getTouchList: function getTouchList() {
+    var touchlist = [];
+    // we can use forEach since pointerEvents only is in IE10
+    Utils.each(this.pointers, function (pointer) {
+      touchlist.push(pointer);
+    });
+    return touchlist;
+  },
+
+  /**
+   * update the position of a pointer
+   * @param {String} eventType matches `EVENT_START|MOVE|END`
+   * @param {Object} pointerEvent
+   */
+  updatePointer: function updatePointer(eventType, pointerEvent) {
+    if (eventType == EVENT_END || eventType != EVENT_END && pointerEvent.buttons !== 1) {
+      delete this.pointers[pointerEvent.pointerId];
+    } else {
+      pointerEvent.identifier = pointerEvent.pointerId;
+      this.pointers[pointerEvent.pointerId] = pointerEvent;
+    }
+  },
+
+  /**
+   * check if ev matches pointertype
+   * @param {String} pointerType matches `POINTER_MOUSE|TOUCH|PEN`
+   * @param {PointerEvent} ev
+   */
+  matchType: function matchType(pointerType, ev) {
+    if (!ev.pointerType) {
+      return false;
+    }
+
+    var pt = ev.pointerType,
+        types = {};
+
+    types[POINTER_MOUSE] = pt === (ev.MSPOINTER_TYPE_MOUSE || POINTER_MOUSE);
+    types[POINTER_TOUCH] = pt === (ev.MSPOINTER_TYPE_TOUCH || POINTER_TOUCH);
+    types[POINTER_PEN] = pt === (ev.MSPOINTER_TYPE_PEN || POINTER_PEN);
+    return types[pointerType];
+  },
+
+  /**
+   * reset the stored pointers
+   */
+  reset: function resetList() {
+    this.pointers = {};
+  }
+};
+
+/**
+ * @module GestureDetector
+ *
+ * @class Detection
+ * @static
+ */
+Detection = GestureDetector.detection = {
+  // contains all registered GestureDetector.gestures in the correct order
+  gestures: [],
+
+  // data of the current GestureDetector.gesture detection session
+  current: null,
+
+  // the previous GestureDetector.gesture session data
+  // is a full clone of the previous gesture.current object
+  previous: null,
+
+  // when this becomes true, no gestures are fired
+  stopped: false,
+
+  /**
+   * start GestureDetector.gesture detection
+   * @param {GestureDetector.Instance} inst
+   * @param {Object} eventData
+   */
+  startDetect: function startDetect(inst, eventData) {
+    // already busy with a GestureDetector.gesture detection on an element
+    if (this.current) {
+      return;
+    }
+
+    this.stopped = false;
+
+    // holds current session
+    this.current = {
+      inst: inst, // reference to GestureDetectorInstance we're working for
+      startEvent: Utils.extend({}, eventData), // start eventData for distances, timing etc
+      lastEvent: false, // last eventData
+      lastCalcEvent: false, // last eventData for calculations.
+      futureCalcEvent: false, // last eventData for calculations.
+      lastCalcData: {}, // last lastCalcData
+      name: '' // current gesture we're in/detected, can be 'tap', 'hold' etc
+    };
+
+    this.detect(eventData);
+  },
+
+  /**
+   * GestureDetector.gesture detection
+   * @param {Object} eventData
+   * @return {any}
+   */
+  detect: function detect(eventData) {
+    if (!this.current || this.stopped) {
+      return;
+    }
+
+    // extend event data with calculations about scale, distance etc
+    eventData = this.extendEventData(eventData);
+
+    // GestureDetector instance and instance options
+    var inst = this.current.inst,
+        instOptions = inst.options;
+
+    // call GestureDetector.gesture handlers
+    Utils.each(this.gestures, function triggerGesture(gesture) {
+      // only when the instance options have enabled this gesture
+      if (!this.stopped && inst.enabled && instOptions[gesture.name]) {
+        gesture.handler.call(gesture, eventData, inst);
+      }
+    }, this);
+
+    // store as previous event event
+    if (this.current) {
+      this.current.lastEvent = eventData;
+    }
+
+    if (eventData.eventType == EVENT_END) {
+      this.stopDetect();
+    }
+
+    return eventData; // eslint-disable-line consistent-return
+  },
+
+  /**
+   * clear the GestureDetector.gesture vars
+   * this is called on endDetect, but can also be used when a final GestureDetector.gesture has been detected
+   * to stop other GestureDetector.gestures from being fired
+   */
+  stopDetect: function stopDetect() {
+    // clone current data to the store as the previous gesture
+    // used for the double tap gesture, since this is an other gesture detect session
+    this.previous = Utils.extend({}, this.current);
+
+    // reset the current
+    this.current = null;
+    this.stopped = true;
+  },
+
+  /**
+   * calculate velocity, angle and direction
+   * @param {Object} ev
+   * @param {Object} center
+   * @param {Number} deltaTime
+   * @param {Number} deltaX
+   * @param {Number} deltaY
+   */
+  getCalculatedData: function getCalculatedData(ev, center, deltaTime, deltaX, deltaY) {
+    var cur = this.current,
+        recalc = false,
+        calcEv = cur.lastCalcEvent,
+        calcData = cur.lastCalcData;
+
+    if (calcEv && ev.timeStamp - calcEv.timeStamp > GestureDetector.CALCULATE_INTERVAL) {
+      center = calcEv.center;
+      deltaTime = ev.timeStamp - calcEv.timeStamp;
+      deltaX = ev.center.clientX - calcEv.center.clientX;
+      deltaY = ev.center.clientY - calcEv.center.clientY;
+      recalc = true;
+    }
+
+    if (ev.eventType == EVENT_TOUCH || ev.eventType == EVENT_RELEASE) {
+      cur.futureCalcEvent = ev;
+    }
+
+    if (!cur.lastCalcEvent || recalc) {
+      calcData.velocity = Utils.getVelocity(deltaTime, deltaX, deltaY);
+      calcData.angle = Utils.getAngle(center, ev.center);
+      calcData.direction = Utils.getDirection(center, ev.center);
+
+      cur.lastCalcEvent = cur.futureCalcEvent || ev;
+      cur.futureCalcEvent = ev;
+    }
+
+    ev.velocityX = calcData.velocity.x;
+    ev.velocityY = calcData.velocity.y;
+    ev.interimAngle = calcData.angle;
+    ev.interimDirection = calcData.direction;
+  },
+
+  /**
+   * extend eventData for GestureDetector.gestures
+   * @param {Object} ev
+   * @return {Object} ev
+   */
+  extendEventData: function extendEventData(ev) {
+    var cur = this.current,
+        startEv = cur.startEvent,
+        lastEv = cur.lastEvent || startEv;
+
+    // update the start touchlist to calculate the scale/rotation
+    if (ev.eventType == EVENT_TOUCH || ev.eventType == EVENT_RELEASE) {
+      startEv.touches = [];
+      Utils.each(ev.touches, function (touch) {
+        startEv.touches.push({
+          clientX: touch.clientX,
+          clientY: touch.clientY
+        });
+      });
+    }
+
+    var deltaTime = ev.timeStamp - startEv.timeStamp,
+        deltaX = ev.center.clientX - startEv.center.clientX,
+        deltaY = ev.center.clientY - startEv.center.clientY;
+
+    this.getCalculatedData(ev, lastEv.center, deltaTime, deltaX, deltaY);
+
+    Utils.extend(ev, {
+      startEvent: startEv,
+
+      deltaTime: deltaTime,
+      deltaX: deltaX,
+      deltaY: deltaY,
+
+      distance: Utils.getDistance(startEv.center, ev.center),
+      angle: Utils.getAngle(startEv.center, ev.center),
+      direction: Utils.getDirection(startEv.center, ev.center),
+      scale: Utils.getScale(startEv.touches, ev.touches),
+      rotation: Utils.getRotation(startEv.touches, ev.touches)
+    });
+
+    return ev;
+  },
+
+  /**
+   * register new gesture
+   * @param {Object} gesture object, see `gestures/` for documentation
+   * @return {Array} gestures
+   */
+  register: function register(gesture) {
+    // add an enable gesture options if there is no given
+    var options = gesture.defaults || {};
+    if (options[gesture.name] === undefined) {
+      options[gesture.name] = true;
+    }
+
+    // extend GestureDetector default options with the GestureDetector.gesture options
+    Utils.extend(GestureDetector.defaults, options, true);
+
+    // set its index
+    gesture.index = gesture.index || 1000;
+
+    // add GestureDetector.gesture to the list
+    this.gestures.push(gesture);
+
+    // sort the list by index
+    this.gestures.sort(function (a, b) {
+      if (a.index < b.index) {
+        return -1;
+      }
+      if (a.index > b.index) {
+        return 1;
+      }
+      return 0;
+    });
+
+    return this.gestures;
+  }
+};
+
+/**
+ * @module GestureDetector
+ */
+
+/**
+ * create new GestureDetector instance
+ * all methods should return the instance itself, so it is chainable.
+ *
+ * @class Instance
+ * @constructor
+ * @param {HTMLElement} element
+ * @param {Object} [options={}] options are merged with `GestureDetector.defaults`
+ * @return {GestureDetector.Instance}
+ */
+GestureDetector.Instance = function (element, options) {
+  var self = this;
+  var listenerOptions = options && options.passive ? { passive: true } : undefined;
+
+  // setup GestureDetectorJS window events and register all gestures
+  // this also sets up the default options
+  setup(listenerOptions);
+
+  /**
+   * @property element
+   * @type {HTMLElement}
+   */
+  this.element = element;
+
+  /**
+   * @property enabled
+   * @type {Boolean}
+   * @protected
+   */
+  this.enabled = true;
+
+  /**
+   * options, merged with the defaults
+   * options with an _ are converted to camelCase
+   * @property options
+   * @type {Object}
+   */
+  Utils.each(options, function (value, name) {
+    delete options[name];
+    options[Utils.toCamelCase(name)] = value;
+  });
+
+  this.options = Utils.extend(Utils.extend({}, GestureDetector.defaults), options || {});
+  this.options.listenerOptions = listenerOptions;
+
+  // add some css to the element to prevent the browser from doing its native behavior
+  if (this.options.behavior) {
+    Utils.toggleBehavior(this.element, this.options.behavior, true);
+  }
+
+  /**
+   * event start handler on the element to start the detection
+   * @property eventStartHandler
+   * @type {Object}
+   */
+  this.eventStartHandler = Event$1.onTouch(element, EVENT_START, function (ev) {
+    if (self.enabled && ev.eventType == EVENT_START) {
+      Detection.startDetect(self, ev);
+    } else if (ev.eventType == EVENT_TOUCH) {
+      Detection.detect(ev);
+    }
+  }, listenerOptions);
+
+  /**
+   * keep a list of user event handlers which needs to be removed when calling 'dispose'
+   * @property eventHandlers
+   * @type {Array}
+   */
+  this.eventHandlers = [];
+};
+
+GestureDetector.Instance.prototype = {
+  /**
+   * @method on
+   * @signature on(gestures, handler)
+   * @description
+   *  [en]Adds an event handler for a gesture. Available gestures are: drag, dragleft, dragright, dragup, dragdown, hold, release, swipe, swipeleft, swiperight, swipeup, swipedown, tap, doubletap, touch, transform, pinch, pinchin, pinchout and rotate. [/en]
+   *  [ja]ジェスチャに対するイベントハンドラを追加します。指定できるジェスチャ名は、drag dragleft dragright dragup dragdown hold release swipe swipeleft swiperight swipeup swipedown tap doubletap touch transform pinch pinchin pinchout rotate です。[/ja]
+   * @param {String} gestures
+   *   [en]A space separated list of gestures.[/en]
+   *   [ja]検知するジェスチャ名を指定します。スペースで複数指定することができます。[/ja]
+   * @param {Function} handler
+   *   [en]An event handling function.[/en]
+   *   [ja]イベントハンドラとなる関数オブジェクトを指定します。[/ja]
+   */
+  on: function onEvent(gestures, handler, opt) {
+    var self = this;
+
+    Event$1.on(self.element, gestures, handler, util$1.extend({}, self.options.listenerOptions, opt), function (type) {
+      self.eventHandlers.push({ gesture: type, handler: handler });
+    });
+    return self;
+  },
+
+  /**
+   * @method off
+   * @signature off(gestures, handler)
+   * @description
+   *  [en]Remove an event listener.[/en]
+   *  [ja]イベントリスナーを削除します。[/ja]
+   * @param {String} gestures
+   *   [en]A space separated list of gestures.[/en]
+   *   [ja]ジェスチャ名を指定します。スペースで複数指定することができます。[/ja]
+   * @param {Function} handler
+   *   [en]An event handling function.[/en]
+   *   [ja]イベントハンドラとなる関数オブジェクトを指定します。[/ja]
+   */
+  off: function offEvent(gestures, handler, opt) {
+    var self = this;
+
+    Event$1.off(self.element, gestures, handler, util$1.extend({}, self.options.listenerOptions, opt), function (type) {
+      var index = Utils.inArray(self.eventHandlers, { gesture: type, handler: handler }, true);
+      if (index >= 0) {
+        self.eventHandlers.splice(index, 1);
+      }
+    });
+    return self;
+  },
+
+  /**
+   * trigger gesture event
+   * @method trigger
+   * @signature trigger(gesture, eventData)
+   * @param {String} gesture
+   * @param {Object} [eventData]
+   */
+  trigger: function triggerEvent(gesture, eventData) {
+    // optional
+    if (!eventData) {
+      eventData = {};
+    }
+
+    // create DOM event
+    var event = GestureDetector.DOCUMENT.createEvent('Event');
+    event.initEvent(gesture, true, true);
+    event.gesture = eventData;
+
+    // trigger on the target if it is in the instance element,
+    // this is for event delegation tricks
+    var element = this.element;
+    if (Utils.hasParent(eventData.target, element)) {
+      element = eventData.target;
+    }
+
+    element.dispatchEvent(event);
+    return this;
+  },
+
+  /**
+   * @method enable
+   * @signature enable(state)
+   * @description
+   *  [en]Enable or disable gesture detection.[/en]
+   *  [ja]ジェスチャ検知を有効化/無効化します。[/ja]
+   * @param {Boolean} state
+   *   [en]Specify if it should be enabled or not.[/en]
+   *   [ja]有効にするかどうかを指定します。[/ja]
+   */
+  enable: function enable(state) {
+    this.enabled = state;
+    return this;
+  },
+
+  /**
+   * @method dispose
+   * @signature dispose()
+   * @description
+   *  [en]Remove and destroy all event handlers for this instance.[/en]
+   *  [ja]このインスタンスでのジェスチャの検知や、イベントハンドラを全て解除して廃棄します。[/ja]
+   */
+  dispose: function dispose() {
+    var i, eh;
+
+    // undo all changes made by stop_browser_behavior
+    Utils.toggleBehavior(this.element, this.options.behavior, false);
+
+    // unbind all custom event handlers
+    for (i = -1; eh = this.eventHandlers[++i];) {
+      // eslint-disable-line no-cond-assign
+      Utils.off(this.element, eh.gesture, eh.handler);
+    }
+
+    this.eventHandlers = [];
+
+    // unbind the start event listener
+    Event$1.off(this.element, EVENT_TYPES[EVENT_START], this.eventStartHandler);
+
+    return null;
+  }
+};
+
+/**
+ * @module gestures
+ */
+/**
+ * Move with x fingers (default 1) around on the page.
+ * Preventing the default browser behavior is a good way to improve feel and working.
+ * ````
+ *  GestureDetectortime.on("drag", function(ev) {
+ *    console.log(ev);
+ *    ev.gesture.preventDefault();
+ *  });
+ * ````
+ *
+ * @class Drag
+ * @static
+ */
+/**
+ * @event drag
+ * @param {Object} ev
+ */
+/**
+ * @event dragstart
+ * @param {Object} ev
+ */
+/**
+ * @event dragend
+ * @param {Object} ev
+ */
+/**
+ * @event drapleft
+ * @param {Object} ev
+ */
+/**
+ * @event dragright
+ * @param {Object} ev
+ */
+/**
+ * @event dragup
+ * @param {Object} ev
+ */
+/**
+ * @event dragdown
+ * @param {Object} ev
+ */
+
+/**
+ * @param {String} name
+ */
+(function (name) {
+  var triggered = false;
+
+  function dragGesture(ev, inst) {
+    var cur = Detection.current;
+
+    // max touches
+    if (inst.options.dragMaxTouches > 0 && ev.touches.length > inst.options.dragMaxTouches) {
+      return;
+    }
+
+    switch (ev.eventType) {
+      case EVENT_START:
+        triggered = false;
+        break;
+
+      case EVENT_MOVE:
+        // when the distance we moved is too small we skip this gesture
+        // or we can be already in dragging
+        if (ev.distance < inst.options.dragMinDistance && cur.name != name) {
+          return;
+        }
+
+        var startCenter = cur.startEvent.center;
+
+        // we are dragging!
+        if (cur.name != name) {
+          cur.name = name;
+          if (inst.options.dragDistanceCorrection && ev.distance > 0) {
+            // When a drag is triggered, set the event center to dragMinDistance pixels from the original event center.
+            // Without this correction, the dragged distance would jumpstart at dragMinDistance pixels instead of at 0.
+            // It might be useful to save the original start point somewhere
+            var factor = Math.abs(inst.options.dragMinDistance / ev.distance);
+            startCenter.pageX += ev.deltaX * factor;
+            startCenter.pageY += ev.deltaY * factor;
+            startCenter.clientX += ev.deltaX * factor;
+            startCenter.clientY += ev.deltaY * factor;
+
+            // recalculate event data using new start point
+            ev = Detection.extendEventData(ev);
+          }
+        }
+
+        // lock drag to axis?
+        if (cur.lastEvent.dragLockToAxis || inst.options.dragLockToAxis && inst.options.dragLockMinDistance <= ev.distance) {
+          ev.dragLockToAxis = true;
+        }
+
+        // keep direction on the axis that the drag gesture started on
+        var lastDirection = cur.lastEvent.direction;
+        if (ev.dragLockToAxis && lastDirection !== ev.direction) {
+          if (Utils.isVertical(lastDirection)) {
+            ev.direction = ev.deltaY < 0 ? DIRECTION_UP : DIRECTION_DOWN;
+          } else {
+            ev.direction = ev.deltaX < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
+          }
+        }
+
+        // first time, trigger dragstart event
+        if (!triggered) {
+          inst.trigger(name + 'start', ev);
+          triggered = true;
+        }
+
+        // trigger events
+        inst.trigger(name, ev);
+        inst.trigger(name + ev.direction, ev);
+
+        var isVertical = Utils.isVertical(ev.direction);
+
+        // block the browser events
+        if (inst.options.dragBlockVertical && isVertical || inst.options.dragBlockHorizontal && !isVertical) {
+          ev.preventDefault();
+        }
+        break;
+
+      case EVENT_RELEASE:
+        if (triggered && ev.changedLength <= inst.options.dragMaxTouches) {
+          inst.trigger(name + 'end', ev);
+          triggered = false;
+        }
+        break;
+
+      case EVENT_END:
+        triggered = false;
+        break;
+    }
+  }
+
+  GestureDetector.gestures.Drag = {
+    name: name,
+    index: 50,
+    handler: dragGesture,
+    defaults: {
+      /**
+       * minimal movement that have to be made before the drag event gets triggered
+       * @property dragMinDistance
+       * @type {Number}
+       * @default 10
+       */
+      dragMinDistance: 10,
+
+      /**
+       * Set dragDistanceCorrection to true to make the starting point of the drag
+       * be calculated from where the drag was triggered, not from where the touch started.
+       * Useful to avoid a jerk-starting drag, which can make fine-adjustments
+       * through dragging difficult, and be visually unappealing.
+       * @property dragDistanceCorrection
+       * @type {Boolean}
+       * @default true
+       */
+      dragDistanceCorrection: true,
+
+      /**
+       * set 0 for unlimited, but this can conflict with transform
+       * @property dragMaxTouches
+       * @type {Number}
+       * @default 1
+       */
+      dragMaxTouches: 1,
+
+      /**
+       * prevent default browser behavior when dragging occurs
+       * be careful with it, it makes the element a blocking element
+       * when you are using the drag gesture, it is a good practice to set this true
+       * @property dragBlockHorizontal
+       * @type {Boolean}
+       * @default false
+       */
+      dragBlockHorizontal: false,
+
+      /**
+       * same as `dragBlockHorizontal`, but for vertical movement
+       * @property dragBlockVertical
+       * @type {Boolean}
+       * @default false
+       */
+      dragBlockVertical: false,
+
+      /**
+       * dragLockToAxis keeps the drag gesture on the axis that it started on,
+       * It disallows vertical directions if the initial direction was horizontal, and vice versa.
+       * @property dragLockToAxis
+       * @type {Boolean}
+       * @default false
+       */
+      dragLockToAxis: false,
+
+      /**
+       * drag lock only kicks in when distance > dragLockMinDistance
+       * This way, locking occurs only when the distance has become large enough to reliably determine the direction
+       * @property dragLockMinDistance
+       * @type {Number}
+       * @default 25
+       */
+      dragLockMinDistance: 25
+    }
+  };
+})('drag');
+
+/**
+ * @module gestures
+ */
+/**
+ * trigger a simple gesture event, so you can do anything in your handler.
+ * only usable if you know what your doing...
+ *
+ * @class Gesture
+ * @static
+ */
+/**
+ * @event gesture
+ * @param {Object} ev
+ */
+GestureDetector.gestures.Gesture = {
+  name: 'gesture',
+  index: 1337,
+  handler: function releaseGesture(ev, inst) {
+    inst.trigger(this.name, ev);
+  }
+};
+
+/**
+ * @module gestures
+ */
+/**
+ * Touch stays at the same place for x time
+ *
+ * @class Hold
+ * @static
+ */
+/**
+ * @event hold
+ * @param {Object} ev
+ */
+
+/**
+ * @param {String} name
+ */
+(function (name) {
+  var timer;
+
+  function holdGesture(ev, inst) {
+    var options = inst.options,
+        current = Detection.current;
+
+    switch (ev.eventType) {
+      case EVENT_START:
+        clearTimeout(timer);
+
+        // set the gesture so we can check in the timeout if it still is
+        current.name = name;
+
+        // set timer and if after the timeout it still is hold,
+        // we trigger the hold event
+        timer = setTimeout(function () {
+          if (current && current.name == name) {
+            inst.trigger(name, ev);
+          }
+        }, options.holdTimeout);
+        break;
+
+      case EVENT_MOVE:
+        if (ev.distance > options.holdThreshold) {
+          clearTimeout(timer);
+        }
+        break;
+
+      case EVENT_RELEASE:
+        clearTimeout(timer);
+        break;
+    }
+  }
+
+  GestureDetector.gestures.Hold = {
+    name: name,
+    index: 10,
+    defaults: {
+      /**
+       * @property holdTimeout
+       * @type {Number}
+       * @default 500
+       */
+      holdTimeout: 500,
+
+      /**
+       * movement allowed while holding
+       * @property holdThreshold
+       * @type {Number}
+       * @default 2
+       */
+      holdThreshold: 2
+    },
+    handler: holdGesture
+  };
+})('hold');
+
+/**
+ * @module gestures
+ */
+/**
+ * when a touch is being released from the page
+ *
+ * @class Release
+ * @static
+ */
+/**
+ * @event release
+ * @param {Object} ev
+ */
+GestureDetector.gestures.Release = {
+  name: 'release',
+  index: Infinity,
+  handler: function releaseGesture(ev, inst) {
+    if (ev.eventType == EVENT_RELEASE) {
+      inst.trigger(this.name, ev);
+    }
+  }
+};
+
+/**
+ * @module gestures
+ */
+/**
+ * triggers swipe events when the end velocity is above the threshold
+ * for best usage, set `preventDefault` (on the drag gesture) to `true`
+ * ````
+ *  GestureDetectortime.on("dragleft swipeleft", function(ev) {
+ *    console.log(ev);
+ *    ev.gesture.preventDefault();
+ *  });
+ * ````
+ *
+ * @class Swipe
+ * @static
+ */
+/**
+ * @event swipe
+ * @param {Object} ev
+ */
+/**
+ * @event swipeleft
+ * @param {Object} ev
+ */
+/**
+ * @event swiperight
+ * @param {Object} ev
+ */
+/**
+ * @event swipeup
+ * @param {Object} ev
+ */
+/**
+ * @event swipedown
+ * @param {Object} ev
+ */
+GestureDetector.gestures.Swipe = {
+  name: 'swipe',
+  index: 40,
+  defaults: {
+    /**
+     * @property swipeMinTouches
+     * @type {Number}
+     * @default 1
+     */
+    swipeMinTouches: 1,
+
+    /**
+     * @property swipeMaxTouches
+     * @type {Number}
+     * @default 1
+     */
+    swipeMaxTouches: 1,
+
+    /**
+     * horizontal swipe velocity
+     * @property swipeVelocityX
+     * @type {Number}
+     * @default 0.6
+     */
+    swipeVelocityX: 0.6,
+
+    /**
+     * vertical swipe velocity
+     * @property swipeVelocityY
+     * @type {Number}
+     * @default 0.6
+     */
+    swipeVelocityY: 0.6
+  },
+
+  handler: function swipeGesture(ev, inst) {
+    if (ev.eventType == EVENT_RELEASE) {
+      var touches = ev.touches.length,
+          options = inst.options;
+
+      // max touches
+      if (touches < options.swipeMinTouches || touches > options.swipeMaxTouches) {
+        return;
+      }
+
+      // when the distance we moved is too small we skip this gesture
+      // or we can be already in dragging
+      if (ev.velocityX > options.swipeVelocityX || ev.velocityY > options.swipeVelocityY) {
+        // trigger swipe events
+        inst.trigger(this.name, ev);
+        inst.trigger(this.name + ev.direction, ev);
+      }
+    }
+  }
+};
+
+/**
+ * @module gestures
+ */
+/**
+ * Single tap and a double tap on a place
+ *
+ * @class Tap
+ * @static
+ */
+/**
+ * @event tap
+ * @param {Object} ev
+ */
+/**
+ * @event doubletap
+ * @param {Object} ev
+ */
+
+/**
+ * @param {String} name
+ */
+(function (name) {
+  var hasMoved = false;
+
+  function tapGesture(ev, inst) {
+    var options = inst.options,
+        current = Detection.current,
+        prev = Detection.previous,
+        sincePrev,
+        didDoubleTap;
+
+    switch (ev.eventType) {
+      case EVENT_START:
+        hasMoved = false;
+        break;
+
+      case EVENT_MOVE:
+        hasMoved = hasMoved || ev.distance > options.tapMaxDistance;
+        break;
+
+      case EVENT_END:
+        if (!Utils.inStr(ev.srcEvent.type, 'cancel') && ev.deltaTime < options.tapMaxTime && !hasMoved) {
+          // previous gesture, for the double tap since these are two different gesture detections
+          sincePrev = prev && prev.lastEvent && ev.timeStamp - prev.lastEvent.timeStamp;
+          didDoubleTap = false;
+
+          // check if double tap
+          if (prev && prev.name == name && sincePrev && sincePrev < options.doubleTapInterval && ev.distance < options.doubleTapDistance) {
+            inst.trigger('doubletap', ev);
+            didDoubleTap = true;
+          }
+
+          // do a single tap
+          if (!didDoubleTap || options.tapAlways) {
+            current.name = name;
+            inst.trigger(current.name, ev);
+          }
+        }
+        break;
+    }
+  }
+
+  GestureDetector.gestures.Tap = {
+    name: name,
+    index: 100,
+    handler: tapGesture,
+    defaults: {
+      /**
+       * max time of a tap, this is for the slow tappers
+       * @property tapMaxTime
+       * @type {Number}
+       * @default 250
+       */
+      tapMaxTime: 250,
+
+      /**
+       * max distance of movement of a tap, this is for the slow tappers
+       * @property tapMaxDistance
+       * @type {Number}
+       * @default 10
+       */
+      tapMaxDistance: 10,
+
+      /**
+       * always trigger the `tap` event, even while double-tapping
+       * @property tapAlways
+       * @type {Boolean}
+       * @default true
+       */
+      tapAlways: true,
+
+      /**
+       * max distance between two taps
+       * @property doubleTapDistance
+       * @type {Number}
+       * @default 20
+       */
+      doubleTapDistance: 20,
+
+      /**
+       * max time between two taps
+       * @property doubleTapInterval
+       * @type {Number}
+       * @default 300
+       */
+      doubleTapInterval: 300
+    }
+  };
+})('tap');
+
+/**
+ * @module gestures
+ */
+/**
+ * when a touch is being touched at the page
+ *
+ * @class Touch
+ * @static
+ */
+/**
+ * @event touch
+ * @param {Object} ev
+ */
+GestureDetector.gestures.Touch = {
+  name: 'touch',
+  index: -Infinity,
+  defaults: {
+    /**
+     * call preventDefault at touchstart, and makes the element blocking by disabling the scrolling of the page,
+     * but it improves gestures like transforming and dragging.
+     * be careful with using this, it can be very annoying for users to be stuck on the page
+     * @property preventDefault
+     * @type {Boolean}
+     * @default false
+     */
+    preventDefault: false,
+
+    /**
+     * disable mouse events, so only touch (or pen!) input triggers events
+     * @property preventMouse
+     * @type {Boolean}
+     * @default false
+     */
+    preventMouse: false
+  },
+  handler: function touchGesture(ev, inst) {
+    if (inst.options.preventMouse && ev.pointerType == POINTER_MOUSE) {
+      ev.stopDetect();
+      return;
+    }
+
+    if (inst.options.preventDefault) {
+      ev.preventDefault();
+    }
+
+    if (ev.eventType == EVENT_TOUCH) {
+      inst.trigger('touch', ev);
+    }
+  }
+};
+
+/**
+ * @module gestures
+ */
+/**
+ * User want to scale or rotate with 2 fingers
+ * Preventing the default browser behavior is a good way to improve feel and working. This can be done with the
+ * `preventDefault` option.
+ *
+ * @class Transform
+ * @static
+ */
+/**
+ * @event transform
+ * @param {Object} ev
+ */
+/**
+ * @event transformstart
+ * @param {Object} ev
+ */
+/**
+ * @event transformend
+ * @param {Object} ev
+ */
+/**
+ * @event pinchin
+ * @param {Object} ev
+ */
+/**
+ * @event pinchout
+ * @param {Object} ev
+ */
+/**
+ * @event rotate
+ * @param {Object} ev
+ */
+
+/**
+ * @param {String} name
+ */
+(function (name) {
+  var triggered = false;
+
+  function transformGesture(ev, inst) {
+    switch (ev.eventType) {
+      case EVENT_START:
+        triggered = false;
+        break;
+
+      case EVENT_MOVE:
+        // at least multitouch
+        if (ev.touches.length < 2) {
+          return;
+        }
+
+        var scaleThreshold = Math.abs(1 - ev.scale);
+        var rotationThreshold = Math.abs(ev.rotation);
+
+        // when the distance we moved is too small we skip this gesture
+        // or we can be already in dragging
+        if (scaleThreshold < inst.options.transformMinScale && rotationThreshold < inst.options.transformMinRotation) {
+          return;
+        }
+
+        // we are transforming!
+        Detection.current.name = name;
+
+        // first time, trigger dragstart event
+        if (!triggered) {
+          inst.trigger(name + 'start', ev);
+          triggered = true;
+        }
+
+        inst.trigger(name, ev); // basic transform event
+
+        // trigger rotate event
+        if (rotationThreshold > inst.options.transformMinRotation) {
+          inst.trigger('rotate', ev);
+        }
+
+        // trigger pinch event
+        if (scaleThreshold > inst.options.transformMinScale) {
+          inst.trigger('pinch', ev);
+          inst.trigger('pinch' + (ev.scale < 1 ? 'in' : 'out'), ev);
+        }
+        break;
+
+      case EVENT_RELEASE:
+        if (triggered && ev.changedLength < 2) {
+          inst.trigger(name + 'end', ev);
+          triggered = false;
+        }
+        break;
+    }
+  }
+
+  GestureDetector.gestures.Transform = {
+    name: name,
+    index: 45,
+    defaults: {
+      /**
+       * minimal scale factor, no scale is 1, zoomin is to 0 and zoomout until higher then 1
+       * @property transformMinScale
+       * @type {Number}
+       * @default 0.01
+       */
+      transformMinScale: 0.01,
+
+      /**
+       * rotation in degrees
+       * @property transformMinRotation
+       * @type {Number}
+       * @default 1
+       */
+      transformMinRotation: 1
+    },
+
+    handler: transformGesture
+  };
+})('transform');
+
+/*
+Copyright 2013-2015 ASIAL CORPORATION
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+   http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+*/
+
+var readyMap = void 0;
+var queueMap = void 0;
+
+function isContentReady(element) {
+  if (element.childNodes.length > 0) {
+    setContentReady(element);
+  }
+  return readyMap.has(element);
+}
+
+function setContentReady(element) {
+  readyMap.set(element, true);
+}
+
+function addCallback(element, fn) {
+  if (!queueMap.has(element)) {
+    queueMap.set(element, []);
+  }
+  queueMap.get(element).push(fn);
+}
+
+function consumeQueue(element) {
+  var callbacks = queueMap.get(element, []) || [];
+  queueMap.delete(element);
+  callbacks.forEach(function (callback) {
+    return callback();
+  });
+}
+
+function contentReady(element) {
+  var fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {};
+
+  if (readyMap === undefined) {
+    readyMap = new WeakMap();
+    queueMap = new WeakMap();
+  }
+
+  addCallback(element, fn);
+
+  if (isContentReady(element)) {
+    consumeQueue(element);
+    return;
+  }
+
+  var observer = new MutationObserver(function (changes) {
+    setContentReady(element);
+    consumeQueue(element);
+  });
+  observer.observe(element, { childList: true, characterData: true });
+
+  // failback for elements has empty content.
+  setImmediate(function () {
+    setContentReady(element);
+    consumeQueue(element);
+  });
+}
+
+/*
+Copyright 2013-2015 ASIAL CORPORATION
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+   http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+*/
+
+var ToastQueue = function () {
+  function ToastQueue() {
+    classCallCheck(this, ToastQueue);
+
+    this.queue = [];
+  }
+
+  createClass(ToastQueue, [{
+    key: "add",
+    value: function add(fn, promise) {
+      var _this = this;
+
+      this.queue.push(fn);
+
+      if (this.queue.length === 1) {
+        setImmediate(this.queue[0]);
+      }
+
+      promise.then(function () {
+        _this.queue.shift();
+
+        if (_this.queue.length > 0) {
+          setTimeout(_this.queue[0], 1000 / 30); // Apply some visual delay
+        }
+      });
+    }
+  }]);
+  return ToastQueue;
+}();
+
+var ToastQueue$1 = new ToastQueue();
+
+/*
+Copyright 2013-2015 ASIAL CORPORATION
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+   http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+*/
+
+var _setAttributes = function _setAttributes(element, options) {
+  ['id', 'class', 'animation'].forEach(function (a) {
+    return options.hasOwnProperty(a) && element.setAttribute(a, options[a]);
+  });
+
+  if (options.modifier) {
+    util$1.addModifier(element, options.modifier);
+  }
+};
+
+var _normalizeArguments = function _normalizeArguments(message) {
+  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
+  var defaults$$1 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
+
+  options = _extends({}, options);
+  typeof message === 'string' ? options.message = message : options = message;
+  if (!options || !options.message && !options.messageHTML) {
+    util$1.throw('Notifications must contain a message');
+  }
+
+  if (options.hasOwnProperty('buttonLabels') || options.hasOwnProperty('buttonLabel')) {
+    options.buttonLabels = options.buttonLabels || options.buttonLabel;
+    if (!Array.isArray(options.buttonLabels)) {
+      options.buttonLabels = [options.buttonLabels || ''];
+    }
+  }
+
+  return util$1.extend({
+    compile: function compile(param) {
+      return param;
+    },
+    callback: function callback(param) {
+      return param;
+    },
+    animation: 'default',
+    cancelable: false,
+    primaryButtonIndex: (options.buttonLabels || defaults$$1.buttonLabels || []).length - 1
+  }, defaults$$1, options);
+};
+
+/**
+ * @object ons.notification
+ * @category dialog
+ * @tutorial vanilla/Reference/notification
+ * @description
+ *   [en]
+ *     Utility methods to create different kinds of notifications. There are three methods available:
+ *
+ *     * `ons.notification.alert()`
+ *     * `ons.notification.confirm()`
+ *     * `ons.notification.prompt()`
+ *     * `ons.notification.toast()`
+ *
+ *     It will automatically display a Material Design dialog on Android devices.
+ *   [/en]
+ *   [ja]いくつかの種類のアラートダイアログを作成するためのユーティリティメソッドを収めたオブジェクトです。[/ja]
+ * @example
+ * ons.notification.alert('Hello, world!');
+ *
+ * ons.notification.confirm('Are you ready?')
+ *   .then(
+ *     function(answer) {
+ *       if (answer === 1) {
+ *         ons.notification.alert('Let\'s go!');
+ *       }
+ *     }
+ *   );
+ *
+ * ons.notification.prompt('How old are ?')
+ *   .then(
+ *     function(age) {
+ *       ons.notification.alert('You are ' + age + ' years old.');
+ *     }
+ *   );
+ */
+var notification = {};
+
+notification._createAlertDialog = function () {
+  for (var _len = arguments.length, params = Array(_len), _key = 0; _key < _len; _key++) {
+    params[_key] = arguments[_key];
+  }
+
+  return new Promise(function (resolve) {
+    var options = _normalizeArguments.apply(undefined, params);
+    util$1.checkMissingImport('AlertDialog', 'AlertDialogButton');
+
+    // Prompt input string
+    var inputString = '';
+    if (options.isPrompt) {
+      inputString = '\n      <input\n        class="text-input text-input--underbar"\n        type="' + (options.inputType || 'text') + '"\n        placeholder="' + (options.placeholder || '') + '"\n        value="' + (options.defaultValue || '') + '"\n        style="width: 100%; margin-top: 10px;"\n      />\n    ';
+    }
+
+    // Buttons string
+    var buttons = '';
+    options.buttonLabels.forEach(function (label, index) {
+      buttons += '\n      <ons-alert-dialog-button\n        class="\n          ' + (index === options.primaryButtonIndex ? ' alert-dialog-button--primal' : '') + '\n          ' + (options.buttonLabels.length <= 2 ? ' alert-dialog-button--rowfooter' : '') + '\n        "\n        style="position: relative;">\n        ' + label + '\n      </ons-alert-dialog-button>\n    ';
+    });
+
+    // Dialog Element
+    var el = {};
+    var _destroyDialog = function _destroyDialog() {
+      if (el.dialog.onDialogCancel) {
+        el.dialog.removeEventListener('dialog-cancel', el.dialog.onDialogCancel);
+      }
+
+      Object.keys(el).forEach(function (key) {
+        return delete el[key];
+      });
+      el = null;
+
+      if (options.destroy instanceof Function) {
+        options.destroy();
+      }
+    };
+
+    el.dialog = document.createElement('ons-alert-dialog');
+    el.dialog.innerHTML = '\n    <div class="alert-dialog-mask"\n      style="\n        ' + (options.maskColor ? 'background-color: ' + options.maskColor : '') + '\n      "></div>\n    <div class="alert-dialog">\n      <div class="alert-dialog-container">\n        <div class="alert-dialog-title">\n          ' + (options.title || '') + '\n        </div>\n        <div class="alert-dialog-content">\n          ' + (options.message || options.messageHTML) + '\n          ' + inputString + '\n        </div>\n        <div class="\n          alert-dialog-footer\n          ' + (options.buttonLabels.length <= 2 ? ' alert-dialog-footer--rowfooter' : '') + '\n        ">\n          ' + buttons + '\n        </div>\n      </div>\n    </div>\n  ';
+    contentReady(el.dialog);
+
+    // Set attributes
+    _setAttributes(el.dialog, options);
+
+    // Prompt events
+    if (options.isPrompt && options.submitOnEnter) {
+      el.input = el.dialog.querySelector('.text-input');
+      el.input.onkeypress = function (event) {
+        if (event.keyCode === 13) {
+          el.dialog.hide().then(function () {
+            if (el) {
+              var resolveValue = el.input.value;
+              _destroyDialog();
+              options.callback(resolveValue);
+              resolve(resolveValue);
+            }
+          });
+        }
+      };
+    }
+
+    // Button events
+    el.footer = el.dialog.querySelector('.alert-dialog-footer');
+    util$1.arrayFrom(el.dialog.querySelectorAll('.alert-dialog-button')).forEach(function (buttonElement, index) {
+      buttonElement.onclick = function () {
+        el.dialog.hide().then(function () {
+          if (el) {
+            var resolveValue = index;
+            if (options.isPrompt) {
+              resolveValue = index === options.primaryButtonIndex ? el.input.value : null;
+            }
+            el.dialog.remove();
+            _destroyDialog();
+            options.callback(resolveValue);
+            resolve(resolveValue);
+          }
+        });
+      };
+
+      el.footer.appendChild(buttonElement);
+    });
+
+    // Cancel events
+    if (options.cancelable) {
+      el.dialog.cancelable = true;
+      el.dialog.onDialogCancel = function () {
+        setImmediate(function () {
+          el.dialog.remove();
+          _destroyDialog();
+        });
+        var resolveValue = options.isPrompt ? null : -1;
+        options.callback(resolveValue);
+        resolve(resolveValue);
+      };
+      el.dialog.addEventListener('dialog-cancel', el.dialog.onDialogCancel, false);
+    }
+
+    // Show dialog
+    document.body.appendChild(el.dialog);
+    options.compile(el.dialog);
+    setImmediate(function () {
+      el.dialog.show().then(function () {
+        if (el.input && options.isPrompt && options.autofocus) {
+          var strLength = el.input.value.length;
+          el.input.focus();
+          el.input.setSelectionRange(strLength, strLength);
+        }
+      });
+    });
+  });
+};
+
+/**
+ * @method alert
+ * @signature alert(message [, options] | options)
+ * @return {Promise}
+ *   [en]Will resolve to the index of the button that was pressed or `-1` when canceled.[/en]
+ *   [ja][/ja]
+ * @param {String} message
+ *   [en]Notification message. This argument is optional but if it's not defined either `options.message` or `options.messageHTML` must be defined instead.[/en]
+ *   [ja][/ja]
+ * @param {Object} options
+ *   [en]Parameter object.[/en]
+ *   [ja]オプションを指定するオブジェクトです。[/ja]
+ * @param {String} [options.message]
+ *   [en]Notification message.[/en]
+ *   [ja]アラートダイアログに表示する文字列を指定します。[/ja]
+ * @param {String} [options.messageHTML]
+ *   [en]Notification message in HTML.[/en]
+ *   [ja]アラートダイアログに表示するHTMLを指定します。[/ja]
+ * @param {String | Array} [options.buttonLabels]
+ *   [en]Labels for the buttons. Default is `"OK"`.[/en]
+ *   [ja]確認ボタンのラベルを指定します。"OK"がデフォルトです。[/ja]
+ * @param {Number} [options.primaryButtonIndex]
+ *   [en]Index of primary button. Default is the last one.[/en]
+ *   [ja]プライマリボタンのインデックスを指定します。デフォルトは 0 です。[/ja]
+ * @param {Boolean} [options.cancelable]
+ *   [en]Whether the dialog is cancelable or not. Default is `false`. If the dialog is cancelable it can be closed by clicking the background or pressing the Android back button.[/en]
+ *   [ja]ダイアログがキャンセル可能かどうかを指定します。[/ja]
+ * @param {String} [options.animation]
+ *   [en]Animation name. Available animations are `none` and `fade`. Default is `fade`.[/en]
+ *   [ja]アラートダイアログを表示する際のアニメーション名を指定します。"none", "fade"のいずれかを指定できます。[/ja]
+ * @param {String} [options.id]
+ *   [en]The `<ons-alert-dialog>` element's ID.[/en]
+ *   [ja]ons-alert-dialog要素のID。[/ja]
+ * @param {String} [options.class]
+ *   [en]The `<ons-alert-dialog>` element's class.[/en]
+ *   [ja]ons-alert-dialog要素のclass。[/ja]
+ * @param {String} [options.title]
+ *   [en]Dialog title. Default is `"Alert"`.[/en]
+ *   [ja]アラートダイアログの上部に表示するタイトルを指定します。"Alert"がデフォルトです。[/ja]
+ * @param {String} [options.modifier]
+ *   [en]Modifier for the dialog.[/en]
+ *   [ja]アラートダイアログのmodifier属性の値を指定します。[/ja]
+ * @param {String} [options.maskColor]
+ *   [en]Color of the background mask. Default is "rgba(0, 0, 0, 0.2)" ("rgba(0, 0, 0, 0.3)" for Material).[/en]
+ *   [ja]背景のマスクの色を指定します。"rgba(0, 0, 0, 0.2)"がデフォルト値です。[/ja]
+ * @param {Function} [options.callback]
+ *   [en]Function that executes after dialog has been closed.[/en]
+ *   [ja]アラートダイアログが閉じられた時に呼び出される関数オブジェクトを指定します。[/ja]
+ * @description
+ *   [en]
+ *     Display an alert dialog to show the user a message.
+ *
+ *     The content of the message can be either simple text or HTML.
+ *
+ *     It can be called in the following ways:
+ *
+ *     ```
+ *     ons.notification.alert(message, options);
+ *     ons.notification.alert(options);
+ *     ```
+ *
+ *     Must specify either `message` or `messageHTML`.
+ *   [/en]
+ *   [ja]
+ *     ユーザーへメッセージを見せるためのアラートダイアログを表示します。
+ *     表示するメッセージは、テキストかもしくはHTMLを指定できます。
+ *     このメソッドの引数には、options.messageもしくはoptions.messageHTMLのどちらかを必ず指定する必要があります。
+ *   [/ja]
+ */
+notification.alert = function (message, options) {
+  return notification._createAlertDialog(message, options, {
+    buttonLabels: ['OK'],
+    title: 'Alert'
+  });
+};
+
+/**
+ * @method confirm
+ * @signature confirm(message [, options] | options)
+ * @return {Promise}
+ *   [en]Will resolve to the index of the button that was pressed or `-1` when canceled.[/en]
+ *   [ja][/ja]
+ * @param {String} message
+ *   [en]Notification message. This argument is optional but if it's not defined either `options.message` or `options.messageHTML` must be defined instead.[/en]
+ *   [ja][/ja]
+ * @param {Object} options
+ *   [en]Parameter object.[/en]
+ * @param {Array} [options.buttonLabels]
+ *   [en]Labels for the buttons. Default is `["Cancel", "OK"]`.[/en]
+ *   [ja]ボタンのラベルの配列を指定します。["Cancel", "OK"]がデフォルトです。[/ja]
+ * @param {Number} [options.primaryButtonIndex]
+ *   [en]Index of primary button. Default is the last one.[/en]
+ *   [ja]プライマリボタンのインデックスを指定します。デフォルトは 1 です。[/ja]
+ * @description
+ *   [en]
+ *     Display a dialog to ask the user for confirmation. Extends `alert()` parameters.
+ *     The default button labels are `"Cancel"` and `"OK"` but they can be customized.
+ *
+ *     It can be called in the following ways:
+ *
+ *     ```
+ *     ons.notification.confirm(message, options);
+ *     ons.notification.confirm(options);
+ *     ```
+ *
+ *     Must specify either `message` or `messageHTML`.
+ *   [/en]
+ *   [ja]
+ *     ユーザに確認を促すダイアログを表示します。
+ *     デオルとのボタンラベルは、"Cancel"と"OK"ですが、これはこのメソッドの引数でカスタマイズできます。
+ *     このメソッドの引数には、options.messageもしくはoptions.messageHTMLのどちらかを必ず指定する必要があります。
+ *   [/ja]
+ */
+notification.confirm = function (message, options) {
+  return notification._createAlertDialog(message, options, {
+    buttonLabels: ['Cancel', 'OK'],
+    title: 'Confirm'
+  });
+};
+
+/**
+ * @method prompt
+ * @signature prompt(message [, options] | options)
+ * @param {String} message
+ *   [en]Notification message. This argument is optional but if it's not defined either `options.message` or `options.messageHTML` must be defined instead.[/en]
+ *   [ja][/ja]
+ * @return {Promise}
+ *   [en]Will resolve to the input value when the dialog is closed or `null` when canceled.[/en]
+ *   [ja][/ja]
+ * @param {Object} options
+ *   [en]Parameter object.[/en]
+ *   [ja]オプションを指定するオブジェクトです。[/ja]
+ * @param {String | Array} [options.buttonLabels]
+ *   [en]Labels for the buttons. Default is `"OK"`.[/en]
+ *   [ja]確認ボタンのラベルを指定します。"OK"がデフォルトです。[/ja]
+ * @param {Number} [options.primaryButtonIndex]
+ *   [en]Index of primary button. Default is the last one.[/en]
+ *   [ja]プライマリボタンのインデックスを指定します。デフォルトは 0 です。[/ja]
+ * @param {String} [options.placeholder]
+ *   [en]Placeholder for the text input.[/en]
+ *   [ja]テキスト欄のプレースホルダに表示するテキストを指定します。[/ja]
+ * @param {String} [options.defaultValue]
+ *   [en]Default value for the text input.[/en]
+ *   [ja]テキスト欄のデフォルトの値を指定します。[/ja]
+ * @param {String} [options.inputType]
+ *   [en]Type of the input element (`password`, `date`...). Default is `text`.[/en]
+ *   [ja][/ja]
+ * @param {Boolean} [options.autofocus]
+ *   [en]Autofocus the input element. Default is `true`. In Cordova, `KeyboardDisplayRequiresUserAction` in `config.xml` must be `false` to activate this feature.[/en]
+ *   [ja]input要素に自動的にフォーカスするかどうかを指定します。デフォルトはtrueです。Cordova環境では、この機能を有効にするためには `config.xml` で `KeyboardDisplayRequiresUserAction` を `false` に設定する必要があります。[/ja]
+ * @param {Boolean} [options.submitOnEnter]
+ *   [en]Submit automatically when enter is pressed. Default is `true`.[/en]
+ *   [ja]Enterが押された際にそのformをsubmitするかどうかを指定します。デフォルトはtrueです。[/ja]
+ * @description
+ *   [en]
+ *     Display a dialog with a prompt to ask the user a question. Extends `alert()` parameters.
+ *
+ *     It can be called in the following ways:
+ *
+ *     ```
+ *     ons.notification.prompt(message, options);
+ *     ons.notification.prompt(options);
+ *     ```
+ *
+ *     Must specify either `message` or `messageHTML`.
+ *   [/en]
+ *   [ja]
+ *     ユーザーに入力を促すダイアログを表示します。
+ *     このメソッドの引数には、options.messageもしくはoptions.messageHTMLのどちらかを必ず指定する必要があります。
+ *   [/ja]
+ */
+notification.prompt = function (message, options) {
+  return notification._createAlertDialog(message, options, {
+    buttonLabels: ['OK'],
+    title: 'Alert',
+    isPrompt: true,
+    autofocus: true,
+    submitOnEnter: true
+  });
+};
+
+/**
+ * @method toast
+ * @signature toast(message [, options] | options)
+ * @return {Promise}
+ *   [en]Will resolve when the toast is hidden.[/en]
+ *   [ja][/ja]
+ * @param {String} message
+ *   [en]Toast message. This argument is optional but if it's not defined then `options.message` must be defined instead.[/en]
+ *   [ja][/ja]
+ * @param {Object} options
+ *   [en]Parameter object.[/en]
+ *   [ja]オプションを指定するオブジェクトです。[/ja]
+ * @param {String} [options.message]
+ *   [en]Notification message.[/en]
+ *   [ja]トーストに表示する文字列を指定します。[/ja]
+ * @param {String} [options.buttonLabel]
+ *   [en]Label for the button.[/en]
+ *   [ja]確認ボタンのラベルを指定します。[/ja]
+ * @param {String} [options.animation]
+ *   [en]Animation name. Available animations are `none`, `fade`, `ascend`, `lift` and `fall`. Default is `ascend` for Android and `lift` for iOS.[/en]
+ *   [ja]トーストを表示する際のアニメーション名を指定します。"none", "fade", "ascend", "lift", "fall"のいずれかを指定できます。[/ja]
+ * @param {Number} [options.timeout]
+ *   [en]Number of miliseconds where the toast is visible before hiding automatically.[/en]
+ *   [ja][/ja]
+ * @param {Boolean} [options.force]
+ *   [en]If `true`, the toast skips the notification queue and is shown immediately. Defaults to `false`.[/en]
+ *   [ja][/ja]
+ * @param {String} [options.id]
+ *   [en]The `<ons-toast>` element's ID.[/en]
+ *   [ja]ons-toast要素のID。[/ja]
+ * @param {String} [options.class]
+ *   [en]The `<ons-toast>` element's class.[/en]
+ *   [ja]ons-toast要素のclass。[/ja]
+ * @param {String} [options.modifier]
+ *   [en]Modifier for the element.[/en]
+ *   [ja]トーストのmodifier属性の値を指定します。[/ja]
+ * @param {Function} [options.callback]
+ *   [en]Function that executes after toast has been hidden.[/en]
+ *   [ja]トーストが閉じられた時に呼び出される関数オブジェクトを指定します。[/ja]
+ * @description
+ *   [en]
+ *     Display a simple notification toast with an optional button that can be used for simple actions.
+ *
+ *     It can be called in the following ways:
+ *
+ *     ```
+ *     ons.notification.toast(message, options);
+ *     ons.notification.toast(options);
+ *     ```
+ *   [/en]
+ *   [ja][/ja]
+ */
+notification.toast = function (message, options) {
+  var promise = new Promise(function (resolve) {
+    util$1.checkMissingImport('Toast'); // Throws error, must be inside promise
+
+    options = _normalizeArguments(message, options, {
+      timeout: 0,
+      force: false
+    });
+
+    var toast = util$1.createElement('\n      <ons-toast>\n        ' + options.message + '\n        ' + (options.buttonLabels ? '<button>' + options.buttonLabels[0] + '</button>' : '') + '\n      </ons-toast>\n    ');
+
+    _setAttributes(toast, options);
+
+    var finish = function finish(value) {
+      if (toast) {
+        toast.hide().then(function () {
+          if (toast) {
+            toast.remove();
+            toast = null;
+            options.callback(value);
+            resolve(value);
+          }
+        });
+      }
+    };
+
+    if (options.buttonLabels) {
+      util$1.findChild(toast._toast, 'button').onclick = function () {
+        return finish(0);
+      };
+    }
+
+    document.body.appendChild(toast);
+    options.compile(toast);
+
+    var show = function show() {
+      toast.parentElement && toast.show(options).then(function () {
+        if (options.timeout) {
+          setTimeout(function () {
+            return finish(-1);
+          }, options.timeout);
+        }
+      });
+    };
+
+    setImmediate(function () {
+      return options.force ? show() : ToastQueue$1.add(show, promise);
+    });
+  });
+
+  return promise;
+};
+
+/*
+Copyright 2013-2015 ASIAL CORPORATION
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+   http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+*/
+
+// Validate parameters
+var checkOptions = function checkOptions(options) {
+  var err = function err(prop) {
+    var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'Function';
+    return util$1.throw('"options.' + prop + '" must be an instance of ' + type);
+  };
+  var hasOwnProperty = function hasOwnProperty(prop) {
+    return Object.hasOwnProperty.call(options, prop);
+  };
+  var instanceOf = function instanceOf(prop) {
+    var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Function;
+    return options[prop] instanceof type;
+  };
+
+  var b = 'buttons',
+      cb = 'callback',
+      c = 'compile',
+      d = 'destroy';
+  (!hasOwnProperty(b) || !instanceOf(b, Array)) && err(b, 'Array');
+  hasOwnProperty(cb) && !instanceOf(cb) && err(cb);
+  hasOwnProperty(c) && !instanceOf(c) && err(c);
+  hasOwnProperty(d) && !instanceOf(d) && err(d);
+};
+
+// Action Sheet
+var actionSheet = (function () {
+  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
+  return new Promise(function (resolve) {
+    util$1.checkMissingImport('ActionSheet');
+    checkOptions(options);
+
+    // Main component
+    var actionSheet = util$1.createElement('\n    <ons-action-sheet\n      ' + (options.title ? 'title="' + options.title + '"' : '') + '\n      ' + (options.cancelable ? 'cancelable' : '') + '\n      ' + (options.modifier ? 'modifier="' + options.modifier + '"' : '') + '\n      ' + (options.maskColor ? 'mask-color="' + options.maskColor + '"' : '') + '\n      ' + (options.id ? 'id="' + options.id + '"' : '') + '\n      ' + (options.class ? 'class="' + options.class + '"' : '') + '\n    >\n      <div class="action-sheet"></div>\n    </ons-action-sheet>\n  ');
+
+    // Resolve action and clean up
+    var finish = function finish(event) {
+      var index = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -1;
+
+      if (actionSheet) {
+        options.destroy && options.destroy(actionSheet);
+
+        actionSheet.removeEventListener('dialog-cancel', finish, false);
+        actionSheet.remove();
+        actionSheet = null;
+
+        options.callback && options.callback(index);
+        resolve(index);
+      }
+    };
+
+    // Link cancel handler
+    actionSheet.addEventListener('dialog-cancel', finish, false);
+
+    // Create buttons and link action handler
+    var buttons = document.createDocumentFragment();
+    options.buttons.forEach(function (item, index) {
+      var buttonOptions = typeof item === 'string' ? { label: item } : _extends({}, item);
+      if (options.destructive === index) {
+        buttonOptions.modifier = (buttonOptions.modifier || '') + ' destructive';
+      }
+
+      var button = util$1.createElement('\n      <ons-action-sheet-button\n        ' + (buttonOptions.icon ? 'icon="' + buttonOptions.icon + '"' : '') + '\n        ' + (buttonOptions.modifier ? 'modifier="' + buttonOptions.modifier + '"' : '') + '\n      >\n        ' + buttonOptions.label + '\n      </ons-action-sheet-button>\n    ');
+
+      button.onclick = function (event) {
+        return actionSheet.hide().then(function () {
+          return finish(event, index);
+        });
+      };
+      buttons.appendChild(button);
+    });
+
+    // Finish component and attach
+    util$1.findChild(actionSheet, '.action-sheet').appendChild(buttons);
+    document.body.appendChild(actionSheet);
+    options.compile && options.compile(el.dialog);
+
+    // Show
+    setImmediate(function () {
+      return actionSheet.show({
+        animation: options.animation,
+        animationOptions: options.animationOptions
+      });
+    });
+  });
+});
+
+/**
+ * MicroEvent - to make any js object an event emitter (server or browser)
+ *
+ * - pure javascript - server compatible, browser compatible
+ * - dont rely on the browser doms
+ * - super simple - you get it immediately, no mystery, no magic involved
+ *
+ * - create a MicroEventDebug with goodies to debug
+ *   - make it safer to use
+*/
+
+/** NOTE: This library is customized for Onsen UI. */
+
+var MicroEvent = function MicroEvent() {};
+MicroEvent.prototype = {
+  on: function on(event, fct) {
+    this._events = this._events || {};
+    this._events[event] = this._events[event] || [];
+    this._events[event].push(fct);
+  },
+  once: function once(event, fct) {
+    var self = this;
+    var wrapper = function wrapper() {
+      self.off(event, wrapper);
+      return fct.apply(null, arguments);
+    };
+    this.on(event, wrapper);
+  },
+  off: function off(event, fct) {
+    this._events = this._events || {};
+    if (event in this._events === false) {
+      return;
+    }
+
+    this._events[event] = this._events[event].filter(function (_fct) {
+      if (fct) {
+        return fct !== _fct;
+      } else {
+        return false;
+      }
+    });
+  },
+  emit: function emit(event /* , args... */) {
+    this._events = this._events || {};
+    if (event in this._events === false) {
+      return;
+    }
+    for (var i = 0; i < this._events[event].length; i++) {
+      this._events[event][i].apply(this, Array.prototype.slice.call(arguments, 1));
+    }
+  }
+};
+
+/**
+ * mixin will delegate all MicroEvent.js function in the destination object
+ *
+ * - require('MicroEvent').mixin(Foobar) will make Foobar able to use MicroEvent
+ *
+ * @param {Object} the object which will support MicroEvent
+*/
+MicroEvent.mixin = function (destObject) {
+  var props = ['on', 'once', 'off', 'emit'];
+  for (var i = 0; i < props.length; i++) {
+    if (typeof destObject === 'function') {
+      destObject.prototype[props[i]] = MicroEvent.prototype[props[i]];
+    } else {
+      destObject[props[i]] = MicroEvent.prototype[props[i]];
+    }
+  }
+};
+
+window.MicroEvent = MicroEvent;
+
+/*
+Copyright 2013-2015 ASIAL CORPORATION
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+   http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+*/
+
+var create = function create() {
+
+  /**
+   * @object ons.orientation
+   * @category util
+   * @description
+   *   [en]Utility methods for orientation detection.[/en]
+   *   [ja]画面のオリエンテーション検知のためのユーティリティメソッドを収めているオブジェクトです。[/ja]
+   */
+  var obj = {
+    /**
+     * @event change
+     * @description
+     *   [en]Fired when the device orientation changes.[/en]
+     *   [ja]デバイスのオリエンテーションが変化した際に発火します。[/ja]
+     * @param {Object} event
+     *   [en]Event object.[/en]
+     *   [ja]イベントオブジェクトです。[/ja]
+     * @param {Boolean} event.isPortrait
+     *   [en]Will be true if the current orientation is portrait mode.[/en]
+     *   [ja]現在のオリエンテーションがportraitの場合にtrueを返します。[/ja]
+     */
+
+    /**
+     * @method on
+     * @signature on(eventName, listener)
+     * @description
+     *   [en]Add an event listener.[/en]
+     *   [ja]イベントリスナーを追加します。[/ja]
+     * @param {String} eventName
+     *   [en]Name of the event.[/en]
+     *   [ja]イベント名を指定します。[/ja]
+     * @param {Function} listener
+     *   [en]Function to execute when the event is triggered.[/en]
+     *   [ja]このイベントが発火された際に呼び出される関数オブジェクトを指定します。[/ja]
+     */
+
+    /**
+     * @method once
+     * @signature once(eventName, listener)
+     * @description
+     *  [en]Add an event listener that's only triggered once.[/en]
+     *  [ja]一度だけ呼び出されるイベントリスナーを追加します。[/ja]
+     * @param {String} eventName
+     *   [en]Name of the event.[/en]
+     *   [ja]イベント名を指定します。[/ja]
+     * @param {Function} listener
+     *   [en]Function to execute when the event is triggered.[/en]
+     *   [ja]イベントが発火した際に呼び出される関数オブジェクトを指定します。[/ja]
+     */
+
+    /**
+     * @method off
+     * @signature off(eventName, [listener])
+     * @description
+     *  [en]Remove an event listener. If the listener is not specified all listeners for the event type will be removed.[/en]
+     *  [ja]イベントリスナーを削除します。もしイベントリスナーを指定しなかった場合には、そのイベントに紐づく全てのイベントリスナーが削除されます。[/ja]
+     * @param {String} eventName
+     *   [en]Name of the event.[/en]
+     *   [ja]イベント名を指定します。[/ja]
+     * @param {Function} listener
+     *   [en]Function to execute when the event is triggered.[/en]
+     *   [ja]削除するイベントリスナーを指定します。[/ja]
+     */
+
+    // actual implementation to detect if whether current screen is portrait or not
+    _isPortrait: false,
+
+    /**
+     * @method isPortrait
+     * @signature isPortrait()
+     * @return {Boolean}
+     *   [en]Will be true if the current orientation is portrait mode.[/en]
+     *   [ja]オリエンテーションがportraitモードの場合にtrueになります。[/ja]
+     * @description
+     *   [en]Returns whether the current screen orientation is portrait or not.[/en]
+     *   [ja]オリエンテーションがportraitモードかどうかを返します。[/ja]
+     */
+    isPortrait: function isPortrait() {
+      return this._isPortrait();
+    },
+
+    /**
+     * @method isLandscape
+     * @signature isLandscape()
+     * @return {Boolean}
+     *   [en]Will be true if the current orientation is landscape mode.[/en]
+     *   [ja]オリエンテーションがlandscapeモードの場合にtrueになります。[/ja]
+     * @description
+     *   [en]Returns whether the current screen orientation is landscape or not.[/en]
+     *   [ja]オリエンテーションがlandscapeモードかどうかを返します。[/ja]
+     */
+    isLandscape: function isLandscape() {
+      return !this.isPortrait();
+    },
+
+    _init: function _init() {
+      document.addEventListener('DOMContentLoaded', this._onDOMContentLoaded.bind(this), false);
+
+      if ('orientation' in window) {
+        window.addEventListener('orientationchange', this._onOrientationChange.bind(this), false);
+      } else {
+        window.addEventListener('resize', this._onResize.bind(this), false);
+      }
+
+      this._isPortrait = function () {
+        return window.innerHeight > window.innerWidth;
+      };
+
+      return this;
+    },
+
+    _onDOMContentLoaded: function _onDOMContentLoaded() {
+      this._installIsPortraitImplementation();
+      this.emit('change', { isPortrait: this.isPortrait() });
+    },
+
+    _installIsPortraitImplementation: function _installIsPortraitImplementation() {
+      var isPortrait = window.innerWidth < window.innerHeight;
+
+      if (!('orientation' in window)) {
+        this._isPortrait = function () {
+          return window.innerHeight > window.innerWidth;
+        };
+      } else if (window.orientation % 180 === 0) {
+        this._isPortrait = function () {
+          return Math.abs(window.orientation % 180) === 0 ? isPortrait : !isPortrait;
+        };
+      } else {
+        this._isPortrait = function () {
+          return Math.abs(window.orientation % 180) === 90 ? isPortrait : !isPortrait;
+        };
+      }
+    },
+
+    _onOrientationChange: function _onOrientationChange() {
+      var _this = this;
+
+      var isPortrait = this._isPortrait();
+
+      // Wait for the dimensions to change because
+      // of Android inconsistency.
+      var nIter = 0;
+      var interval = setInterval(function () {
+        nIter++;
+
+        var w = window.innerWidth;
+        var h = window.innerHeight;
+
+        if (isPortrait && w <= h || !isPortrait && w >= h) {
+          _this.emit('change', { isPortrait: isPortrait });
+          clearInterval(interval);
+        } else if (nIter === 50) {
+          _this.emit('change', { isPortrait: isPortrait });
+          clearInterval(interval);
+        }
+      }, 20);
+    },
+
+    // Run on not mobile browser.
+    _onResize: function _onResize() {
+      this.emit('change', { isPortrait: this.isPortrait() });
+    }
+  };
+
+  MicroEvent.mixin(obj);
+
+  return obj;
+};
+
+var orientation = create()._init();
+
+/*
+Copyright 2013-2015 ASIAL CORPORATION
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+   http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+*/
+
+/**
+ * @object ons.modifier
+ * @category visual
+ * @description
+ *   [en]
+ *     Utility methods to change modifier attributes of Onsen UI elements..
+ *   [/en]
+ *   [ja][/ja]
+ * @example
+ * ons.modifier.add(myOnsInputElement, 'underbar');
+ * ons.modifier.toggle(myOnsToastElement, 'custom-modifier');
+ *
+ */
+var modifier = {
+  /**
+   * @method add
+   * @signature add(element, modifier [, modifier])
+   * @description
+   *   [en]Add the specified modifiers to the element if they are not already included.[/en]
+   *   [ja][/ja]
+   * @param {HTMLElement} element
+   *   [en]Target element.[/en]
+   *   [ja][/ja]
+   * @param {String} modifier
+   *   [en]Name of the modifier.[/en]
+   *   [ja][/ja]
+   */
+  add: function add(element) {
+    for (var _len = arguments.length, modifiers = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
+      modifiers[_key - 1] = arguments[_key];
+    }
+
+    return modifiers.forEach(function (modifier) {
+      return util$1.addModifier(element, modifier);
+    });
+  },
+  /**
+   * @method remove
+   * @signature remove(element, modifier [, modifier])
+   * @description
+   *   [en]Remove the specified modifiers from the element if they are included.[/en]
+   *   [ja][/ja]
+   * @param {HTMLElement} element
+   *   [en]Target element.[/en]
+   *   [ja][/ja]
+   * @param {String} modifier
+   *   [en]Name of the modifier.[/en]
+   *   [ja][/ja]
+   */
+  remove: function remove(element) {
+    for (var _len2 = arguments.length, modifiers = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
+      modifiers[_key2 - 1] = arguments[_key2];
+    }
+
+    return modifiers.forEach(function (modifier) {
+      return util$1.removeModifier(element, modifier);
+    });
+  },
+  /**
+   * @method contains
+   * @signature contains(element, modifier)
+   * @description
+   *   [en]Check whether the specified modifier is included in the element.[/en]
+   *   [ja][/ja]
+   * @param {HTMLElement} element
+   *   [en]Target element.[/en]
+   *   [ja][/ja]
+   * @param {String} modifier
+   *   [en]Name of the modifier.[/en]
+   *   [ja][/ja]
+   * @return {Boolean}
+   *   [en]`true` when the specified modifier is found in the element's `modifier` attribute. `false` otherwise.[/en]
+   *   [ja][/ja]
+   */
+  contains: util$1.hasModifier,
+  /**
+   * @method toggle
+   * @signature toggle(element, modifier [, force])
+   * @description
+   *   [en]Toggle the specified modifier.[/en]
+   *   [ja][/ja]
+   * @param {HTMLElement} element
+   *   [en]Target element.[/en]
+   *   [ja][/ja]
+   * @param {String} modifier
+   *   [en]Name of the modifier.[/en]
+   *   [ja][/ja]
+   * @param {String} force
+   *   [en]If it evaluates to true, add specified modifier value, and if it evaluates to false, remove it.[/en]
+   *   [ja][/ja]
+   */
+  toggle: util$1.toggleModifier
+};
+
+/*
+Copyright 2013-2015 ASIAL CORPORATION
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+   http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+*/
+
+var softwareKeyboard = new MicroEvent();
+softwareKeyboard._visible = false;
+
+var onShow = function onShow() {
+  softwareKeyboard._visible = true;
+  softwareKeyboard.emit('show');
+};
+
+var onHide = function onHide() {
+  softwareKeyboard._visible = false;
+  softwareKeyboard.emit('hide');
+};
+
+var bindEvents = function bindEvents() {
+  if (typeof Keyboard !== 'undefined') {
+    // https://github.com/martinmose/cordova-keyboard/blob/95f3da3a38d8f8e1fa41fbf40145352c13535a00/README.md
+    Keyboard.onshow = onShow;
+    Keyboard.onhide = onHide;
+    softwareKeyboard.emit('init', { visible: Keyboard.isVisible });
+
+    return true;
+  } else if (typeof cordova.plugins !== 'undefined' && typeof cordova.plugins.Keyboard !== 'undefined') {
+    // https://github.com/driftyco/ionic-plugins-keyboard/blob/ca27ecf/README.md
+    window.addEventListener('native.keyboardshow', onShow);
+    window.addEventListener('native.keyboardhide', onHide);
+    softwareKeyboard.emit('init', { visible: cordova.plugins.Keyboard.isVisible });
+
+    return true;
+  }
+
+  return false;
+};
+
+var noPluginError = function noPluginError() {
+  util$1.warn('ons-keyboard: Cordova Keyboard plugin is not present.');
+};
+
+document.addEventListener('deviceready', function () {
+  if (!bindEvents()) {
+    if (document.querySelector('[ons-keyboard-active]') || document.querySelector('[ons-keyboard-inactive]')) {
+      noPluginError();
+    }
+
+    softwareKeyboard.on = noPluginError;
+  }
+});
+
+/*
+Copyright 2013-2015 ASIAL CORPORATION
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+   http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+*/
+
+var generateId = function () {
+  var i = 0;
+  return function () {
+    return i++;
+  };
+}();
+
+/**
+ * Door locking system.
+ *
+ * @param {Object} [options]
+ * @param {Function} [options.log]
+ */
+
+var DoorLock = function () {
+  function DoorLock() {
+    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
+    classCallCheck(this, DoorLock);
+
+    this._lockList = [];
+    this._waitList = [];
+    this._log = options.log || function () {};
+  }
+
+  /**
+   * Register a lock.
+   *
+   * @return {Function} Callback for unlocking.
+   */
+
+
+  createClass(DoorLock, [{
+    key: 'lock',
+    value: function lock() {
+      var _this = this;
+
+      var unlock = function unlock() {
+        _this._unlock(unlock);
+      };
+      unlock.id = generateId();
+      this._lockList.push(unlock);
+      this._log('lock: ' + unlock.id);
+
+      return unlock;
+    }
+  }, {
+    key: '_unlock',
+    value: function _unlock(fn) {
+      var index = this._lockList.indexOf(fn);
+      if (index === -1) {
+        throw new Error('This function is not registered in the lock list.');
+      }
+
+      this._lockList.splice(index, 1);
+      this._log('unlock: ' + fn.id);
+
+      this._tryToFreeWaitList();
+    }
+  }, {
+    key: '_tryToFreeWaitList',
+    value: function _tryToFreeWaitList() {
+      while (!this.isLocked() && this._waitList.length > 0) {
+        this._waitList.shift()();
+      }
+    }
+
+    /**
+     * Register a callback for waiting unlocked door.
+     *
+     * @params {Function} callback Callback on unlocking the door completely.
+     */
+
+  }, {
+    key: 'waitUnlock',
+    value: function waitUnlock(callback) {
+      if (!(callback instanceof Function)) {
+        throw new Error('The callback param must be a function.');
+      }
+
+      if (this.isLocked()) {
+        this._waitList.push(callback);
+      } else {
+        callback();
+      }
+    }
+
+    /**
+     * @return {Boolean}
+     */
+
+  }, {
+    key: 'isLocked',
+    value: function isLocked() {
+      return this._lockList.length > 0;
+    }
+  }]);
+  return DoorLock;
+}();
+
+/*
+Copyright 2013-2015 ASIAL CORPORATION
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+   http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+*/
+// Default implementation for global PageLoader.
+function loadPage(_ref, done) {
+  var page = _ref.page,
+      parent = _ref.parent,
+      _ref$params = _ref.params;
+
+  internal$1.getPageHTMLAsync(page).then(function (html) {
+    var pageElement = util$1.createElement(html);
+    parent.appendChild(pageElement);
+
+    done(pageElement);
+  });
+}
+
+function unloadPage(element) {
+  if (element._destroy instanceof Function) {
+    element._destroy();
+  } else {
+    element.remove();
+  }
+}
+
+var PageLoader = function () {
+  /**
+   * @param {Function} [fn] Returns an object that has "element" property and "unload" function.
+   */
+  function PageLoader(loader, unloader) {
+    classCallCheck(this, PageLoader);
+
+    this._loader = loader instanceof Function ? loader : loadPage;
+    this._unloader = unloader instanceof Function ? unloader : unloadPage;
+  }
+
+  /**
+   * Set internal loader implementation.
+   */
+
+
+  createClass(PageLoader, [{
+    key: 'load',
+
+
+    /**
+     * @param {any} options.page
+     * @param {Element} options.parent A location to load page.
+     * @param {Object} [options.params] Extra parameters for ons-page.
+     * @param {Function} done Take an object that has "element" property and "unload" function.
+     */
+    value: function load(_ref2, done) {
+      var page = _ref2.page,
+          parent = _ref2.parent,
+          _ref2$params = _ref2.params,
+          params = _ref2$params === undefined ? {} : _ref2$params;
+
+      this._loader({ page: page, parent: parent, params: params }, function (pageElement) {
+        if (!(pageElement instanceof Element)) {
+          throw Error('pageElement must be an instance of Element.');
+        }
+
+        done(pageElement);
+      });
+    }
+  }, {
+    key: 'unload',
+    value: function unload(pageElement) {
+      if (!(pageElement instanceof Element)) {
+        throw Error('pageElement must be an instance of Element.');
+      }
+
+      this._unloader(pageElement);
+    }
+  }, {
+    key: 'internalLoader',
+    set: function set$$1(fn) {
+      if (!(fn instanceof Function)) {
+        throw Error('First parameter must be an instance of Function');
+      }
+      this._loader = fn;
+    },
+    get: function get$$1() {
+      return this._loader;
+    }
+  }]);
+  return PageLoader;
+}();
+
+var defaultPageLoader = new PageLoader();
+
+var instantPageLoader = new PageLoader(function (_ref3, done) {
+  var page = _ref3.page,
+      parent = _ref3.parent,
+      _ref3$params = _ref3.params;
+
+  var element = util$1.createElement(page.trim());
+  parent.appendChild(element);
+
+  done(element);
+}, unloadPage);
+
+/*
+Copyright 2013-2015 ASIAL CORPORATION
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+   http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+*/
+
+/**
+ * @object ons
+ * @category util
+ * @description
+ *   [ja]Onsen UIで利用できるグローバルなオブジェクトです。[/ja]
+ *   [en]A global object that's used in Onsen UI. [/en]
+ */
+var ons$1 = {
+  animit: Animit,
+  defaultPageLoader: defaultPageLoader,
+  elements: onsElements,
+  GestureDetector: GestureDetector,
+  modifier: modifier,
+  notification: notification,
+  orientation: orientation,
+  pageAttributeExpression: pageAttributeExpression,
+  PageLoader: PageLoader,
+  platform: platform,
+  softwareKeyboard: softwareKeyboard,
+  _autoStyle: autoStyle,
+  _internal: internal$1,
+  _readyLock: new DoorLock(),
+  _util: util$1
+};
+
+ons$1.platform.select((window.location.search.match(/platform=([\w-]+)/) || [])[1]);
+
+waitDeviceReady();
+
+var readyError = function readyError(after) {
+  return util$1.throw('This method must be called ' + (after ? 'after' : 'before') + ' ons.isReady() is true');
+};
+
+/**
+ * @method isReady
+ * @signature isReady()
+ * @return {Boolean}
+ *   [en]Will be true if Onsen UI is initialized.[/en]
+ *   [ja]初期化されているかどうかを返します。[/ja]
+ * @description
+ *   [en]Returns true if Onsen UI is initialized.[/en]
+ *   [ja]Onsen UIがすでに初期化されているかどうかを返すメソッドです。[/ja]
+ */
+ons$1.isReady = function () {
+  return !ons$1._readyLock.isLocked();
+};
+
+/**
+ * @method isWebView
+ * @signature isWebView()
+ * @return {Boolean}
+ *   [en]Will be true if the app is running in Cordova.[/en]
+ *   [ja]Cordovaで実行されている場合にtrueになります。[/ja]
+ * @description
+ *   [en]Returns true if running inside Cordova.[/en]
+ *   [ja]Cordovaで実行されているかどうかを返すメソッドです。[/ja]
+ */
+ons$1.isWebView = ons$1.platform.isWebView;
+
+/**
+ * @method ready
+ * @signature ready(callback)
+ * @description
+ *   [ja]アプリの初期化に利用するメソッドです。渡された関数は、Onsen UIの初期化が終了している時点で必ず呼ばれます。[/ja]
+ *   [en]Method used to wait for app initialization. Waits for `DOMContentLoaded` and `deviceready`, when necessary, before executing the callback.[/en]
+ * @param {Function} callback
+ *   [en]Function that executes after Onsen UI has been initialized.[/en]
+ *   [ja]Onsen UIが初期化が完了した後に呼び出される関数オブジェクトを指定します。[/ja]
+ */
+ons$1.ready = function (callback) {
+  if (ons$1.isReady()) {
+    callback();
+  } else {
+    ons$1._readyLock.waitUnlock(callback);
+  }
+};
+
+/**
+ * @method setDefaultDeviceBackButtonListener
+ * @signature setDefaultDeviceBackButtonListener(listener)
+ * @param {Function} listener
+ *   [en]Function that executes when device back button is pressed. Must be called on `ons.ready`.[/en]
+ *   [ja]デバイスのバックボタンが押された時に実行される関数オブジェクトを指定します。[/ja]
+ * @description
+ *   [en]Set default handler for device back button.[/en]
+ *   [ja]デバイスのバックボタンのためのデフォルトのハンドラを設定します。[/ja]
+ */
+ons$1.setDefaultDeviceBackButtonListener = function (listener) {
+  if (!ons$1.isReady()) {
+    readyError(true);
+  }
+  ons$1._defaultDeviceBackButtonHandler.setListener(listener);
+};
+
+/**
+ * @method disableDeviceBackButtonHandler
+ * @signature disableDeviceBackButtonHandler()
+ * @description
+ * [en]Disable device back button event handler. Must be called on `ons.ready`.[/en]
+ * [ja]デバイスのバックボタンのイベントを受け付けないようにします。[/ja]
+ */
+ons$1.disableDeviceBackButtonHandler = function () {
+  if (!ons$1.isReady()) {
+    readyError(true);
+  }
+  internal$1.dbbDispatcher.disable();
+};
+
+/**
+ * @method enableDeviceBackButtonHandler
+ * @signature enableDeviceBackButtonHandler()
+ * @description
+ * [en]Enable device back button event handler. Must be called on `ons.ready`.[/en]
+ * [ja]デバイスのバックボタンのイベントを受け付けるようにします。[/ja]
+ */
+ons$1.enableDeviceBackButtonHandler = function () {
+  if (!ons$1.isReady()) {
+    readyError(true);
+  }
+  internal$1.dbbDispatcher.enable();
+};
+
+ons$1.fireDeviceBackButtonEvent = function () {
+  internal$1.dbbDispatcher.fireDeviceBackButtonEvent();
+};
+
+/**
+ * @method enableAutoStatusBarFill
+ * @signature enableAutoStatusBarFill()
+ * @description
+ *   [en]Enable status bar fill feature on iOS7 and above (except for iPhone X). Must be called before `ons.ready`.[/en]
+ *   [ja]iOS7以上（iPhone Xは除く）で、ステータスバー部分の高さを自動的に埋める処理を有効にします。[/ja]
+ */
+ons$1.enableAutoStatusBarFill = function () {
+  if (ons$1.isReady()) {
+    readyError(false);
+  }
+  internal$1.config.autoStatusBarFill = true;
+};
+
+/**
+ * @method disableAutoStatusBarFill
+ * @signature disableAutoStatusBarFill()
+ * @description
+ *   [en]Disable status bar fill feature on iOS7 and above (except for iPhone X). Must be called before `ons.ready`.[/en]
+ *   [ja]iOS7以上（iPhone Xは除く）で、ステータスバー部分の高さを自動的に埋める処理を無効にします。[/ja]
+ */
+ons$1.disableAutoStatusBarFill = function () {
+  if (ons$1.isReady()) {
+    readyError(false);
+  }
+  internal$1.config.autoStatusBarFill = false;
+};
+
+/**
+ * @method mockStatusBar
+ * @signature mockStatusBar()
+ * @description
+ *   [en]Creates a static element similar to iOS status bar. Only useful for browser testing. Must be called before `ons.ready`.[/en]
+ *   [ja][/ja]
+ */
+ons$1.mockStatusBar = function () {
+  if (ons$1.isReady()) {
+    readyError(false);
+  }
+
+  var mock = function mock() {
+    if (!document.body.children[0] || !document.body.children[0].classList.contains('ons-status-bar-mock')) {
+      var android = platform.isAndroid(),
+          i = function i(_i) {
+        return '<i class="' + _i.split('-')[0] + ' ' + _i + '"></i>';
+      };
+      var left = android ? i('zmdi-twitter') + ' ' + i('zmdi-google-play') : 'No SIM ' + i('fa-wifi'),
+          center = android ? '' : '12:28 PM',
+          right = android ? i('zmdi-network') + ' ' + i('zmdi-wifi') + ' ' + i('zmdi-battery') + ' 12:28 PM' : '80% ' + i('fa-battery-three-quarters');
+
+      document.body.insertBefore(util$1.createElement('<div class="ons-status-bar-mock ' + (android ? 'android' : 'ios') + '">' + ('<div>' + left + '</div><div>' + center + '</div><div>' + right + '</div>') + '</div>'), document.body.firstChild);
+    }
+  };
+
+  document.body ? mock() : internal$1.waitDOMContentLoaded(mock);
+};
+
+/**
+ * @method disableAnimations
+ * @signature disableAnimations()
+ * @description
+ *   [en]Disable all animations. Could be handy for testing and older devices.[/en]
+ *   [ja]アニメーションを全て無効にします。テストの際に便利です。[/ja]
+ */
+ons$1.disableAnimations = function () {
+  internal$1.config.animationsDisabled = true;
+};
+
+/**
+ * @method enableAnimations
+ * @signature enableAnimations()
+ * @description
+ *   [en]Enable animations (default).[/en]
+ *   [ja]アニメーションを有効にします。[/ja]
+ */
+ons$1.enableAnimations = function () {
+  internal$1.config.animationsDisabled = false;
+};
+
+ons$1._disableWarnings = function () {
+  internal$1.config.warningsDisabled = true;
+};
+
+ons$1._enableWarnings = function () {
+  internal$1.config.warningsDisabled = false;
+};
+
+/**
+ * @method disableAutoStyling
+ * @signature disableAutoStyling()
+ * @description
+ *   [en]Disable automatic styling.[/en]
+ *   [ja][/ja]
+ */
+ons$1.disableAutoStyling = autoStyle.disable;
+
+/**
+ * @method enableAutoStyling
+ * @signature enableAutoStyling()
+ * @description
+ *   [en]Enable automatic styling based on OS (default).[/en]
+ *   [ja][/ja]
+ */
+ons$1.enableAutoStyling = autoStyle.enable;
+
+/**
+ * @method disableIconAutoPrefix
+ * @signature disableIconAutoPrefix()
+ * @description
+ *   [en]Disable adding `fa-` prefix automatically to `ons-icon` classes. Useful when including custom icon packs.[/en]
+ *   [ja][/ja]
+ */
+ons$1.disableIconAutoPrefix = function () {
+  util$1.checkMissingImport('Icon');
+  onsElements.Icon.setAutoPrefix(false);
+};
+
+/**
+ * @method forceUIWebViewScrollFix
+ * @signature forceUIWebViewScrollFix()
+ * @param {Boolean} force Enable or disable the fix.
+ * @description
+ *   [en]Applies a fix for iOS UIWebView which prevents scroll events jumping to pages under the top layer. This may visually affect normal scrolling of UIWebView if you open a dialog/menu before the scroll momentum finished. Disabled by default.[/en]
+ *   [ja][/ja]
+ */
+ons$1.forceUIWebViewScrollFix = function () {
+  var force = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
+
+  internal$1.config.forceUIWebViewScrollFix = force;
+};
+
+/**
+ * @method forcePlatformStyling
+ * @signature forcePlatformStyling(platform)
+ * @description
+ *   [en]Refresh styling for the given platform. Only useful for demos. Use `ons.platform.select(...)` instead for development and production.[/en]
+ *   [ja][/ja]
+ * @param {string} platform New platform to style the elements.
+ */
+ons$1.forcePlatformStyling = function (newPlatform) {
+  ons$1.enableAutoStyling();
+  ons$1.platform.select(newPlatform || 'ios');
+
+  ons$1._util.arrayFrom(document.querySelectorAll('*')).forEach(function (element) {
+    if (element.tagName.toLowerCase() === 'ons-if') {
+      element._platformUpdate();
+    } else if (element.tagName.match(/^ons-/i)) {
+      autoStyle.prepare(element, true);
+      if (element.tagName.toLowerCase() === 'ons-tabbar') {
+        element._updatePosition();
+      }
+    }
+  });
+};
+
+/**
+ * @method preload
+ * @signature preload(templatePaths)
+ * @param {String|Array} templatePaths
+ *   [en]Set of HTML file paths containing 'ons-page' elements.[/en]
+ *   [ja][/ja]
+ * @return {Promise}
+ *   [en]Promise that resolves when all the templates are cached.[/en]
+ *   [ja][/ja]
+ * @description
+ *   [en]Separated files need to be requested on demand and this can slightly delay pushing new pages. This method requests and caches templates for later use.[/en]
+ *   [ja][/ja]
+ */
+ons$1.preload = function () {
+  var templates = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
+
+  return Promise.all((templates instanceof Array ? templates : [templates]).map(function (template) {
+    if (typeof template !== 'string') {
+      util$1.throw('Expected string arguments but got ' + (typeof template === 'undefined' ? 'undefined' : _typeof(template)));
+    }
+    return internal$1.getTemplateHTMLAsync(template);
+  }));
+};
+
+/**
+ * @method createElement
+ * @signature createElement(template, options)
+ * @param {String} template
+ *   [en]Either an HTML file path, a `<template>` id or an HTML string such as `'<div id="foo">hoge</div>'`.[/en]
+ *   [ja][/ja]
+ * @param {Object} [options]
+ *   [en]Parameter object.[/en]
+ *   [ja]オプションを指定するオブジェクト。[/ja]
+ * @param {Boolean|HTMLElement} [options.append]
+ *   [en]Whether or not the element should be automatically appended to the DOM.  Defaults to `false`. If `true` value is given, `document.body` will be used as the target.[/en]
+ *   [ja][/ja]
+ * @param {HTMLElement} [options.insertBefore]
+ *   [en]Reference node that becomes the next sibling of the new node (`options.append` element).[/en]
+ *   [ja][/ja]
+ * @return {HTMLElement|Promise}
+ *   [en]If the provided template was an inline HTML string, it returns the new element. Otherwise, it returns a promise that resolves to the new element.[/en]
+ *   [ja][/ja]
+ * @description
+ *   [en]Create a new element from a template. Both inline HTML and external files are supported although the return value differs.[/en]
+ *   [ja][/ja]
+ */
+ons$1.createElement = function (template) {
+  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
+
+  template = template.trim();
+
+  var create = function create(html) {
+    var element = ons$1._util.createElement(html);
+    element.remove();
+
+    if (options.append) {
+      var target = options.append instanceof HTMLElement ? options.append : document.body;
+      target.insertBefore(element, options.insertBefore || null);
+      options.link instanceof Function && options.link(element);
+    }
+
+    return element;
+  };
+
+  return template.charAt(0) === '<' ? create(template) : internal$1.getPageHTMLAsync(template).then(create);
+};
+
+/**
+ * @method createPopover
+ * @signature createPopover(page, [options])
+ * @param {String} page
+ *   [en]Page name. Can be either an HTML file or a <template> containing a <ons-dialog> component.[/en]
+ *   [ja]pageのURLか、もしくは`<template>`で宣言したテンプレートのid属性の値を指定できます。[/ja]
+ * @param {Object} [options]
+ *   [en]Parameter object.[/en]
+ *   [ja]オプションを指定するオブジェクト。[/ja]
+ * @param {Object} [options.parentScope]
+ *   [en]Parent scope of the dialog. Used to bind models and access scope methods from the dialog.[/en]
+ *   [ja]ダイアログ内で利用する親スコープを指定します。ダイアログからモデルやスコープのメソッドにアクセスするのに使います。このパラメータはAngularJSバインディングでのみ利用できます。[/ja]
+ * @return {Promise}
+ *   [en]Promise object that resolves to the popover component object.[/en]
+ *   [ja]ポップオーバーのコンポーネントオブジェクトを解決するPromiseオブジェクトを返します。[/ja]
+ * @description
+ *   [en]Create a popover instance from a template.[/en]
+ *   [ja]テンプレートからポップオーバーのインスタンスを生成します。[/ja]
+ */
+/**
+ * @method createDialog
+ * @signature createDialog(page, [options])
+ * @param {String} page
+ *   [en]Page name. Can be either an HTML file or an `<template>` containing a <ons-dialog> component.[/en]
+ *   [ja]pageのURLか、もしくは`<template>`で宣言したテンプレートのid属性の値を指定できます。[/ja]
+ * @param {Object} [options]
+ *   [en]Parameter object.[/en]
+ *   [ja]オプションを指定するオブジェクト。[/ja]
+ * @return {Promise}
+ *   [en]Promise object that resolves to the dialog component object.[/en]
+ *   [ja]ダイアログのコンポーネントオブジェクトを解決するPromiseオブジェクトを返します。[/ja]
+ * @description
+ *   [en]Create a dialog instance from a template.[/en]
+ *   [ja]テンプレートからダイアログのインスタンスを生成します。[/ja]
+ */
+/**
+ * @method createAlertDialog
+ * @signature createAlertDialog(page, [options])
+ * @param {String} page
+ *   [en]Page name. Can be either an HTML file or an `<template>` containing a <ons-alert-dialog> component.[/en]
+ *   [ja]pageのURLか、もしくは`<template>`で宣言したテンプレートのid属性の値を指定できます。[/ja]
+ * @param {Object} [options]
+ *   [en]Parameter object.[/en]
+ *   [ja]オプションを指定するオブジェクト。[/ja]
+ * @return {Promise}
+ *   [en]Promise object that resolves to the alert dialog component object.[/en]
+ *   [ja]ダイアログのコンポーネントオブジェクトを解決するPromiseオブジェクトを返します。[/ja]
+ * @description
+ *   [en]Create a alert dialog instance from a template.[/en]
+ *   [ja]テンプレートからアラートダイアログのインスタンスを生成します。[/ja]
+ */
+ons$1.createPopover = ons$1.createDialog = ons$1.createAlertDialog = function (template) {
+  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
+  return ons$1.createElement(template, _extends({ append: true }, options));
+};
+
+/**
+ * @method openActionSheet
+ * @signature openActionSheet(options)
+ * @description
+ *   [en]Shows an instant Action Sheet and lets the user choose an action.[/en]
+ *   [ja][/ja]
+ * @param {Object} [options]
+ *   [en]Parameter object.[/en]
+ *   [ja]オプションを指定するオブジェクト。[/ja]
+ * @param {Array} [options.buttons]
+ *   [en]Represent each button of the action sheet following the specified order. Every item can be either a string label or an object containing `label`, `icon` and `modifier` properties.[/en]
+ *   [ja][/ja]
+ * @param {String} [options.title]
+ *   [en]Optional title for the action sheet.[/en]
+ *   [ja][/ja]
+ * @param {Number} [options.destructive]
+ *   [en]Optional index of the "destructive" button (only for iOS). It can be specified in the button array as well.[/en]
+ *   [ja][/ja]
+ * @param {Boolean} [options.cancelable]
+ *   [en]Whether the action sheet can be canceled by tapping on the background mask or not.[/en]
+ *   [ja][/ja]
+ * @param {String} [options.modifier]
+ *   [en]Modifier attribute of the action sheet. E.g. `'destructive'`.[/en]
+ *   [ja][/ja]
+ * @param {String} [options.maskColor]
+ *   [en]Optionally change the background mask color.[/en]
+ *   [ja][/ja]
+ * @param {String} [options.id]
+ *   [en]The element's id attribute.[/en]
+ *   [ja][/ja]
+ * @param {String} [options.class]
+ *   [en]The element's class attribute.[/en]
+ *   [ja][/ja]
+ * @return {Promise}
+ *   [en]Will resolve when the action sheet is closed. The resolve value is either the index of the tapped button or -1 when canceled.[/en]
+ *   [ja][/ja]
+ */
+ons$1.openActionSheet = actionSheet;
+
+/**
+ * @method resolveLoadingPlaceholder
+ * @signature resolveLoadingPlaceholder(page)
+ * @param {String} page
+ *   [en]Page name. Can be either an HTML file or a `<template>` id.[/en]
+ *   [ja]pageのURLか、もしくは`<template>`で宣言したテンプレートのid属性の値を指定できます。[/ja]
+ * @description
+ *   [en]If no page is defined for the `ons-loading-placeholder` attribute it will wait for this method being called before loading the page.[/en]
+ *   [ja]ons-loading-placeholderの属性値としてページが指定されていない場合は、ページロード前に呼ばれるons.resolveLoadingPlaceholder処理が行われるまで表示されません。[/ja]
+ */
+ons$1.resolveLoadingPlaceholder = function (page, link) {
+  var elements = ons$1._util.arrayFrom(window.document.querySelectorAll('[ons-loading-placeholder]'));
+  if (elements.length === 0) {
+    util$1.throw('No ons-loading-placeholder exists');
+  }
+
+  elements.filter(function (element) {
+    return !element.getAttribute('page');
+  }).forEach(function (element) {
+    element.setAttribute('ons-loading-placeholder', page);
+    ons$1._resolveLoadingPlaceholder(element, page, link);
+  });
+};
+
+ons$1._setupLoadingPlaceHolders = function () {
+  ons$1.ready(function () {
+    var elements = ons$1._util.arrayFrom(window.document.querySelectorAll('[ons-loading-placeholder]'));
+
+    elements.forEach(function (element) {
+      var page = element.getAttribute('ons-loading-placeholder');
+      if (typeof page === 'string') {
+        ons$1._resolveLoadingPlaceholder(element, page);
+      }
+    });
+  });
+};
+
+ons$1._resolveLoadingPlaceholder = function (parent, page) {
+  var link = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : function (el, done) {
+    return done();
+  };
+
+  page && ons$1.createElement(page).then(function (element) {
+    element.style.display = 'none';
+    parent.appendChild(element);
+    link(element, function () {
+      while (parent.firstChild && parent.firstChild !== element) {
+        parent.removeChild(parent.firstChild);
+      }
+      element.style.display = '';
+    });
+  }).catch(function (error) {
+    return Promise.reject('Unabled to resolve placeholder: ' + error);
+  });
+};
+
+function waitDeviceReady() {
+  var unlockDeviceReady = ons$1._readyLock.lock();
+  window.addEventListener('DOMContentLoaded', function () {
+    if (ons$1.isWebView()) {
+      window.document.addEventListener('deviceready', unlockDeviceReady, false);
+    } else {
+      unlockDeviceReady();
+    }
+  }, false);
+}
+
+/**
+ * @method getScriptPage
+ * @signature getScriptPage()
+ * @description
+ *   [en]Access the last created page from the current `script` scope. Only works inside `<script></script>` tags that are direct children of `ons-page` element. Use this to add lifecycle hooks to a page.[/en]
+ *   [ja][/ja]
+ * @return {HTMLElement}
+ *   [en]Returns the corresponding page element.[/en]
+ *   [ja][/ja]
+ */
+var getCS = 'currentScript' in document ? function () {
+  return document.currentScript;
+} : function () {
+  return document.scripts[document.scripts.length - 1];
+};
+ons$1.getScriptPage = function () {
+  return getCS() && /ons-page/i.test(getCS().parentElement.tagName) && getCS().parentElement || null;
+};
+
+function createCommonjsModule(fn, module) {
+	return module = { exports: {} }, fn(module, module.exports), module.exports;
+}
+
+var fastclick = createCommonjsModule(function (module) {
+	(function () {
+		function FastClick(layer, options) {
+			var oldOnClick;
+
+			options = options || {};
+
+			/**
+    * Whether a click is currently being tracked.
+    *
+    * @type boolean
+    */
+			this.trackingClick = false;
+
+			/**
+    * Timestamp for when click tracking started.
+    *
+    * @type number
+    */
+			this.trackingClickStart = 0;
+
+			/**
+    * The element being tracked for a click.
+    *
+    * @type EventTarget
+    */
+			this.targetElement = null;
+
+			/**
+    * X-coordinate of touch start event.
+    *
+    * @type number
+    */
+			this.touchStartX = 0;
+
+			/**
+    * Y-coordinate of touch start event.
+    *
+    * @type number
+    */
+			this.touchStartY = 0;
+
+			/**
+    * ID of the last touch, retrieved from Touch.identifier.
+    *
+    * @type number
+    */
+			this.lastTouchIdentifier = 0;
+
+			/**
+    * Touchmove boundary, beyond which a click will be cancelled.
+    *
+    * @type number
+    */
+			this.touchBoundary = options.touchBoundary || 10;
+
+			/**
+    * The FastClick layer.
+    *
+    * @type Element
+    */
+			this.layer = layer;
+
+			/**
+    * The minimum time between tap(touchstart and touchend) events
+    *
+    * @type number
+    */
+			this.tapDelay = options.tapDelay || 200;
+
+			/**
+    * The maximum time for a tap
+    *
+    * @type number
+    */
+			this.tapTimeout = options.tapTimeout || 700;
+
+			if (FastClick.notNeeded(layer)) {
+				return;
+			}
+
+			// Some old versions of Android don't have Function.prototype.bind
+			function bind(method, context) {
+				return function () {
+					return method.apply(context, arguments);
+				};
+			}
+
+			var methods = ['onMouse', 'onClick', 'onTouchStart', 'onTouchMove', 'onTouchEnd', 'onTouchCancel'];
+			var context = this;
+			for (var i = 0, l = methods.length; i < l; i++) {
+				context[methods[i]] = bind(context[methods[i]], context);
+			}
+
+			// Set up event handlers as required
+			if (deviceIsAndroid) {
+				layer.addEventListener('mouseover', this.onMouse, true);
+				layer.addEventListener('mousedown', this.onMouse, true);
+				layer.addEventListener('mouseup', this.onMouse, true);
+			}
+
+			layer.addEventListener('click', this.onClick, true);
+			layer.addEventListener('touchstart', this.onTouchStart, false);
+			layer.addEventListener('touchmove', this.onTouchMove, false);
+			layer.addEventListener('touchend', this.onTouchEnd, false);
+			layer.addEventListener('touchcancel', this.onTouchCancel, false);
+
+			// Hack is required for browsers that don't support Event#stopImmediatePropagation (e.g. Android 2)
+			// which is how FastClick normally stops click events bubbling to callbacks registered on the FastClick
+			// layer when they are cancelled.
+			if (!Event.prototype.stopImmediatePropagation) {
+				layer.removeEventListener = function (type, callback, capture) {
+					var rmv = Node.prototype.removeEventListener;
+					if (type === 'click') {
+						rmv.call(layer, type, callback.hijacked || callback, capture);
+					} else {
+						rmv.call(layer, type, callback, capture);
+					}
+				};
+
+				layer.addEventListener = function (type, callback, capture) {
+					var adv = Node.prototype.addEventListener;
+					if (type === 'click') {
+						adv.call(layer, type, callback.hijacked || (callback.hijacked = function (event) {
+							if (!event.propagationStopped) {
+								callback(event);
+							}
+						}), capture);
+					} else {
+						adv.call(layer, type, callback, capture);
+					}
+				};
+			}
+
+			// If a handler is already declared in the element's onclick attribute, it will be fired before
+			// FastClick's onClick handler. Fix this by pulling out the user-defined handler function and
+			// adding it as listener.
+			if (typeof layer.onclick === 'function') {
+
+				// Android browser on at least 3.2 requires a new reference to the function in layer.onclick
+				// - the old one won't work if passed to addEventListener directly.
+				oldOnClick = layer.onclick;
+				layer.addEventListener('click', function (event) {
+					oldOnClick(event);
+				}, false);
+				layer.onclick = null;
+			}
+		}
+
+		/**
+  * Windows Phone 8.1 fakes user agent string to look like Android and iPhone.
+  *
+  * @type boolean
+  */
+		var deviceIsWindowsPhone = navigator.userAgent.indexOf("Windows Phone") >= 0;
+
+		/**
+   * Android requires exceptions.
+   *
+   * @type boolean
+   */
+		var deviceIsAndroid = navigator.userAgent.indexOf('Android') > 0 && !deviceIsWindowsPhone;
+
+		/**
+   * iOS requires exceptions.
+   *
+   * @type boolean
+   */
+		var deviceIsIOS = /iP(ad|hone|od)/.test(navigator.userAgent) && !deviceIsWindowsPhone;
+
+		/**
+   * iOS 4 requires an exception for select elements.
+   *
+   * @type boolean
+   */
+		var deviceIsIOS4 = deviceIsIOS && /OS 4_\d(_\d)?/.test(navigator.userAgent);
+
+		/**
+   * iOS 6.0-7.* requires the target element to be manually derived
+   *
+   * @type boolean
+   */
+		var deviceIsIOSWithBadTarget = deviceIsIOS && /OS [6-7]_\d/.test(navigator.userAgent);
+
+		/**
+   * BlackBerry requires exceptions.
+   *
+   * @type boolean
+   */
+		var deviceIsBlackBerry10 = navigator.userAgent.indexOf('BB10') > 0;
+
+		/**
+   * Valid types for text inputs
+   *
+   * @type array
+   */
+		var textFields = ['email', 'number', 'password', 'search', 'tel', 'text', 'url'];
+
+		/**
+   * Determine whether a given element requires a native click.
+   *
+   * @param {EventTarget|Element} target Target DOM element
+   * @returns {boolean} Returns true if the element needs a native click
+   */
+		FastClick.prototype.needsClick = function (target) {
+			switch (target.nodeName.toLowerCase()) {
+
+				// Don't send a synthetic click to disabled inputs (issue #62)
+				case 'button':
+				case 'select':
+				case 'textarea':
+					if (target.disabled) {
+						return true;
+					}
+
+					break;
+				case 'input':
+
+					// File inputs need real clicks on iOS 6 due to a browser bug (issue #68)
+					if (deviceIsIOS && target.type === 'file' || target.disabled) {
+						return true;
+					}
+
+					break;
+				case 'label':
+				case 'iframe': // iOS8 homescreen apps can prevent events bubbling into frames
+				case 'video':
+					return true;
+			}
+
+			return (/\bneedsclick\b/.test(target.className)
+			);
+		};
+
+		/**
+   * Determine whether a given element requires a call to focus to simulate click into element.
+   *
+   * @param {EventTarget|Element} target Target DOM element
+   * @returns {boolean} Returns true if the element requires a call to focus to simulate native click.
+   */
+		FastClick.prototype.needsFocus = function (target) {
+			switch (target.nodeName.toLowerCase()) {
+				case 'textarea':
+					return true;
+				case 'select':
+					return !deviceIsAndroid;
+				case 'input':
+					switch (target.type) {
+						case 'button':
+						case 'checkbox':
+						case 'file':
+						case 'image':
+						case 'radio':
+						case 'submit':
+							return false;
+					}
+
+					// No point in attempting to focus disabled inputs
+					return !target.disabled && !target.readOnly;
+				default:
+					return (/\bneedsfocus\b/.test(target.className)
+					);
+			}
+		};
+
+		/**
+   * Send a click event to the specified element.
+   *
+   * @param {EventTarget|Element} targetElement
+   * @param {Event} event
+   */
+		FastClick.prototype.sendClick = function (targetElement, event) {
+			var clickEvent, touch;
+
+			// On some Android devices activeElement needs to be blurred otherwise the synthetic click will have no effect (#24)
+			if (document.activeElement && document.activeElement !== targetElement) {
+				document.activeElement.blur();
+			}
+
+			touch = event.changedTouches[0];
+
+			// Synthesise a click event, with an extra attribute so it can be tracked
+			clickEvent = document.createEvent('MouseEvents');
+			clickEvent.initMouseEvent(this.determineEventType(targetElement), true, true, window, 1, touch.screenX, touch.screenY, touch.clientX, touch.clientY, false, false, false, false, 0, null);
+			clickEvent.forwardedTouchEvent = true;
+			targetElement.dispatchEvent(clickEvent);
+		};
+
+		FastClick.prototype.determineEventType = function (targetElement) {
+
+			//Issue #159: Android Chrome Select Box does not open with a synthetic click event
+			if (deviceIsAndroid && targetElement.tagName.toLowerCase() === 'select') {
+				return 'mousedown';
+			}
+
+			return 'click';
+		};
+
+		/**
+   * @param {EventTarget|Element} targetElement
+   */
+		FastClick.prototype.focus = function (targetElement) {
+			var length;
+
+			// Issue #160: on iOS 7, some input elements (e.g. date datetime month) throw a vague TypeError on setSelectionRange. These elements don't have an integer value for the selectionStart and selectionEnd properties, but unfortunately that can't be used for detection because accessing the properties also throws a TypeError. Just check the type instead. Filed as Apple bug #15122724.
+			if (deviceIsIOS && targetElement.setSelectionRange && targetElement.type.indexOf('date') !== 0 && targetElement.type !== 'time' && targetElement.type !== 'month' && targetElement.type !== 'email' && targetElement.type !== 'number') {
+				length = targetElement.value.length;
+				targetElement.setSelectionRange(length, length);
+			} else {
+				targetElement.focus();
+			}
+		};
+
+		/**
+   * Check whether the given target element is a child of a scrollable layer and if so, set a flag on it.
+   *
+   * @param {EventTarget|Element} targetElement
+   */
+		FastClick.prototype.updateScrollParent = function (targetElement) {
+			var scrollParent, parentElement;
+
+			scrollParent = targetElement.fastClickScrollParent;
+
+			// Attempt to discover whether the target element is contained within a scrollable layer. Re-check if the
+			// target element was moved to another parent.
+			if (!scrollParent || !scrollParent.contains(targetElement)) {
+				parentElement = targetElement;
+				do {
+					if (parentElement.scrollHeight > parentElement.offsetHeight) {
+						scrollParent = parentElement;
+						targetElement.fastClickScrollParent = parentElement;
+						break;
+					}
+
+					parentElement = parentElement.parentElement;
+				} while (parentElement);
+			}
+
+			// Always update the scroll top tracker if possible.
+			if (scrollParent) {
+				scrollParent.fastClickLastScrollTop = scrollParent.scrollTop;
+			}
+		};
+
+		/**
+   * @param {EventTarget} targetElement
+   * @returns {Element|EventTarget}
+   */
+		FastClick.prototype.getTargetElementFromEventTarget = function (eventTarget) {
+
+			// On some older browsers (notably Safari on iOS 4.1 - see issue #56) the event target may be a text node.
+			if (eventTarget.nodeType === Node.TEXT_NODE) {
+				return eventTarget.parentNode;
+			}
+
+			return eventTarget;
+		};
+
+		/**
+   * @param {EventTarget} targetElement
+   * @returns {boolean}
+   */
+		FastClick.prototype.isTextField = function (targetElement) {
+			return targetElement.tagName.toLowerCase() === 'textarea' || textFields.indexOf(targetElement.type) !== -1;
+		};
+
+		/**
+   * On touch start, record the position and scroll offset.
+   *
+   * @param {Event} event
+   * @returns {boolean}
+   */
+		FastClick.prototype.onTouchStart = function (event) {
+			var targetElement, touch;
+
+			// Ignore multiple touches, otherwise pinch-to-zoom is prevented if both fingers are on the FastClick element (issue #111).
+			if (event.targetTouches.length > 1) {
+				return true;
+			}
+
+			targetElement = this.getTargetElementFromEventTarget(event.target);
+			touch = event.targetTouches[0];
+
+			// Ignore touches on contenteditable elements to prevent conflict with text selection.
+			// (For details: https://github.com/ftlabs/fastclick/pull/211 )
+			if (targetElement.isContentEditable) {
+				return true;
+			}
+
+			if (deviceIsIOS) {
+				// Ignore touchstart in focused text field
+				// Allows normal text selection and commands (select/paste/cut) when a field has focus, while still allowing fast tap-to-focus.
+				// Without this fix, user needs to tap-and-hold a text field for context menu, and double-tap to select text doesn't work at all.
+				if (targetElement === document.activeElement && this.isTextField(targetElement)) {
+					return true;
+				}
+
+				if (!deviceIsIOS4) {
+
+					// Weird things happen on iOS when an alert or confirm dialog is opened from a click event callback (issue #23):
+					// when the user next taps anywhere else on the page, new touchstart and touchend events are dispatched
+					// with the same identifier as the touch event that previously triggered the click that triggered the alert.
+					// Sadly, there is an issue on iOS 4 that causes some normal touch events to have the same identifier as an
+					// immediately preceeding touch event (issue #52), so this fix is unavailable on that platform.
+					// Issue 120: touch.identifier is 0 when Chrome dev tools 'Emulate touch events' is set with an iOS device UA string,
+					// which causes all touch events to be ignored. As this block only applies to iOS, and iOS identifiers are always long,
+					// random integers, it's safe to to continue if the identifier is 0 here.
+					if (touch.identifier && touch.identifier === this.lastTouchIdentifier) {
+						event.preventDefault();
+						return false;
+					}
+
+					this.lastTouchIdentifier = touch.identifier;
+
+					// If the target element is a child of a scrollable layer (using -webkit-overflow-scrolling: touch) and:
+					// 1) the user does a fling scroll on the scrollable layer
+					// 2) the user stops the fling scroll with another tap
+					// then the event.target of the last 'touchend' event will be the element that was under the user's finger
+					// when the fling scroll was started, causing FastClick to send a click event to that layer - unless a check
+					// is made to ensure that a parent layer was not scrolled before sending a synthetic click (issue #42).
+					this.updateScrollParent(targetElement);
+				}
+			}
+
+			this.trackingClick = true;
+			this.trackingClickStart = event.timeStamp;
+			this.targetElement = targetElement;
+
+			this.touchStartX = touch.pageX;
+			this.touchStartY = touch.pageY;
+
+			// Prevent phantom clicks on fast double-tap (issue #36)
+			if (event.timeStamp - this.lastClickTime < this.tapDelay && event.timeStamp - this.lastClickTime > -1) {
+				event.preventDefault();
+			}
+
+			return true;
+		};
+
+		/**
+   * Based on a touchmove event object, check whether the touch has moved past a boundary since it started.
+   *
+   * @param {Event} event
+   * @returns {boolean}
+   */
+		FastClick.prototype.touchHasMoved = function (event) {
+			var touch = event.changedTouches[0],
+			    boundary = this.touchBoundary;
+
+			if (Math.abs(touch.pageX - this.touchStartX) > boundary || Math.abs(touch.pageY - this.touchStartY) > boundary) {
+				return true;
+			}
+
+			return false;
+		};
+
+		/**
+   * Update the last position.
+   *
+   * @param {Event} event
+   * @returns {boolean}
+   */
+		FastClick.prototype.onTouchMove = function (event) {
+			if (!this.trackingClick) {
+				return true;
+			}
+
+			// If the touch has moved, cancel the click tracking
+			if (this.targetElement !== this.getTargetElementFromEventTarget(event.target) || this.touchHasMoved(event)) {
+				this.trackingClick = false;
+				this.targetElement = null;
+			}
+
+			return true;
+		};
+
+		/**
+   * Attempt to find the labelled control for the given label element.
+   *
+   * @param {EventTarget|HTMLLabelElement} labelElement
+   * @returns {Element|null}
+   */
+		FastClick.prototype.findControl = function (labelElement) {
+
+			// Fast path for newer browsers supporting the HTML5 control attribute
+			if (labelElement.control !== undefined) {
+				return labelElement.control;
+			}
+
+			// All browsers under test that support touch events also support the HTML5 htmlFor attribute
+			if (labelElement.htmlFor) {
+				return document.getElementById(labelElement.htmlFor);
+			}
+
+			// If no for attribute exists, attempt to retrieve the first labellable descendant element
+			// the list of which is defined here: http://www.w3.org/TR/html5/forms.html#category-label
+			return labelElement.querySelector('button, input:not([type=hidden]), keygen, meter, output, progress, select, textarea');
+		};
+
+		/**
+   * On touch end, determine whether to send a click event at once.
+   *
+   * @param {Event} event
+   * @returns {boolean}
+   */
+		FastClick.prototype.onTouchEnd = function (event) {
+			var forElement,
+			    trackingClickStart,
+			    targetTagName,
+			    scrollParent,
+			    touch,
+			    targetElement = this.targetElement;
+
+			if (!this.trackingClick) {
+				return true;
+			}
+
+			// Prevent phantom clicks on fast double-tap (issue #36)
+			if (event.timeStamp - this.lastClickTime < this.tapDelay && event.timeStamp - this.lastClickTime > -1) {
+				this.cancelNextClick = true;
+				return true;
+			}
+
+			if (event.timeStamp - this.trackingClickStart > this.tapTimeout) {
+				return true;
+			}
+
+			// Reset to prevent wrong click cancel on input (issue #156).
+			this.cancelNextClick = false;
+
+			this.lastClickTime = event.timeStamp;
+
+			trackingClickStart = this.trackingClickStart;
+			this.trackingClick = false;
+			this.trackingClickStart = 0;
+
+			// On some iOS devices, the targetElement supplied with the event is invalid if the layer
+			// is performing a transition or scroll, and has to be re-detected manually. Note that
+			// for this to function correctly, it must be called *after* the event target is checked!
+			// See issue #57; also filed as rdar://13048589 .
+			if (deviceIsIOSWithBadTarget) {
+				touch = event.changedTouches[0];
+
+				// In certain cases arguments of elementFromPoint can be negative, so prevent setting targetElement to null
+				targetElement = document.elementFromPoint(touch.pageX - window.pageXOffset, touch.pageY - window.pageYOffset) || targetElement;
+				targetElement.fastClickScrollParent = this.targetElement.fastClickScrollParent;
+			}
+
+			targetTagName = targetElement.tagName.toLowerCase();
+			if (targetTagName === 'label') {
+				forElement = this.findControl(targetElement);
+				if (forElement) {
+					this.focus(targetElement);
+					if (deviceIsAndroid) {
+						return false;
+					}
+
+					targetElement = forElement;
+				}
+			} else if (this.needsFocus(targetElement)) {
+
+				// Case 1: If the touch started a while ago (best guess is 100ms based on tests for issue #36) then focus will be triggered anyway. Return early and unset the target element reference so that the subsequent click will be allowed through.
+				// Case 2: Without this exception for input elements tapped when the document is contained in an iframe, then any inputted text won't be visible even though the value attribute is updated as the user types (issue #37).
+				if (event.timeStamp - trackingClickStart > 100 || deviceIsIOS && window.top !== window && targetTagName === 'input') {
+					this.targetElement = null;
+					return false;
+				}
+
+				this.focus(targetElement);
+				this.sendClick(targetElement, event);
+
+				// Select elements need the event to go through on iOS 4, otherwise the selector menu won't open.
+				// Also this breaks opening selects when VoiceOver is active on iOS6, iOS7 (and possibly others)
+				if (!deviceIsIOS4 || targetTagName !== 'select') {
+					this.targetElement = null;
+					event.preventDefault();
+				}
+
+				return false;
+			}
+
+			if (deviceIsIOS && !deviceIsIOS4) {
+
+				// Don't send a synthetic click event if the target element is contained within a parent layer that was scrolled
+				// and this tap is being used to stop the scrolling (usually initiated by a fling - issue #42).
+				scrollParent = targetElement.fastClickScrollParent;
+				if (scrollParent && scrollParent.fastClickLastScrollTop !== scrollParent.scrollTop) {
+					return true;
+				}
+			}
+
+			// Prevent the actual click from going though - unless the target node is marked as requiring
+			// real clicks or if it is in the whitelist in which case only non-programmatic clicks are permitted.
+			if (!this.needsClick(targetElement)) {
+				event.preventDefault();
+				this.sendClick(targetElement, event);
+			}
+
+			return false;
+		};
+
+		/**
+   * On touch cancel, stop tracking the click.
+   *
+   * @returns {void}
+   */
+		FastClick.prototype.onTouchCancel = function () {
+			this.trackingClick = false;
+			this.targetElement = null;
+		};
+
+		/**
+   * Determine mouse events which should be permitted.
+   *
+   * @param {Event} event
+   * @returns {boolean}
+   */
+		FastClick.prototype.onMouse = function (event) {
+
+			// If a target element was never set (because a touch event was never fired) allow the event
+			if (!this.targetElement) {
+				return true;
+			}
+
+			if (event.forwardedTouchEvent) {
+				return true;
+			}
+
+			// Programmatically generated events targeting a specific element should be permitted
+			if (!event.cancelable) {
+				return true;
+			}
+
+			// Derive and check the target element to see whether the mouse event needs to be permitted;
+			// unless explicitly enabled, prevent non-touch click events from triggering actions,
+			// to prevent ghost/doubleclicks.
+			if (!this.needsClick(this.targetElement) || this.cancelNextClick) {
+
+				// Prevent any user-added listeners declared on FastClick element from being fired.
+				if (event.stopImmediatePropagation) {
+					event.stopImmediatePropagation();
+				} else {
+
+					// Part of the hack for browsers that don't support Event#stopImmediatePropagation (e.g. Android 2)
+					event.propagationStopped = true;
+				}
+
+				// Cancel the event
+				event.stopPropagation();
+				event.preventDefault();
+
+				return false;
+			}
+
+			// If the mouse event is permitted, return true for the action to go through.
+			return true;
+		};
+
+		/**
+   * On actual clicks, determine whether this is a touch-generated click, a click action occurring
+   * naturally after a delay after a touch (which needs to be cancelled to avoid duplication), or
+   * an actual click which should be permitted.
+   *
+   * @param {Event} event
+   * @returns {boolean}
+   */
+		FastClick.prototype.onClick = function (event) {
+			var permitted;
+
+			// It's possible for another FastClick-like library delivered with third-party code to fire a click event before FastClick does (issue #44). In that case, set the click-tracking flag back to false and return early. This will cause onTouchEnd to return early.
+			if (this.trackingClick) {
+				this.targetElement = null;
+				this.trackingClick = false;
+				return true;
+			}
+
+			// Very odd behaviour on iOS (issue #18): if a submit element is present inside a form and the user hits enter in the iOS simulator or clicks the Go button on the pop-up OS keyboard the a kind of 'fake' click event will be triggered with the submit-type input element as the target.
+			if (event.target.type === 'submit' && event.detail === 0) {
+				return true;
+			}
+
+			permitted = this.onMouse(event);
+
+			// Only unset targetElement if the click is not permitted. This will ensure that the check for !targetElement in onMouse fails and the browser's click doesn't go through.
+			if (!permitted) {
+				this.targetElement = null;
+			}
+
+			// If clicks are permitted, return true for the action to go through.
+			return permitted;
+		};
+
+		/**
+   * Remove all FastClick's event listeners.
+   *
+   * @returns {void}
+   */
+		FastClick.prototype.destroy = function () {
+			var layer = this.layer;
+
+			if (deviceIsAndroid) {
+				layer.removeEventListener('mouseover', this.onMouse, true);
+				layer.removeEventListener('mousedown', this.onMouse, true);
+				layer.removeEventListener('mouseup', this.onMouse, true);
+			}
+
+			layer.removeEventListener('click', this.onClick, true);
+			layer.removeEventListener('touchstart', this.onTouchStart, false);
+			layer.removeEventListener('touchmove', this.onTouchMove, false);
+			layer.removeEventListener('touchend', this.onTouchEnd, false);
+			layer.removeEventListener('touchcancel', this.onTouchCancel, false);
+		};
+
+		/**
+   * Check whether FastClick is needed.
+   *
+   * @param {Element} layer The layer to listen on
+   */
+		FastClick.notNeeded = function (layer) {
+			var metaViewport;
+			var chromeVersion;
+			var blackberryVersion;
+			var firefoxVersion;
+
+			// Devices that don't support touch don't need FastClick
+			if (typeof window.ontouchstart === 'undefined') {
+				return true;
+			}
+
+			// Chrome version - zero for other browsers
+			chromeVersion = +(/Chrome\/([0-9]+)/.exec(navigator.userAgent) || [, 0])[1];
+
+			if (chromeVersion) {
+
+				if (deviceIsAndroid) {
+					metaViewport = document.querySelector('meta[name=viewport]');
+
+					if (metaViewport) {
+						// Chrome on Android with user-scalable="no" doesn't need FastClick (issue #89)
+						if (metaViewport.content.indexOf('user-scalable=no') !== -1) {
+							return true;
+						}
+						// Chrome 32 and above with width=device-width or less don't need FastClick
+						if (chromeVersion > 31 && document.documentElement.scrollWidth <= window.outerWidth) {
+							return true;
+						}
+					}
+
+					// Chrome desktop doesn't need FastClick (issue #15)
+				} else {
+					return true;
+				}
+			}
+
+			if (deviceIsBlackBerry10) {
+				blackberryVersion = navigator.userAgent.match(/Version\/([0-9]*)\.([0-9]*)/);
+
+				// BlackBerry 10.3+ does not require Fastclick library.
+				// https://github.com/ftlabs/fastclick/issues/251
+				if (blackberryVersion[1] >= 10 && blackberryVersion[2] >= 3) {
+					metaViewport = document.querySelector('meta[name=viewport]');
+
+					if (metaViewport) {
+						// user-scalable=no eliminates click delay.
+						if (metaViewport.content.indexOf('user-scalable=no') !== -1) {
+							return true;
+						}
+						// width=device-width (or less than device-width) eliminates click delay.
+						if (document.documentElement.scrollWidth <= window.outerWidth) {
+							return true;
+						}
+					}
+				}
+			}
+
+			// IE10 with -ms-touch-action: none or manipulation, which disables double-tap-to-zoom (issue #97)
+			if (layer.style.msTouchAction === 'none' || layer.style.touchAction === 'manipulation') {
+				return true;
+			}
+
+			// Firefox version - zero for other browsers
+			firefoxVersion = +(/Firefox\/([0-9]+)/.exec(navigator.userAgent) || [, 0])[1];
+
+			if (firefoxVersion >= 27) {
+				// Firefox 27+ does not have tap delay if the content is not zoomable - https://bugzilla.mozilla.org/show_bug.cgi?id=922896
+
+				metaViewport = document.querySelector('meta[name=viewport]');
+				if (metaViewport && (metaViewport.content.indexOf('user-scalable=no') !== -1 || document.documentElement.scrollWidth <= window.outerWidth)) {
+					return true;
+				}
+			}
+
+			// IE11: prefixed -ms-touch-action is no longer supported and it's recomended to use non-prefixed version
+			// http://msdn.microsoft.com/en-us/library/windows/apps/Hh767313.aspx
+			if (layer.style.touchAction === 'none' || layer.style.touchAction === 'manipulation') {
+				return true;
+			}
+
+			return false;
+		};
+
+		/**
+   * Factory method for creating a FastClick object
+   *
+   * @param {Element} layer The layer to listen on
+   * @param {Object} [options={}] The options to override the defaults
+   */
+		FastClick.attach = function (layer, options) {
+			return new FastClick(layer, options);
+		};
+
+		if (typeof undefined === 'function' && _typeof(undefined.amd) === 'object' && undefined.amd) {
+
+			// AMD. Register as an anonymous module.
+			undefined(function () {
+				return FastClick;
+			});
+		} else if ('object' !== 'undefined' && module.exports) {
+			module.exports = FastClick.attach;
+			module.exports.FastClick = FastClick;
+		} else {
+			window.FastClick = FastClick;
+		}
+	})();
+});
+
+var fastclick_1 = fastclick.FastClick;
+
+// For @onsenui/custom-elements
+if (window.customElements) {
+    // even if native CE1 impl exists, use polyfill
+    window.customElements.forcePolyfill = true;
+}
+
+var _global = createCommonjsModule(function (module) {
+  // https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
+  var global = module.exports = typeof window != 'undefined' && window.Math == Math ? window : typeof self != 'undefined' && self.Math == Math ? self
+  // eslint-disable-next-line no-new-func
+  : Function('return this')();
+  if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef
+});
+
+var _core = createCommonjsModule(function (module) {
+  var core = module.exports = { version: '2.6.5' };
+  if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef
+});
+
+var _core_1 = _core.version;
+
+var _isObject = function _isObject(it) {
+  return (typeof it === 'undefined' ? 'undefined' : _typeof(it)) === 'object' ? it !== null : typeof it === 'function';
+};
+
+var _anObject = function _anObject(it) {
+  if (!_isObject(it)) throw TypeError(it + ' is not an object!');
+  return it;
+};
+
+var _fails = function _fails(exec) {
+  try {
+    return !!exec();
+  } catch (e) {
+    return true;
+  }
+};
+
+// Thank's IE8 for his funny defineProperty
+var _descriptors = !_fails(function () {
+  return Object.defineProperty({}, 'a', { get: function get() {
+      return 7;
+    } }).a != 7;
+});
+
+var document$1 = _global.document;
+// typeof document.createElement is 'object' in old IE
+var is = _isObject(document$1) && _isObject(document$1.createElement);
+var _domCreate = function _domCreate(it) {
+  return is ? document$1.createElement(it) : {};
+};
+
+var _ie8DomDefine = !_descriptors && !_fails(function () {
+  return Object.defineProperty(_domCreate('div'), 'a', { get: function get() {
+      return 7;
+    } }).a != 7;
+});
+
+// 7.1.1 ToPrimitive(input [, PreferredType])
+
+// instead of the ES6 spec version, we didn't implement @@toPrimitive case
+// and the second argument - flag - preferred type is a string
+var _toPrimitive = function _toPrimitive(it, S) {
+  if (!_isObject(it)) return it;
+  var fn, val;
+  if (S && typeof (fn = it.toString) == 'function' && !_isObject(val = fn.call(it))) return val;
+  if (typeof (fn = it.valueOf) == 'function' && !_isObject(val = fn.call(it))) return val;
+  if (!S && typeof (fn = it.toString) == 'function' && !_isObject(val = fn.call(it))) return val;
+  throw TypeError("Can't convert object to primitive value");
+};
+
+var dP = Object.defineProperty;
+
+var f = _descriptors ? Object.defineProperty : function defineProperty(O, P, Attributes) {
+  _anObject(O);
+  P = _toPrimitive(P, true);
+  _anObject(Attributes);
+  if (_ie8DomDefine) try {
+    return dP(O, P, Attributes);
+  } catch (e) {/* empty */}
+  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
+  if ('value' in Attributes) O[P] = Attributes.value;
+  return O;
+};
+
+var _objectDp = {
+  f: f
+};
+
+var _propertyDesc = function _propertyDesc(bitmap, value) {
+  return {
+    enumerable: !(bitmap & 1),
+    configurable: !(bitmap & 2),
+    writable: !(bitmap & 4),
+    value: value
+  };
+};
+
+var _hide = _descriptors ? function (object, key, value) {
+  return _objectDp.f(object, key, _propertyDesc(1, value));
+} : function (object, key, value) {
+  object[key] = value;
+  return object;
+};
+
+var hasOwnProperty = {}.hasOwnProperty;
+var _has = function _has(it, key) {
+  return hasOwnProperty.call(it, key);
+};
+
+var id = 0;
+var px = Math.random();
+var _uid = function _uid(key) {
+  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
+};
+
+var _library = false;
+
+var _shared = createCommonjsModule(function (module) {
+  var SHARED = '__core-js_shared__';
+  var store = _global[SHARED] || (_global[SHARED] = {});
+
+  (module.exports = function (key, value) {
+    return store[key] || (store[key] = value !== undefined ? value : {});
+  })('versions', []).push({
+    version: _core.version,
+    mode: _library ? 'pure' : 'global',
+    copyright: '© 2019 Denis Pushkarev (zloirock.ru)'
+  });
+});
+
+var _functionToString = _shared('native-function-to-string', Function.toString);
+
+var _redefine = createCommonjsModule(function (module) {
+  var SRC = _uid('src');
+
+  var TO_STRING = 'toString';
+  var TPL = ('' + _functionToString).split(TO_STRING);
+
+  _core.inspectSource = function (it) {
+    return _functionToString.call(it);
+  };
+
+  (module.exports = function (O, key, val, safe) {
+    var isFunction = typeof val == 'function';
+    if (isFunction) _has(val, 'name') || _hide(val, 'name', key);
+    if (O[key] === val) return;
+    if (isFunction) _has(val, SRC) || _hide(val, SRC, O[key] ? '' + O[key] : TPL.join(String(key)));
+    if (O === _global) {
+      O[key] = val;
+    } else if (!safe) {
+      delete O[key];
+      _hide(O, key, val);
+    } else if (O[key]) {
+      O[key] = val;
+    } else {
+      _hide(O, key, val);
+    }
+    // add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
+  })(Function.prototype, TO_STRING, function toString() {
+    return typeof this == 'function' && this[SRC] || _functionToString.call(this);
+  });
+});
+
+var _aFunction = function _aFunction(it) {
+  if (typeof it != 'function') throw TypeError(it + ' is not a function!');
+  return it;
+};
+
+// optional / simple context binding
+
+var _ctx = function _ctx(fn, that, length) {
+  _aFunction(fn);
+  if (that === undefined) return fn;
+  switch (length) {
+    case 1:
+      return function (a) {
+        return fn.call(that, a);
+      };
+    case 2:
+      return function (a, b) {
+        return fn.call(that, a, b);
+      };
+    case 3:
+      return function (a, b, c) {
+        return fn.call(that, a, b, c);
+      };
+  }
+  return function () /* ...args */{
+    return fn.apply(that, arguments);
+  };
+};
+
+var PROTOTYPE = 'prototype';
+
+var $export = function $export(type, name, source) {
+  var IS_FORCED = type & $export.F;
+  var IS_GLOBAL = type & $export.G;
+  var IS_STATIC = type & $export.S;
+  var IS_PROTO = type & $export.P;
+  var IS_BIND = type & $export.B;
+  var target = IS_GLOBAL ? _global : IS_STATIC ? _global[name] || (_global[name] = {}) : (_global[name] || {})[PROTOTYPE];
+  var exports = IS_GLOBAL ? _core : _core[name] || (_core[name] = {});
+  var expProto = exports[PROTOTYPE] || (exports[PROTOTYPE] = {});
+  var key, own, out, exp;
+  if (IS_GLOBAL) source = name;
+  for (key in source) {
+    // contains in native
+    own = !IS_FORCED && target && target[key] !== undefined;
+    // export native or passed
+    out = (own ? target : source)[key];
+    // bind timers to global for call from export context
+    exp = IS_BIND && own ? _ctx(out, _global) : IS_PROTO && typeof out == 'function' ? _ctx(Function.call, out) : out;
+    // extend global
+    if (target) _redefine(target, key, out, type & $export.U);
+    // export
+    if (exports[key] != out) _hide(exports, key, exp);
+    if (IS_PROTO && expProto[key] != out) expProto[key] = out;
+  }
+};
+_global.core = _core;
+// type bitmap
+$export.F = 1; // forced
+$export.G = 2; // global
+$export.S = 4; // static
+$export.P = 8; // proto
+$export.B = 16; // bind
+$export.W = 32; // wrap
+$export.U = 64; // safe
+$export.R = 128; // real proto method for `library`
+var _export = $export;
+
+var f$2 = {}.propertyIsEnumerable;
+
+var _objectPie = {
+	f: f$2
+};
+
+var toString = {}.toString;
+
+var _cof = function _cof(it) {
+  return toString.call(it).slice(8, -1);
+};
+
+// fallback for non-array-like ES3 and non-enumerable old V8 strings
+
+// eslint-disable-next-line no-prototype-builtins
+var _iobject = Object('z').propertyIsEnumerable(0) ? Object : function (it) {
+  return _cof(it) == 'String' ? it.split('') : Object(it);
+};
+
+// 7.2.1 RequireObjectCoercible(argument)
+var _defined = function _defined(it) {
+  if (it == undefined) throw TypeError("Can't call method on  " + it);
+  return it;
+};
+
+// to indexed object, toObject with fallback for non-array-like ES3 strings
+
+
+var _toIobject = function _toIobject(it) {
+  return _iobject(_defined(it));
+};
+
+var gOPD = Object.getOwnPropertyDescriptor;
+
+var f$1 = _descriptors ? gOPD : function getOwnPropertyDescriptor(O, P) {
+  O = _toIobject(O);
+  P = _toPrimitive(P, true);
+  if (_ie8DomDefine) try {
+    return gOPD(O, P);
+  } catch (e) {/* empty */}
+  if (_has(O, P)) return _propertyDesc(!_objectPie.f.call(O, P), O[P]);
+};
+
+var _objectGopd = {
+  f: f$1
+};
+
+// Works with __proto__ only. Old v8 can't work with null proto objects.
+/* eslint-disable no-proto */
+
+var check = function check(O, proto) {
+  _anObject(O);
+  if (!_isObject(proto) && proto !== null) throw TypeError(proto + ": can't set as prototype!");
+};
+var _setProto = {
+  set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line
+  function (test, buggy, set) {
+    try {
+      set = _ctx(Function.call, _objectGopd.f(Object.prototype, '__proto__').set, 2);
+      set(test, []);
+      buggy = !(test instanceof Array);
+    } catch (e) {
+      buggy = true;
+    }
+    return function setPrototypeOf(O, proto) {
+      check(O, proto);
+      if (buggy) O.__proto__ = proto;else set(O, proto);
+      return O;
+    };
+  }({}, false) : undefined),
+  check: check
+};
+
+// 19.1.3.19 Object.setPrototypeOf(O, proto)
+
+_export(_export.S, 'Object', { setPrototypeOf: _setProto.set });
+
+var setPrototypeOf = _core.Object.setPrototypeOf;
+
+var _wks = createCommonjsModule(function (module) {
+  var store = _shared('wks');
+
+  var _Symbol = _global.Symbol;
+  var USE_SYMBOL = typeof _Symbol == 'function';
+
+  var $exports = module.exports = function (name) {
+    return store[name] || (store[name] = USE_SYMBOL && _Symbol[name] || (USE_SYMBOL ? _Symbol : _uid)('Symbol.' + name));
+  };
+
+  $exports.store = store;
+});
+
+// getting tag from 19.1.3.6 Object.prototype.toString()
+
+var TAG = _wks('toStringTag');
+// ES3 wrong here
+var ARG = _cof(function () {
+  return arguments;
+}()) == 'Arguments';
+
+// fallback for IE11 Script Access Denied error
+var tryGet = function tryGet(it, key) {
+  try {
+    return it[key];
+  } catch (e) {/* empty */}
+};
+
+var _classof = function _classof(it) {
+  var O, T, B;
+  return it === undefined ? 'Undefined' : it === null ? 'Null'
+  // @@toStringTag case
+  : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T
+  // builtinTag case
+  : ARG ? _cof(O)
+  // ES3 arguments fallback
+  : (B = _cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
+};
+
+// 19.1.3.6 Object.prototype.toString()
+
+var test = {};
+test[_wks('toStringTag')] = 'z';
+if (test + '' != '[object z]') {
+  _redefine(Object.prototype, 'toString', function toString() {
+    return '[object ' + _classof(this) + ']';
+  }, true);
+}
+
+// 7.1.4 ToInteger
+var ceil = Math.ceil;
+var floor = Math.floor;
+var _toInteger = function _toInteger(it) {
+  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
+};
+
+// true  -> String#at
+// false -> String#codePointAt
+var _stringAt = function _stringAt(TO_STRING) {
+  return function (that, pos) {
+    var s = String(_defined(that));
+    var i = _toInteger(pos);
+    var l = s.length;
+    var a, b;
+    if (i < 0 || i >= l) return TO_STRING ? '' : undefined;
+    a = s.charCodeAt(i);
+    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff ? TO_STRING ? s.charAt(i) : a : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
+  };
+};
+
+var _iterators = {};
+
+// 7.1.15 ToLength
+
+var min = Math.min;
+var _toLength = function _toLength(it) {
+  return it > 0 ? min(_toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
+};
+
+var max = Math.max;
+var min$1 = Math.min;
+var _toAbsoluteIndex = function _toAbsoluteIndex(index, length) {
+  index = _toInteger(index);
+  return index < 0 ? max(index + length, 0) : min$1(index, length);
+};
+
+// false -> Array#indexOf
+// true  -> Array#includes
+
+
+var _arrayIncludes = function _arrayIncludes(IS_INCLUDES) {
+  return function ($this, el, fromIndex) {
+    var O = _toIobject($this);
+    var length = _toLength(O.length);
+    var index = _toAbsoluteIndex(fromIndex, length);
+    var value;
+    // Array#includes uses SameValueZero equality algorithm
+    // eslint-disable-next-line no-self-compare
+    if (IS_INCLUDES && el != el) while (length > index) {
+      value = O[index++];
+      // eslint-disable-next-line no-self-compare
+      if (value != value) return true;
+      // Array#indexOf ignores holes, Array#includes - not
+    } else for (; length > index; index++) {
+      if (IS_INCLUDES || index in O) {
+        if (O[index] === el) return IS_INCLUDES || index || 0;
+      }
+    }return !IS_INCLUDES && -1;
+  };
+};
+
+var shared = _shared('keys');
+
+var _sharedKey = function _sharedKey(key) {
+  return shared[key] || (shared[key] = _uid(key));
+};
+
+var arrayIndexOf = _arrayIncludes(false);
+var IE_PROTO$1 = _sharedKey('IE_PROTO');
+
+var _objectKeysInternal = function _objectKeysInternal(object, names) {
+  var O = _toIobject(object);
+  var i = 0;
+  var result = [];
+  var key;
+  for (key in O) {
+    if (key != IE_PROTO$1) _has(O, key) && result.push(key);
+  } // Don't enum bug & hidden keys
+  while (names.length > i) {
+    if (_has(O, key = names[i++])) {
+      ~arrayIndexOf(result, key) || result.push(key);
+    }
+  }return result;
+};
+
+// IE 8- don't enum bug keys
+var _enumBugKeys = 'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'.split(',');
+
+// 19.1.2.14 / 15.2.3.14 Object.keys(O)
+
+
+var _objectKeys = Object.keys || function keys(O) {
+  return _objectKeysInternal(O, _enumBugKeys);
+};
+
+var _objectDps = _descriptors ? Object.defineProperties : function defineProperties(O, Properties) {
+  _anObject(O);
+  var keys = _objectKeys(Properties);
+  var length = keys.length;
+  var i = 0;
+  var P;
+  while (length > i) {
+    _objectDp.f(O, P = keys[i++], Properties[P]);
+  }return O;
+};
+
+var document$2 = _global.document;
+var _html = document$2 && document$2.documentElement;
+
+// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
+
+
+var IE_PROTO = _sharedKey('IE_PROTO');
+var Empty = function Empty() {/* empty */};
+var PROTOTYPE$1 = 'prototype';
+
+// Create object with fake `null` prototype: use iframe Object with cleared prototype
+var _createDict = function createDict() {
+  // Thrash, waste and sodomy: IE GC bug
+  var iframe = _domCreate('iframe');
+  var i = _enumBugKeys.length;
+  var lt = '<';
+  var gt = '>';
+  var iframeDocument;
+  iframe.style.display = 'none';
+  _html.appendChild(iframe);
+  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
+  // createDict = iframe.contentWindow.Object;
+  // html.removeChild(iframe);
+  iframeDocument = iframe.contentWindow.document;
+  iframeDocument.open();
+  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
+  iframeDocument.close();
+  _createDict = iframeDocument.F;
+  while (i--) {
+    delete _createDict[PROTOTYPE$1][_enumBugKeys[i]];
+  }return _createDict();
+};
+
+var _objectCreate = Object.create || function create(O, Properties) {
+  var result;
+  if (O !== null) {
+    Empty[PROTOTYPE$1] = _anObject(O);
+    result = new Empty();
+    Empty[PROTOTYPE$1] = null;
+    // add "__proto__" for Object.getPrototypeOf polyfill
+    result[IE_PROTO] = O;
+  } else result = _createDict();
+  return Properties === undefined ? result : _objectDps(result, Properties);
+};
+
+var def = _objectDp.f;
+
+var TAG$1 = _wks('toStringTag');
+
+var _setToStringTag = function _setToStringTag(it, tag, stat) {
+  if (it && !_has(it = stat ? it : it.prototype, TAG$1)) def(it, TAG$1, { configurable: true, value: tag });
+};
+
+var IteratorPrototype = {};
+
+// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
+_hide(IteratorPrototype, _wks('iterator'), function () {
+  return this;
+});
+
+var _iterCreate = function _iterCreate(Constructor, NAME, next) {
+  Constructor.prototype = _objectCreate(IteratorPrototype, { next: _propertyDesc(1, next) });
+  _setToStringTag(Constructor, NAME + ' Iterator');
+};
+
+// 7.1.13 ToObject(argument)
+
+var _toObject = function _toObject(it) {
+  return Object(_defined(it));
+};
+
+// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
+
+
+var IE_PROTO$2 = _sharedKey('IE_PROTO');
+var ObjectProto = Object.prototype;
+
+var _objectGpo = Object.getPrototypeOf || function (O) {
+  O = _toObject(O);
+  if (_has(O, IE_PROTO$2)) return O[IE_PROTO$2];
+  if (typeof O.constructor == 'function' && O instanceof O.constructor) {
+    return O.constructor.prototype;
+  }return O instanceof Object ? ObjectProto : null;
+};
+
+var ITERATOR = _wks('iterator');
+var BUGGY = !([].keys && 'next' in [].keys()); // Safari has buggy iterators w/o `next`
+var FF_ITERATOR = '@@iterator';
+var KEYS = 'keys';
+var VALUES = 'values';
+
+var returnThis = function returnThis() {
+  return this;
+};
+
+var _iterDefine = function _iterDefine(Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
+  _iterCreate(Constructor, NAME, next);
+  var getMethod = function getMethod(kind) {
+    if (!BUGGY && kind in proto) return proto[kind];
+    switch (kind) {
+      case KEYS:
+        return function keys() {
+          return new Constructor(this, kind);
+        };
+      case VALUES:
+        return function values() {
+          return new Constructor(this, kind);
+        };
+    }return function entries() {
+      return new Constructor(this, kind);
+    };
+  };
+  var TAG = NAME + ' Iterator';
+  var DEF_VALUES = DEFAULT == VALUES;
+  var VALUES_BUG = false;
+  var proto = Base.prototype;
+  var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];
+  var $default = $native || getMethod(DEFAULT);
+  var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined;
+  var $anyNative = NAME == 'Array' ? proto.entries || $native : $native;
+  var methods, key, IteratorPrototype;
+  // Fix native
+  if ($anyNative) {
+    IteratorPrototype = _objectGpo($anyNative.call(new Base()));
+    if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {
+      // Set @@toStringTag to native iterators
+      _setToStringTag(IteratorPrototype, TAG, true);
+      // fix for some old engines
+      if (!_library && typeof IteratorPrototype[ITERATOR] != 'function') _hide(IteratorPrototype, ITERATOR, returnThis);
+    }
+  }
+  // fix Array#{values, @@iterator}.name in V8 / FF
+  if (DEF_VALUES && $native && $native.name !== VALUES) {
+    VALUES_BUG = true;
+    $default = function values() {
+      return $native.call(this);
+    };
+  }
+  // Define iterator
+  if ((!_library || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {
+    _hide(proto, ITERATOR, $default);
+  }
+  // Plug for library
+  _iterators[NAME] = $default;
+  _iterators[TAG] = returnThis;
+  if (DEFAULT) {
+    methods = {
+      values: DEF_VALUES ? $default : getMethod(VALUES),
+      keys: IS_SET ? $default : getMethod(KEYS),
+      entries: $entries
+    };
+    if (FORCED) for (key in methods) {
+      if (!(key in proto)) _redefine(proto, key, methods[key]);
+    } else _export(_export.P + _export.F * (BUGGY || VALUES_BUG), NAME, methods);
+  }
+  return methods;
+};
+
+var $at = _stringAt(true);
+
+// 21.1.3.27 String.prototype[@@iterator]()
+_iterDefine(String, 'String', function (iterated) {
+  this._t = String(iterated); // target
+  this._i = 0; // next index
+  // 21.1.5.2.1 %StringIteratorPrototype%.next()
+}, function () {
+  var O = this._t;
+  var index = this._i;
+  var point;
+  if (index >= O.length) return { value: undefined, done: true };
+  point = $at(O, index);
+  this._i += point.length;
+  return { value: point, done: false };
+});
+
+// 22.1.3.31 Array.prototype[@@unscopables]
+var UNSCOPABLES = _wks('unscopables');
+var ArrayProto = Array.prototype;
+if (ArrayProto[UNSCOPABLES] == undefined) _hide(ArrayProto, UNSCOPABLES, {});
+var _addToUnscopables = function _addToUnscopables(key) {
+  ArrayProto[UNSCOPABLES][key] = true;
+};
+
+var _iterStep = function _iterStep(done, value) {
+  return { value: value, done: !!done };
+};
+
+// 22.1.3.4 Array.prototype.entries()
+// 22.1.3.13 Array.prototype.keys()
+// 22.1.3.29 Array.prototype.values()
+// 22.1.3.30 Array.prototype[@@iterator]()
+var es6_array_iterator = _iterDefine(Array, 'Array', function (iterated, kind) {
+  this._t = _toIobject(iterated); // target
+  this._i = 0; // next index
+  this._k = kind; // kind
+  // 22.1.5.2.1 %ArrayIteratorPrototype%.next()
+}, function () {
+  var O = this._t;
+  var kind = this._k;
+  var index = this._i++;
+  if (!O || index >= O.length) {
+    this._t = undefined;
+    return _iterStep(1);
+  }
+  if (kind == 'keys') return _iterStep(0, index);
+  if (kind == 'values') return _iterStep(0, O[index]);
+  return _iterStep(0, [index, O[index]]);
+}, 'values');
+
+// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
+_iterators.Arguments = _iterators.Array;
+
+_addToUnscopables('keys');
+_addToUnscopables('values');
+_addToUnscopables('entries');
+
+var ITERATOR$1 = _wks('iterator');
+var TO_STRING_TAG = _wks('toStringTag');
+var ArrayValues = _iterators.Array;
+
+var DOMIterables = {
+  CSSRuleList: true, // TODO: Not spec compliant, should be false.
+  CSSStyleDeclaration: false,
+  CSSValueList: false,
+  ClientRectList: false,
+  DOMRectList: false,
+  DOMStringList: false,
+  DOMTokenList: true,
+  DataTransferItemList: false,
+  FileList: false,
+  HTMLAllCollection: false,
+  HTMLCollection: false,
+  HTMLFormElement: false,
+  HTMLSelectElement: false,
+  MediaList: true, // TODO: Not spec compliant, should be false.
+  MimeTypeArray: false,
+  NamedNodeMap: false,
+  NodeList: true,
+  PaintRequestList: false,
+  Plugin: false,
+  PluginArray: false,
+  SVGLengthList: false,
+  SVGNumberList: false,
+  SVGPathSegList: false,
+  SVGPointList: false,
+  SVGStringList: false,
+  SVGTransformList: false,
+  SourceBufferList: false,
+  StyleSheetList: true, // TODO: Not spec compliant, should be false.
+  TextTrackCueList: false,
+  TextTrackList: false,
+  TouchList: false
+};
+
+for (var collections = _objectKeys(DOMIterables), i = 0; i < collections.length; i++) {
+  var NAME = collections[i];
+  var explicit = DOMIterables[NAME];
+  var Collection = _global[NAME];
+  var proto = Collection && Collection.prototype;
+  var key;
+  if (proto) {
+    if (!proto[ITERATOR$1]) _hide(proto, ITERATOR$1, ArrayValues);
+    if (!proto[TO_STRING_TAG]) _hide(proto, TO_STRING_TAG, NAME);
+    _iterators[NAME] = ArrayValues;
+    if (explicit) for (key in es6_array_iterator) {
+      if (!proto[key]) _redefine(proto, key, es6_array_iterator[key], true);
+    }
+  }
+}
+
+var _redefineAll = function _redefineAll(target, src, safe) {
+  for (var key in src) {
+    _redefine(target, key, src[key], safe);
+  }return target;
+};
+
+var _anInstance = function _anInstance(it, Constructor, name, forbiddenField) {
+  if (!(it instanceof Constructor) || forbiddenField !== undefined && forbiddenField in it) {
+    throw TypeError(name + ': incorrect invocation!');
+  }return it;
+};
+
+// call something on iterator step with safe closing on error
+
+var _iterCall = function _iterCall(iterator, fn, value, entries) {
+  try {
+    return entries ? fn(_anObject(value)[0], value[1]) : fn(value);
+    // 7.4.6 IteratorClose(iterator, completion)
+  } catch (e) {
+    var ret = iterator['return'];
+    if (ret !== undefined) _anObject(ret.call(iterator));
+    throw e;
+  }
+};
+
+// check on default Array iterator
+
+var ITERATOR$2 = _wks('iterator');
+var ArrayProto$1 = Array.prototype;
+
+var _isArrayIter = function _isArrayIter(it) {
+  return it !== undefined && (_iterators.Array === it || ArrayProto$1[ITERATOR$2] === it);
+};
+
+var ITERATOR$3 = _wks('iterator');
+
+var core_getIteratorMethod = _core.getIteratorMethod = function (it) {
+  if (it != undefined) return it[ITERATOR$3] || it['@@iterator'] || _iterators[_classof(it)];
+};
+
+var _forOf = createCommonjsModule(function (module) {
+  var BREAK = {};
+  var RETURN = {};
+  var exports = module.exports = function (iterable, entries, fn, that, ITERATOR) {
+    var iterFn = ITERATOR ? function () {
+      return iterable;
+    } : core_getIteratorMethod(iterable);
+    var f = _ctx(fn, that, entries ? 2 : 1);
+    var index = 0;
+    var length, step, iterator, result;
+    if (typeof iterFn != 'function') throw TypeError(iterable + ' is not iterable!');
+    // fast case for arrays with default iterator
+    if (_isArrayIter(iterFn)) for (length = _toLength(iterable.length); length > index; index++) {
+      result = entries ? f(_anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
+      if (result === BREAK || result === RETURN) return result;
+    } else for (iterator = iterFn.call(iterable); !(step = iterator.next()).done;) {
+      result = _iterCall(iterator, f, step.value, entries);
+      if (result === BREAK || result === RETURN) return result;
+    }
+  };
+  exports.BREAK = BREAK;
+  exports.RETURN = RETURN;
+});
+
+var SPECIES = _wks('species');
+
+var _setSpecies = function _setSpecies(KEY) {
+  var C = _global[KEY];
+  if (_descriptors && C && !C[SPECIES]) _objectDp.f(C, SPECIES, {
+    configurable: true,
+    get: function get() {
+      return this;
+    }
+  });
+};
+
+var _meta = createCommonjsModule(function (module) {
+  var META = _uid('meta');
+
+  var setDesc = _objectDp.f;
+  var id = 0;
+  var isExtensible = Object.isExtensible || function () {
+    return true;
+  };
+  var FREEZE = !_fails(function () {
+    return isExtensible(Object.preventExtensions({}));
+  });
+  var setMeta = function setMeta(it) {
+    setDesc(it, META, { value: {
+        i: 'O' + ++id, // object ID
+        w: {} // weak collections IDs
+      } });
+  };
+  var fastKey = function fastKey(it, create) {
+    // return primitive with prefix
+    if (!_isObject(it)) return (typeof it === 'undefined' ? 'undefined' : _typeof(it)) == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
+    if (!_has(it, META)) {
+      // can't set metadata to uncaught frozen object
+      if (!isExtensible(it)) return 'F';
+      // not necessary to add metadata
+      if (!create) return 'E';
+      // add missing metadata
+      setMeta(it);
+      // return object ID
+    }return it[META].i;
+  };
+  var getWeak = function getWeak(it, create) {
+    if (!_has(it, META)) {
+      // can't set metadata to uncaught frozen object
+      if (!isExtensible(it)) return true;
+      // not necessary to add metadata
+      if (!create) return false;
+      // add missing metadata
+      setMeta(it);
+      // return hash weak collections IDs
+    }return it[META].w;
+  };
+  // add metadata on freeze-family methods calling
+  var onFreeze = function onFreeze(it) {
+    if (FREEZE && meta.NEED && isExtensible(it) && !_has(it, META)) setMeta(it);
+    return it;
+  };
+  var meta = module.exports = {
+    KEY: META,
+    NEED: false,
+    fastKey: fastKey,
+    getWeak: getWeak,
+    onFreeze: onFreeze
+  };
+});
+
+var _meta_1 = _meta.KEY;
+var _meta_2 = _meta.NEED;
+var _meta_3 = _meta.fastKey;
+var _meta_4 = _meta.getWeak;
+var _meta_5 = _meta.onFreeze;
+
+var _validateCollection = function _validateCollection(it, TYPE) {
+  if (!_isObject(it) || it._t !== TYPE) throw TypeError('Incompatible receiver, ' + TYPE + ' required!');
+  return it;
+};
+
+var dP$1 = _objectDp.f;
+
+var fastKey = _meta.fastKey;
+
+var SIZE = _descriptors ? '_s' : 'size';
+
+var getEntry = function getEntry(that, key) {
+  // fast case
+  var index = fastKey(key);
+  var entry;
+  if (index !== 'F') return that._i[index];
+  // frozen object case
+  for (entry = that._f; entry; entry = entry.n) {
+    if (entry.k == key) return entry;
+  }
+};
+
+var _collectionStrong = {
+  getConstructor: function getConstructor(wrapper, NAME, IS_MAP, ADDER) {
+    var C = wrapper(function (that, iterable) {
+      _anInstance(that, C, NAME, '_i');
+      that._t = NAME; // collection type
+      that._i = _objectCreate(null); // index
+      that._f = undefined; // first entry
+      that._l = undefined; // last entry
+      that[SIZE] = 0; // size
+      if (iterable != undefined) _forOf(iterable, IS_MAP, that[ADDER], that);
+    });
+    _redefineAll(C.prototype, {
+      // 23.1.3.1 Map.prototype.clear()
+      // 23.2.3.2 Set.prototype.clear()
+      clear: function clear() {
+        for (var that = _validateCollection(this, NAME), data = that._i, entry = that._f; entry; entry = entry.n) {
+          entry.r = true;
+          if (entry.p) entry.p = entry.p.n = undefined;
+          delete data[entry.i];
+        }
+        that._f = that._l = undefined;
+        that[SIZE] = 0;
+      },
+      // 23.1.3.3 Map.prototype.delete(key)
+      // 23.2.3.4 Set.prototype.delete(value)
+      'delete': function _delete(key) {
+        var that = _validateCollection(this, NAME);
+        var entry = getEntry(that, key);
+        if (entry) {
+          var next = entry.n;
+          var prev = entry.p;
+          delete that._i[entry.i];
+          entry.r = true;
+          if (prev) prev.n = next;
+          if (next) next.p = prev;
+          if (that._f == entry) that._f = next;
+          if (that._l == entry) that._l = prev;
+          that[SIZE]--;
+        }return !!entry;
+      },
+      // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
+      // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
+      forEach: function forEach(callbackfn /* , that = undefined */) {
+        _validateCollection(this, NAME);
+        var f = _ctx(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3);
+        var entry;
+        while (entry = entry ? entry.n : this._f) {
+          f(entry.v, entry.k, this);
+          // revert to the last existing entry
+          while (entry && entry.r) {
+            entry = entry.p;
+          }
+        }
+      },
+      // 23.1.3.7 Map.prototype.has(key)
+      // 23.2.3.7 Set.prototype.has(value)
+      has: function has(key) {
+        return !!getEntry(_validateCollection(this, NAME), key);
+      }
+    });
+    if (_descriptors) dP$1(C.prototype, 'size', {
+      get: function get() {
+        return _validateCollection(this, NAME)[SIZE];
+      }
+    });
+    return C;
+  },
+  def: function def(that, key, value) {
+    var entry = getEntry(that, key);
+    var prev, index;
+    // change existing entry
+    if (entry) {
+      entry.v = value;
+      // create new entry
+    } else {
+      that._l = entry = {
+        i: index = fastKey(key, true), // <- index
+        k: key, // <- key
+        v: value, // <- value
+        p: prev = that._l, // <- previous entry
+        n: undefined, // <- next entry
+        r: false // <- removed
+      };
+      if (!that._f) that._f = entry;
+      if (prev) prev.n = entry;
+      that[SIZE]++;
+      // add to index
+      if (index !== 'F') that._i[index] = entry;
+    }return that;
+  },
+  getEntry: getEntry,
+  setStrong: function setStrong(C, NAME, IS_MAP) {
+    // add .keys, .values, .entries, [@@iterator]
+    // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11
+    _iterDefine(C, NAME, function (iterated, kind) {
+      this._t = _validateCollection(iterated, NAME); // target
+      this._k = kind; // kind
+      this._l = undefined; // previous
+    }, function () {
+      var that = this;
+      var kind = that._k;
+      var entry = that._l;
+      // revert to the last existing entry
+      while (entry && entry.r) {
+        entry = entry.p;
+      } // get next entry
+      if (!that._t || !(that._l = entry = entry ? entry.n : that._t._f)) {
+        // or finish the iteration
+        that._t = undefined;
+        return _iterStep(1);
+      }
+      // return step by kind
+      if (kind == 'keys') return _iterStep(0, entry.k);
+      if (kind == 'values') return _iterStep(0, entry.v);
+      return _iterStep(0, [entry.k, entry.v]);
+    }, IS_MAP ? 'entries' : 'values', !IS_MAP, true);
+
+    // add [@@species], 23.1.2.2, 23.2.2.2
+    _setSpecies(NAME);
+  }
+};
+
+var ITERATOR$4 = _wks('iterator');
+var SAFE_CLOSING = false;
+
+try {
+  var riter = [7][ITERATOR$4]();
+  riter['return'] = function () {
+    SAFE_CLOSING = true;
+  };
+  // eslint-disable-next-line no-throw-literal
+  
+} catch (e) {/* empty */}
+
+var _iterDetect = function _iterDetect(exec, skipClosing) {
+  if (!skipClosing && !SAFE_CLOSING) return false;
+  var safe = false;
+  try {
+    var arr = [7];
+    var iter = arr[ITERATOR$4]();
+    iter.next = function () {
+      return { done: safe = true };
+    };
+    arr[ITERATOR$4] = function () {
+      return iter;
+    };
+    exec(arr);
+  } catch (e) {/* empty */}
+  return safe;
+};
+
+var setPrototypeOf$2 = _setProto.set;
+var _inheritIfRequired = function _inheritIfRequired(that, target, C) {
+  var S = target.constructor;
+  var P;
+  if (S !== C && typeof S == 'function' && (P = S.prototype) !== C.prototype && _isObject(P) && setPrototypeOf$2) {
+    setPrototypeOf$2(that, P);
+  }return that;
+};
+
+var _collection = function _collection(NAME, wrapper, methods, common, IS_MAP, IS_WEAK) {
+  var Base = _global[NAME];
+  var C = Base;
+  var ADDER = IS_MAP ? 'set' : 'add';
+  var proto = C && C.prototype;
+  var O = {};
+  var fixMethod = function fixMethod(KEY) {
+    var fn = proto[KEY];
+    _redefine(proto, KEY, KEY == 'delete' ? function (a) {
+      return IS_WEAK && !_isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);
+    } : KEY == 'has' ? function has(a) {
+      return IS_WEAK && !_isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);
+    } : KEY == 'get' ? function get(a) {
+      return IS_WEAK && !_isObject(a) ? undefined : fn.call(this, a === 0 ? 0 : a);
+    } : KEY == 'add' ? function add(a) {
+      fn.call(this, a === 0 ? 0 : a);return this;
+    } : function set(a, b) {
+      fn.call(this, a === 0 ? 0 : a, b);return this;
+    });
+  };
+  if (typeof C != 'function' || !(IS_WEAK || proto.forEach && !_fails(function () {
+    new C().entries().next();
+  }))) {
+    // create collection constructor
+    C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);
+    _redefineAll(C.prototype, methods);
+    _meta.NEED = true;
+  } else {
+    var instance = new C();
+    // early implementations not supports chaining
+    var HASNT_CHAINING = instance[ADDER](IS_WEAK ? {} : -0, 1) != instance;
+    // V8 ~  Chromium 40- weak-collections throws on primitives, but should return false
+    var THROWS_ON_PRIMITIVES = _fails(function () {
+      instance.has(1);
+    });
+    // most early implementations doesn't supports iterables, most modern - not close it correctly
+    var ACCEPT_ITERABLES = _iterDetect(function (iter) {
+      new C(iter);
+    }); // eslint-disable-line no-new
+    // for early implementations -0 and +0 not the same
+    var BUGGY_ZERO = !IS_WEAK && _fails(function () {
+      // V8 ~ Chromium 42- fails only with 5+ elements
+      var $instance = new C();
+      var index = 5;
+      while (index--) {
+        $instance[ADDER](index, index);
+      }return !$instance.has(-0);
+    });
+    if (!ACCEPT_ITERABLES) {
+      C = wrapper(function (target, iterable) {
+        _anInstance(target, C, NAME);
+        var that = _inheritIfRequired(new Base(), target, C);
+        if (iterable != undefined) _forOf(iterable, IS_MAP, that[ADDER], that);
+        return that;
+      });
+      C.prototype = proto;
+      proto.constructor = C;
+    }
+    if (THROWS_ON_PRIMITIVES || BUGGY_ZERO) {
+      fixMethod('delete');
+      fixMethod('has');
+      IS_MAP && fixMethod('get');
+    }
+    if (BUGGY_ZERO || HASNT_CHAINING) fixMethod(ADDER);
+    // weak collections should not contains .clear method
+    if (IS_WEAK && proto.clear) delete proto.clear;
+  }
+
+  _setToStringTag(C, NAME);
+
+  O[NAME] = C;
+  _export(_export.G + _export.W + _export.F * (C != Base), O);
+
+  if (!IS_WEAK) common.setStrong(C, NAME, IS_MAP);
+
+  return C;
+};
+
+var SET = 'Set';
+
+// 23.2 Set Objects
+var es6_set = _collection(SET, function (get) {
+  return function Set() {
+    return get(this, arguments.length > 0 ? arguments[0] : undefined);
+  };
+}, {
+  // 23.2.3.1 Set.prototype.add(value)
+  add: function add(value) {
+    return _collectionStrong.def(_validateCollection(this, SET), value = value === 0 ? 0 : value, value);
+  }
+}, _collectionStrong);
+
+var _arrayFromIterable = function _arrayFromIterable(iter, ITERATOR) {
+  var result = [];
+  _forOf(iter, false, result.push, result, ITERATOR);
+  return result;
+};
+
+// https://github.com/DavidBruant/Map-Set.prototype.toJSON
+
+
+var _collectionToJson = function _collectionToJson(NAME) {
+  return function toJSON() {
+    if (_classof(this) != NAME) throw TypeError(NAME + "#toJSON isn't generic");
+    return _arrayFromIterable(this);
+  };
+};
+
+// https://github.com/DavidBruant/Map-Set.prototype.toJSON
+
+
+_export(_export.P + _export.R, 'Set', { toJSON: _collectionToJson('Set') });
+
+// https://tc39.github.io/proposal-setmap-offrom/
+
+
+var _setCollectionOf = function _setCollectionOf(COLLECTION) {
+  _export(_export.S, COLLECTION, { of: function of() {
+      var length = arguments.length;
+      var A = new Array(length);
+      while (length--) {
+        A[length] = arguments[length];
+      }return new this(A);
+    } });
+};
+
+// https://tc39.github.io/proposal-setmap-offrom/#sec-set.of
+_setCollectionOf('Set');
+
+// https://tc39.github.io/proposal-setmap-offrom/
+
+
+var _setCollectionFrom = function _setCollectionFrom(COLLECTION) {
+  _export(_export.S, COLLECTION, { from: function from(source /* , mapFn, thisArg */) {
+      var mapFn = arguments[1];
+      var mapping, A, n, cb;
+      _aFunction(this);
+      mapping = mapFn !== undefined;
+      if (mapping) _aFunction(mapFn);
+      if (source == undefined) return new this();
+      A = [];
+      if (mapping) {
+        n = 0;
+        cb = _ctx(mapFn, arguments[2], 2);
+        _forOf(source, false, function (nextItem) {
+          A.push(cb(nextItem, n++));
+        });
+      } else {
+        _forOf(source, false, A.push, A);
+      }
+      return new this(A);
+    } });
+};
+
+// https://tc39.github.io/proposal-setmap-offrom/#sec-set.from
+_setCollectionFrom('Set');
+
+var set$1 = _core.Set;
+
+var MAP = 'Map';
+
+// 23.1 Map Objects
+var es6_map = _collection(MAP, function (get) {
+  return function Map() {
+    return get(this, arguments.length > 0 ? arguments[0] : undefined);
+  };
+}, {
+  // 23.1.3.6 Map.prototype.get(key)
+  get: function get(key) {
+    var entry = _collectionStrong.getEntry(_validateCollection(this, MAP), key);
+    return entry && entry.v;
+  },
+  // 23.1.3.9 Map.prototype.set(key, value)
+  set: function set(key, value) {
+    return _collectionStrong.def(_validateCollection(this, MAP), key === 0 ? 0 : key, value);
+  }
+}, _collectionStrong, true);
+
+// https://github.com/DavidBruant/Map-Set.prototype.toJSON
+
+
+_export(_export.P + _export.R, 'Map', { toJSON: _collectionToJson('Map') });
+
+// https://tc39.github.io/proposal-setmap-offrom/#sec-map.of
+_setCollectionOf('Map');
+
+// https://tc39.github.io/proposal-setmap-offrom/#sec-map.from
+_setCollectionFrom('Map');
+
+var map = _core.Map;
+
+// 7.2.2 IsArray(argument)
+
+var _isArray = Array.isArray || function isArray(arg) {
+  return _cof(arg) == 'Array';
+};
+
+var SPECIES$1 = _wks('species');
+
+var _arraySpeciesConstructor = function _arraySpeciesConstructor(original) {
+  var C;
+  if (_isArray(original)) {
+    C = original.constructor;
+    // cross-realm fallback
+    if (typeof C == 'function' && (C === Array || _isArray(C.prototype))) C = undefined;
+    if (_isObject(C)) {
+      C = C[SPECIES$1];
+      if (C === null) C = undefined;
+    }
+  }return C === undefined ? Array : C;
+};
+
+// 9.4.2.3 ArraySpeciesCreate(originalArray, length)
+
+
+var _arraySpeciesCreate = function _arraySpeciesCreate(original, length) {
+  return new (_arraySpeciesConstructor(original))(length);
+};
+
+// 0 -> Array#forEach
+// 1 -> Array#map
+// 2 -> Array#filter
+// 3 -> Array#some
+// 4 -> Array#every
+// 5 -> Array#find
+// 6 -> Array#findIndex
+
+
+var _arrayMethods = function _arrayMethods(TYPE, $create) {
+  var IS_MAP = TYPE == 1;
+  var IS_FILTER = TYPE == 2;
+  var IS_SOME = TYPE == 3;
+  var IS_EVERY = TYPE == 4;
+  var IS_FIND_INDEX = TYPE == 6;
+  var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
+  var create = $create || _arraySpeciesCreate;
+  return function ($this, callbackfn, that) {
+    var O = _toObject($this);
+    var self = _iobject(O);
+    var f = _ctx(callbackfn, that, 3);
+    var length = _toLength(self.length);
+    var index = 0;
+    var result = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined;
+    var val, res;
+    for (; length > index; index++) {
+      if (NO_HOLES || index in self) {
+        val = self[index];
+        res = f(val, index, O);
+        if (TYPE) {
+          if (IS_MAP) result[index] = res; // map
+          else if (res) switch (TYPE) {
+              case 3:
+                return true; // some
+              case 5:
+                return val; // find
+              case 6:
+                return index; // findIndex
+              case 2:
+                result.push(val); // filter
+            } else if (IS_EVERY) return false; // every
+        }
+      }
+    }return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;
+  };
+};
+
+var f$3 = Object.getOwnPropertySymbols;
+
+var _objectGops = {
+	f: f$3
+};
+
+// 19.1.2.1 Object.assign(target, source, ...)
+
+
+var $assign = Object.assign;
+
+// should work with symbols and should have deterministic property order (V8 bug)
+var _objectAssign = !$assign || _fails(function () {
+  var A = {};
+  var B = {};
+  // eslint-disable-next-line no-undef
+  var S = Symbol();
+  var K = 'abcdefghijklmnopqrst';
+  A[S] = 7;
+  K.split('').forEach(function (k) {
+    B[k] = k;
+  });
+  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;
+}) ? function assign(target, source) {
+  // eslint-disable-line no-unused-vars
+  var T = _toObject(target);
+  var aLen = arguments.length;
+  var index = 1;
+  var getSymbols = _objectGops.f;
+  var isEnum = _objectPie.f;
+  while (aLen > index) {
+    var S = _iobject(arguments[index++]);
+    var keys = getSymbols ? _objectKeys(S).concat(getSymbols(S)) : _objectKeys(S);
+    var length = keys.length;
+    var j = 0;
+    var key;
+    while (length > j) {
+      if (isEnum.call(S, key = keys[j++])) T[key] = S[key];
+    }
+  }return T;
+} : $assign;
+
+var getWeak = _meta.getWeak;
+
+var arrayFind = _arrayMethods(5);
+var arrayFindIndex = _arrayMethods(6);
+var id$1 = 0;
+
+// fallback for uncaught frozen keys
+var uncaughtFrozenStore = function uncaughtFrozenStore(that) {
+  return that._l || (that._l = new UncaughtFrozenStore());
+};
+var UncaughtFrozenStore = function UncaughtFrozenStore() {
+  this.a = [];
+};
+var findUncaughtFrozen = function findUncaughtFrozen(store, key) {
+  return arrayFind(store.a, function (it) {
+    return it[0] === key;
+  });
+};
+UncaughtFrozenStore.prototype = {
+  get: function get(key) {
+    var entry = findUncaughtFrozen(this, key);
+    if (entry) return entry[1];
+  },
+  has: function has(key) {
+    return !!findUncaughtFrozen(this, key);
+  },
+  set: function set(key, value) {
+    var entry = findUncaughtFrozen(this, key);
+    if (entry) entry[1] = value;else this.a.push([key, value]);
+  },
+  'delete': function _delete(key) {
+    var index = arrayFindIndex(this.a, function (it) {
+      return it[0] === key;
+    });
+    if (~index) this.a.splice(index, 1);
+    return !!~index;
+  }
+};
+
+var _collectionWeak = {
+  getConstructor: function getConstructor(wrapper, NAME, IS_MAP, ADDER) {
+    var C = wrapper(function (that, iterable) {
+      _anInstance(that, C, NAME, '_i');
+      that._t = NAME; // collection type
+      that._i = id$1++; // collection id
+      that._l = undefined; // leak store for uncaught frozen objects
+      if (iterable != undefined) _forOf(iterable, IS_MAP, that[ADDER], that);
+    });
+    _redefineAll(C.prototype, {
+      // 23.3.3.2 WeakMap.prototype.delete(key)
+      // 23.4.3.3 WeakSet.prototype.delete(value)
+      'delete': function _delete(key) {
+        if (!_isObject(key)) return false;
+        var data = getWeak(key);
+        if (data === true) return uncaughtFrozenStore(_validateCollection(this, NAME))['delete'](key);
+        return data && _has(data, this._i) && delete data[this._i];
+      },
+      // 23.3.3.4 WeakMap.prototype.has(key)
+      // 23.4.3.4 WeakSet.prototype.has(value)
+      has: function has(key) {
+        if (!_isObject(key)) return false;
+        var data = getWeak(key);
+        if (data === true) return uncaughtFrozenStore(_validateCollection(this, NAME)).has(key);
+        return data && _has(data, this._i);
+      }
+    });
+    return C;
+  },
+  def: function def(that, key, value) {
+    var data = getWeak(_anObject(key), true);
+    if (data === true) uncaughtFrozenStore(that).set(key, value);else data[that._i] = value;
+    return that;
+  },
+  ufstore: uncaughtFrozenStore
+};
+
+var es6_weakMap = createCommonjsModule(function (module) {
+  var each = _arrayMethods(0);
+
+  var NATIVE_WEAK_MAP = _validateCollection;
+  var IS_IE11 = !_global.ActiveXObject && 'ActiveXObject' in _global;
+  var WEAK_MAP = 'WeakMap';
+  var getWeak = _meta.getWeak;
+  var isExtensible = Object.isExtensible;
+  var uncaughtFrozenStore = _collectionWeak.ufstore;
+  var InternalMap;
+
+  var wrapper = function wrapper(get) {
+    return function WeakMap() {
+      return get(this, arguments.length > 0 ? arguments[0] : undefined);
+    };
+  };
+
+  var methods = {
+    // 23.3.3.3 WeakMap.prototype.get(key)
+    get: function get(key) {
+      if (_isObject(key)) {
+        var data = getWeak(key);
+        if (data === true) return uncaughtFrozenStore(_validateCollection(this, WEAK_MAP)).get(key);
+        return data ? data[this._i] : undefined;
+      }
+    },
+    // 23.3.3.5 WeakMap.prototype.set(key, value)
+    set: function set(key, value) {
+      return _collectionWeak.def(_validateCollection(this, WEAK_MAP), key, value);
+    }
+  };
+
+  // 23.3 WeakMap Objects
+  var $WeakMap = module.exports = _collection(WEAK_MAP, wrapper, methods, _collectionWeak, true, true);
+
+  // IE11 WeakMap frozen keys fix
+  if (NATIVE_WEAK_MAP && IS_IE11) {
+    InternalMap = _collectionWeak.getConstructor(wrapper, WEAK_MAP);
+    _objectAssign(InternalMap.prototype, methods);
+    _meta.NEED = true;
+    each(['delete', 'has', 'get', 'set'], function (key) {
+      var proto = $WeakMap.prototype;
+      var method = proto[key];
+      _redefine(proto, key, function (a, b) {
+        // store frozen objects on internal weakmap shim
+        if (_isObject(a) && !isExtensible(a)) {
+          if (!this._f) this._f = new InternalMap();
+          var result = this._f[key](a, b);
+          return key == 'set' ? this : result;
+          // store all the rest on native weakmap
+        }return method.call(this, a, b);
+      });
+    });
+  }
+});
+
+// https://tc39.github.io/proposal-setmap-offrom/#sec-weakmap.of
+_setCollectionOf('WeakMap');
+
+// https://tc39.github.io/proposal-setmap-offrom/#sec-weakmap.from
+_setCollectionFrom('WeakMap');
+
+var weakMap = _core.WeakMap;
+
+var _createProperty = function _createProperty(object, index, value) {
+  if (index in object) _objectDp.f(object, index, _propertyDesc(0, value));else object[index] = value;
+};
+
+_export(_export.S + _export.F * !_iterDetect(function (iter) {
+  
+}), 'Array', {
+  // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)
+  from: function from(arrayLike /* , mapfn = undefined, thisArg = undefined */) {
+    var O = _toObject(arrayLike);
+    var C = typeof this == 'function' ? this : Array;
+    var aLen = arguments.length;
+    var mapfn = aLen > 1 ? arguments[1] : undefined;
+    var mapping = mapfn !== undefined;
+    var index = 0;
+    var iterFn = core_getIteratorMethod(O);
+    var length, result, step, iterator;
+    if (mapping) mapfn = _ctx(mapfn, aLen > 2 ? arguments[2] : undefined, 2);
+    // if object isn't iterable or it's array with default iterator - use simple case
+    if (iterFn != undefined && !(C == Array && _isArrayIter(iterFn))) {
+      for (iterator = iterFn.call(O), result = new C(); !(step = iterator.next()).done; index++) {
+        _createProperty(result, index, mapping ? _iterCall(iterator, mapfn, [step.value, index], true) : step.value);
+      }
+    } else {
+      length = _toLength(O.length);
+      for (result = new C(length); length > index; index++) {
+        _createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]);
+      }
+    }
+    result.length = index;
+    return result;
+  }
+});
+
+var from$1 = _core.Array.from;
+
+var reservedTagList = new Set(['annotation-xml', 'color-profile', 'font-face', 'font-face-src', 'font-face-uri', 'font-face-format', 'font-face-name', 'missing-glyph']);
+
+/**
+ * @param {string} localName
+ * @returns {boolean}
+ */
+function isValidCustomElementName(localName) {
+  var reserved = reservedTagList.has(localName);
+  var validForm = /^[a-z][.0-9_a-z]*-[\-.0-9_a-z]*$/.test(localName);
+  return !reserved && validForm;
+}
+
+/**
+ * @private
+ * @param {!Node} node
+ * @return {boolean}
+ */
+function isConnected(node) {
+  // Use `Node#isConnected`, if defined.
+  var nativeValue = node.isConnected;
+  if (nativeValue !== undefined) {
+    return nativeValue;
+  }
+
+  /** @type {?Node|undefined} */
+  var current = node;
+  while (current && !(current.__CE_isImportDocument || current instanceof Document)) {
+    current = current.parentNode || (window.ShadowRoot && current instanceof ShadowRoot ? current.host : undefined);
+  }
+  return !!(current && (current.__CE_isImportDocument || current instanceof Document));
+}
+
+/**
+ * @param {!Node} root
+ * @param {!Node} start
+ * @return {?Node}
+ */
+function nextSiblingOrAncestorSibling(root, start) {
+  var node = start;
+  while (node && node !== root && !node.nextSibling) {
+    node = node.parentNode;
+  }
+  return !node || node === root ? null : node.nextSibling;
+}
+
+/**
+ * @param {!Node} root
+ * @param {!Node} start
+ * @return {?Node}
+ */
+function nextNode(root, start) {
+  return start.firstChild ? start.firstChild : nextSiblingOrAncestorSibling(root, start);
+}
+
+/**
+ * @param {!Node} root
+ * @param {!function(!Element)} callback
+ * @param {!Set<Node>=} visitedImports
+ */
+function walkDeepDescendantElements(root, callback) {
+  var visitedImports = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new Set();
+
+  var node = root;
+  while (node) {
+    if (node.nodeType === Node.ELEMENT_NODE) {
+      var element = /** @type {!Element} */node;
+
+      callback(element);
+
+      var localName = element.localName;
+      if (localName === 'link' && element.getAttribute('rel') === 'import') {
+        // If this import (polyfilled or not) has it's root node available,
+        // walk it.
+        var importNode = /** @type {!Node} */element.import;
+        if (importNode instanceof Node && !visitedImports.has(importNode)) {
+          // Prevent multiple walks of the same import root.
+          visitedImports.add(importNode);
+
+          for (var child = importNode.firstChild; child; child = child.nextSibling) {
+            walkDeepDescendantElements(child, callback, visitedImports);
+          }
+        }
+
+        // Ignore descendants of import links to prevent attempting to walk the
+        // elements created by the HTML Imports polyfill that we just walked
+        // above.
+        node = nextSiblingOrAncestorSibling(root, element);
+        continue;
+      } else if (localName === 'template') {
+        // Ignore descendants of templates. There shouldn't be any descendants
+        // because they will be moved into `.content` during construction in
+        // browsers that support template but, in case they exist and are still
+        // waiting to be moved by a polyfill, they will be ignored.
+        node = nextSiblingOrAncestorSibling(root, element);
+        continue;
+      }
+
+      // Walk shadow roots.
+      var shadowRoot = element.__CE_shadowRoot;
+      if (shadowRoot) {
+        for (var _child = shadowRoot.firstChild; _child; _child = _child.nextSibling) {
+          walkDeepDescendantElements(_child, callback, visitedImports);
+        }
+      }
+    }
+
+    node = nextNode(root, node);
+  }
+}
+
+/**
+ * Used to suppress Closure's "Modifying the prototype is only allowed if the
+ * constructor is in the same scope" warning without using
+ * `@suppress {newCheckTypes, duplicate}` because `newCheckTypes` is too broad.
+ *
+ * @param {!Object} destination
+ * @param {string} name
+ * @param {*} value
+ */
+function setPropertyUnchecked(destination, name, value) {
+  destination[name] = value;
+}
+
+/**
+ * @enum {number}
+ */
+var CustomElementState = {
+  custom: 1,
+  failed: 2
+};
+
+var CustomElementInternals = function () {
+  function CustomElementInternals() {
+    classCallCheck(this, CustomElementInternals);
+
+    /** @type {!Map<string, !CustomElementDefinition>} */
+    this._localNameToDefinition = new Map();
+
+    /** @type {!Map<!Function, !CustomElementDefinition>} */
+    this._constructorToDefinition = new Map();
+
+    /** @type {!Array<!function(!Node)>} */
+    this._patches = [];
+
+    /** @type {boolean} */
+    this._hasPatches = false;
+  }
+
+  /**
+   * @param {string} localName
+   * @param {!CustomElementDefinition} definition
+   */
+
+
+  createClass(CustomElementInternals, [{
+    key: 'setDefinition',
+    value: function setDefinition(localName, definition) {
+      this._localNameToDefinition.set(localName, definition);
+      this._constructorToDefinition.set(definition.constructor, definition);
+    }
+
+    /**
+     * @param {string} localName
+     * @return {!CustomElementDefinition|undefined}
+     */
+
+  }, {
+    key: 'localNameToDefinition',
+    value: function localNameToDefinition(localName) {
+      return this._localNameToDefinition.get(localName);
+    }
+
+    /**
+     * @param {!Function} constructor
+     * @return {!CustomElementDefinition|undefined}
+     */
+
+  }, {
+    key: 'constructorToDefinition',
+    value: function constructorToDefinition(constructor) {
+      return this._constructorToDefinition.get(constructor);
+    }
+
+    /**
+     * @param {!function(!Node)} listener
+     */
+
+  }, {
+    key: 'addPatch',
+    value: function addPatch(listener) {
+      this._hasPatches = true;
+      this._patches.push(listener);
+    }
+
+    /**
+     * @param {!Node} node
+     */
+
+  }, {
+    key: 'patchTree',
+    value: function patchTree(node) {
+      var _this = this;
+
+      if (!this._hasPatches) return;
+
+      walkDeepDescendantElements(node, function (element) {
+        return _this.patch(element);
+      });
+    }
+
+    /**
+     * @param {!Node} node
+     */
+
+  }, {
+    key: 'patch',
+    value: function patch(node) {
+      if (!this._hasPatches) return;
+
+      if (node.__CE_patched) return;
+      node.__CE_patched = true;
+
+      for (var i = 0; i < this._patches.length; i++) {
+        this._patches[i](node);
+      }
+    }
+
+    /**
+     * @param {!Node} root
+     */
+
+  }, {
+    key: 'connectTree',
+    value: function connectTree(root) {
+      var elements = [];
+
+      walkDeepDescendantElements(root, function (element) {
+        return elements.push(element);
+      });
+
+      for (var i = 0; i < elements.length; i++) {
+        var element = elements[i];
+        if (element.__CE_state === CustomElementState.custom) {
+          if (isConnected(element)) {
+            this.connectedCallback(element);
+          }
+        } else {
+          this.upgradeElement(element);
+        }
+      }
+    }
+
+    /**
+     * @param {!Node} root
+     */
+
+  }, {
+    key: 'disconnectTree',
+    value: function disconnectTree(root) {
+      var elements = [];
+
+      walkDeepDescendantElements(root, function (element) {
+        return elements.push(element);
+      });
+
+      for (var i = 0; i < elements.length; i++) {
+        var element = elements[i];
+        if (element.__CE_state === CustomElementState.custom) {
+          this.disconnectedCallback(element);
+        }
+      }
+    }
+
+    /**
+     * Upgrades all uncustomized custom elements at and below a root node for
+     * which there is a definition. When custom element reaction callbacks are
+     * assumed to be called synchronously (which, by the current DOM / HTML spec
+     * definitions, they are *not*), callbacks for both elements customized
+     * synchronously by the parser and elements being upgraded occur in the same
+     * relative order.
+     *
+     * NOTE: This function, when used to simulate the construction of a tree that
+     * is already created but not customized (i.e. by the parser), does *not*
+     * prevent the element from reading the 'final' (true) state of the tree. For
+     * example, the element, during truly synchronous parsing / construction would
+     * see that it contains no children as they have not yet been inserted.
+     * However, this function does not modify the tree, the element will
+     * (incorrectly) have children. Additionally, self-modification restrictions
+     * for custom element constructors imposed by the DOM spec are *not* enforced.
+     *
+     *
+     * The following nested list shows the steps extending down from the HTML
+     * spec's parsing section that cause elements to be synchronously created and
+     * upgraded:
+     *
+     * The "in body" insertion mode:
+     * https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody
+     * - Switch on token:
+     *   .. other cases ..
+     *   -> Any other start tag
+     *      - [Insert an HTML element](below) for the token.
+     *
+     * Insert an HTML element:
+     * https://html.spec.whatwg.org/multipage/syntax.html#insert-an-html-element
+     * - Insert a foreign element for the token in the HTML namespace:
+     *   https://html.spec.whatwg.org/multipage/syntax.html#insert-a-foreign-element
+     *   - Create an element for a token:
+     *     https://html.spec.whatwg.org/multipage/syntax.html#create-an-element-for-the-token
+     *     - Will execute script flag is true?
+     *       - (Element queue pushed to the custom element reactions stack.)
+     *     - Create an element:
+     *       https://dom.spec.whatwg.org/#concept-create-element
+     *       - Sync CE flag is true?
+     *         - Constructor called.
+     *         - Self-modification restrictions enforced.
+     *       - Sync CE flag is false?
+     *         - (Upgrade reaction enqueued.)
+     *     - Attributes appended to element.
+     *       (`attributeChangedCallback` reactions enqueued.)
+     *     - Will execute script flag is true?
+     *       - (Element queue popped from the custom element reactions stack.
+     *         Reactions in the popped stack are invoked.)
+     *   - (Element queue pushed to the custom element reactions stack.)
+     *   - Insert the element:
+     *     https://dom.spec.whatwg.org/#concept-node-insert
+     *     - Shadow-including descendants are connected. During parsing
+     *       construction, there are no shadow-*excluding* descendants.
+     *       However, the constructor may have validly attached a shadow
+     *       tree to itself and added descendants to that shadow tree.
+     *       (`connectedCallback` reactions enqueued.)
+     *   - (Element queue popped from the custom element reactions stack.
+     *     Reactions in the popped stack are invoked.)
+     *
+     * @param {!Node} root
+     * @param {!Set<Node>=} visitedImports
+     */
+
+  }, {
+    key: 'patchAndUpgradeTree',
+    value: function patchAndUpgradeTree(root) {
+      var _this2 = this;
+
+      var visitedImports = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Set();
+
+      var elements = [];
+
+      var gatherElements = function gatherElements(element) {
+        if (element.localName === 'link' && element.getAttribute('rel') === 'import') {
+          // The HTML Imports polyfill sets a descendant element of the link to
+          // the `import` property, specifically this is *not* a Document.
+          var importNode = /** @type {?Node} */element.import;
+
+          if (importNode instanceof Node && importNode.readyState === 'complete') {
+            importNode.__CE_isImportDocument = true;
+
+            // Connected links are associated with the registry.
+            importNode.__CE_hasRegistry = true;
+          } else {
+            // If this link's import root is not available, its contents can't be
+            // walked. Wait for 'load' and walk it when it's ready.
+            element.addEventListener('load', function () {
+              var importNode = /** @type {!Node} */element.import;
+
+              if (importNode.__CE_documentLoadHandled) return;
+              importNode.__CE_documentLoadHandled = true;
+
+              importNode.__CE_isImportDocument = true;
+
+              // Connected links are associated with the registry.
+              importNode.__CE_hasRegistry = true;
+
+              // Clone the `visitedImports` set that was populated sync during
+              // the `patchAndUpgradeTree` call that caused this 'load' handler to
+              // be added. Then, remove *this* link's import node so that we can
+              // walk that import again, even if it was partially walked later
+              // during the same `patchAndUpgradeTree` call.
+              visitedImports.delete(importNode);
+
+              _this2.patchAndUpgradeTree(importNode, visitedImports);
+            });
+          }
+        } else {
+          elements.push(element);
+        }
+      };
+
+      // `walkDeepDescendantElements` populates (and internally checks against)
+      // `visitedImports` when traversing a loaded import.
+      walkDeepDescendantElements(root, gatherElements, visitedImports);
+
+      if (this._hasPatches) {
+        for (var i = 0; i < elements.length; i++) {
+          this.patch(elements[i]);
+        }
+      }
+
+      for (var _i = 0; _i < elements.length; _i++) {
+        this.upgradeElement(elements[_i]);
+      }
+    }
+
+    /**
+     * @param {!Element} element
+     */
+
+  }, {
+    key: 'upgradeElement',
+    value: function upgradeElement(element) {
+      var currentState = element.__CE_state;
+      if (currentState !== undefined) return;
+
+      var definition = this.localNameToDefinition(element.localName);
+      if (!definition) return;
+
+      definition.constructionStack.push(element);
+
+      var constructor = definition.constructor;
+      try {
+        try {
+          var result = new constructor();
+          if (result !== element) {
+            throw new Error('The custom element constructor did not produce the element being upgraded.');
+          }
+        } finally {
+          definition.constructionStack.pop();
+        }
+      } catch (e) {
+        element.__CE_state = CustomElementState.failed;
+        throw e;
+      }
+
+      element.__CE_state = CustomElementState.custom;
+      element.__CE_definition = definition;
+
+      if (definition.attributeChangedCallback) {
+        var observedAttributes = definition.observedAttributes;
+        for (var i = 0; i < observedAttributes.length; i++) {
+          var name = observedAttributes[i];
+          var value = element.getAttribute(name);
+          if (value !== null) {
+            this.attributeChangedCallback(element, name, null, value, null);
+          }
+        }
+      }
+
+      if (isConnected(element)) {
+        this.connectedCallback(element);
+      }
+    }
+
+    /**
+     * @param {!Element} element
+     */
+
+  }, {
+    key: 'connectedCallback',
+    value: function connectedCallback(element) {
+      var definition = element.__CE_definition;
+      if (definition.connectedCallback) {
+        definition.connectedCallback.call(element);
+      }
+
+      element.__CE_isConnectedCallbackCalled = true;
+    }
+
+    /**
+     * @param {!Element} element
+     */
+
+  }, {
+    key: 'disconnectedCallback',
+    value: function disconnectedCallback(element) {
+      if (!element.__CE_isConnectedCallbackCalled) {
+        this.connectedCallback(element);
+      }
+
+      var definition = element.__CE_definition;
+      if (definition.disconnectedCallback) {
+        definition.disconnectedCallback.call(element);
+      }
+
+      element.__CE_isConnectedCallbackCalled = undefined;
+    }
+
+    /**
+     * @param {!Element} element
+     * @param {string} name
+     * @param {?string} oldValue
+     * @param {?string} newValue
+     * @param {?string} namespace
+     */
+
+  }, {
+    key: 'attributeChangedCallback',
+    value: function attributeChangedCallback(element, name, oldValue, newValue, namespace) {
+      var definition = element.__CE_definition;
+      if (definition.attributeChangedCallback && definition.observedAttributes.indexOf(name) > -1) {
+        definition.attributeChangedCallback.call(element, name, oldValue, newValue, namespace);
+      }
+    }
+  }]);
+  return CustomElementInternals;
+}();
+
+var DocumentConstructionObserver = function () {
+  function DocumentConstructionObserver(internals, doc) {
+    classCallCheck(this, DocumentConstructionObserver);
+
+    /**
+     * @type {!CustomElementInternals}
+     */
+    this._internals = internals;
+
+    /**
+     * @type {!Document}
+     */
+    this._document = doc;
+
+    /**
+     * @type {MutationObserver|undefined}
+     */
+    this._observer = undefined;
+
+    // Simulate tree construction for all currently accessible nodes in the
+    // document.
+    this._internals.patchAndUpgradeTree(this._document);
+
+    if (this._document.readyState === 'loading') {
+      this._observer = new MutationObserver(this._handleMutations.bind(this));
+
+      // Nodes created by the parser are given to the observer *before* the next
+      // task runs. Inline scripts are run in a new task. This means that the
+      // observer will be able to handle the newly parsed nodes before the inline
+      // script is run.
+      this._observer.observe(this._document, {
+        childList: true,
+        subtree: true
+      });
+    }
+  }
+
+  createClass(DocumentConstructionObserver, [{
+    key: 'disconnect',
+    value: function disconnect() {
+      if (this._observer) {
+        this._observer.disconnect();
+      }
+    }
+
+    /**
+     * @param {!Array<!MutationRecord>} mutations
+     */
+
+  }, {
+    key: '_handleMutations',
+    value: function _handleMutations(mutations) {
+      // Once the document's `readyState` is 'interactive' or 'complete', all new
+      // nodes created within that document will be the result of script and
+      // should be handled by patching.
+      var readyState = this._document.readyState;
+      if (readyState === 'interactive' || readyState === 'complete') {
+        this.disconnect();
+      }
+
+      for (var i = 0; i < mutations.length; i++) {
+        var addedNodes = mutations[i].addedNodes;
+        for (var j = 0; j < addedNodes.length; j++) {
+          var node = addedNodes[j];
+          this._internals.patchAndUpgradeTree(node);
+        }
+      }
+    }
+  }]);
+  return DocumentConstructionObserver;
+}();
+
+/**
+ * @template T
+ */
+var Deferred = function () {
+  function Deferred() {
+    var _this = this;
+
+    classCallCheck(this, Deferred);
+
+    /**
+     * @private
+     * @type {T|undefined}
+     */
+    this._value = undefined;
+
+    /**
+     * @private
+     * @type {Function|undefined}
+     */
+    this._resolve = undefined;
+
+    /**
+     * @private
+     * @type {!Promise<T>}
+     */
+    this._promise = new Promise(function (resolve) {
+      _this._resolve = resolve;
+
+      if (_this._value) {
+        resolve(_this._value);
+      }
+    });
+  }
+
+  /**
+   * @param {T} value
+   */
+
+
+  createClass(Deferred, [{
+    key: 'resolve',
+    value: function resolve(value) {
+      if (this._value) {
+        throw new Error('Already resolved.');
+      }
+
+      this._value = value;
+
+      if (this._resolve) {
+        this._resolve(value);
+      }
+    }
+
+    /**
+     * @return {!Promise<T>}
+     */
+
+  }, {
+    key: 'toPromise',
+    value: function toPromise() {
+      return this._promise;
+    }
+  }]);
+  return Deferred;
+}();
+
+/**
+ * @unrestricted
+ */
+
+var CustomElementRegistry = function () {
+
+  /**
+   * @param {!CustomElementInternals} internals
+   */
+  function CustomElementRegistry(internals) {
+    classCallCheck(this, CustomElementRegistry);
+
+    /**
+     * @private
+     * @type {boolean}
+     */
+    this._elementDefinitionIsRunning = false;
+
+    /**
+     * @private
+     * @type {!CustomElementInternals}
+     */
+    this._internals = internals;
+
+    /**
+     * @private
+     * @type {!Map<string, !Deferred<undefined>>}
+     */
+    this._whenDefinedDeferred = new Map();
+
+    /**
+     * The default flush callback triggers the document walk synchronously.
+     * @private
+     * @type {!Function}
+     */
+    this._flushCallback = function (fn) {
+      return fn();
+    };
+
+    /**
+     * @private
+     * @type {boolean}
+     */
+    this._flushPending = false;
+
+    /**
+     * @private
+     * @type {!Array<string>}
+     */
+    this._unflushedLocalNames = [];
+
+    /**
+     * @private
+     * @type {!DocumentConstructionObserver}
+     */
+    this._documentConstructionObserver = new DocumentConstructionObserver(internals, document);
+  }
+
+  /**
+   * @param {string} localName
+   * @param {!Function} constructor
+   */
+
+
+  createClass(CustomElementRegistry, [{
+    key: 'define',
+    value: function define(localName, constructor) {
+      var _this = this;
+
+      if (!(constructor instanceof Function)) {
+        throw new TypeError('Custom element constructors must be functions.');
+      }
+
+      if (!isValidCustomElementName(localName)) {
+        throw new SyntaxError('The element name \'' + localName + '\' is not valid.');
+      }
+
+      if (this._internals.localNameToDefinition(localName)) {
+        throw new Error('A custom element with name \'' + localName + '\' has already been defined.');
+      }
+
+      if (this._elementDefinitionIsRunning) {
+        throw new Error('A custom element is already being defined.');
+      }
+      this._elementDefinitionIsRunning = true;
+
+      var connectedCallback = void 0;
+      var disconnectedCallback = void 0;
+      var adoptedCallback = void 0;
+      var attributeChangedCallback = void 0;
+      var observedAttributes = void 0;
+      try {
+        var getCallback = function getCallback(name) {
+          var callbackValue = prototype[name];
+          if (callbackValue !== undefined && !(callbackValue instanceof Function)) {
+            throw new Error('The \'' + name + '\' callback must be a function.');
+          }
+          return callbackValue;
+        };
+
+        /** @type {!Object} */
+        var prototype = constructor.prototype;
+        if (!(prototype instanceof Object)) {
+          throw new TypeError('The custom element constructor\'s prototype is not an object.');
+        }
+
+        connectedCallback = getCallback('connectedCallback');
+        disconnectedCallback = getCallback('disconnectedCallback');
+        adoptedCallback = getCallback('adoptedCallback');
+        attributeChangedCallback = getCallback('attributeChangedCallback');
+        observedAttributes = constructor['observedAttributes'] || [];
+      } catch (e) {
+        return;
+      } finally {
+        this._elementDefinitionIsRunning = false;
+      }
+
+      var definition = {
+        localName: localName,
+        constructor: constructor,
+        connectedCallback: connectedCallback,
+        disconnectedCallback: disconnectedCallback,
+        adoptedCallback: adoptedCallback,
+        attributeChangedCallback: attributeChangedCallback,
+        observedAttributes: observedAttributes,
+        constructionStack: []
+      };
+
+      this._internals.setDefinition(localName, definition);
+
+      this._unflushedLocalNames.push(localName);
+
+      // If we've already called the flush callback and it hasn't called back yet,
+      // don't call it again.
+      if (!this._flushPending) {
+        this._flushPending = true;
+        this._flushCallback(function () {
+          return _this._flush();
+        });
+      }
+    }
+  }, {
+    key: '_flush',
+    value: function _flush() {
+      // If no new definitions were defined, don't attempt to flush. This could
+      // happen if a flush callback keeps the function it is given and calls it
+      // multiple times.
+      if (this._flushPending === false) return;
+
+      this._flushPending = false;
+      this._internals.patchAndUpgradeTree(document);
+
+      while (this._unflushedLocalNames.length > 0) {
+        var localName = this._unflushedLocalNames.shift();
+        var deferred = this._whenDefinedDeferred.get(localName);
+        if (deferred) {
+          deferred.resolve(undefined);
+        }
+      }
+    }
+
+    /**
+     * @param {string} localName
+     * @return {Function|undefined}
+     */
+
+  }, {
+    key: 'get',
+    value: function get$$1(localName) {
+      var definition = this._internals.localNameToDefinition(localName);
+      if (definition) {
+        return definition.constructor;
+      }
+
+      return undefined;
+    }
+
+    /**
+     * @param {string} localName
+     * @return {!Promise<undefined>}
+     */
+
+  }, {
+    key: 'whenDefined',
+    value: function whenDefined(localName) {
+      if (!isValidCustomElementName(localName)) {
+        return Promise.reject(new SyntaxError('\'' + localName + '\' is not a valid custom element name.'));
+      }
+
+      var prior = this._whenDefinedDeferred.get(localName);
+      if (prior) {
+        return prior.toPromise();
+      }
+
+      var deferred = new Deferred();
+      this._whenDefinedDeferred.set(localName, deferred);
+
+      var definition = this._internals.localNameToDefinition(localName);
+      // Resolve immediately only if the given local name has a definition *and*
+      // the full document walk to upgrade elements with that local name has
+      // already happened.
+      if (definition && this._unflushedLocalNames.indexOf(localName) === -1) {
+        deferred.resolve(undefined);
+      }
+
+      return deferred.toPromise();
+    }
+  }, {
+    key: 'polyfillWrapFlushCallback',
+    value: function polyfillWrapFlushCallback(outer) {
+      this._documentConstructionObserver.disconnect();
+      var inner = this._flushCallback;
+      this._flushCallback = function (flush) {
+        return outer(function () {
+          return inner(flush);
+        });
+      };
+    }
+  }]);
+  return CustomElementRegistry;
+}();
+
+window['CustomElementRegistry'] = CustomElementRegistry;
+CustomElementRegistry.prototype['define'] = CustomElementRegistry.prototype.define;
+CustomElementRegistry.prototype['get'] = CustomElementRegistry.prototype.get;
+CustomElementRegistry.prototype['whenDefined'] = CustomElementRegistry.prototype.whenDefined;
+CustomElementRegistry.prototype['polyfillWrapFlushCallback'] = CustomElementRegistry.prototype.polyfillWrapFlushCallback;
+
+var Native = {
+  Document_createElement: window.Document.prototype.createElement,
+  Document_createElementNS: window.Document.prototype.createElementNS,
+  Document_importNode: window.Document.prototype.importNode,
+  Document_prepend: window.Document.prototype['prepend'],
+  Document_append: window.Document.prototype['append'],
+  Node_cloneNode: window.Node.prototype.cloneNode,
+  Node_appendChild: window.Node.prototype.appendChild,
+  Node_insertBefore: window.Node.prototype.insertBefore,
+  Node_removeChild: window.Node.prototype.removeChild,
+  Node_replaceChild: window.Node.prototype.replaceChild,
+  Node_textContent: Object.getOwnPropertyDescriptor(window.Node.prototype, 'textContent'),
+  Element_attachShadow: window.Element.prototype['attachShadow'],
+  Element_innerHTML: Object.getOwnPropertyDescriptor(window.Element.prototype, 'innerHTML'),
+  Element_getAttribute: window.Element.prototype.getAttribute,
+  Element_setAttribute: window.Element.prototype.setAttribute,
+  Element_removeAttribute: window.Element.prototype.removeAttribute,
+  Element_getAttributeNS: window.Element.prototype.getAttributeNS,
+  Element_setAttributeNS: window.Element.prototype.setAttributeNS,
+  Element_removeAttributeNS: window.Element.prototype.removeAttributeNS,
+  Element_insertAdjacentElement: window.Element.prototype['insertAdjacentElement'],
+  Element_prepend: window.Element.prototype['prepend'],
+  Element_append: window.Element.prototype['append'],
+  Element_before: window.Element.prototype['before'],
+  Element_after: window.Element.prototype['after'],
+  Element_replaceWith: window.Element.prototype['replaceWith'],
+  Element_remove: window.Element.prototype['remove'],
+  HTMLElement: window.HTMLElement,
+  HTMLElement_innerHTML: Object.getOwnPropertyDescriptor(window.HTMLElement.prototype, 'innerHTML'),
+  HTMLElement_insertAdjacentElement: window.HTMLElement.prototype['insertAdjacentElement']
+};
+
+/**
+ * This class exists only to work around Closure's lack of a way to describe
+ * singletons. It represents the 'already constructed marker' used in custom
+ * element construction stacks.
+ *
+ * https://html.spec.whatwg.org/#concept-already-constructed-marker
+ */
+var AlreadyConstructedMarker = function AlreadyConstructedMarker() {
+  classCallCheck(this, AlreadyConstructedMarker);
+};
+
+var AlreadyConstructedMarker$1 = new AlreadyConstructedMarker();
+
+/**
+ * @param {!CustomElementInternals} internals
+ */
+var PatchHTMLElement = function (internals) {
+  window['HTMLElement'] = function () {
+    /**
+     * @type {function(new: HTMLElement): !HTMLElement}
+     */
+    function HTMLElement() {
+      // This should really be `new.target` but `new.target` can't be emulated
+      // in ES5. Assuming the user keeps the default value of the constructor's
+      // prototype's `constructor` property, this is equivalent.
+      /** @type {!Function} */
+      var constructor = this.constructor;
+
+      var definition = internals.constructorToDefinition(constructor);
+      if (!definition) {
+        throw new Error('The custom element being constructed was not registered with `customElements`.');
+      }
+
+      var constructionStack = definition.constructionStack;
+
+      if (constructionStack.length === 0) {
+        var _element = Native.Document_createElement.call(document, definition.localName);
+        Object.setPrototypeOf(_element, constructor.prototype);
+        _element.__CE_state = CustomElementState.custom;
+        _element.__CE_definition = definition;
+        internals.patch(_element);
+        return _element;
+      }
+
+      var lastIndex = constructionStack.length - 1;
+      var element = constructionStack[lastIndex];
+      if (element === AlreadyConstructedMarker$1) {
+        throw new Error('The HTMLElement constructor was either called reentrantly for this constructor or called multiple times.');
+      }
+      constructionStack[lastIndex] = AlreadyConstructedMarker$1;
+
+      Object.setPrototypeOf(element, constructor.prototype);
+      internals.patch( /** @type {!HTMLElement} */element);
+
+      return element;
+    }
+
+    HTMLElement.prototype = Native.HTMLElement.prototype;
+
+    return HTMLElement;
+  }();
+};
+
+/**
+ * @param {!CustomElementInternals} internals
+ * @param {!Object} destination
+ * @param {!ParentNodeNativeMethods} builtIn
+ */
+var PatchParentNode = function (internals, destination, builtIn) {
+  /**
+   * @param {...(!Node|string)} nodes
+   */
+  destination['prepend'] = function () {
+    for (var _len = arguments.length, nodes = Array(_len), _key = 0; _key < _len; _key++) {
+      nodes[_key] = arguments[_key];
+    }
+
+    // TODO: Fix this for when one of `nodes` is a DocumentFragment!
+    var connectedBefore = /** @type {!Array<!Node>} */nodes.filter(function (node) {
+      // DocumentFragments are not connected and will not be added to the list.
+      return node instanceof Node && isConnected(node);
+    });
+
+    builtIn.prepend.apply(this, nodes);
+
+    for (var i = 0; i < connectedBefore.length; i++) {
+      internals.disconnectTree(connectedBefore[i]);
+    }
+
+    if (isConnected(this)) {
+      for (var _i = 0; _i < nodes.length; _i++) {
+        var node = nodes[_i];
+        if (node instanceof Element) {
+          internals.connectTree(node);
+        }
+      }
+    }
+  };
+
+  /**
+   * @param {...(!Node|string)} nodes
+   */
+  destination['append'] = function () {
+    for (var _len2 = arguments.length, nodes = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
+      nodes[_key2] = arguments[_key2];
+    }
+
+    // TODO: Fix this for when one of `nodes` is a DocumentFragment!
+    var connectedBefore = /** @type {!Array<!Node>} */nodes.filter(function (node) {
+      // DocumentFragments are not connected and will not be added to the list.
+      return node instanceof Node && isConnected(node);
+    });
+
+    builtIn.append.apply(this, nodes);
+
+    for (var i = 0; i < connectedBefore.length; i++) {
+      internals.disconnectTree(connectedBefore[i]);
+    }
+
+    if (isConnected(this)) {
+      for (var _i2 = 0; _i2 < nodes.length; _i2++) {
+        var node = nodes[_i2];
+        if (node instanceof Element) {
+          internals.connectTree(node);
+        }
+      }
+    }
+  };
+};
+
+/**
+ * @param {!CustomElementInternals} internals
+ */
+var PatchDocument = function (internals) {
+  setPropertyUnchecked(Document.prototype, 'createElement',
+  /**
+   * @this {Document}
+   * @param {string} localName
+   * @return {!Element}
+   */
+  function (localName) {
+    // Only create custom elements if this document is associated with the registry.
+    if (this.__CE_hasRegistry) {
+      var definition = internals.localNameToDefinition(localName);
+      if (definition) {
+        return new definition.constructor();
+      }
+    }
+
+    var result = /** @type {!Element} */
+    Native.Document_createElement.call(this, localName);
+    internals.patch(result);
+    return result;
+  });
+
+  setPropertyUnchecked(Document.prototype, 'importNode',
+  /**
+   * @this {Document}
+   * @param {!Node} node
+   * @param {boolean=} deep
+   * @return {!Node}
+   */
+  function (node, deep) {
+    var clone = Native.Document_importNode.call(this, node, deep);
+    // Only create custom elements if this document is associated with the registry.
+    if (!this.__CE_hasRegistry) {
+      internals.patchTree(clone);
+    } else {
+      internals.patchAndUpgradeTree(clone);
+    }
+    return clone;
+  });
+
+  var NS_HTML = "http://www.w3.org/1999/xhtml";
+
+  setPropertyUnchecked(Document.prototype, 'createElementNS',
+  /**
+   * @this {Document}
+   * @param {?string} namespace
+   * @param {string} localName
+   * @return {!Element}
+   */
+  function (namespace, localName) {
+    // Only create custom elements if this document is associated with the registry.
+    if (this.__CE_hasRegistry && (namespace === null || namespace === NS_HTML)) {
+      var definition = internals.localNameToDefinition(localName);
+      if (definition) {
+        return new definition.constructor();
+      }
+    }
+
+    var result = /** @type {!Element} */
+    Native.Document_createElementNS.call(this, namespace, localName);
+    internals.patch(result);
+    return result;
+  });
+
+  PatchParentNode(internals, Document.prototype, {
+    prepend: Native.Document_prepend,
+    append: Native.Document_append
+  });
+};
+
+/**
+ * @param {!CustomElementInternals} internals
+ */
+var PatchNode = function (internals) {
+  // `Node#nodeValue` is implemented on `Attr`.
+  // `Node#textContent` is implemented on `Attr`, `Element`.
+
+  setPropertyUnchecked(Node.prototype, 'insertBefore',
+  /**
+   * @this {Node}
+   * @param {!Node} node
+   * @param {?Node} refNode
+   * @return {!Node}
+   */
+  function (node, refNode) {
+    if (node instanceof DocumentFragment) {
+      var insertedNodes = Array.prototype.slice.apply(node.childNodes);
+      var _nativeResult = Native.Node_insertBefore.call(this, node, refNode);
+
+      // DocumentFragments can't be connected, so `disconnectTree` will never
+      // need to be called on a DocumentFragment's children after inserting it.
+
+      if (isConnected(this)) {
+        for (var i = 0; i < insertedNodes.length; i++) {
+          internals.connectTree(insertedNodes[i]);
+        }
+      }
+
+      return _nativeResult;
+    }
+
+    var nodeWasConnected = isConnected(node);
+    var nativeResult = Native.Node_insertBefore.call(this, node, refNode);
+
+    if (nodeWasConnected) {
+      internals.disconnectTree(node);
+    }
+
+    if (isConnected(this)) {
+      internals.connectTree(node);
+    }
+
+    return nativeResult;
+  });
+
+  setPropertyUnchecked(Node.prototype, 'appendChild',
+  /**
+   * @this {Node}
+   * @param {!Node} node
+   * @return {!Node}
+   */
+  function (node) {
+    if (node instanceof DocumentFragment) {
+      var insertedNodes = Array.prototype.slice.apply(node.childNodes);
+      var _nativeResult2 = Native.Node_appendChild.call(this, node);
+
+      // DocumentFragments can't be connected, so `disconnectTree` will never
+      // need to be called on a DocumentFragment's children after inserting it.
+
+      if (isConnected(this)) {
+        for (var i = 0; i < insertedNodes.length; i++) {
+          internals.connectTree(insertedNodes[i]);
+        }
+      }
+
+      return _nativeResult2;
+    }
+
+    var nodeWasConnected = isConnected(node);
+    var nativeResult = Native.Node_appendChild.call(this, node);
+
+    if (nodeWasConnected) {
+      internals.disconnectTree(node);
+    }
+
+    if (isConnected(this)) {
+      internals.connectTree(node);
+    }
+
+    return nativeResult;
+  });
+
+  setPropertyUnchecked(Node.prototype, 'cloneNode',
+  /**
+   * @this {Node}
+   * @param {boolean=} deep
+   * @return {!Node}
+   */
+  function (deep) {
+    var clone = Native.Node_cloneNode.call(this, deep);
+    // Only create custom elements if this element's owner document is
+    // associated with the registry.
+    if (!this.ownerDocument.__CE_hasRegistry) {
+      internals.patchTree(clone);
+    } else {
+      internals.patchAndUpgradeTree(clone);
+    }
+    return clone;
+  });
+
+  setPropertyUnchecked(Node.prototype, 'removeChild',
+  /**
+   * @this {Node}
+   * @param {!Node} node
+   * @return {!Node}
+   */
+  function (node) {
+    var nodeWasConnected = isConnected(node);
+    var nativeResult = Native.Node_removeChild.call(this, node);
+
+    if (nodeWasConnected) {
+      internals.disconnectTree(node);
+    }
+
+    return nativeResult;
+  });
+
+  setPropertyUnchecked(Node.prototype, 'replaceChild',
+  /**
+   * @this {Node}
+   * @param {!Node} nodeToInsert
+   * @param {!Node} nodeToRemove
+   * @return {!Node}
+   */
+  function (nodeToInsert, nodeToRemove) {
+    if (nodeToInsert instanceof DocumentFragment) {
+      var insertedNodes = Array.prototype.slice.apply(nodeToInsert.childNodes);
+      var _nativeResult3 = Native.Node_replaceChild.call(this, nodeToInsert, nodeToRemove);
+
+      // DocumentFragments can't be connected, so `disconnectTree` will never
+      // need to be called on a DocumentFragment's children after inserting it.
+
+      if (isConnected(this)) {
+        internals.disconnectTree(nodeToRemove);
+        for (var i = 0; i < insertedNodes.length; i++) {
+          internals.connectTree(insertedNodes[i]);
+        }
+      }
+
+      return _nativeResult3;
+    }
+
+    var nodeToInsertWasConnected = isConnected(nodeToInsert);
+    var nativeResult = Native.Node_replaceChild.call(this, nodeToInsert, nodeToRemove);
+    var thisIsConnected = isConnected(this);
+
+    if (thisIsConnected) {
+      internals.disconnectTree(nodeToRemove);
+    }
+
+    if (nodeToInsertWasConnected) {
+      internals.disconnectTree(nodeToInsert);
+    }
+
+    if (thisIsConnected) {
+      internals.connectTree(nodeToInsert);
+    }
+
+    return nativeResult;
+  });
+
+  function patch_textContent(destination, baseDescriptor) {
+    Object.defineProperty(destination, 'textContent', {
+      enumerable: baseDescriptor.enumerable,
+      configurable: true,
+      get: baseDescriptor.get,
+      set: /** @this {Node} */function set(assignedValue) {
+        // If this is a text node then there are no nodes to disconnect.
+        if (this.nodeType === Node.TEXT_NODE) {
+          baseDescriptor.set.call(this, assignedValue);
+          return;
+        }
+
+        var removedNodes = undefined;
+        // Checking for `firstChild` is faster than reading `childNodes.length`
+        // to compare with 0.
+        if (this.firstChild) {
+          // Using `childNodes` is faster than `children`, even though we only
+          // care about elements.
+          var childNodes = this.childNodes;
+          var childNodesLength = childNodes.length;
+          if (childNodesLength > 0 && isConnected(this)) {
+            // Copying an array by iterating is faster than using slice.
+            removedNodes = new Array(childNodesLength);
+            for (var i = 0; i < childNodesLength; i++) {
+              removedNodes[i] = childNodes[i];
+            }
+          }
+        }
+
+        baseDescriptor.set.call(this, assignedValue);
+
+        if (removedNodes) {
+          for (var _i = 0; _i < removedNodes.length; _i++) {
+            internals.disconnectTree(removedNodes[_i]);
+          }
+        }
+      }
+    });
+  }
+
+  if (Native.Node_textContent && Native.Node_textContent.get) {
+    patch_textContent(Node.prototype, Native.Node_textContent);
+  } else {
+    internals.addPatch(function (element) {
+      patch_textContent(element, {
+        enumerable: true,
+        configurable: true,
+        // NOTE: This implementation of the `textContent` getter assumes that
+        // text nodes' `textContent` getter will not be patched.
+        get: /** @this {Node} */function get() {
+          /** @type {!Array<string>} */
+          var parts = [];
+
+          for (var i = 0; i < this.childNodes.length; i++) {
+            parts.push(this.childNodes[i].textContent);
+          }
+
+          return parts.join('');
+        },
+        set: /** @this {Node} */function set(assignedValue) {
+          while (this.firstChild) {
+            Native.Node_removeChild.call(this, this.firstChild);
+          }
+          Native.Node_appendChild.call(this, document.createTextNode(assignedValue));
+        }
+      });
+    });
+  }
+};
+
+/**
+ * @param {!CustomElementInternals} internals
+ * @param {!Object} destination
+ * @param {!ChildNodeNativeMethods} builtIn
+ */
+var PatchChildNode = function (internals, destination, builtIn) {
+  /**
+   * @param {...(!Node|string)} nodes
+   */
+  destination['before'] = function () {
+    for (var _len = arguments.length, nodes = Array(_len), _key = 0; _key < _len; _key++) {
+      nodes[_key] = arguments[_key];
+    }
+
+    // TODO: Fix this for when one of `nodes` is a DocumentFragment!
+    var connectedBefore = /** @type {!Array<!Node>} */nodes.filter(function (node) {
+      // DocumentFragments are not connected and will not be added to the list.
+      return node instanceof Node && isConnected(node);
+    });
+
+    builtIn.before.apply(this, nodes);
+
+    for (var i = 0; i < connectedBefore.length; i++) {
+      internals.disconnectTree(connectedBefore[i]);
+    }
+
+    if (isConnected(this)) {
+      for (var _i = 0; _i < nodes.length; _i++) {
+        var node = nodes[_i];
+        if (node instanceof Element) {
+          internals.connectTree(node);
+        }
+      }
+    }
+  };
+
+  /**
+   * @param {...(!Node|string)} nodes
+   */
+  destination['after'] = function () {
+    for (var _len2 = arguments.length, nodes = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
+      nodes[_key2] = arguments[_key2];
+    }
+
+    // TODO: Fix this for when one of `nodes` is a DocumentFragment!
+    var connectedBefore = /** @type {!Array<!Node>} */nodes.filter(function (node) {
+      // DocumentFragments are not connected and will not be added to the list.
+      return node instanceof Node && isConnected(node);
+    });
+
+    builtIn.after.apply(this, nodes);
+
+    for (var i = 0; i < connectedBefore.length; i++) {
+      internals.disconnectTree(connectedBefore[i]);
+    }
+
+    if (isConnected(this)) {
+      for (var _i2 = 0; _i2 < nodes.length; _i2++) {
+        var node = nodes[_i2];
+        if (node instanceof Element) {
+          internals.connectTree(node);
+        }
+      }
+    }
+  };
+
+  /**
+   * @param {...(!Node|string)} nodes
+   */
+  destination['replaceWith'] = function () {
+    for (var _len3 = arguments.length, nodes = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
+      nodes[_key3] = arguments[_key3];
+    }
+
+    // TODO: Fix this for when one of `nodes` is a DocumentFragment!
+    var connectedBefore = /** @type {!Array<!Node>} */nodes.filter(function (node) {
+      // DocumentFragments are not connected and will not be added to the list.
+      return node instanceof Node && isConnected(node);
+    });
+
+    var wasConnected = isConnected(this);
+
+    builtIn.replaceWith.apply(this, nodes);
+
+    for (var i = 0; i < connectedBefore.length; i++) {
+      internals.disconnectTree(connectedBefore[i]);
+    }
+
+    if (wasConnected) {
+      internals.disconnectTree(this);
+      for (var _i3 = 0; _i3 < nodes.length; _i3++) {
+        var node = nodes[_i3];
+        if (node instanceof Element) {
+          internals.connectTree(node);
+        }
+      }
+    }
+  };
+
+  destination['remove'] = function () {
+    var wasConnected = isConnected(this);
+
+    builtIn.remove.call(this);
+
+    if (wasConnected) {
+      internals.disconnectTree(this);
+    }
+  };
+};
+
+/**
+ * @param {!CustomElementInternals} internals
+ */
+var PatchElement = function (internals) {
+  if (Native.Element_attachShadow) {
+    setPropertyUnchecked(Element.prototype, 'attachShadow',
+    /**
+     * @this {Element}
+     * @param {!{mode: string}} init
+     * @return {ShadowRoot}
+     */
+    function (init) {
+      var shadowRoot = Native.Element_attachShadow.call(this, init);
+      this.__CE_shadowRoot = shadowRoot;
+      return shadowRoot;
+    });
+  } else {
+    console.warn('Custom Elements: `Element#attachShadow` was not patched.');
+  }
+
+  function patch_innerHTML(destination, baseDescriptor) {
+    Object.defineProperty(destination, 'innerHTML', {
+      enumerable: baseDescriptor.enumerable,
+      configurable: true,
+      get: baseDescriptor.get,
+      set: /** @this {Element} */function set(htmlString) {
+        var _this = this;
+
+        var isConnected$$1 = isConnected(this);
+
+        // NOTE: In IE11, when using the native `innerHTML` setter, all nodes
+        // that were previously descendants of the context element have all of
+        // their children removed as part of the set - the entire subtree is
+        // 'disassembled'. This work around walks the subtree *before* using the
+        // native setter.
+        /** @type {!Array<!Element>|undefined} */
+        var removedElements = undefined;
+        if (isConnected$$1) {
+          removedElements = [];
+          walkDeepDescendantElements(this, function (element) {
+            if (element !== _this) {
+              removedElements.push(element);
+            }
+          });
+        }
+
+        baseDescriptor.set.call(this, htmlString);
+
+        if (removedElements) {
+          for (var i = 0; i < removedElements.length; i++) {
+            var element = removedElements[i];
+            if (element.__CE_state === CustomElementState.custom) {
+              internals.disconnectedCallback(element);
+            }
+          }
+        }
+
+        // Only create custom elements if this element's owner document is
+        // associated with the registry.
+        if (!this.ownerDocument.__CE_hasRegistry) {
+          internals.patchTree(this);
+        } else {
+          internals.patchAndUpgradeTree(this);
+        }
+        return htmlString;
+      }
+    });
+  }
+
+  if (Native.Element_innerHTML && Native.Element_innerHTML.get) {
+    patch_innerHTML(Element.prototype, Native.Element_innerHTML);
+  } else if (Native.HTMLElement_innerHTML && Native.HTMLElement_innerHTML.get) {
+    patch_innerHTML(HTMLElement.prototype, Native.HTMLElement_innerHTML);
+  } else {
+
+    /** @type {HTMLDivElement} */
+    var rawDiv = Native.Document_createElement.call(document, 'div');
+
+    internals.addPatch(function (element) {
+      patch_innerHTML(element, {
+        enumerable: true,
+        configurable: true,
+        // Implements getting `innerHTML` by performing an unpatched `cloneNode`
+        // of the element and returning the resulting element's `innerHTML`.
+        // TODO: Is this too expensive?
+        get: /** @this {Element} */function get() {
+          return Native.Node_cloneNode.call(this, true).innerHTML;
+        },
+        // Implements setting `innerHTML` by creating an unpatched element,
+        // setting `innerHTML` of that element and replacing the target
+        // element's children with those of the unpatched element.
+        set: /** @this {Element} */function set(assignedValue) {
+          // NOTE: re-route to `content` for `template` elements.
+          // We need to do this because `template.appendChild` does not
+          // route into `template.content`.
+          /** @type {!Node} */
+          var content = this.localName === 'template' ? /** @type {!HTMLTemplateElement} */this.content : this;
+          rawDiv.innerHTML = assignedValue;
+
+          while (content.childNodes.length > 0) {
+            Native.Node_removeChild.call(content, content.childNodes[0]);
+          }
+          while (rawDiv.childNodes.length > 0) {
+            Native.Node_appendChild.call(content, rawDiv.childNodes[0]);
+          }
+        }
+      });
+    });
+  }
+
+  setPropertyUnchecked(Element.prototype, 'setAttribute',
+  /**
+   * @this {Element}
+   * @param {string} name
+   * @param {string} newValue
+   */
+  function (name, newValue) {
+    // Fast path for non-custom elements.
+    if (this.__CE_state !== CustomElementState.custom) {
+      return Native.Element_setAttribute.call(this, name, newValue);
+    }
+
+    var oldValue = Native.Element_getAttribute.call(this, name);
+    Native.Element_setAttribute.call(this, name, newValue);
+    newValue = Native.Element_getAttribute.call(this, name);
+    internals.attributeChangedCallback(this, name, oldValue, newValue, null);
+  });
+
+  setPropertyUnchecked(Element.prototype, 'setAttributeNS',
+  /**
+   * @this {Element}
+   * @param {?string} namespace
+   * @param {string} name
+   * @param {string} newValue
+   */
+  function (namespace, name, newValue) {
+    // Fast path for non-custom elements.
+    if (this.__CE_state !== CustomElementState.custom) {
+      return Native.Element_setAttributeNS.call(this, namespace, name, newValue);
+    }
+
+    var oldValue = Native.Element_getAttributeNS.call(this, namespace, name);
+    Native.Element_setAttributeNS.call(this, namespace, name, newValue);
+    newValue = Native.Element_getAttributeNS.call(this, namespace, name);
+    internals.attributeChangedCallback(this, name, oldValue, newValue, namespace);
+  });
+
+  setPropertyUnchecked(Element.prototype, 'removeAttribute',
+  /**
+   * @this {Element}
+   * @param {string} name
+   */
+  function (name) {
+    // Fast path for non-custom elements.
+    if (this.__CE_state !== CustomElementState.custom) {
+      return Native.Element_removeAttribute.call(this, name);
+    }
+
+    var oldValue = Native.Element_getAttribute.call(this, name);
+    Native.Element_removeAttribute.call(this, name);
+    if (oldValue !== null) {
+      internals.attributeChangedCallback(this, name, oldValue, null, null);
+    }
+  });
+
+  setPropertyUnchecked(Element.prototype, 'removeAttributeNS',
+  /**
+   * @this {Element}
+   * @param {?string} namespace
+   * @param {string} name
+   */
+  function (namespace, name) {
+    // Fast path for non-custom elements.
+    if (this.__CE_state !== CustomElementState.custom) {
+      return Native.Element_removeAttributeNS.call(this, namespace, name);
+    }
+
+    var oldValue = Native.Element_getAttributeNS.call(this, namespace, name);
+    Native.Element_removeAttributeNS.call(this, namespace, name);
+    // In older browsers, `Element#getAttributeNS` may return the empty string
+    // instead of null if the attribute does not exist. For details, see;
+    // https://developer.mozilla.org/en-US/docs/Web/API/Element/getAttributeNS#Notes
+    var newValue = Native.Element_getAttributeNS.call(this, namespace, name);
+    if (oldValue !== newValue) {
+      internals.attributeChangedCallback(this, name, oldValue, newValue, namespace);
+    }
+  });
+
+  function patch_insertAdjacentElement(destination, baseMethod) {
+    setPropertyUnchecked(destination, 'insertAdjacentElement',
+    /**
+     * @this {Element}
+     * @param {string} where
+     * @param {!Element} element
+     * @return {?Element}
+     */
+    function (where, element) {
+      var wasConnected = isConnected(element);
+      var insertedElement = /** @type {!Element} */
+      baseMethod.call(this, where, element);
+
+      if (wasConnected) {
+        internals.disconnectTree(element);
+      }
+
+      if (isConnected(insertedElement)) {
+        internals.connectTree(element);
+      }
+      return insertedElement;
+    });
+  }
+
+  if (Native.HTMLElement_insertAdjacentElement) {
+    patch_insertAdjacentElement(HTMLElement.prototype, Native.HTMLElement_insertAdjacentElement);
+  } else if (Native.Element_insertAdjacentElement) {
+    patch_insertAdjacentElement(Element.prototype, Native.Element_insertAdjacentElement);
+  } else {
+    console.warn('Custom Elements: `Element#insertAdjacentElement` was not patched.');
+  }
+
+  PatchParentNode(internals, Element.prototype, {
+    prepend: Native.Element_prepend,
+    append: Native.Element_append
+  });
+
+  PatchChildNode(internals, Element.prototype, {
+    before: Native.Element_before,
+    after: Native.Element_after,
+    replaceWith: Native.Element_replaceWith,
+    remove: Native.Element_remove
+  });
+};
+
+/**
+ * @license
+ * Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
+ * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
+ * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
+ * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
+ * Code distributed by Google as part of the polymer project is also
+ * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
+ */
+
+var priorCustomElements = window['customElements'];
+
+if (!priorCustomElements || priorCustomElements['forcePolyfill'] || typeof priorCustomElements['define'] != 'function' || typeof priorCustomElements['get'] != 'function') {
+  /** @type {!CustomElementInternals} */
+  var internals = new CustomElementInternals();
+
+  PatchHTMLElement(internals);
+  PatchDocument(internals);
+  PatchNode(internals);
+  PatchElement(internals);
+
+  // The main document is always associated with the registry.
+  document.__CE_hasRegistry = true;
+
+  /** @type {!CustomElementRegistry} */
+  var customElements$1 = new CustomElementRegistry(internals);
+
+  Object.defineProperty(window, 'customElements', {
+    configurable: true,
+    enumerable: true,
+    value: customElements$1
+  });
+}
+
+/**
+ * @license
+ * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
+ * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
+ * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
+ * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
+ * Code distributed by Google as part of the polymer project is also
+ * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
+ */
+// @version 0.7.22
+
+(function (global) {
+  if (global.JsMutationObserver) {
+    return;
+  }
+  var registrationsTable = new WeakMap();
+  var setImmediate;
+  if (/Trident|Edge/.test(navigator.userAgent)) {
+    setImmediate = setTimeout;
+  } else if (window.setImmediate) {
+    setImmediate = window.setImmediate;
+  } else {
+    var setImmediateQueue = [];
+    var sentinel = String(Math.random());
+    window.addEventListener("message", function (e) {
+      if (e.data === sentinel) {
+        var queue = setImmediateQueue;
+        setImmediateQueue = [];
+        queue.forEach(function (func) {
+          func();
+        });
+      }
+    });
+    setImmediate = function setImmediate(func) {
+      setImmediateQueue.push(func);
+      window.postMessage(sentinel, "*");
+    };
+  }
+  var isScheduled = false;
+  var scheduledObservers = [];
+  function scheduleCallback(observer) {
+    scheduledObservers.push(observer);
+    if (!isScheduled) {
+      isScheduled = true;
+      setImmediate(dispatchCallbacks);
+    }
+  }
+  function wrapIfNeeded(node) {
+    return window.ShadowDOMPolyfill && window.ShadowDOMPolyfill.wrapIfNeeded(node) || node;
+  }
+  function dispatchCallbacks() {
+    isScheduled = false;
+    var observers = scheduledObservers;
+    scheduledObservers = [];
+    observers.sort(function (o1, o2) {
+      return o1.uid_ - o2.uid_;
+    });
+    var anyNonEmpty = false;
+    observers.forEach(function (observer) {
+      var queue = observer.takeRecords();
+      removeTransientObserversFor(observer);
+      if (queue.length) {
+        observer.callback_(queue, observer);
+        anyNonEmpty = true;
+      }
+    });
+    if (anyNonEmpty) dispatchCallbacks();
+  }
+  function removeTransientObserversFor(observer) {
+    observer.nodes_.forEach(function (node) {
+      var registrations = registrationsTable.get(node);
+      if (!registrations) return;
+      registrations.forEach(function (registration) {
+        if (registration.observer === observer) registration.removeTransientObservers();
+      });
+    });
+  }
+  function forEachAncestorAndObserverEnqueueRecord(target, callback) {
+    for (var node = target; node; node = node.parentNode) {
+      var registrations = registrationsTable.get(node);
+      if (registrations) {
+        for (var j = 0; j < registrations.length; j++) {
+          var registration = registrations[j];
+          var options = registration.options;
+          if (node !== target && !options.subtree) continue;
+          var record = callback(options);
+          if (record) registration.enqueue(record);
+        }
+      }
+    }
+  }
+  var uidCounter = 0;
+  function JsMutationObserver(callback) {
+    this.callback_ = callback;
+    this.nodes_ = [];
+    this.records_ = [];
+    this.uid_ = ++uidCounter;
+  }
+  JsMutationObserver.prototype = {
+    observe: function observe(target, options) {
+      target = wrapIfNeeded(target);
+      if (!options.childList && !options.attributes && !options.characterData || options.attributeOldValue && !options.attributes || options.attributeFilter && options.attributeFilter.length && !options.attributes || options.characterDataOldValue && !options.characterData) {
+        throw new SyntaxError();
+      }
+      var registrations = registrationsTable.get(target);
+      if (!registrations) registrationsTable.set(target, registrations = []);
+      var registration;
+      for (var i = 0; i < registrations.length; i++) {
+        if (registrations[i].observer === this) {
+          registration = registrations[i];
+          registration.removeListeners();
+          registration.options = options;
+          break;
+        }
+      }
+      if (!registration) {
+        registration = new Registration(this, target, options);
+        registrations.push(registration);
+        this.nodes_.push(target);
+      }
+      registration.addListeners();
+    },
+    disconnect: function disconnect() {
+      this.nodes_.forEach(function (node) {
+        var registrations = registrationsTable.get(node);
+        for (var i = 0; i < registrations.length; i++) {
+          var registration = registrations[i];
+          if (registration.observer === this) {
+            registration.removeListeners();
+            registrations.splice(i, 1);
+            break;
+          }
+        }
+      }, this);
+      this.records_ = [];
+    },
+    takeRecords: function takeRecords() {
+      var copyOfRecords = this.records_;
+      this.records_ = [];
+      return copyOfRecords;
+    }
+  };
+  function MutationRecord(type, target) {
+    this.type = type;
+    this.target = target;
+    this.addedNodes = [];
+    this.removedNodes = [];
+    this.previousSibling = null;
+    this.nextSibling = null;
+    this.attributeName = null;
+    this.attributeNamespace = null;
+    this.oldValue = null;
+  }
+  function copyMutationRecord(original) {
+    var record = new MutationRecord(original.type, original.target);
+    record.addedNodes = original.addedNodes.slice();
+    record.removedNodes = original.removedNodes.slice();
+    record.previousSibling = original.previousSibling;
+    record.nextSibling = original.nextSibling;
+    record.attributeName = original.attributeName;
+    record.attributeNamespace = original.attributeNamespace;
+    record.oldValue = original.oldValue;
+    return record;
+  }
+  var currentRecord, recordWithOldValue;
+  function getRecord(type, target) {
+    return currentRecord = new MutationRecord(type, target);
+  }
+  function getRecordWithOldValue(oldValue) {
+    if (recordWithOldValue) return recordWithOldValue;
+    recordWithOldValue = copyMutationRecord(currentRecord);
+    recordWithOldValue.oldValue = oldValue;
+    return recordWithOldValue;
+  }
+  function clearRecords() {
+    currentRecord = recordWithOldValue = undefined;
+  }
+  function recordRepresentsCurrentMutation(record) {
+    return record === recordWithOldValue || record === currentRecord;
+  }
+  function selectRecord(lastRecord, newRecord) {
+    if (lastRecord === newRecord) return lastRecord;
+    if (recordWithOldValue && recordRepresentsCurrentMutation(lastRecord)) return recordWithOldValue;
+    return null;
+  }
+  function Registration(observer, target, options) {
+    this.observer = observer;
+    this.target = target;
+    this.options = options;
+    this.transientObservedNodes = [];
+  }
+  Registration.prototype = {
+    enqueue: function enqueue(record) {
+      var records = this.observer.records_;
+      var length = records.length;
+      if (records.length > 0) {
+        var lastRecord = records[length - 1];
+        var recordToReplaceLast = selectRecord(lastRecord, record);
+        if (recordToReplaceLast) {
+          records[length - 1] = recordToReplaceLast;
+          return;
+        }
+      } else {
+        scheduleCallback(this.observer);
+      }
+      records[length] = record;
+    },
+    addListeners: function addListeners() {
+      this.addListeners_(this.target);
+    },
+    addListeners_: function addListeners_(node) {
+      var options = this.options;
+      if (options.attributes) node.addEventListener("DOMAttrModified", this, true);
+      if (options.characterData) node.addEventListener("DOMCharacterDataModified", this, true);
+      if (options.childList) node.addEventListener("DOMNodeInserted", this, true);
+      if (options.childList || options.subtree) node.addEventListener("DOMNodeRemoved", this, true);
+    },
+    removeListeners: function removeListeners() {
+      this.removeListeners_(this.target);
+    },
+    removeListeners_: function removeListeners_(node) {
+      var options = this.options;
+      if (options.attributes) node.removeEventListener("DOMAttrModified", this, true);
+      if (options.characterData) node.removeEventListener("DOMCharacterDataModified", this, true);
+      if (options.childList) node.removeEventListener("DOMNodeInserted", this, true);
+      if (options.childList || options.subtree) node.removeEventListener("DOMNodeRemoved", this, true);
+    },
+    addTransientObserver: function addTransientObserver(node) {
+      if (node === this.target) return;
+      this.addListeners_(node);
+      this.transientObservedNodes.push(node);
+      var registrations = registrationsTable.get(node);
+      if (!registrations) registrationsTable.set(node, registrations = []);
+      registrations.push(this);
+    },
+    removeTransientObservers: function removeTransientObservers() {
+      var transientObservedNodes = this.transientObservedNodes;
+      this.transientObservedNodes = [];
+      transientObservedNodes.forEach(function (node) {
+        this.removeListeners_(node);
+        var registrations = registrationsTable.get(node);
+        for (var i = 0; i < registrations.length; i++) {
+          if (registrations[i] === this) {
+            registrations.splice(i, 1);
+            break;
+          }
+        }
+      }, this);
+    },
+    handleEvent: function handleEvent(e) {
+      e.stopImmediatePropagation();
+      switch (e.type) {
+        case "DOMAttrModified":
+          var name = e.attrName;
+          var namespace = e.relatedNode.namespaceURI;
+          var target = e.target;
+          var record = new getRecord("attributes", target);
+          record.attributeName = name;
+          record.attributeNamespace = namespace;
+          var oldValue = e.attrChange === MutationEvent.ADDITION ? null : e.prevValue;
+          forEachAncestorAndObserverEnqueueRecord(target, function (options) {
+            if (!options.attributes) return;
+            if (options.attributeFilter && options.attributeFilter.length && options.attributeFilter.indexOf(name) === -1 && options.attributeFilter.indexOf(namespace) === -1) {
+              return;
+            }
+            if (options.attributeOldValue) return getRecordWithOldValue(oldValue);
+            return record;
+          });
+          break;
+
+        case "DOMCharacterDataModified":
+          var target = e.target;
+          var record = getRecord("characterData", target);
+          var oldValue = e.prevValue;
+          forEachAncestorAndObserverEnqueueRecord(target, function (options) {
+            if (!options.characterData) return;
+            if (options.characterDataOldValue) return getRecordWithOldValue(oldValue);
+            return record;
+          });
+          break;
+
+        case "DOMNodeRemoved":
+          this.addTransientObserver(e.target);
+
+        case "DOMNodeInserted":
+          var changedNode = e.target;
+          var addedNodes, removedNodes;
+          if (e.type === "DOMNodeInserted") {
+            addedNodes = [changedNode];
+            removedNodes = [];
+          } else {
+            addedNodes = [];
+            removedNodes = [changedNode];
+          }
+          var previousSibling = changedNode.previousSibling;
+          var nextSibling = changedNode.nextSibling;
+          var record = getRecord("childList", e.target.parentNode);
+          record.addedNodes = addedNodes;
+          record.removedNodes = removedNodes;
+          record.previousSibling = previousSibling;
+          record.nextSibling = nextSibling;
+          forEachAncestorAndObserverEnqueueRecord(e.relatedNode, function (options) {
+            if (!options.childList) return;
+            return record;
+          });
+      }
+      clearRecords();
+    }
+  };
+  global.JsMutationObserver = JsMutationObserver;
+  if (!global.MutationObserver) {
+    global.MutationObserver = JsMutationObserver;
+    JsMutationObserver._isPolyfilled = true;
+  }
+})(self);
+
+/*
+Copyright (c) 2012 Barnesandnoble.com, llc, Donavon West, and Domenic Denicola
+
+Permission is hereby granted, free of charge, to any person obtaining
+a copy of this software and associated documentation files (the
+"Software"), to deal in the Software without restriction, including
+without limitation the rights to use, copy, modify, merge, publish,
+distribute, sublicense, and/or sell copies of the Software, and to
+permit persons to whom the Software is furnished to do so, subject to
+the following conditions:
+
+The above copyright notice and this permission notice shall be
+included in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+*/
+(function (global, undefined) {
+    if (global.setImmediate) {
+        return;
+    }
+
+    var nextHandle = 1; // Spec says greater than zero
+    var tasksByHandle = {};
+    var currentlyRunningATask = false;
+    var doc = global.document;
+    var setImmediate;
+
+    function addFromSetImmediateArguments(args) {
+        tasksByHandle[nextHandle] = partiallyApplied.apply(undefined, args);
+        return nextHandle++;
+    }
+
+    // This function accepts the same arguments as setImmediate, but
+    // returns a function that requires no arguments.
+    function partiallyApplied(handler) {
+        var args = [].slice.call(arguments, 1);
+        return function () {
+            if (typeof handler === "function") {
+                handler.apply(undefined, args);
+            } else {
+                new Function("" + handler)();
+            }
+        };
+    }
+
+    function runIfPresent(handle) {
+        // From the spec: "Wait until any invocations of this algorithm started before this one have completed."
+        // So if we're currently running a task, we'll need to delay this invocation.
+        if (currentlyRunningATask) {
+            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a
+            // "too much recursion" error.
+            setTimeout(partiallyApplied(runIfPresent, handle), 0);
+        } else {
+            var task = tasksByHandle[handle];
+            if (task) {
+                currentlyRunningATask = true;
+                try {
+                    task();
+                } finally {
+                    clearImmediate(handle);
+                    currentlyRunningATask = false;
+                }
+            }
+        }
+    }
+
+    function clearImmediate(handle) {
+        delete tasksByHandle[handle];
+    }
+
+    function installNextTickImplementation() {
+        setImmediate = function setImmediate() {
+            var handle = addFromSetImmediateArguments(arguments);
+            process.nextTick(partiallyApplied(runIfPresent, handle));
+            return handle;
+        };
+    }
+
+    function canUsePostMessage() {
+        // The test against `importScripts` prevents this implementation from being installed inside a web worker,
+        // where `global.postMessage` means something completely different and can't be used for this purpose.
+        if (global.postMessage && !global.importScripts) {
+            var postMessageIsAsynchronous = true;
+            var oldOnMessage = global.onmessage;
+            global.onmessage = function () {
+                postMessageIsAsynchronous = false;
+            };
+            global.postMessage("", "*");
+            global.onmessage = oldOnMessage;
+            return postMessageIsAsynchronous;
+        }
+    }
+
+    function installPostMessageImplementation() {
+        // Installs an event handler on `global` for the `message` event: see
+        // * https://developer.mozilla.org/en/DOM/window.postMessage
+        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages
+
+        var messagePrefix = "setImmediate$" + Math.random() + "$";
+        var onGlobalMessage = function onGlobalMessage(event) {
+            if (event.source === global && typeof event.data === "string" && event.data.indexOf(messagePrefix) === 0) {
+                runIfPresent(+event.data.slice(messagePrefix.length));
+            }
+        };
+
+        if (global.addEventListener) {
+            global.addEventListener("message", onGlobalMessage, false);
+        } else {
+            global.attachEvent("onmessage", onGlobalMessage);
+        }
+
+        setImmediate = function setImmediate() {
+            var handle = addFromSetImmediateArguments(arguments);
+            global.postMessage(messagePrefix + handle, "*");
+            return handle;
+        };
+    }
+
+    function installMessageChannelImplementation() {
+        var channel = new MessageChannel();
+        channel.port1.onmessage = function (event) {
+            var handle = event.data;
+            runIfPresent(handle);
+        };
+
+        setImmediate = function setImmediate() {
+            var handle = addFromSetImmediateArguments(arguments);
+            channel.port2.postMessage(handle);
+            return handle;
+        };
+    }
+
+    function installReadyStateChangeImplementation() {
+        var html = doc.documentElement;
+        setImmediate = function setImmediate() {
+            var handle = addFromSetImmediateArguments(arguments);
+            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
+            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
+            var script = doc.createElement("script");
+            script.onreadystatechange = function () {
+                runIfPresent(handle);
+                script.onreadystatechange = null;
+                html.removeChild(script);
+                script = null;
+            };
+            html.appendChild(script);
+            return handle;
+        };
+    }
+
+    function installSetTimeoutImplementation() {
+        setImmediate = function setImmediate() {
+            var handle = addFromSetImmediateArguments(arguments);
+            setTimeout(partiallyApplied(runIfPresent, handle), 0);
+            return handle;
+        };
+    }
+
+    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.
+    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);
+    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;
+
+    // Don't get fooled by e.g. browserify environments.
+    if ({}.toString.call(global.process) === "[object process]") {
+        // For Node.js before 0.9
+        installNextTickImplementation();
+    } else if (canUsePostMessage()) {
+        // For non-IE10 modern browsers
+        installPostMessageImplementation();
+    } else if (global.MessageChannel) {
+        // For web workers, where supported
+        installMessageChannelImplementation();
+    } else if (doc && "onreadystatechange" in doc.createElement("script")) {
+        // For IE 6–8
+        installReadyStateChangeImplementation();
+    } else {
+        // For older browsers
+        installSetTimeoutImplementation();
+    }
+
+    attachTo.setImmediate = setImmediate;
+    attachTo.clearImmediate = clearImmediate;
+})(self);
+
+// Caution:
+// Do not replace this import statement with codes.
+//
+// If you replace this import statement with codes,
+// the codes will be executed after the following polyfills are imported
+// because import statements are hoisted during compilation.
+// Polyfill ECMAScript standard features with global namespace pollution
+// Polyfill Custom Elements v1 with global namespace pollution
+// Polyfill MutationObserver with global namespace pollution
+// Polyfill setImmediate with global namespace pollution
+
+(function () {
+  var DEFAULT_VIEWPORT = 'width=device-width,initial-scale=1,maximum-scale=1,minimum-scale=1,user-scalable=no';
+
+  var Viewport = {
+    ensureViewportElement: function ensureViewportElement() {
+      var viewportElement = document.querySelector('meta[name=viewport]');
+
+      if (!viewportElement) {
+        viewportElement = document.createElement('meta');
+        viewportElement.name = 'viewport';
+        document.head.appendChild(viewportElement);
+      }
+
+      return viewportElement;
+    },
+
+    setup: function setup() {
+      var viewportElement = Viewport.ensureViewportElement();
+
+      if (!viewportElement) {
+        return;
+      }
+
+      if (!viewportElement.hasAttribute('content')) {
+        viewportElement.setAttribute('content', DEFAULT_VIEWPORT);
+      }
+    }
+  };
+
+  window.Viewport = Viewport;
+})();
+
+function setup$1(ons) {
+  if (window._onsLoaded) {
+    ons._util.warn('Onsen UI is loaded more than once.');
+  }
+  window._onsLoaded = true;
+
+  // fastclick
+  window.addEventListener('load', function () {
+    ons.fastClick = fastclick_1.attach(document.body);
+
+    var supportTouchAction = 'touch-action' in document.body.style;
+
+    ons.platform._runOnActualPlatform(function () {
+      if (ons.platform.isAndroid()) {
+        // In Android4.4+, correct viewport settings can remove click delay.
+        // So disable FastClick on Android.
+        ons.fastClick.destroy();
+      } else if (ons.platform.isIOS()) {
+        if (supportTouchAction && (ons.platform.isIOSSafari() || ons.platform.isWKWebView())) {
+          // If 'touch-action' supported in iOS Safari or WKWebView, disable FastClick.
+          ons.fastClick.destroy();
+        } else {
+          // Do nothing. 'touch-action: manipulation' has no effect on UIWebView.
+        }
+      }
+    });
+  }, false);
+
+  ons.ready(function () {
+    ons.enableDeviceBackButtonHandler();
+    ons._defaultDeviceBackButtonHandler = ons._internal.dbbDispatcher.createHandler(window.document.body, function () {
+      if (Object.hasOwnProperty.call(navigator, 'app')) {
+        navigator.app.exitApp();
+      } else {
+        console.warn('Could not close the app. Is \'cordova.js\' included?\nError: \'window.navigator.app\' is undefined.');
+      }
+    });
+    document.body._gestureDetector = new ons.GestureDetector(document.body, { passive: true });
+
+    // Simulate Device Back Button on ESC press
+    if (!ons.platform.isWebView()) {
+      document.body.addEventListener('keydown', function (event) {
+        if (event.keyCode === 27) {
+          ons.fireDeviceBackButtonEvent();
+        }
+      });
+    }
+
+    // setup loading placeholder
+    ons._setupLoadingPlaceHolders();
+  });
+
+  // viewport.js
+  Viewport.setup();
+}
+
+/*
+Copyright 2013-2015 ASIAL CORPORATION
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+   http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+*/
+
+function getElementClass() {
+  if (typeof HTMLElement !== 'function') {
+    // case of Safari
+    var _BaseElement = function _BaseElement() {};
+    _BaseElement.prototype = document.createElement('div');
+    return _BaseElement;
+  } else {
+    return HTMLElement;
+  }
+}
+
+var BaseElement = function (_getElementClass) {
+  inherits(BaseElement, _getElementClass);
+
+  function BaseElement() {
+    classCallCheck(this, BaseElement);
+    return possibleConstructorReturn(this, (BaseElement.__proto__ || Object.getPrototypeOf(BaseElement)).call(this));
+  }
+
+  return BaseElement;
+}(getElementClass());
+
+/*
+Copyright 2013-2015 ASIAL CORPORATION
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+   http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+*/
+
+/**
+ * @element ons-template
+ * @category util
+ * @description
+ *   [en]
+ *     Define a separate HTML fragment and use as a template. These templates can be loaded as pages in `<ons-navigator>`, `<ons-tabbar>` and `<ons-splitter>`. They can also be used to generate dialogs. Since Onsen UI 2.4.0, the native `<template>` element can be used instead of `<ons-template>` for better performance and features. `<ons-template>` is still supported for backward compatibility.
+ *   [/en]
+ *   [ja]テンプレートとして使用するためのHTMLフラグメントを定義します。この要素でHTMLを宣言すると、id属性に指定した名前をpageのURLとしてons-navigatorなどのコンポーネントから参照できます。[/ja]
+ * @seealso ons-navigator
+ *   [en]The `<ons-navigator>` component enables stack based navigation.[/en]
+ *   [ja][/ja]
+ * @seealso ons-tabbar
+ *   [en]The `<ons-tabbar>` component is used to add tab navigation.[/en]
+ *   [ja][/ja]
+ * @seealso ons-splitter
+ *   [en]The `<ons-splitter>` component can be used to create a draggable menu or column based layout.[/en]
+ *   [ja][/ja]
+ * @example
+ * <ons-template id="foobar.html">
+ *   <ons-page>
+ *     Page content
+ *   </ons-page>
+ * </ons-template>
+ *
+ * <ons-navigator page="foobar.html"></ons-navigator>
+ */
+
+var TemplateElement = function (_BaseElement) {
+  inherits(TemplateElement, _BaseElement);
+
+  /**
+   * @property template
+   * @type {String}
+   * @description
+   *  [en]Template content. This property can not be used with AngularJS bindings.[/en]
+   *  [ja][/ja]
+   */
+
+  function TemplateElement() {
+    classCallCheck(this, TemplateElement);
+
+    var _this = possibleConstructorReturn(this, (TemplateElement.__proto__ || Object.getPrototypeOf(TemplateElement)).call(this));
+
+    _this.template = _this.innerHTML;
+
+    while (_this.firstChild) {
+      _this.removeChild(_this.firstChild);
+    }
+    return _this;
+  }
+
+  createClass(TemplateElement, [{
+    key: 'connectedCallback',
+    value: function connectedCallback() {
+      if (this.parentNode) {
+        // Note: this.parentNode is not set in some CE0/CE1 polyfills.
+        // Show warning when the ons-template is not located just under document.body
+        if (this.parentNode !== document.body) {
+          // if the parent is not document.body
+          util$1.warn('ons-template (id = ' + this.getAttribute('id') + ') must be located just under document.body' + (this.parentNode.outerHTML ? ':\n\n' + this.parentNode.outerHTML : '.'));
+        }
+      }
+
+      var event = new CustomEvent('_templateloaded', { bubbles: true, cancelable: true });
+      event.template = this.template;
+      event.templateId = this.getAttribute('id');
+
+      this.dispatchEvent(event);
+    }
+  }]);
+  return TemplateElement;
+}(BaseElement);
+
+onsElements.Template = TemplateElement;
+customElements.define('ons-template', TemplateElement);
+
+/*
+Copyright 2013-2015 ASIAL CORPORATION
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+   http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+*/
+
+/**
+ * @element ons-if
+ * @category conditional
+ * @tutorial vanilla/Reference/if
+ * @description
+ *   [en]
+ *     Conditionally display content depending on the platform, device orientation or both.
+ *
+ *     Sometimes it is useful to conditionally hide or show certain components based on platform. When running on iOS the `<ons-if>` element can be used to hide the `<ons-fab>` element.
+ *   [/en]
+ *   [ja][/ja]
+ * @guide theming.html#cross-platform-styling-autostyling [en]Information about cross platform styling[/en][ja]Information about cross platform styling[/ja]
+ * @example
+ * <ons-page>
+ *   <ons-if orientation="landscape">
+ *     Landscape view!
+ *   </ons-if>
+ *   <ons-if platform="android">
+ *     This is Android.
+ *   </ons-if>
+ *   <ons-if platform="ios other">
+ *     This is not Android.
+ *   </ons-if>
+ * </ons-page>
+ */
+
+var IfElement = function (_BaseElement) {
+  inherits(IfElement, _BaseElement);
+
+  /**
+   * @attribute platform
+   * @initonly
+   * @type {string}
+   * @description
+   *  [en]Space-separated platform names. Possible values are `"ios"`, `"android"`, `"windows"` and `"other"`.[/en]
+   *  [ja][/ja]
+   */
+
+  /**
+   * @attribute orientation
+   * @type {string}
+   * @description
+   *  [en]Either `"portrait"` or `"landscape"`.[/en]
+   *  [ja]portraitもしくはlandscapeを指定します[/ja]
+   */
+
+  function IfElement() {
+    classCallCheck(this, IfElement);
+
+    var _this = possibleConstructorReturn(this, (IfElement.__proto__ || Object.getPrototypeOf(IfElement)).call(this));
+
+    contentReady(_this, function () {
+      if (platform._getSelectedPlatform() !== null) {
+        _this._platformUpdate();
+      } else if (!_this._isAllowedPlatform()) {
+        while (_this.childNodes[0]) {
+          _this.childNodes[0].remove();
+        }
+        _this._platformUpdate();
+      }
+    });
+
+    _this._onOrientationChange();
+    return _this;
+  }
+
+  createClass(IfElement, [{
+    key: 'connectedCallback',
+    value: function connectedCallback() {
+      orientation.on('change', this._onOrientationChange.bind(this));
+    }
+  }, {
+    key: 'attributeChangedCallback',
+    value: function attributeChangedCallback(name) {
+      if (name === 'orientation') {
+        this._onOrientationChange();
+      }
+    }
+  }, {
+    key: 'disconnectedCallback',
+    value: function disconnectedCallback() {
+      orientation.off('change', this._onOrientationChange);
+    }
+  }, {
+    key: '_platformUpdate',
+    value: function _platformUpdate() {
+      this.style.display = this._isAllowedPlatform() ? '' : 'none';
+    }
+  }, {
+    key: '_isAllowedPlatform',
+    value: function _isAllowedPlatform() {
+      return !this.getAttribute('platform') || this.getAttribute('platform').split(/\s+/).indexOf(platform.getMobileOS()) >= 0;
+    }
+  }, {
+    key: '_onOrientationChange',
+    value: function _onOrientationChange() {
+      if (this.hasAttribute('orientation') && this._isAllowedPlatform()) {
+        var conditionalOrientation = this.getAttribute('orientation').toLowerCase();
+        var currentOrientation = orientation.isPortrait() ? 'portrait' : 'landscape';
+
+        this.style.display = conditionalOrientation === currentOrientation ? '' : 'none';
+      }
+    }
+  }], [{
+    key: 'observedAttributes',
+    get: function get$$1() {
+      return ['orientation'];
+    }
+  }]);
+  return IfElement;
+}(BaseElement);
+
+onsElements.If = IfElement;
+customElements.define('ons-if', IfElement);
+
+/*
+Copyright 2013-2015 ASIAL CORPORATION
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+   http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+*/
+
+var BaseAnimator = function () {
+
+  /**
+   * @param {Object} options
+   * @param {String} options.timing
+   * @param {Number} options.duration
+   * @param {Number} options.delay
+   */
+  function BaseAnimator() {
+    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
+    classCallCheck(this, BaseAnimator);
+
+    this.timing = options.timing || 'linear';
+    this.duration = options.duration || 0;
+    this.delay = options.delay || 0;
+
+    this.def = {
+      timing: this.timing,
+      duration: this.duration,
+      delay: this.delay
+    };
+  }
+
+  createClass(BaseAnimator, null, [{
+    key: 'extend',
+    value: function extend() {
+      var properties = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
+
+      var extendedAnimator = this;
+      var newAnimator = function newAnimator() {
+        extendedAnimator.apply(this, arguments);
+        util$1.extend(this, properties);
+      };
+
+      newAnimator.prototype = this.prototype;
+      return newAnimator;
+    }
+  }]);
+  return BaseAnimator;
+}();
+
+/*
+Copyright 2013-2015 ASIAL CORPORATION
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+   http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+*/
+
+// This object should not be exposed to users. Please keep this private.
+var iPhoneXPatch = {};
+
+iPhoneXPatch.isIPhoneXPortraitPatchActive = function () {
+  return document.documentElement.getAttribute('onsflag-iphonex-portrait') != null && window.innerWidth < window.innerHeight;
+};
+
+iPhoneXPatch.isIPhoneXLandscapePatchActive = function () {
+  // If width === height, treat it as landscape
+  return document.documentElement.getAttribute('onsflag-iphonex-landscape') != null && window.innerWidth >= window.innerHeight;
+};
+
+/**
+ * Returns the safe area lengths based on the current state of the safe areas.
+ */
+iPhoneXPatch.getSafeAreaLengths = function () {
+  var safeAreaLengths = void 0;
+  if (iPhoneXPatch.isIPhoneXPortraitPatchActive()) {
+    safeAreaLengths = {
+      top: 44,
+      right: 0,
+      bottom: 34,
+      left: 0
+    };
+  } else if (iPhoneXPatch.isIPhoneXLandscapePatchActive()) {
+    safeAreaLengths = {
+      top: 0,
+      right: 44,
+      bottom: 21,
+      left: 44
+    };
+  } else {
+    safeAreaLengths = {
+      top: 0,
+      right: 0,
+      bottom: 0,
+      left: 0
+    };
+  }
+
+  return safeAreaLengths;
+};
+
+/**
+ * Returns the safe area rect based on the current state of the safe areas.
+ */
+iPhoneXPatch.getSafeAreaDOMRect = function () {
+  var safeAreaRect = void 0;
+  if (iPhoneXPatch.isIPhoneXPortraitPatchActive()) {
+    safeAreaRect = {
+      x: 0,
+      y: 44, /* 0 + 44 (top safe area) */
+      width: window.innerWidth,
+      height: window.innerHeight - 78 /* height - 44 (top safe area) - 34 (bottom safe area) */
+    };
+  } else if (iPhoneXPatch.isIPhoneXLandscapePatchActive()) {
+    safeAreaRect = {
+      x: 44, /* 0 + 44 (left safe area) */
+      y: 0,
+      width: window.innerWidth - 88, /* width - 44 (left safe area) - 34 (right safe area) */
+      height: window.innerHeight - 21 /* height - 21 (bottom safe area) */
+    };
+  } else {
+    safeAreaRect = {
+      x: 0,
+      y: 0,
+      width: window.innerWidth,
+      height: window.innerHeight
+    };
+  }
+
+  return _extends({}, safeAreaRect, {
+    left: safeAreaRect.x,
+    top: safeAreaRect.y,
+    right: safeAreaRect.x + safeAreaRect.width,
+    bottom: safeAreaRect.y + safeAreaRect.height
+  });
+};
+
+/*
+Copyright 2013-2015 ASIAL CORPORATION
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+   http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+*/
+
+var ActionSheetAnimator = function (_BaseAnimator) {
+  inherits(ActionSheetAnimator, _BaseAnimator);
+
+  function ActionSheetAnimator() {
+    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
+        _ref$timing = _ref.timing,
+        timing = _ref$timing === undefined ? 'linear' : _ref$timing,
+        _ref$delay = _ref.delay,
+        delay = _ref$delay === undefined ? 0 : _ref$delay,
+        _ref$duration = _ref.duration,
+        duration = _ref$duration === undefined ? 0.2 : _ref$duration;
+
+    classCallCheck(this, ActionSheetAnimator);
+    return possibleConstructorReturn(this, (ActionSheetAnimator.__proto__ || Object.getPrototypeOf(ActionSheetAnimator)).call(this, { timing: timing, delay: delay, duration: duration }));
+  }
+
+  /**
+   * @param {HTMLElement} dialog
+   * @param {Function} done
+   */
+
+
+  createClass(ActionSheetAnimator, [{
+    key: 'show',
+    value: function show(dialog, done) {
+      done();
+    }
+
+    /**
+     * @param {HTMLElement} dialog
+     * @param {Function} done
+     */
+
+  }, {
+    key: 'hide',
+    value: function hide(dialog, done) {
+      done();
+    }
+  }]);
+  return ActionSheetAnimator;
+}(BaseAnimator);
+
+/**
+ * Android style animator for Action Sheet.
+ */
+var MDActionSheetAnimator = function (_ActionSheetAnimator) {
+  inherits(MDActionSheetAnimator, _ActionSheetAnimator);
+
+  function MDActionSheetAnimator() {
+    var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
+        _ref2$timing = _ref2.timing,
+        timing = _ref2$timing === undefined ? 'ease' : _ref2$timing,
+        _ref2$delay = _ref2.delay,
+        delay = _ref2$delay === undefined ? 0 : _ref2$delay,
+        _ref2$duration = _ref2.duration,
+        duration = _ref2$duration === undefined ? 0.4 : _ref2$duration;
+
+    classCallCheck(this, MDActionSheetAnimator);
+
+    var _this2 = possibleConstructorReturn(this, (MDActionSheetAnimator.__proto__ || Object.getPrototypeOf(MDActionSheetAnimator)).call(this, { timing: timing, delay: delay, duration: duration }));
+
+    _this2.maskTiming = 'linear';
+    _this2.maskDuration = 0.2;
+    return _this2;
+  }
+
+  /**
+   * @param {Object} dialog
+   * @param {Function} callback
+   */
+
+
+  createClass(MDActionSheetAnimator, [{
+    key: 'show',
+    value: function show(dialog, callback) {
+
+      Animit.runAll(Animit(dialog._mask).queue({ opacity: 0 }).wait(this.delay).queue({ opacity: 1.0 }, {
+        duration: this.maskDuration,
+        timing: this.maskTiming
+      }), Animit(dialog._sheet, this.def).default({ transform: 'translate3d(0, 80%, 0)', opacity: 0 }, { transform: 'translate3d(0, 0, 0)', opacity: 1 }).queue(function (done) {
+        callback && callback();
+        done();
+      }));
+    }
+
+    /**
+     * @param {Object} dialog
+     * @param {Function} callback
+     */
+
+  }, {
+    key: 'hide',
+    value: function hide(dialog, callback) {
+      Animit.runAll(Animit(dialog._mask).queue({ opacity: 1 }).wait(this.delay).queue({ opacity: 0 }, {
+        duration: this.maskDuration,
+        timing: this.maskTiming
+      }), Animit(dialog._sheet, this.def).default({ transform: 'translate3d(0, 0, 0)', opacity: 1 }, { transform: 'translate3d(0, 80%, 0)', opacity: 0 }).queue(function (done) {
+        callback && callback();
+        done();
+      }));
+    }
+  }]);
+  return MDActionSheetAnimator;
+}(ActionSheetAnimator);
+
+/**
+ * iOS style animator for dialog.
+ */
+var IOSActionSheetAnimator = function (_ActionSheetAnimator2) {
+  inherits(IOSActionSheetAnimator, _ActionSheetAnimator2);
+
+  function IOSActionSheetAnimator() {
+    var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
+        _ref3$timing = _ref3.timing,
+        timing = _ref3$timing === undefined ? 'ease' : _ref3$timing,
+        _ref3$delay = _ref3.delay,
+        delay = _ref3$delay === undefined ? 0 : _ref3$delay,
+        _ref3$duration = _ref3.duration,
+        duration = _ref3$duration === undefined ? 0.3 : _ref3$duration;
+
+    classCallCheck(this, IOSActionSheetAnimator);
+
+    var _this3 = possibleConstructorReturn(this, (IOSActionSheetAnimator.__proto__ || Object.getPrototypeOf(IOSActionSheetAnimator)).call(this, { timing: timing, delay: delay, duration: duration }));
+
+    _this3.maskTiming = 'linear';
+    _this3.maskDuration = 0.2;
+    if (iPhoneXPatch.isIPhoneXPortraitPatchActive()) {
+      _this3.liftAmount = 'calc(100% + 48px)';
+    } else if (iPhoneXPatch.isIPhoneXLandscapePatchActive()) {
+      _this3.liftAmount = 'calc(100% + 33px)';
+    } else {
+      _this3.liftAmount = document.body.clientHeight / 2.0 - 1 + 'px'; // avoid Forced Synchronous Layout
+    }
+    return _this3;
+  }
+
+  /**
+   * @param {Object} dialog
+   * @param {Function} callback
+   */
+
+
+  createClass(IOSActionSheetAnimator, [{
+    key: 'show',
+    value: function show(dialog, callback) {
+      Animit.runAll(Animit(dialog._mask).queue({ opacity: 0 }).wait(this.delay).queue({ opacity: 1 }, {
+        duration: this.maskDuration,
+        timing: this.maskTiming
+      }), Animit(dialog._sheet, this.def).default({ transform: 'translate3d(0, ' + this.liftAmount + ', 0)' }, { transform: 'translate3d(0, 0, 0)' }).queue(function (done) {
+        callback && callback();
+        done();
+      }));
+    }
+
+    /**
+     * @param {Object} dialog
+     * @param {Function} callback
+     */
+
+  }, {
+    key: 'hide',
+    value: function hide(dialog, callback) {
+      Animit.runAll(Animit(dialog._mask).queue({ opacity: 1 }).wait(this.delay).queue({ opacity: 0 }, {
+        duration: this.maskDuration,
+        timing: this.maskTiming
+      }), Animit(dialog._sheet, this.def).default({ transform: 'translate3d(0, 0, 0)' }, { transform: 'translate3d(0, ' + this.liftAmount + ', 0)' }).queue(function (done) {
+        callback && callback();
+        done();
+      }));
+    }
+  }]);
+  return IOSActionSheetAnimator;
+}(ActionSheetAnimator);
+
+/*
+Copyright 2013-2015 ASIAL CORPORATION
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+   http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+*/
+
+var BaseDialogElement = function (_BaseElement) {
+  inherits(BaseDialogElement, _BaseElement);
+  createClass(BaseDialogElement, [{
+    key: '_updateAnimatorFactory',
+    value: function _updateAnimatorFactory() {
+      util$1.throwMember();
+    }
+  }, {
+    key: '_toggleStyle',
+    value: function _toggleStyle(shouldShow) {
+      this.style.display = shouldShow ? 'block' : 'none';
+    }
+  }, {
+    key: '_scheme',
+    get: function get$$1() {
+      util$1.throwMember();
+    }
+  }]);
+
+  function BaseDialogElement() {
+    classCallCheck(this, BaseDialogElement);
+
+    var _this = possibleConstructorReturn(this, (BaseDialogElement.__proto__ || Object.getPrototypeOf(BaseDialogElement)).call(this));
+
+    if (_this.constructor === BaseDialogElement) {
+      util$1.throwAbstract();
+    }
+
+    _this._visible = false;
+    _this._doorLock = new DoorLock();
+    _this._cancel = _this._cancel.bind(_this);
+    _this._selfCamelName = util$1.camelize(_this.tagName.slice(4));
+    _this._defaultDBB = function (e) {
+      return _this.cancelable ? _this._cancel() : e.callParentHandler();
+    };
+    _this._animatorFactory = _this._updateAnimatorFactory();
+    return _this;
+  }
+
+  createClass(BaseDialogElement, [{
+    key: '_cancel',
+    value: function _cancel() {
+      var _this2 = this;
+
+      if (this.cancelable && !this._running) {
+        this._running = true;
+        this.hide().then(function () {
+          _this2._running = false;
+          util$1.triggerElementEvent(_this2, 'dialog-cancel');
+        }, function () {
+          return _this2._running = false;
+        });
+      }
+    }
+  }, {
+    key: 'show',
+    value: function show() {
+      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
+        args[_key] = arguments[_key];
+      }
+
+      return this._setVisible.apply(this, [true].concat(args));
+    }
+  }, {
+    key: 'hide',
+    value: function hide() {
+      for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
+        args[_key2] = arguments[_key2];
+      }
+
+      return this._setVisible.apply(this, [false].concat(args));
+    }
+  }, {
+    key: 'toggle',
+    value: function toggle() {
+      for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
+        args[_key3] = arguments[_key3];
+      }
+
+      return this._setVisible.apply(this, [!this.visible].concat(args));
+    }
+  }, {
+    key: '_setVisible',
+    value: function _setVisible(shouldShow) {
+      var _util$triggerElementE,
+          _this3 = this;
+
+      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
+
+      var action = shouldShow ? 'show' : 'hide';
+
+      options = _extends({}, options);
+      options.animationOptions = util$1.extend(options.animationOptions || {}, AnimatorFactory.parseAnimationOptionsString(this.getAttribute('animation-options')));
+
+      var canceled = false;
+      util$1.triggerElementEvent(this, 'pre' + action, (_util$triggerElementE = {}, defineProperty(_util$triggerElementE, this._selfCamelName, this), defineProperty(_util$triggerElementE, 'cancel', function cancel() {
+        return canceled = true;
+      }), _util$triggerElementE));
+
+      if (canceled) {
+        return Promise.reject('Canceled in pre' + action + ' event.');
+      }
+
+      return new Promise(function (resolve) {
+        _this3._doorLock.waitUnlock(function () {
+          var unlock = _this3._doorLock.lock();
+          var animator = _this3._animatorFactory.newAnimator(options);
+
+          shouldShow && _this3._toggleStyle(true, options);
+          _this3._visible = shouldShow;
+          util$1.iosPageScrollFix(shouldShow);
+
+          contentReady(_this3, function () {
+            animator[action](_this3, function () {
+              !shouldShow && _this3._toggleStyle(false, options);
+
+              unlock();
+
+              util$1.propagateAction(_this3, '_' + action);
+              util$1.triggerElementEvent(_this3, 'post' + action, defineProperty({}, _this3._selfCamelName, _this3)); // postshow posthide
+
+              if (options.callback instanceof Function) {
+                options.callback(_this3);
+              }
+
+              resolve(_this3);
+            });
+          });
+        });
+      });
+    }
+  }, {
+    key: '_updateMask',
+    value: function _updateMask() {
+      var _this4 = this;
+
+      contentReady(this, function () {
+        if (_this4._mask && _this4.getAttribute('mask-color')) {
+          _this4._mask.style.backgroundColor = _this4.getAttribute('mask-color');
+        }
+      });
+    }
+  }, {
+    key: 'connectedCallback',
+    value: function connectedCallback() {
+      var _this5 = this;
+
+      if (typeof this._defaultDBB === 'function') {
+        this.onDeviceBackButton = this._defaultDBB.bind(this);
+      }
+
+      contentReady(this, function () {
+        if (_this5._mask) {
+          _this5._mask.addEventListener('click', _this5._cancel, false);
+          util$1.iosMaskScrollFix(_this5._mask, true);
+        }
+      });
+    }
+  }, {
+    key: 'disconnectedCallback',
+    value: function disconnectedCallback() {
+      if (this._backButtonHandler) {
+        this._backButtonHandler.destroy();
+        this._backButtonHandler = null;
+      }
+
+      if (this._mask) {
+        this._mask.removeEventListener('click', this._cancel, false);
+        util$1.iosMaskScrollFix(this._mask, false);
+      }
+    }
+  }, {
+    key: 'attributeChangedCallback',
+    value: function attributeChangedCallback(name, last, current) {
+      switch (name) {
+        case 'modifier':
+          ModifierUtil.onModifierChanged(last, current, this, this._scheme);
+          break;
+        case 'animation':
+          this._animatorFactory = this._updateAnimatorFactory();
+          break;
+        case 'mask-color':
+          this._updateMask();
+          break;
+      }
+    }
+  }, {
+    key: 'onDeviceBackButton',
+    get: function get$$1() {
+      return this._backButtonHandler;
+    },
+    set: function set$$1(callback) {
+      if (this._backButtonHandler) {
+        this._backButtonHandler.destroy();
+      }
+
+      this._backButtonHandler = deviceBackButtonDispatcher.createHandler(this, callback);
+    }
+  }, {
+    key: 'visible',
+    get: function get$$1() {
+      return this._visible;
+    }
+  }, {
+    key: 'disabled',
+    set: function set$$1(value) {
+      return util$1.toggleAttribute(this, 'disabled', value);
+    },
+    get: function get$$1() {
+      return this.hasAttribute('disabled');
+    }
+  }, {
+    key: 'cancelable',
+    set: function set$$1(value) {
+      return util$1.toggleAttribute(this, 'cancelable', value);
+    },
+    get: function get$$1() {
+      return this.hasAttribute('cancelable');
+    }
+  }], [{
+    key: 'observedAttributes',
+    get: function get$$1() {
+      return ['modifier', 'animation', 'mask-color'];
+    }
+  }, {
+    key: 'events',
+    get: function get$$1() {
+      return ['preshow', 'postshow', 'prehide', 'posthide', 'dialog-cancel'];
+    }
+  }]);
+  return BaseDialogElement;
+}(BaseElement);
+
+/*
+Copyright 2013-2015 ASIAL CORPORATION
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+   http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+*/
+
+var scheme = {
+  '.action-sheet': 'action-sheet--*',
+  '.action-sheet-mask': 'action-sheet-mask--*',
+  '.action-sheet-title': 'action-sheet-title--*'
+};
+
+var _animatorDict = {
+  'default': function _default() {
+    return platform.isAndroid() ? MDActionSheetAnimator : IOSActionSheetAnimator;
+  },
+  'none': ActionSheetAnimator
+};
+
+/**
+ * @element ons-action-sheet
+ * @category dialog
+ * @description
+ *   [en]
+ *     Action/bottom sheet that is displayed on top of current screen.
+ *
+ *     This element can either be attached directly to the `<body>` or dynamically created from a template using the `ons.createElement(template, { append: true })` utility function and the `<template>` tag.
+ *
+ *     The action sheet is useful for displaying a list of options and asking the user to make a decision. A `ons-action-sheet-button` is provided for this purpose, although it can contain any type of content.
+ *
+ *     It will automatically be displayed as Material Design (bottom sheet) when running on an Android device.
+ *   [/en]
+ *   [ja]
+ *     アクションシート、もしくはボトムシートを現在のスクリーン上に表示します。
+ *
+ *     この要素は、`<body>`要素に直接アタッチされるか、もしくは`ons.createElement(template, { append: true })`と`<template>`タグを使ってテンプレートから動的に生成されます。
+ *
+ *     アクションシートは、選択肢のリストを表示してユーザーに尋ねるのに便利です。`ons-action-sheet-button`は、この要素の中に置くために提供されていますが、それ以外にも他のどのような要素を含むことができます。
+ *
+ *     Androidデバイスで実行されるときには、自動的にマテリアルデザイン(ボトムシート)として表示されます。
+ *   [/ja]
+ * @modifier material
+ *   [en]Display a Material Design bottom sheet.[/en]
+ *   [ja]マテリアルデザインのボトムシートを表示します。[/ja]
+ * @tutorial vanilla/reference/action-sheet
+ * @guide theming.html#modifiers [en]More details about the `modifier` attribute[/en][ja]modifier属性の使い方[/ja]
+ * @seealso ons-popover
+ *   [en]`<ons-popover>` component[/en]
+ *   [ja]ons-popoverコンポーネント[/ja]
+ * @seealso ons-modal
+ *   [en]`<ons-modal>` component[/en]
+ *   [ja]ons-modalコンポーネント[/ja]
+ * @example
+ * <ons-action-sheet id="sheet">
+ *   <ons-action-sheet-button>Label</ons-action-sheet-button>
+ *   <ons-action-sheet-button>Label</ons-action-sheet-button>
+ * </ons-action-sheet>
+ *
+ * <script>
+ *   document.getElementById('sheet').show();
+ * </script>
+ */
+
+var ActionSheetElement = function (_BaseDialogElement) {
+  inherits(ActionSheetElement, _BaseDialogElement);
+
+  /**
+   * @event preshow
+   * @description
+   * [en]Fired just before the action sheet is displayed.[/en]
+   * [ja]ダイアログが表示される直前に発火します。[/ja]
+   * @param {Object} event [en]Event object.[/en]
+   * @param {Object} event.actionSheet
+   *   [en]Component object.[/en]
+   *   [ja]コンポーネントのオブジェクト。[/ja]
+   * @param {Function} event.cancel
+   *   [en]Execute this function to stop the action sheet from being shown.[/en]
+   *   [ja]この関数を実行すると、ダイアログの表示がキャンセルされます。[/ja]
+   */
+
+  /**
+   * @event postshow
+   * @description
+   * [en]Fired just after the action sheet is displayed.[/en]
+   * [ja]ダイアログが表示された直後に発火します。[/ja]
+   * @param {Object} event [en]Event object.[/en]
+   * @param {Object} event.actionSheet
+   *   [en]Component object.[/en]
+   *   [ja]コンポーネントのオブジェクト。[/ja]
+   */
+
+  /**
+   * @event prehide
+   * @description
+   * [en]Fired just before the action sheet is hidden.[/en]
+   * [ja]ダイアログが隠れる直前に発火します。[/ja]
+   * @param {Object} event [en]Event object.[/en]
+   * @param {Object} event.actionSheet
+   *   [en]Component object.[/en]
+   *   [ja]コンポーネントのオブジェクト。[/ja]
+   * @param {Function} event.cancel
+   *   [en]Execute this function to stop the action sheet from being hidden.[/en]
+   *   [ja]この関数を実行すると、ダイアログの非表示がキャンセルされます。[/ja]
+   */
+
+  /**
+   * @event posthide
+   * @description
+   * [en]Fired just after the action sheet is hidden.[/en]
+   * [ja]ダイアログが隠れた後に発火します。[/ja]
+   * @param {Object} event [en]Event object.[/en]
+   * @param {Object} event.actionSheet
+   *   [en]Component object.[/en]
+   *   [ja]コンポーネントのオブジェクト。[/ja]
+   */
+
+  /**
+   * @attribute title
+   * @type {String}
+   * @description
+   *  [en]Optional title of the action sheet. A new element will be created containing this string.[/en]
+   *  [ja]アクションシートのタイトルを指定します。ここで指定した文字列を含む新しい要素が作成されます。[/ja]
+   */
+
+  /**
+   * @attribute modifier
+   * @type {String}
+   * @description
+   *  [en]The appearance of the action sheet.[/en]
+   *  [ja]ダイアログの表現を指定します。[/ja]
+   */
+
+  /**
+   * @attribute cancelable
+   * @description
+   *  [en]If this attribute is set the action sheet can be closed by tapping the background or by pressing the back button on Android devices.[/en]
+   *  [ja]この属性が設定されると、アクションシートの背景やAndroidデバイスのバックボタンを推すことでアクションシートが閉じるようになります。[/ja]
+   */
+
+  /**
+   * @attribute disabled
+   * @description
+   *  [en]If this attribute is set the action sheet is disabled.[/en]
+   *  [ja]この属性がある時、ダイアログはdisabled状態になります。[/ja]
+   */
+
+  /**
+   * @attribute animation
+   * @type {String}
+   * @default default
+   * @description
+   *  [en]The animation used when showing and hiding the action sheet. Can be either `"none"` or `"default"`.[/en]
+   *  [ja]ダイアログを表示する際のアニメーション名を指定します。"none"もしくは"default"を指定できます。[/ja]
+   */
+
+  /**
+   * @attribute animation-options
+   * @type {Expression}
+   * @description
+   *  [en]Specify the animation's duration, timing and delay with an object literal. E.g. `{duration: 0.2, delay: 1, timing: 'ease-in'}`.[/en]
+   *  [ja]アニメーション時のduration, timing, delayをオブジェクトリテラルで指定します。e.g. `{duration: 0.2, delay: 1, timing: 'ease-in'}`[/ja]
+   */
+
+  /**
+   * @attribute mask-color
+   * @type {String}
+   * @default rgba(0, 0, 0, 0.2)
+   * @description
+   *  [en]Color of the background mask. Default is `"rgba(0, 0, 0, 0.2)"`.[/en]
+   *  [ja]背景のマスクの色を指定します。"rgba(0, 0, 0, 0.2)"がデフォルト値です。[/ja]
+   */
+
+  function ActionSheetElement() {
+    classCallCheck(this, ActionSheetElement);
+
+    var _this = possibleConstructorReturn(this, (ActionSheetElement.__proto__ || Object.getPrototypeOf(ActionSheetElement)).call(this));
+
+    contentReady(_this, function () {
+      return _this._compile();
+    });
+    return _this;
+  }
+
+  createClass(ActionSheetElement, [{
+    key: '_updateAnimatorFactory',
+    value: function _updateAnimatorFactory() {
+      return new AnimatorFactory({
+        animators: _animatorDict,
+        baseClass: ActionSheetAnimator,
+        baseClassName: 'ActionSheetAnimator',
+        defaultAnimation: this.getAttribute('animation')
+      });
+    }
+  }, {
+    key: '_compile',
+    value: function _compile() {
+      autoStyle.prepare(this);
+
+      this.style.display = 'none';
+      this.style.zIndex = 10001;
+
+      /* Expected result:
+       *   <ons-action-sheet>
+       *     <div class="action-sheet-mask"></div>
+       *     <div class="action-sheet">
+       *       <div class="action-sheet-title></div>
+       *       ...
+       *     </div>
+       *   </ons-action-sheet>
+       */
+
+      if (!this._sheet) {
+        var sheet = document.createElement('div');
+        sheet.classList.add('action-sheet');
+
+        while (this.firstChild) {
+          sheet.appendChild(this.firstChild);
+        }
+
+        this.appendChild(sheet);
+      }
+
+      if (!this._title && this.hasAttribute('title')) {
+        var title = document.createElement('div');
+        title.innerHTML = this.getAttribute('title');
+        title.classList.add('action-sheet-title');
+        this._sheet.insertBefore(title, this._sheet.firstChild);
+      }
+
+      if (!this._mask) {
+        var mask = document.createElement('div');
+        mask.classList.add('action-sheet-mask');
+        this.insertBefore(mask, this.firstChild);
+      }
+
+      this._sheet.style.zIndex = 20001;
+      this._mask.style.zIndex = 20000;
+
+      ModifierUtil.initModifier(this, this._scheme);
+    }
+  }, {
+    key: '_updateTitle',
+    value: function _updateTitle() {
+      if (this._title) {
+        this._title.innerHTML = this.getAttribute('title');
+      }
+    }
+
+    /**
+     * @property onDeviceBackButton
+     * @type {Object}
+     * @description
+     *   [en]Back-button handler.[/en]
+     *   [ja]バックボタンハンドラ。[/ja]
+     */
+
+    /**
+     * @method show
+     * @signature show([options])
+     * @param {Object} [options]
+     *   [en]Parameter object.[/en]
+     *   [ja]オプションを指定するオブジェクト。[/ja]
+     * @param {String} [options.animation]
+     *   [en]Animation name. Available animations are `"none"` and `"slide"`.[/en]
+     *   [ja]アニメーション名を指定します。"none", "slide"のいずれかを指定します。[/ja]
+     * @param {String} [options.animationOptions]
+     *   [en]Specify the animation's duration, delay and timing. E.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}`.[/en]
+     *   [ja]アニメーション時のduration, delay, timingを指定します。e.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}` [/ja]
+     * @param {Function} [options.callback]
+     *   [en]This function is called after the action sheet has been revealed.[/en]
+     *   [ja]ダイアログが表示され終わった後に呼び出される関数オブジェクトを指定します。[/ja]
+     * @description
+     *  [en]Show the action sheet.[/en]
+     *  [ja]ダイアログを開きます。[/ja]
+     * @return {Promise} Resolves to the displayed element.
+     */
+
+    /**
+     * @method hide
+     * @signature hide([options])
+     * @param {Object} [options]
+     *   [en]Parameter object.[/en]
+     *   [ja]オプションを指定するオブジェクト。[/ja]
+     * @param {String} [options.animation]
+     *   [en]Animation name. Available animations are `"none"` and `"slide"`.[/en]
+     *   [ja]アニメーション名を指定します。"none", "slide"のいずれかを指定できます。[/ja]
+     * @param {String} [options.animationOptions]
+     *   [en]Specify the animation's duration, delay and timing. E.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}`.[/en]
+     *   [ja]アニメーション時のduration, delay, timingを指定します。e.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}`[/ja]
+     * @param {Function} [options.callback]
+     *   [en]This functions is called after the action sheet has been hidden.[/en]
+     *   [ja]ダイアログが隠れた後に呼び出される関数オブジェクトを指定します。[/ja]
+     * @description
+     *   [en]Hide the action sheet.[/en]
+     *   [ja]ダイアログを閉じます。[/ja]
+     * @return {Promise}
+     *   [en]Resolves to the hidden element[/en]
+     *   [ja]隠れた要素を解決します。[/ja]
+     */
+
+    /**
+     * @property visible
+     * @readonly
+     * @type {Boolean}
+     * @description
+     *   [en]Whether the action sheet is visible or not.[/en]
+     *   [ja]要素が見える場合に`true`。[/ja]
+     */
+
+    /**
+     * @property disabled
+     * @type {Boolean}
+     * @description
+     *   [en]Whether the action sheet is disabled or not.[/en]
+     *   [ja]無効化されている場合に`true`。[/ja]
+     */
+
+    /**
+     * @property cancelable
+     * @type {Boolean}
+     * @description
+     *   [en]Whether the action sheet is cancelable or not. A cancelable action sheet can be closed by tapping the background or by pressing the back button on Android devices.[/en]
+     *   [ja]アクションシートがキャンセル可能かどうかを設定します。キャンセル可能なアクションシートは、背景をタップしたりAndroidデバイスのバックボタンを推すことで閉じるようになります。[/ja]
+     */
+
+  }, {
+    key: 'attributeChangedCallback',
+    value: function attributeChangedCallback(name, last, current) {
+      if (name === 'title') {
+        this._updateTitle();
+      } else {
+        get(ActionSheetElement.prototype.__proto__ || Object.getPrototypeOf(ActionSheetElement.prototype), 'attributeChangedCallback', this).call(this, name, last, current);
+      }
+    }
+
+    /**
+     * @param {String} name
+     * @param {ActionSheetAnimator} Animator
+     */
+
+  }, {
+    key: '_scheme',
+    get: function get$$1() {
+      return scheme;
+    }
+  }, {
+    key: '_mask',
+    get: function get$$1() {
+      return util$1.findChild(this, '.action-sheet-mask');
+    }
+  }, {
+    key: '_sheet',
+    get: function get$$1() {
+      return util$1.findChild(this, '.action-sheet');
+    }
+  }, {
+    key: '_title',
+    get: function get$$1() {
+      return this.querySelector('.action-sheet-title');
+    }
+  }], [{
+    key: 'registerAnimator',
+    value: function registerAnimator(name, Animator) {
+      if (!(Animator.prototype instanceof ActionSheetAnimator)) {
+        util$1.throwAnimator('ActionSheet');
+      }
+      _animatorDict[name] = Animator;
+    }
+  }, {
+    key: 'observedAttributes',
+    get: function get$$1() {
+      return [].concat(toConsumableArray(get(ActionSheetElement.__proto__ || Object.getPrototypeOf(ActionSheetElement), 'observedAttributes', this)), ['title']);
+    }
+  }, {
+    key: 'animators',
+    get: function get$$1() {
+      return _animatorDict;
+    }
+  }, {
+    key: 'ActionSheetAnimator',
+    get: function get$$1() {
+      return ActionSheetAnimator;
+    }
+  }]);
+  return ActionSheetElement;
+}(BaseDialogElement);
+
+onsElements.ActionSheet = ActionSheetElement;
+customElements.define('ons-action-sheet', ActionSheetElement);
+
+/*
+Copyright 2013-2015 ASIAL CORPORATION
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+   http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+*/
+
+var BaseButtonElement = function (_BaseElement) {
+  inherits(BaseButtonElement, _BaseElement);
+  createClass(BaseButtonElement, [{
+    key: '_scheme',
+    get: function get$$1() {
+      util$1.throwMember();
+    }
+  }, {
+    key: '_defaultClassName',
+    get: function get$$1() {
+      util$1.throwMember();
+    }
+  }, {
+    key: '_rippleOpt',
+    get: function get$$1() {
+      return [this];
+    }
+  }]);
+
+  function BaseButtonElement() {
+    classCallCheck(this, BaseButtonElement);
+
+    var _this = possibleConstructorReturn(this, (BaseButtonElement.__proto__ || Object.getPrototypeOf(BaseButtonElement)).call(this));
+
+    if (_this.constructor === BaseButtonElement) {
+      util$1.throwAbstract();
+    }
+
+    contentReady(_this, function () {
+      return _this._compile();
+    });
+    return _this;
+  }
+
+  createClass(BaseButtonElement, [{
+    key: '_compile',
+    value: function _compile() {
+      autoStyle.prepare(this);
+
+      this.classList.add(this._defaultClassName);
+
+      if (!this._icon && this.hasAttribute('icon')) {
+        util$1.checkMissingImport('Icon');
+        var icon = util$1.createElement('<ons-icon icon="' + this.getAttribute('icon') + '"></ons-icon>');
+        icon.classList.add(this._defaultClassName.replace('button', 'icon'));
+        this.insertBefore(icon, this.firstChild);
+      }
+
+      this._updateRipple();
+
+      ModifierUtil.initModifier(this, this._scheme);
+    }
+  }, {
+    key: '_updateIcon',
+    value: function _updateIcon() {
+      if (this._icon) {
+        this._icon.setAttribute('icon', this.getAttribute('icon'));
+      }
+    }
+  }, {
+    key: '_updateRipple',
+    value: function _updateRipple() {
+      this._rippleOpt && util$1.updateRipple.apply(util$1, toConsumableArray(this._rippleOpt));
+    }
+  }, {
+    key: 'attributeChangedCallback',
+    value: function attributeChangedCallback(name, last, current) {
+      switch (name) {
+        case 'class':
+          util$1.restoreClass(this, this._defaultClassName, this._scheme);
+          break;
+        case 'modifier':
+          ModifierUtil.onModifierChanged(last, current, this, this._scheme);
+          break;
+        case 'icon':
+          this._updateIcon();
+          break;
+        case 'ripple':
+          this.classList.contains(this._defaultClassName) && this._updateRipple();
+          break;
+      }
+    }
+  }, {
+    key: 'disabled',
+    set: function set$$1(value) {
+      return util$1.toggleAttribute(this, 'disabled', value);
+    },
+    get: function get$$1() {
+      return this.hasAttribute('disabled');
+    }
+  }, {
+    key: '_icon',
+    get: function get$$1() {
+      return util$1.findChild(this, 'ons-icon');
+    }
+  }], [{
+    key: 'observedAttributes',
+    get: function get$$1() {
+      return ['modifier', 'class', 'icon', 'ripple'];
+    }
+  }]);
+  return BaseButtonElement;
+}(BaseElement);
+
+/*
+Copyright 2013-2015 ASIAL CORPORATION
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+   http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+*/
+
+/**
+ * @element ons-action-sheet-button
+ * @category dialog
+ * @modifier destructive
+ *   [en]Shows a "destructive" button (only for iOS).[/en]
+ *   [ja]"destructive"なボタンを表示します(iOSでのみ有効)。[/ja]
+ * @description
+ *   [en]Component that represent each button of the action sheet.[/en]
+ *   [ja]アクションシートに表示される各ボタンを表現するコンポーネントです。[/ja]
+ * @seealso ons-action-sheet
+ *   [en]The `<ons-action-sheet>` component[/en]
+ *   [ja]ons-action-sheetコンポーネント[/ja]
+ * @seealso ons-list-item
+ *   [en]The `<ons-list-item>` component[/en]
+ *   [ja]ons-list-itemコンポーネント[/ja]
+ * @seealso ons-icon
+ *   [en]The `<ons-icon>` component[/en]
+ *   [ja]ons-iconコンポーネント[/ja]
+ * @tutorial vanilla/Reference/action-sheet
+ * @guide appsize.html#removing-icon-packs [en]Removing icon packs.[/en][ja][/ja]
+ * @guide faq.html#how-can-i-use-custom-icon-packs [en]Adding custom icon packs.[/en][ja][/ja]
+ * @modifier material
+ *   [en]Display a Material Design action sheet button.[/en]
+ *   [ja]マテリアルデザインのアクションシート用のボタンを表示します。[/ja]
+ * @example
+ * <ons-action-sheet id="sheet">
+ *   <ons-action-sheet-button>Label</ons-action-sheet-button>
+ *   <ons-action-sheet-button>Label</ons-action-sheet-button>
+ * </ons-action-sheet>
+ *
+ * <script>
+ *   document.getElementById('sheet').show();
+ * </script>
+ */
+
+var ActionSheetButtonElement = function (_BaseButtonElement) {
+  inherits(ActionSheetButtonElement, _BaseButtonElement);
+
+  function ActionSheetButtonElement() {
+    classCallCheck(this, ActionSheetButtonElement);
+    return possibleConstructorReturn(this, (ActionSheetButtonElement.__proto__ || Object.getPrototypeOf(ActionSheetButtonElement)).apply(this, arguments));
+  }
+
+  createClass(ActionSheetButtonElement, [{
+    key: '_scheme',
+
+
+    /**
+     * @attribute icon
+     * @type {String}
+     * @description
+     *  [en]Creates an `ons-icon` component with this string. Only visible on Android. Check [See also](#seealso) section for more information.[/en]
+     *  [ja]`ons-icon`コンポーネントを悪性します。Androidでのみ表示されます。[/ja]
+     */
+
+    /**
+     * @attribute modifier
+     * @type {String}
+     * @description
+     *   [en]The appearance of the action sheet button.[/en]
+     *   [ja]アクションシートボタンの見た目を設定します。[/ja]
+     */
+
+    get: function get$$1() {
+      return {
+        '': 'action-sheet-button--*',
+        '.action-sheet-icon': 'action-sheet-icon--*'
+      };
+    }
+  }, {
+    key: '_defaultClassName',
+    get: function get$$1() {
+      return 'action-sheet-button';
+    }
+  }, {
+    key: '_rippleOpt',
+    get: function get$$1() {
+      return undefined;
+    }
+  }]);
+  return ActionSheetButtonElement;
+}(BaseButtonElement);
+
+onsElements.ActionSheetButton = ActionSheetButtonElement;
+customElements.define('ons-action-sheet-button', ActionSheetButtonElement);
+
+/*
+Copyright 2013-2015 ASIAL CORPORATION
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+   http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+*/
+
+var AlertDialogAnimator = function (_BaseAnimator) {
+  inherits(AlertDialogAnimator, _BaseAnimator);
+
+  function AlertDialogAnimator() {
+    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
+        _ref$timing = _ref.timing,
+        timing = _ref$timing === undefined ? 'linear' : _ref$timing,
+        _ref$delay = _ref.delay,
+        delay = _ref$delay === undefined ? 0 : _ref$delay,
+        _ref$duration = _ref.duration,
+        duration = _ref$duration === undefined ? 0.2 : _ref$duration;
+
+    classCallCheck(this, AlertDialogAnimator);
+    return possibleConstructorReturn(this, (AlertDialogAnimator.__proto__ || Object.getPrototypeOf(AlertDialogAnimator)).call(this, { timing: timing, delay: delay, duration: duration }));
+  }
+
+  /**
+   * @param {HTMLElement} dialog
+   * @param {Function} done
+   */
+
+
+  createClass(AlertDialogAnimator, [{
+    key: 'show',
+    value: function show(dialog, done) {
+      done();
+    }
+
+    /**
+     * @param {HTMLElement} dialog
+     * @param {Function} done
+     */
+
+  }, {
+    key: 'hide',
+    value: function hide(dialog, done) {
+      done();
+    }
+  }]);
+  return AlertDialogAnimator;
+}(BaseAnimator);
+
+/**
+ * Android style animator for alert dialog.
+ */
+var AndroidAlertDialogAnimator = function (_AlertDialogAnimator) {
+  inherits(AndroidAlertDialogAnimator, _AlertDialogAnimator);
+
+  function AndroidAlertDialogAnimator() {
+    var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
+        _ref2$timing = _ref2.timing,
+        timing = _ref2$timing === undefined ? 'cubic-bezier(.1, .7, .4, 1)' : _ref2$timing,
+        _ref2$duration = _ref2.duration,
+        duration = _ref2$duration === undefined ? 0.2 : _ref2$duration,
+        _ref2$delay = _ref2.delay,
+        delay = _ref2$delay === undefined ? 0 : _ref2$delay;
+
+    classCallCheck(this, AndroidAlertDialogAnimator);
+    return possibleConstructorReturn(this, (AndroidAlertDialogAnimator.__proto__ || Object.getPrototypeOf(AndroidAlertDialogAnimator)).call(this, { duration: duration, timing: timing, delay: delay }));
+  }
+
+  /**
+   * @param {Object} dialog
+   * @param {Function} callback
+   */
+
+
+  createClass(AndroidAlertDialogAnimator, [{
+    key: 'show',
+    value: function show(dialog, callback) {
+      callback = callback ? callback : function () {};
+
+      Animit.runAll(Animit(dialog._mask, this.def).default({ opacity: 0 }, { opacity: 1 }), Animit(dialog._dialog, this.def).default({ transform: 'translate3d(-50%, -50%, 0) scale3d(.9, .9, 1)', opacity: 0 }, { transform: 'translate3d(-50%, -50%, 0) scale3d(1, 1, 1)', opacity: 1 }).queue(function (done) {
+        callback();
+        done();
+      }));
+    }
+
+    /**
+     * @param {Object} dialog
+     * @param {Function} callback
+     */
+
+  }, {
+    key: 'hide',
+    value: function hide(dialog, callback) {
+      callback = callback ? callback : function () {};
+
+      Animit.runAll(Animit(dialog._mask, this.def).default({ opacity: 1 }, { opacity: 0 }), Animit(dialog._dialog, this.def).default({ transform: 'translate3d(-50%, -50%, 0) scale3d(1, 1, 1)', opacity: 1 }, { transform: 'translate3d(-50%, -50%, 0) scale3d(.9, .9, 1)', opacity: 0 }).queue(function (done) {
+        callback();
+        done();
+      }));
+    }
+  }]);
+  return AndroidAlertDialogAnimator;
+}(AlertDialogAnimator);
+
+/**
+ * iOS style animator for alert dialog.
+ */
+var IOSAlertDialogAnimator = function (_AlertDialogAnimator2) {
+  inherits(IOSAlertDialogAnimator, _AlertDialogAnimator2);
+
+  function IOSAlertDialogAnimator() {
+    var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
+        _ref3$timing = _ref3.timing,
+        timing = _ref3$timing === undefined ? 'cubic-bezier(.1, .7, .4, 1)' : _ref3$timing,
+        _ref3$duration = _ref3.duration,
+        duration = _ref3$duration === undefined ? 0.2 : _ref3$duration,
+        _ref3$delay = _ref3.delay,
+        delay = _ref3$delay === undefined ? 0 : _ref3$delay;
+
+    classCallCheck(this, IOSAlertDialogAnimator);
+    return possibleConstructorReturn(this, (IOSAlertDialogAnimator.__proto__ || Object.getPrototypeOf(IOSAlertDialogAnimator)).call(this, { duration: duration, timing: timing, delay: delay }));
+  }
+
+  /*
+   * @param {Object} dialog
+   * @param {Function} callback
+   */
+
+
+  createClass(IOSAlertDialogAnimator, [{
+    key: 'show',
+    value: function show(dialog, callback) {
+      callback = callback ? callback : function () {};
+
+      Animit.runAll(Animit(dialog._mask, this.def).default({ opacity: 0 }, { opacity: 1 }), Animit(dialog._dialog, this.def).default({ transform: 'translate3d(-50%, -50%, 0) scale3d(1.3, 1.3, 1)', opacity: 0 }, { transform: 'translate3d(-50%, -50%, 0) scale3d(1, 1, 1)', opacity: 1 }).queue(function (done) {
+        callback();
+        done();
+      }));
+    }
+
+    /**
+     * @param {Object} dialog
+     * @param {Function} callback
+     */
+
+  }, {
+    key: 'hide',
+    value: function hide(dialog, callback) {
+      callback = callback ? callback : function () {};
+
+      Animit.runAll(Animit(dialog._mask, this.def).default({ opacity: 1 }, { opacity: 0 }), Animit(dialog._dialog, this.def).default({ opacity: 1 }, { opacity: 0 }).queue(function (done) {
+        callback();
+        done();
+      }));
+    }
+  }]);
+  return IOSAlertDialogAnimator;
+}(AlertDialogAnimator);
+
+/*
+Copyright 2013-2015 ASIAL CORPORATION
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+   http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+*/
+
+var scheme$1 = {
+  '.alert-dialog': 'alert-dialog--*',
+  '.alert-dialog-container': 'alert-dialog-container--*',
+  '.alert-dialog-title': 'alert-dialog-title--*',
+  '.alert-dialog-content': 'alert-dialog-content--*',
+  '.alert-dialog-footer': 'alert-dialog-footer--*',
+  '.alert-dialog-footer--rowfooter': 'alert-dialog-footer--rowfooter--*',
+  '.alert-dialog-button--rowfooter': 'alert-dialog-button--rowfooter--*',
+  '.alert-dialog-button--primal': 'alert-dialog-button--primal--*',
+  '.alert-dialog-button': 'alert-dialog-button--*',
+  'ons-alert-dialog-button': 'alert-dialog-button--*',
+  '.alert-dialog-mask': 'alert-dialog-mask--*',
+  '.text-input': 'text-input--*'
+};
+
+var _animatorDict$1 = {
+  'none': AlertDialogAnimator,
+  'default': function _default() {
+    return platform.isAndroid() ? AndroidAlertDialogAnimator : IOSAlertDialogAnimator;
+  },
+  'fade': function fade() {
+    return platform.isAndroid() ? AndroidAlertDialogAnimator : IOSAlertDialogAnimator;
+  }
+};
+
+/**
+ * @element ons-alert-dialog
+ * @category dialog
+ * @description
+ *   [en]
+ *     Alert dialog that is displayed on top of the current screen. Useful for displaying questions, warnings or error messages to the user. The title, content and buttons can be easily customized and it will automatically switch style based on the platform.
+ *
+ *     To use the element it can either be attached directly to the `<body>` element or dynamically created from a template using the `ons.createAlertDialog(template)` utility function and the `<template>` tag.
+ *   [/en]
+ *   [ja]
+ *     現在のスクリーンの上に表示するアラートダイアログです。ユーザに対する問いかけ、警告、エラーメッセージを表示するのに利用できます。タイトルやコンテンツやボタンは簡単にカスタマイズでき、実行しているプラットフォームに併せてスタイルが自動的に切り替わります。
+ *   [/ja]
+ * @codepen Qwwxyp
+ * @tutorial vanilla/Reference/alert-dialog
+ * @modifier material
+ *   [en]Material Design style[/en]
+ *   [ja]マテリアルデザインのスタイル[/ja]
+ * @modifier rowfooter
+ *   [en]Horizontally aligns the footer buttons.[/en]
+ *   [ja]フッターの複数のボタンを水平に配置[/ja]
+ * @seealso ons-dialog
+ *   [en]ons-dialog component[/en]
+ *   [ja]ons-dialogコンポーネント[/ja]
+ * @seealso ons-popover
+ *   [en]ons-popover component[/en]
+ *   [ja]ons-dialogコンポーネント[/ja]
+ * @seealso ons.notification
+ *   [en]Using ons.notification utility functions.[/en]
+ *   [ja]アラートダイアログを表示するには、ons.notificationオブジェクトのメソッドを使うこともできます。[/ja]
+ * @example
+ * <ons-alert-dialog id="alert-dialog">
+ *   <div class="alert-dialog-title">Warning!</div>
+ *   <div class="alert-dialog-content">
+ *     An error has occurred!
+ *   </div>
+ *   <div class="alert-dialog-footer">
+ *     <button id="alert-dialog-button" class="alert-dialog-button">OK</button>
+ *   </div>
+ * </ons-alert-dialog>
+ * <script>
+ *   document.getElementById('alert-dialog').show();
+ * </script>
+ */
+
+var AlertDialogElement = function (_BaseDialogElement) {
+  inherits(AlertDialogElement, _BaseDialogElement);
+
+  /**
+   * @event preshow
+   * @description
+   *   [en]Fired just before the alert dialog is displayed.[/en]
+   *   [ja]アラートダイアログが表示される直前に発火します。[/ja]
+   * @param {Object} event [en]Event object.[/en]
+   * @param {Object} event.alertDialog
+   *   [en]Alert dialog object.[/en]
+   *   [ja]アラートダイアログのオブジェクト。[/ja]
+   * @param {Function} event.cancel
+   *   [en]Execute to stop the dialog from showing.[/en]
+   *   [ja]この関数を実行すると、アラートダイアログの表示を止めます。[/ja]
+   */
+
+  /**
+   * @event postshow
+   * @description
+   *   [en]Fired just after the alert dialog is displayed.[/en]
+   *   [ja]アラートダイアログが表示された直後に発火します。[/ja]
+   * @param {Object} event [en]Event object.[/en]
+   * @param {Object} event.alertDialog
+   *   [en]Alert dialog object.[/en]
+   *   [ja]アラートダイアログのオブジェクト。[/ja]
+   */
+
+  /**
+   * @event prehide
+   * @description
+   *   [en]Fired just before the alert dialog is hidden.[/en]
+   *   [ja]アラートダイアログが隠れる直前に発火します。[/ja]
+   * @param {Object} event [en]Event object.[/en]
+   * @param {Object} event.alertDialog
+   *   [en]Alert dialog object.[/en]
+   *   [ja]アラートダイアログのオブジェクト。[/ja]
+   * @param {Function} event.cancel
+   *   [en]Execute to stop the dialog from hiding.[/en]
+   *   [ja]この関数を実行すると、アラートダイアログが閉じようとするのを止めます。[/ja]
+   */
+
+  /**
+   * @event posthide
+   * @description
+   * [en]Fired just after the alert dialog is hidden.[/en]
+   * [ja]アラートダイアログが隠れた後に発火します。[/ja]
+   * @param {Object} event [en]Event object.[/en]
+   * @param {Object} event.alertDialog
+   *   [en]Alert dialog object.[/en]
+   *   [ja]アラートダイアログのオブジェクト。[/ja]
+   */
+
+  /**
+   * @attribute modifier
+   * @type {String}
+   * @description
+   *  [en]The appearance of the dialog.[/en]
+   *  [ja]ダイアログの見た目を指定します。[/ja]
+   */
+
+  /**
+   * @attribute cancelable
+   * @description
+   *  [en]If this attribute is set the dialog can be closed by tapping the background or by pressing the back button on Android devices.[/en]
+   *  [ja]この属性を設定すると、ダイアログの背景をタップしたりAndroidデバイスのバックボタンを押すとダイアログが閉じるようになります。[/ja]
+   */
+
+  /**
+   * @attribute disabled
+   * @description
+   *  [en]If this attribute is set the dialog is disabled.[/en]
+   *  [ja]この属性がある時、アラートダイアログはdisabled状態になります。[/ja]
+   */
+
+  /**
+   * @attribute animation
+   * @type {String}
+   * @default default
+   * @description
+   *  [en]The animation used when showing and hiding the dialog. Can be either `"none"` or `"default"`.[/en]
+   *  [ja]ダイアログを表示する際のアニメーション名を指定します。デフォルトでは"none"か"default"が指定できます。[/ja]
+   */
+
+  /**
+   * @attribute animation-options
+   * @type {Expression}
+   * @description
+   *  [en]Specify the animation's duration, timing and delay with an object literal. E.g. `{duration: 0.2, delay: 1, timing: 'ease-in'}`.[/en]
+   *  [ja]アニメーション時のduration, timing, delayをオブジェクトリテラルで指定します。例：{duration: 0.2, delay: 1, timing: 'ease-in'}[/ja]
+   */
+
+  /**
+   * @attribute mask-color
+   * @type {String}
+   * @default rgba(0, 0, 0, 0.2)
+   * @description
+   *  [en]Color of the background mask. Default is "rgba(0, 0, 0, 0.2)".[/en]
+   *  [ja]背景のマスクの色を指定します。"rgba(0, 0, 0, 0.2)"がデフォルト値です。[/ja]
+   */
+
+  function AlertDialogElement() {
+    classCallCheck(this, AlertDialogElement);
+
+    var _this = possibleConstructorReturn(this, (AlertDialogElement.__proto__ || Object.getPrototypeOf(AlertDialogElement)).call(this));
+
+    contentReady(_this, function () {
+      return _this._compile();
+    });
+    return _this;
+  }
+
+  createClass(AlertDialogElement, [{
+    key: '_updateAnimatorFactory',
+    value: function _updateAnimatorFactory() {
+      return new AnimatorFactory({
+        animators: _animatorDict$1,
+        baseClass: AlertDialogAnimator,
+        baseClassName: 'AlertDialogAnimator',
+        defaultAnimation: this.getAttribute('animation')
+      });
+    }
+  }, {
+    key: '_compile',
+    value: function _compile() {
+      autoStyle.prepare(this);
+
+      this.style.display = 'none';
+      this.style.zIndex = 10001;
+
+      /**
+       * Expected result after compile:
+       *
+       * <ons-alert-dialog style="none">
+       *   <div class="alert-dialog-mask"></div>
+       *   <div class="alert-dialog">
+       *     <div class="alert-dialog-container">...</div>
+       *   </div>
+       * </ons-alert-dialog>
+       */
+
+      var content = document.createDocumentFragment();
+
+      if (!this._mask && !this._dialog) {
+        while (this.firstChild) {
+          content.appendChild(this.firstChild);
+        }
+      }
+
+      if (!this._mask) {
+        var mask = document.createElement('div');
+        mask.classList.add('alert-dialog-mask');
+        this.insertBefore(mask, this.children[0]);
+      }
+
+      if (!this._dialog) {
+        var dialog = document.createElement('div');
+        dialog.classList.add('alert-dialog');
+        this.insertBefore(dialog, null);
+      }
+
+      if (!util$1.findChild(this._dialog, '.alert-dialog-container')) {
+        var container = document.createElement('div');
+        container.classList.add('alert-dialog-container');
+        this._dialog.appendChild(container);
+      }
+
+      this._dialog.children[0].appendChild(content);
+
+      this._dialog.style.zIndex = 20001;
+      this._mask.style.zIndex = 20000;
+
+      ModifierUtil.initModifier(this, this._scheme);
+    }
+
+    /**
+     * @property disabled
+     * @type {Boolean}
+     * @description
+     *   [en]Whether the element is disabled or not.[/en]
+     *   [ja]無効化されている場合に`true`。[/ja]
+     */
+
+    /**
+     * @property cancelable
+     * @type {Boolean}
+     * @description
+     *   [en]Whether the dialog is cancelable or not. A cancelable dialog can be closed by tapping the background or by pressing the back button on Android devices.[/en]
+     *   [ja]そのダイアログがキャンセル可能かどうかを表します。キャンセル可能なダイアログは、背景をタップするかAndroidデバイスのバックボタンを押すことで閉じることが出来るようになります。[/ja]
+     */
+
+    /**
+     * @method show
+     * @signature show([options])
+     * @param {Object} [options]
+     *   [en]Parameter object.[/en]
+     *   [ja]オプションを指定するオブジェクトです。[/ja]
+     * @param {String} [options.animation]
+     *   [en]Animation name. Available animations are `"fade"` and `"none"`.[/en]
+     *   [ja]アニメーション名を指定します。指定できるのは、"fade", "none"のいずれかです。[/ja]
+     * @param {String} [options.animationOptions]
+     *   [en]Specify the animation's duration, delay and timing. E.g.  `{duration: 0.2, delay: 0.4, timing: 'ease-in'}`.[/en]
+     *   [ja]アニメーション時のduration, delay, timingを指定します。e.g. <code>{duration: 0.2, delay: 0.4, timing: 'ease-in'}</code> [/ja]
+     * @param {Function} [options.callback]
+     *   [en]Function to execute after the dialog has been revealed.[/en]
+     *   [ja]ダイアログが表示され終わった時に呼び出されるコールバックを指定します。[/ja]
+     * @description
+     *   [en]Show the alert dialog.[/en]
+     *   [ja]ダイアログを表示します。[/ja]
+     * @return {Promise}
+     *   [en]A `Promise` object that resolves to the displayed element.[/en]
+     *   [ja]表示される要素を解決する`Promise`オブジェクトを返します。[/ja]
+     */
+
+    /**
+     * @method hide
+     * @signature hide([options])
+     * @param {Object} [options]
+     *   [en]Parameter object.[/en]
+     *   [ja]オプションを指定するオブジェクト。[/ja]
+     * @param {String} [options.animation]
+     *   [en]Animation name. Available animations are `"fade"` and `"none"`.[/en]
+     *   [ja]アニメーション名を指定します。"fade", "none"のいずれかを指定します。[/ja]
+     * @param {String} [options.animationOptions]
+     *   [en]Specify the animation's duration, delay and timing. E.g.  <code>{duration: 0.2, delay: 0.4, timing: 'ease-in'}</code>[/en]
+     *   [ja]アニメーション時のduration, delay, timingを指定します。e.g. <code>{duration: 0.2, delay: 0.4, timing: 'ease-in'}</code> [/ja]
+     * @param {Function} [options.callback]
+     *   [en]Function to execute after the dialog has been hidden.[/en]
+     *   [ja]このダイアログが閉じた時に呼び出されるコールバックを指定します。[/ja]
+     * @description
+     *   [en]Hide the alert dialog.[/en]
+     *   [ja]ダイアログを閉じます。[/ja]
+     * @return {Promise}
+     *   [en]Resolves to the hidden element[/en]
+     *   [ja]隠れた要素を解決する`Promise`オブジェクトを返します。[/ja]
+     */
+
+    /**
+     * @property visible
+     * @readonly
+     * @type {Boolean}
+     * @description
+     *   [en]Whether the dialog is visible or not.[/en]
+     *   [ja]要素が見える場合に`true`。[/ja]
+     */
+
+    /**
+     * @property onDeviceBackButton
+     * @type {Object}
+     * @description
+     *   [en]Back-button handler.[/en]
+     *   [ja]バックボタンハンドラ。[/ja]
+     */
+
+    /**
+     * @param {String} name
+     * @param {DialogAnimator} Animator
+     */
+
+  }, {
+    key: '_scheme',
+    get: function get$$1() {
+      return scheme$1;
+    }
+
+    /**
+     * @return {Element}
+     */
+
+  }, {
+    key: '_mask',
+    get: function get$$1() {
+      return util$1.findChild(this, '.alert-dialog-mask');
+    }
+
+    /**
+     * @return {Element}
+     */
+
+  }, {
+    key: '_dialog',
+    get: function get$$1() {
+      return util$1.findChild(this, '.alert-dialog');
+    }
+
+    /**
+     * @return {Element}
+     */
+
+  }, {
+    key: '_titleElement',
+    get: function get$$1() {
+      return util$1.findChild(this._dialog.children[0], '.alert-dialog-title');
+    }
+
+    /**
+     * @return {Element}
+     */
+
+  }, {
+    key: '_contentElement',
+    get: function get$$1() {
+      return util$1.findChild(this._dialog.children[0], '.alert-dialog-content');
+    }
+  }], [{
+    key: 'registerAnimator',
+    value: function registerAnimator(name, Animator) {
+      if (!(Animator.prototype instanceof AlertDialogAnimator)) {
+        util$1.throwAnimator('AlertDialog');
+      }
+      _animatorDict$1[name] = Animator;
+    }
+  }, {
+    key: 'animators',
+    get: function get$$1() {
+      return _animatorDict$1;
+    }
+  }, {
+    key: 'AlertDialogAnimator',
+    get: function get$$1() {
+      return AlertDialogAnimator;
+    }
+  }]);
+  return AlertDialogElement;
+}(BaseDialogElement);
+
+onsElements.AlertDialog = AlertDialogElement;
+customElements.define('ons-alert-dialog', AlertDialogElement);
+
+/*
+Copyright 2013-2015 ASIAL CORPORATION
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+   http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+*/
+
+/**
+ * @element ons-alert-dialog-button
+ * @modifier material
+ *   [en]Material Design alert-dialog button.[/en]
+ *   [ja]マテリアルデザインのボタンを表示します。[/ja]
+ * @description
+ *   [en][/en]
+ *   [ja][/ja]
+ * @seealso ons-alert-dialog
+ *   [en]The `<ons-alert-dialog>` component displays a alert dialog.[/en]
+ *   [ja]ons-alert-dialogコンポーネント[/ja]
+ * @example
+ *  <ons-alert-dialog>
+ *    <div class="alert-dialog-title">Warning!</div>
+ *    <div class="alert-dialog-content">
+ *      An error has occurred!
+ *    </div>
+ *    <div class="alert-dialog-footer">
+ *      <alert-dialog-button onclick="app.close()">Cancel</alert-dialog-button>
+ *      <alert-dialog-button class="alert-dialog-button" onclick="app.close()">OK</alert-dialog-button>
+ *    </div>
+ *  </ons-alert-dialog>
+ */
+
+var AlertDialogButtonElement = function (_BaseButtonElement) {
+  inherits(AlertDialogButtonElement, _BaseButtonElement);
+
+  function AlertDialogButtonElement() {
+    classCallCheck(this, AlertDialogButtonElement);
+    return possibleConstructorReturn(this, (AlertDialogButtonElement.__proto__ || Object.getPrototypeOf(AlertDialogButtonElement)).apply(this, arguments));
+  }
+
+  createClass(AlertDialogButtonElement, [{
+    key: '_scheme',
+
+
+    /**
+     * @attribute modifier
+     * @type {String}
+     * @description
+     *   [en]The appearance of the button.[/en]
+     *   [ja]ボタンの表現を指定します。[/ja]
+     */
+
+    /**
+     * @attribute disabled
+     * @description
+     *   [en]Specify if button should be disabled.[/en]
+     *   [ja]ボタンを無効化する場合は指定してください。[/ja]
+     */
+
+    /**
+     * @property disabled
+     * @type {Boolean}
+     * @description
+     *   [en]Whether the element is disabled or not.[/en]
+     *   [ja]無効化されている場合に`true`。[/ja]
+     */
+
+    get: function get$$1() {
+      return { '': 'alert-dialog-button--*' };
+    }
+  }, {
+    key: '_defaultClassName',
+    get: function get$$1() {
+      return 'alert-dialog-button';
+    }
+  }, {
+    key: '_rippleOpt',
+    get: function get$$1() {
+      return [this, undefined, { 'modifier': 'light-gray' }];
+    }
+  }]);
+  return AlertDialogButtonElement;
+}(BaseButtonElement);
+
+onsElements.AlertDialogButton = AlertDialogButtonElement;
+customElements.define('ons-alert-dialog-button', AlertDialogButtonElement);
+
+var iosBackButtonIcon = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<svg width=\"13px\" height=\"21px\" viewBox=\"0 0 13 21\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\">\n    <title>ios-back-button-icon</title>\n    <desc>Created with Sketch.</desc>\n    <defs></defs>\n    <g id=\"toolbar-back-button\" stroke=\"none\" stroke-width=\"1\" fill-rule=\"evenodd\">\n        <g id=\"ios\" transform=\"translate(-34.000000, -30.000000)\">\n            <polygon id=\"ios-back-button-icon\" points=\"34 40.5 44.5 30 46.5 32 38 40.5 46.5 49 44.5 51\"></polygon>\n        </g>\n    </g>\n</svg>\n";
+
+var mdBackButtonIcon = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<svg width=\"16px\" height=\"16px\" viewBox=\"0 0 16 16\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\">\n    <title>md-back-button-icon</title>\n    <desc>Created with Sketch.</desc>\n    <defs></defs>\n    <g id=\"toolbar-back-button\" stroke=\"none\" stroke-width=\"1\" fill-rule=\"evenodd\">\n        <g id=\"android\" transform=\"translate(-32.000000, -32.000000)\" fill-rule=\"nonzero\">\n            <polygon id=\"md-back-button-icon\" points=\"48 39 35.83 39 41.42 33.41 40 32 32 40 40 48 41.41 46.59 35.83 41 48 41\"></polygon>\n        </g>\n    </g>\n</svg>\n";
+
+/*
+Copyright 2013-2015 ASIAL CORPORATION
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+   http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+*/
+
+var defaultClassName = 'back-button';
+
+var scheme$2 = {
+  '': 'back-button--*',
+  '.back-button__icon': 'back-button--*__icon',
+  '.back-button__label': 'back-button--*__label'
+};
+
+/**
+ * @element ons-back-button
+ * @category navigation
+ * @description
+ *   [en]
+ *     Back button component for `<ons-toolbar>`. Put it in the left part of the `<ons-toolbar>`.
+ *
+ *     It will find the parent `<ons-navigator>` element and pop a page when clicked. This behavior can be overriden by specifying the `onClick` property.
+ *   [/en]
+ *   [ja][/ja]
+ * @codepen aHmGL
+ * @tutorial vanilla/Reference/back-button
+ * @modifier material
+ *   [en]Material Design style[/en]
+ *   [ja][/ja]
+ * @seealso ons-toolbar
+ *   [en]ons-toolbar component[/en]
+ *   [ja]ons-toolbarコンポーネント[/ja]
+ * @seealso ons-navigator
+ *   [en]ons-navigator component[/en]
+ *   [ja]ons-navigatorコンポーネント[/ja]
+ * @example
+ * <ons-toolbar>
+ *   <div class="left">
+ *     <ons-back-button>Back</ons-back-button>
+ *   </div>
+ *   <div class="center">
+ *     Title
+ *   <div>
+ * </ons-toolbar>
+ */
+
+var BackButtonElement = function (_BaseElement) {
+  inherits(BackButtonElement, _BaseElement);
+
+  /**
+   * @attribute modifier
+   * @type {String}
+   * @description
+   *  [en]The appearance of the back button.[/en]
+   *  [ja]バックボタンの見た目を指定します。[/ja]
+   */
+
+  function BackButtonElement() {
+    classCallCheck(this, BackButtonElement);
+
+    var _this = possibleConstructorReturn(this, (BackButtonElement.__proto__ || Object.getPrototypeOf(BackButtonElement)).call(this));
+
+    contentReady(_this, function () {
+      _this._compile();
+    });
+
+    _this._options = {};
+    _this._boundOnClick = _this._onClick.bind(_this);
+    return _this;
+  }
+
+  createClass(BackButtonElement, [{
+    key: '_updateIcon',
+    value: function _updateIcon() {
+      var icon = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : util$1.findChild(this, '.back-button__icon');
+
+      icon.innerHTML = autoStyle.getPlatform(this) === 'android' || util$1.hasModifier(this, 'material') ? mdBackButtonIcon : iosBackButtonIcon;
+    }
+  }, {
+    key: '_compile',
+    value: function _compile() {
+      autoStyle.prepare(this);
+
+      this.classList.add(defaultClassName);
+
+      if (!util$1.findChild(this, '.back-button__label')) {
+        var label = util$1.create('span.back-button__label');
+
+        while (this.childNodes[0]) {
+          label.appendChild(this.childNodes[0]);
+        }
+        this.appendChild(label);
+      }
+
+      if (!util$1.findChild(this, '.back-button__icon')) {
+        var icon = util$1.create('span.back-button__icon');
+        this._updateIcon(icon);
+
+        this.insertBefore(icon, this.children[0]);
+      }
+
+      util$1.updateRipple(this, undefined, { center: '', 'size': 'contain', 'background': 'transparent' });
+
+      ModifierUtil.initModifier(this, scheme$2);
+    }
+
+    /**
+     * @property options
+     * @type {Object}
+     * @description
+     *   [en]Options object.[/en]
+     *   [ja]オプションを指定するオブジェクト。[/ja]
+     */
+
+    /**
+     * @property options.animation
+     * @type {String}
+     * @description
+     *   [en]Animation name. Available animations are "slide", "lift", "fade" and "none".
+     *     These are platform based animations. For fixed animations, add "-ios" or "-md"
+     *     suffix to the animation name. E.g. "lift-ios", "lift-md". Defaults values are "slide-ios" and "fade-md".
+     *   [/en]
+     *   [ja][/ja]
+     */
+
+    /**
+     * @property options.animationOptions
+     * @type {String}
+     * @description
+     *   [en]Specify the animation's duration, delay and timing. E.g.  `{duration: 0.2, delay: 0.4, timing: 'ease-in'}`[/en]
+     *   [ja]アニメーション時のduration, delay, timingを指定します。e.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}` [/ja]
+     */
+
+    /**
+     * @property options.callback
+     * @type {String}
+     * @description
+     *   [en]Function that is called when the transition has ended.[/en]
+     *   [ja]このメソッドによる画面遷移が終了した際に呼び出される関数オブジェクトを指定します。[/ja]
+     */
+
+  }, {
+    key: '_onClick',
+
+
+    /**
+     * @property onClick
+     * @type {Function}
+     * @description
+     *   [en]Used to override the default back button behavior.[/en]
+     *   [ja][/ja]
+     */
+    value: function _onClick() {
+      if (this.onClick) {
+        this.onClick.apply(this);
+      } else {
+        var navigator = util$1.findParent(this, 'ons-navigator');
+        if (navigator) {
+          navigator.popPage(this.options);
+        }
+      }
+    }
+  }, {
+    key: 'connectedCallback',
+    value: function connectedCallback() {
+      this.addEventListener('click', this._boundOnClick, false);
+    }
+  }, {
+    key: 'attributeChangedCallback',
+    value: function attributeChangedCallback(name, last, current) {
+      switch (name) {
+        case 'class':
+          util$1.restoreClass(this, defaultClassName, scheme$2);
+          break;
+
+        case 'modifier':
+          {
+            ModifierUtil.onModifierChanged(last, current, this, scheme$2) && this._updateIcon();
+            break;
+          }
+      }
+    }
+  }, {
+    key: 'disconnectedCallback',
+    value: function disconnectedCallback() {
+      this.removeEventListener('click', this._boundOnClick, false);
+    }
+  }, {
+    key: 'show',
+    value: function show() {
+      this.style.display = 'inline-block';
+    }
+  }, {
+    key: 'hide',
+    value: function hide() {
+      this.style.display = 'none';
+    }
+  }, {
+    key: 'options',
+    get: function get$$1() {
+      return this._options;
+    },
+    set: function set$$1(object) {
+      this._options = object;
+    }
+  }], [{
+    key: 'observedAttributes',
+    get: function get$$1() {
+      return ['modifier', 'class'];
+    }
+  }]);
+  return BackButtonElement;
+}(BaseElement);
+
+onsElements.BackButton = BackButtonElement;
+customElements.define('ons-back-button', BackButtonElement);
+
+/*
+Copyright 2013-2015 ASIAL CORPORATION
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+   http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+*/
+
+var defaultClassName$1 = 'bottom-bar';
+var scheme$3 = { '': 'bottom-bar--*' };
+
+/**
+ * @element ons-bottom-toolbar
+ * @category page
+ * @description
+ *   [en]Toolbar component that is positioned at the bottom of the page. Since bottom toolbars are very versatile elements, `ons-bottom-toolbar` does not provide any specific layout syntax for its children. Modifiers or custom CSS must be used.[/en]
+ *   [ja]ページ下部に配置されるツールバー用コンポーネントです。[/ja]
+ * @modifier transparent
+ *   [en]Make the toolbar transparent.[/en]
+ *   [ja]ツールバーの背景を透明にして表示します。[/ja]
+ * @modifier aligned
+ *   [en]Vertically aligns its children and applies flexbox for block elements. `justify-content` CSS rule can be used to change horizontal align.[/en]
+ *   [ja]ツールバーの背景を透明にして表示します。[/ja]
+ * @seealso ons-toolbar [en]ons-toolbar component[/en][ja]ons-toolbarコンポーネント[/ja]
+ * @example
+ * <ons-bottom-toolbar>
+ *   Content
+ * </ons-bottom-toolbar>
+ */
+
+var BottomToolbarElement = function (_BaseElement) {
+  inherits(BottomToolbarElement, _BaseElement);
+
+  /**
+   * @attribute modifier
+   * @type {String}
+   * @description
+   *   [en]The appearance of the toolbar.[/en]
+   *   [ja]ツールバーの見た目の表現を指定します。[/ja]
+   */
+
+  function BottomToolbarElement() {
+    classCallCheck(this, BottomToolbarElement);
+
+    var _this = possibleConstructorReturn(this, (BottomToolbarElement.__proto__ || Object.getPrototypeOf(BottomToolbarElement)).call(this));
+
+    _this.classList.add(defaultClassName$1);
+    ModifierUtil.initModifier(_this, scheme$3);
+    return _this;
+  }
+
+  createClass(BottomToolbarElement, [{
+    key: 'attributeChangedCallback',
+    value: function attributeChangedCallback(name, last, current) {
+      switch (name) {
+        case 'class':
+          util$1.restoreClass(this, defaultClassName$1, scheme$3);
+          break;
+        case 'modifier':
+          ModifierUtil.onModifierChanged(last, current, this, scheme$3);
+          break;
+      }
+    }
+  }], [{
+    key: 'observedAttributes',
+    get: function get$$1() {
+      return ['modifier', 'class'];
+    }
+  }]);
+  return BottomToolbarElement;
+}(BaseElement);
+
+onsElements.BottomToolbar = BottomToolbarElement;
+customElements.define('ons-bottom-toolbar', BottomToolbarElement);
+
+/*
+Copyright 2013-2015 ASIAL CORPORATION
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+   http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+*/
+
+/**
+ * @element ons-button
+ * @category form
+ * @modifier outline
+ *   [en]Button with outline and transparent background[/en]
+ *   [ja]アウトラインを持ったボタンを表示します。[/ja]
+ * @modifier light
+ *   [en]Button that doesn't stand out.[/en]
+ *   [ja]目立たないボタンを表示します。[/ja]
+ * @modifier quiet
+ *   [en]Button with no outline and or background..[/en]
+ *   [ja]枠線や背景が無い文字だけのボタンを表示します。[/ja]
+ * @modifier cta
+ *   [en]Button that really stands out.[/en]
+ *   [ja]目立つボタンを表示します。[/ja]
+ * @modifier large
+ *   [en]Large button that covers the width of the screen.[/en]
+ *   [ja]横いっぱいに広がる大きなボタンを表示します。[/ja]
+ * @modifier large--quiet
+ *   [en]Large quiet button.[/en]
+ *   [ja]横いっぱいに広がるquietボタンを表示します。[/ja]
+ * @modifier large--cta
+ *   [en]Large call to action button.[/en]
+ *   [ja]横いっぱいに広がるctaボタンを表示します。[/ja]
+ * @modifier material
+ *   [en]Material Design button[/en]
+ *   [ja]マテリアルデザインのボタン[/ja]
+ * @modifier material--flat
+ *   [en]Material Design flat button[/en]
+ *   [ja]マテリアルデザインのフラットボタン[/ja]
+ * @description
+ *   [en]
+ *     Button component. If you want to place a button in a toolbar, use `<ons-toolbar-button>` or `<ons-back-button>` instead.
+ *
+ *     Will automatically display as a Material Design button with a ripple effect on Android.
+ *   [/en]
+ *   [ja]ボタン用コンポーネント。ツールバーにボタンを設置する場合は、ons-toolbar-buttonもしくはons-back-buttonコンポーネントを使用します。[/ja]
+ * @codepen hLayx
+ * @tutorial vanilla/Reference/button
+ * @guide theming.html#modifiers [en]More details about the `modifier` attribute[/en][ja]modifier属性の使い方[/ja]
+ * @guide theming.html#cross-platform-styling-autostyling [en]Information about cross platform styling[/en][ja]Information about cross platform styling[/ja]
+ * @example
+ * <ons-button modifier="large--cta">
+ *   Tap Me
+ * </ons-button>
+ */
+
+var ButtonElement = function (_BaseButtonElement) {
+  inherits(ButtonElement, _BaseButtonElement);
+
+  function ButtonElement() {
+    classCallCheck(this, ButtonElement);
+    return possibleConstructorReturn(this, (ButtonElement.__proto__ || Object.getPrototypeOf(ButtonElement)).apply(this, arguments));
+  }
+
+  createClass(ButtonElement, [{
+    key: '_scheme',
+
+
+    /**
+     * @attribute modifier
+     * @type {String}
+     * @description
+     *  [en]The appearance of the button.[/en]
+     *  [ja]ボタンの表現を指定します。[/ja]
+     */
+
+    /**
+     * @attribute ripple
+     * @description
+     *  [en]If this attribute is defined, the button will have a ripple effect.[/en]
+     *  [ja][/ja]
+     */
+
+    /**
+     * @attribute disabled
+     * @description
+     *   [en]Specify if button should be disabled.[/en]
+     *   [ja]ボタンを無効化する場合は指定します。[/ja]
+     */
+
+    /**
+     * @property disabled
+     * @type {Boolean}
+     * @description
+     *   [en]Whether the button is disabled or not.[/en]
+     *   [ja]無効化されている場合に`true`。[/ja]
+     */
+
+    get: function get$$1() {
+      return { '': 'button--*' };
+    }
+  }, {
+    key: '_defaultClassName',
+    get: function get$$1() {
+      return 'button';
+    }
+  }]);
+  return ButtonElement;
+}(BaseButtonElement);
+
+onsElements.Button = ButtonElement;
+customElements.define('ons-button', ButtonElement);
+
+/*
+Copyright 2013-2015 ASIAL CORPORATION
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+   http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+*/
+
+var defaultClassName$2 = 'card';
+var scheme$4 = {
+  '': 'card--*',
+  '.card__title': 'card--*__title',
+  '.card__content': 'card--*__content'
+};
+
+/**
+ * @element ons-card
+ * @category visual
+ * @modifier material
+ *   [en]A card with material design.[/en]
+ *   [ja]リストの上下のボーダーが無いリストを表示します。[/ja]
+ * @description
+ *   [en]
+ *    Component to create a card that displays some information.
+ *
+ *    The card may be composed by divs with specially prepared classes `title` and/or `content`. You can also add your own content as you please.[/en]
+ *   [ja][/ja]
+ * @tutorial vanilla/Reference/card
+ * @example
+ * <ons-card>
+ *   <p>Some content</p>
+ * </ons-card>
+ */
+
+var CardElement = function (_BaseElement) {
+  inherits(CardElement, _BaseElement);
+
+  /**
+   * @attribute modifier
+   * @type {String}
+   * @description
+   *   [en]The appearance of the card.[/en]
+   *   [ja]リストの表現を指定します。[/ja]
+   */
+
+  function CardElement() {
+    classCallCheck(this, CardElement);
+
+    var _this = possibleConstructorReturn(this, (CardElement.__proto__ || Object.getPrototypeOf(CardElement)).call(this));
+
+    contentReady(_this, function () {
+      _this._compile();
+    });
+    return _this;
+  }
+
+  createClass(CardElement, [{
+    key: '_compile',
+    value: function _compile() {
+      for (var i = 0; i < this.children.length; i++) {
+        var el = this.children[i];
+
+        if (el.classList.contains('title')) {
+          el.classList.add('card__title');
+          
+        } else if (el.classList.contains('content')) {
+          el.classList.add('card__content');
+          
+        }
+      }
+
+      autoStyle.prepare(this);
+      this.classList.add(defaultClassName$2);
+      ModifierUtil.initModifier(this, scheme$4);
+    }
+  }, {
+    key: 'attributeChangedCallback',
+    value: function attributeChangedCallback(name, last, current) {
+      switch (name) {
+        case 'class':
+          util$1.restoreClass(this, defaultClassName$2, scheme$4);
+          break;
+        case 'modifier':
+          ModifierUtil.onModifierChanged(last, current, this, scheme$4);
+          break;
+      }
+    }
+  }], [{
+    key: 'observedAttributes',
+    get: function get$$1() {
+      return ['modifier', 'class'];
+    }
+  }]);
+  return CardElement;
+}(BaseElement);
+
+onsElements.Card = CardElement;
+customElements.define('ons-card', CardElement);
+
+/*
+Copyright 2013-2015 ASIAL CORPORATION
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+   http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+*/
+
+var scheme$5 = { '': 'carousel-item--*' };
+
+/**
+ * @element ons-carousel-item
+ * @category carousel
+ * @description
+ *   [en]
+ *     Carousel item component. Used as a child of the `<ons-carousel>` element.
+ *   [/en]
+ *   [ja][/ja]
+ * @codepen xbbzOQ
+ * @tutorial vanilla/Reference/carousel
+ * @seealso ons-carousel
+ *   [en]`<ons-carousel>` components[/en]
+ *   [ja]<ons-carousel>コンポーネント[/ja]
+ * @example
+ * <ons-carousel style="width: 100%; height: 200px">
+ *   <ons-carousel-item>
+ *    ...
+ *   </ons-carousel-item>
+ *   <ons-carousel-item>
+ *    ...
+ *   </ons-carousel-item>
+ * </ons-carousel>
+ */
+
+var CarouselItemElement = function (_BaseElement) {
+  inherits(CarouselItemElement, _BaseElement);
+
+  function CarouselItemElement() {
+    classCallCheck(this, CarouselItemElement);
+
+    var _this = possibleConstructorReturn(this, (CarouselItemElement.__proto__ || Object.getPrototypeOf(CarouselItemElement)).call(this));
+
+    _this.style.width = '100%';
+    ModifierUtil.initModifier(_this, scheme$5);
+    return _this;
+  }
+
+  createClass(CarouselItemElement, [{
+    key: 'attributeChangedCallback',
+    value: function attributeChangedCallback(name, last, current) {
+      if (name === 'modifier') {
+        return ModifierUtil.onModifierChanged(last, current, this, scheme$5);
+      }
+    }
+  }], [{
+    key: 'observedAttributes',
+    get: function get$$1() {
+      return ['modifier'];
+    }
+  }]);
+  return CarouselItemElement;
+}(BaseElement);
+
+onsElements.CarouselItem = CarouselItemElement;
+customElements.define('ons-carousel-item', CarouselItemElement);
+
+var directionMap = {
+  vertical: {
+    axis: 'Y',
+    size: 'Height',
+    dir: ['up', 'down'],
+    t3d: ['0px, ', 'px, 0px']
+  },
+  horizontal: {
+    axis: 'X',
+    size: 'Width',
+    dir: ['left', 'right'],
+    t3d: ['', 'px, 0px, 0px']
+  }
+};
+
+var Swiper = function () {
+  function Swiper(params) {
+    var _this = this;
+
+    classCallCheck(this, Swiper);
+
+    // Parameters
+    var FALSE = function FALSE() {
+      return false;
+    };
+    'getInitialIndex getBubbleWidth isVertical isOverScrollable isCentered\n    isAutoScrollable refreshHook preChangeHook postChangeHook overScrollHook'.split(/\s+/).forEach(function (key) {
+      return _this[key] = params[key] || FALSE;
+    });
+
+    this.getElement = params.getElement; // Required
+    this.scrollHook = params.scrollHook; // Optional
+    this.itemSize = params.itemSize || '100%';
+
+    this.getAutoScrollRatio = function () {
+      var ratio = params.getAutoScrollRatio && params.getAutoScrollRatio.apply(params, arguments);
+      ratio = typeof ratio === 'number' && ratio === ratio ? ratio : .5;
+      if (ratio < 0.0 || ratio > 1.0) {
+        util$1.throw('Invalid auto-scroll-ratio ' + ratio + '. Must be between 0 and 1');
+      }
+      return ratio;
+    };
+
+    // Prevent clicks only on desktop
+    this.shouldBlock = util$1.globals.actualMobileOS === 'other';
+
+    // Bind handlers
+    this.onDragStart = this.onDragStart.bind(this);
+    this.onDrag = this.onDrag.bind(this);
+    this.onDragEnd = this.onDragEnd.bind(this);
+    this.onResize = this.onResize.bind(this);
+
+    this._shouldFixScroll = util$1.globals.actualMobileOS === 'ios';
+  }
+
+  createClass(Swiper, [{
+    key: 'init',
+    value: function init() {
+      var _this2 = this;
+
+      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
+          swipeable = _ref.swipeable,
+          autoRefresh = _ref.autoRefresh;
+
+      this.initialized = true;
+      this.target = this.getElement().children[0];
+      this.blocker = this.getElement().children[1];
+      if (!this.target || !this.blocker) {
+        util$1.throw('Expected "target" and "blocker" elements to exist before initializing Swiper');
+      }
+
+      if (!this.shouldBlock) {
+        this.blocker.style.display = 'none';
+      }
+
+      // Add classes
+      this.getElement().classList.add('ons-swiper');
+      this.target.classList.add('ons-swiper-target');
+      this.blocker.classList.add('ons-swiper-blocker');
+
+      // Setup listeners
+      this._gestureDetector = new GestureDetector(this.getElement(), { dragMinDistance: 1, dragLockToAxis: true, passive: !this._shouldFixScroll });
+      this._mutationObserver = new MutationObserver(function () {
+        return _this2.refresh();
+      });
+      this.updateSwipeable(swipeable);
+      this.updateAutoRefresh(autoRefresh);
+
+      // Setup initial layout
+      this._scroll = this._offset = this._lastActiveIndex = 0;
+      this._updateLayout();
+      this._setupInitialIndex();
+      setImmediate(function () {
+        return _this2.initialized && _this2._setupInitialIndex();
+      });
+
+      // Fix rendering glitch on Android 4.1
+      // Fix for iframes where the width is inconsistent at the beginning
+      if (window !== window.parent || this.offsetHeight === 0) {
+        window.requestAnimationFrame(function () {
+          return _this2.initialized && _this2.onResize();
+        });
+      }
+    }
+  }, {
+    key: 'dispose',
+    value: function dispose() {
+      this.initialized = false;
+      this.updateSwipeable(false);
+      this.updateAutoRefresh(false);
+
+      this._gestureDetector && this._gestureDetector.dispose();
+      this.target = this.blocker = this._gestureDetector = this._mutationObserver = null;
+
+      this.setupResize(false);
+    }
+  }, {
+    key: 'onResize',
+    value: function onResize() {
+      var i = this._scroll / this.targetSize;
+      this._reset();
+      this.setActiveIndex(i);
+      this.refresh();
+    }
+  }, {
+    key: '_calculateItemSize',
+    value: function _calculateItemSize() {
+      var matches = this.itemSize.match(/^(\d+)(px|%)/);
+
+      if (!matches) {
+        util$1.throw('Invalid state: swiper\'s size unit must be \'%\' or \'px\'');
+      }
+
+      var value = parseInt(matches[1], 10);
+      return matches[2] === '%' ? Math.round(value / 100 * this.targetSize) : value;
+    }
+  }, {
+    key: '_setupInitialIndex',
+    value: function _setupInitialIndex() {
+      this._reset();
+      this._lastActiveIndex = Math.max(Math.min(Number(this.getInitialIndex()), this.itemCount), 0);
+      this._scroll = this._offset + this.itemNumSize * this._lastActiveIndex;
+      this._scrollTo(this._scroll);
+    }
+  }, {
+    key: '_setSwiping',
+    value: function _setSwiping(toggle) {
+      this.target.classList.toggle('swiping', toggle); // Hides everything except shown pages
+    }
+  }, {
+    key: 'setActiveIndex',
+    value: function setActiveIndex(index) {
+      var _this3 = this;
+
+      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
+
+      this._setSwiping(true);
+      index = Math.max(0, Math.min(index, this.itemCount - 1));
+      var scroll = Math.max(0, Math.min(this.maxScroll, this._offset + this.itemNumSize * index));
+
+      if (platform.isUIWebView()) {
+        /* Dirty fix for #2231(https://github.com/OnsenUI/OnsenUI/issues/2231). begin */
+        var concat = function concat(arrayOfArray) {
+          return Array.prototype.concat.apply([], arrayOfArray);
+        };
+        var contents = concat(util$1.arrayFrom(this.target.children).map(function (page) {
+          return util$1.arrayFrom(page.children).filter(function (child) {
+            return child.classList.contains('page__content');
+          });
+        }));
+
+        var map = new Map();
+        return new Promise(function (resolve) {
+          contents.forEach(function (content) {
+            map.set(content, content.getAttribute('class'));
+            content.classList.add('page__content--suppress-layer-creation');
+          });
+          requestAnimationFrame(resolve);
+        }).then(function () {
+          return _this3._changeTo(scroll, options);
+        }).then(function () {
+          return new Promise(function (resolve) {
+            contents.forEach(function (content) {
+              content.setAttribute('class', map.get(content));
+            });
+            requestAnimationFrame(resolve);
+          });
+        });
+        /* end */
+      } else {
+        return this._changeTo(scroll, options);
+      }
+    }
+  }, {
+    key: 'getActiveIndex',
+    value: function getActiveIndex() {
+      var scroll = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._scroll;
+
+      scroll -= this._offset;
+      var count = this.itemCount,
+          size = this.itemNumSize;
+
+      if (this.itemNumSize === 0 || !util$1.isInteger(scroll)) {
+        return this._lastActiveIndex;
+      }
+
+      if (scroll <= 0) {
+        return 0;
+      }
+
+      for (var i = 0; i < count; i++) {
+        if (size * i <= scroll && size * (i + 1) > scroll) {
+          return i;
+        }
+      }
+
+      return count - 1;
+    }
+  }, {
+    key: 'setupResize',
+    value: function setupResize(add) {
+      window[(add ? 'add' : 'remove') + 'EventListener']('resize', this.onResize, true);
+    }
+  }, {
+    key: 'show',
+    value: function show() {
+      var _this4 = this;
+
+      this.setupResize(true);
+      this.onResize();
+      setTimeout(function () {
+        return _this4.target && _this4.target.classList.add('active');
+      }, 1000 / 60); // Hide elements after animations
+    }
+  }, {
+    key: 'hide',
+    value: function hide() {
+      this.setupResize(false);
+      this.target.classList.remove('active'); // Show elements before animations
+    }
+  }, {
+    key: 'updateSwipeable',
+    value: function updateSwipeable(shouldUpdate) {
+      if (this._gestureDetector) {
+        var action = shouldUpdate ? 'on' : 'off';
+        this._gestureDetector[action]('drag', this.onDrag);
+        this._gestureDetector[action]('dragstart', this.onDragStart);
+        this._gestureDetector[action]('dragend', this.onDragEnd);
+      }
+    }
+  }, {
+    key: 'updateAutoRefresh',
+    value: function updateAutoRefresh(shouldWatch) {
+      if (this._mutationObserver) {
+        shouldWatch ? this._mutationObserver.observe(this.target, { childList: true }) : this._mutationObserver.disconnect();
+      }
+    }
+  }, {
+    key: 'updateItemSize',
+    value: function updateItemSize(newSize) {
+      this.itemSize = newSize || '100%';
+      this.refresh();
+    }
+  }, {
+    key: 'toggleBlocker',
+    value: function toggleBlocker(block) {
+      this.blocker.style.pointerEvents = block ? 'auto' : 'none';
+    }
+  }, {
+    key: '_canConsumeGesture',
+    value: function _canConsumeGesture(gesture) {
+      var d = gesture.direction;
+      var isFirst = this._scroll === 0 && !this.isOverScrollable();
+      var isLast = this._scroll === this.maxScroll && !this.isOverScrollable();
+
+      return this.isVertical() ? d === 'down' && !isFirst || d === 'up' && !isLast : d === 'right' && !isFirst || d === 'left' && !isLast;
+    }
+  }, {
+    key: 'onDragStart',
+    value: function onDragStart(event) {
+      var _this5 = this;
+
+      this._ignoreDrag = event.consumed || !util$1.isValidGesture(event);
+
+      if (!this._ignoreDrag) {
+        var consume = event.consume;
+        event.consume = function () {
+          consume && consume();_this5._ignoreDrag = true;
+        };
+
+        if (this._canConsumeGesture(event.gesture)) {
+          var startX = event.gesture.center && event.gesture.center.clientX || 0,
+              distFromEdge = this.getBubbleWidth() || 0,
+              start = function start() {
+            consume && consume();
+            event.consumed = true;
+            _this5._started = true; // Avoid starting drag from outside
+            _this5.shouldBlock && _this5.toggleBlocker(true);
+            _this5._setSwiping(true);
+            util$1.iosPreventScroll(_this5._gestureDetector);
+          };
+
+          // Let parent elements consume the gesture or consume it right away
+          startX < distFromEdge || startX > this.targetSize - distFromEdge ? setImmediate(function () {
+            return !_this5._ignoreDrag && start();
+          }) : start();
+        }
+      }
+    }
+  }, {
+    key: 'onDrag',
+    value: function onDrag(event) {
+      if (!event.gesture || this._ignoreDrag || !this._started) {
+        return;
+      }
+
+      this._continued = true; // Fix for random 'dragend' without 'drag'
+      event.stopPropagation();
+
+      this._scrollTo(this._scroll - this._getDelta(event), { throttle: true });
+    }
+  }, {
+    key: 'onDragEnd',
+    value: function onDragEnd(event) {
+      this._started = false;
+      if (!event.gesture || this._ignoreDrag || !this._continued) {
+        this._ignoreDrag = true; // onDragEnd might fire before onDragStart's setImmediate
+        return;
+      }
+
+      this._continued = false;
+      event.stopPropagation();
+
+      var scroll = this._scroll - this._getDelta(event);
+      var normalizedScroll = this._normalizeScroll(scroll);
+      scroll === normalizedScroll ? this._startMomentumScroll(scroll, event) : this._killOverScroll(normalizedScroll);
+      this.shouldBlock && this.toggleBlocker(false);
+    }
+  }, {
+    key: '_startMomentumScroll',
+    value: function _startMomentumScroll(scroll, event) {
+      var velocity = this._getVelocity(event),
+          matchesDirection = event.gesture.interimDirection === this.dM.dir[this._getDelta(event) < 0 ? 0 : 1];
+
+      var nextScroll = this._getAutoScroll(scroll, velocity, matchesDirection);
+      var duration = Math.abs(nextScroll - scroll) / (velocity + 0.01) / 1000;
+      duration = Math.min(.25, Math.max(.1, duration));
+
+      this._changeTo(nextScroll, { swipe: true, animationOptions: { duration: duration, timing: 'cubic-bezier(.4, .7, .5, 1)' } });
+    }
+  }, {
+    key: '_killOverScroll',
+    value: function _killOverScroll(scroll) {
+      var _this6 = this;
+
+      this._scroll = scroll;
+      var direction = this.dM.dir[Number(scroll > 0)];
+      var killOverScroll = function killOverScroll() {
+        return _this6._changeTo(scroll, { animationOptions: { duration: .4, timing: 'cubic-bezier(.1, .4, .1, 1)' } });
+      };
+      this.overScrollHook({ direction: direction, killOverScroll: killOverScroll }) || killOverScroll();
+    }
+  }, {
+    key: '_changeTo',
+    value: function _changeTo(scroll) {
+      var _this7 = this;
+
+      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
+
+      var e = { activeIndex: this.getActiveIndex(scroll), lastActiveIndex: this._lastActiveIndex, swipe: options.swipe || false };
+      var change = e.activeIndex !== e.lastActiveIndex;
+      var canceled = change ? this.preChangeHook(e) : false;
+
+      this._scroll = canceled ? this._offset + e.lastActiveIndex * this.itemNumSize : scroll;
+      this._lastActiveIndex = canceled ? e.lastActiveIndex : e.activeIndex;
+
+      return this._scrollTo(this._scroll, options).then(function () {
+        if (scroll === _this7._scroll && !canceled) {
+          _this7._setSwiping(false);
+          change && _this7.postChangeHook(e);
+        } else if (options.reject) {
+          _this7._setSwiping(false);
+          return Promise.reject('Canceled');
+        }
+      });
+    }
+  }, {
+    key: '_scrollTo',
+    value: function _scrollTo(scroll) {
+      var _this8 = this;
+
+      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
+
+      if (options.throttle) {
+        var ratio = 0.35;
+        if (scroll < 0) {
+          scroll = this.isOverScrollable() ? Math.round(scroll * ratio) : 0;
+        } else {
+          var maxScroll = this.maxScroll;
+          if (maxScroll < scroll) {
+            scroll = this.isOverScrollable() ? maxScroll + Math.round((scroll - maxScroll) * ratio) : maxScroll;
+          }
+        }
+      }
+
+      var opt = options.animation === 'none' ? {} : options.animationOptions;
+      this.scrollHook && this.itemNumSize > 0 && this.scrollHook((scroll / this.itemNumSize).toFixed(2), options.animationOptions || {});
+
+      return new Promise(function (resolve) {
+        return Animit(_this8.target).queue({ transform: _this8._getTransform(scroll) }, opt).play(resolve);
+      });
+    }
+  }, {
+    key: '_getAutoScroll',
+    value: function _getAutoScroll(scroll, velocity, matchesDirection) {
+      var max = this.maxScroll,
+          offset = this._offset,
+          size = this.itemNumSize;
+
+      if (!this.isAutoScrollable()) {
+        return Math.max(0, Math.min(max, scroll));
+      }
+
+      var arr = [];
+      for (var s = offset; s < max; s += size) {
+        arr.push(s);
+      }
+      arr.push(max);
+
+      arr = arr.sort(function (left, right) {
+        return Math.abs(left - scroll) - Math.abs(right - scroll);
+      }).filter(function (item, pos) {
+        return !pos || item !== arr[pos - 1];
+      });
+
+      var result = arr[0];
+      var lastScroll = this._lastActiveIndex * size + offset;
+      var scrollRatio = Math.abs(scroll - lastScroll) / size;
+
+      if (scrollRatio <= this.getAutoScrollRatio(matchesDirection, velocity, size)) {
+        result = lastScroll;
+      } else {
+        if (scrollRatio < 1.0 && arr[0] === lastScroll && arr.length > 1) {
+          result = arr[1];
+        }
+      }
+      return Math.max(0, Math.min(max, result));
+    }
+  }, {
+    key: '_reset',
+    value: function _reset() {
+      this._targetSize = this._itemNumSize = undefined;
+    }
+  }, {
+    key: '_normalizeScroll',
+    value: function _normalizeScroll(scroll) {
+      return Math.max(Math.min(scroll, this.maxScroll), 0);
+    }
+  }, {
+    key: 'refresh',
+    value: function refresh() {
+      this._reset();
+      this._updateLayout();
+
+      if (util$1.isInteger(this._scroll)) {
+        var scroll = this._normalizeScroll(this._scroll);
+        scroll !== this._scroll ? this._killOverScroll(scroll) : this._changeTo(scroll);
+      } else {
+        this._setupInitialIndex();
+      }
+
+      this.refreshHook();
+    }
+  }, {
+    key: '_getDelta',
+    value: function _getDelta(event) {
+      return event.gesture['delta' + this.dM.axis];
+    }
+  }, {
+    key: '_getVelocity',
+    value: function _getVelocity(event) {
+      return event.gesture['velocity' + this.dM.axis];
+    }
+  }, {
+    key: '_getTransform',
+    value: function _getTransform(scroll) {
+      return 'translate3d(' + this.dM.t3d[0] + -scroll + this.dM.t3d[1] + ')';
+    }
+  }, {
+    key: '_updateLayout',
+    value: function _updateLayout() {
+      this.dM = directionMap[this.isVertical() ? 'vertical' : 'horizontal'];
+      this.target.classList.toggle('ons-swiper-target--vertical', this.isVertical());
+
+      for (var c = this.target.children[0]; c; c = c.nextElementSibling) {
+        c.style[this.dM.size.toLowerCase()] = this.itemSize;
+      }
+
+      if (this.isCentered()) {
+        this._offset = (this.targetSize - this.itemNumSize) / -2 || 0;
+      }
+    }
+  }, {
+    key: 'itemCount',
+    get: function get$$1() {
+      return this.target.children.length;
+    }
+  }, {
+    key: 'itemNumSize',
+    get: function get$$1() {
+      if (typeof this._itemNumSize !== 'number' || this._itemNumSize !== this._itemNumSize) {
+        this._itemNumSize = this._calculateItemSize();
+      }
+      return this._itemNumSize;
+    }
+  }, {
+    key: 'maxScroll',
+    get: function get$$1() {
+      var max = this.itemCount * this.itemNumSize - this.targetSize;
+      return Math.ceil(max < 0 ? 0 : max); // Need to return an integer value.
+    }
+  }, {
+    key: 'targetSize',
+    get: function get$$1() {
+      if (!this._targetSize) {
+        this._targetSize = this.target['offset' + this.dM.size];
+      }
+      return this._targetSize;
+    }
+  }]);
+  return Swiper;
+}();
+
+/*
+Copyright 2013-2015 ASIAL CORPORATION
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+   http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+*/
+
+/**
+ * @element ons-carousel
+ * @category carousel
+ * @description
+ *   [en]
+ *     Carousel component. A carousel can be used to display several items in the same space.
+ *
+ *     The component supports displaying content both horizontally and vertically. The user can scroll through the items by dragging and it can also be controller programmatically.
+ *   [/en]
+ *   [ja][/ja]
+ * @codepen xbbzOQ
+ * @tutorial vanilla/Reference/carousel
+ * @seealso ons-carousel-item
+ *   [en]`<ons-carousel-item>` component[/en]
+ *   [ja]ons-carousel-itemコンポーネント[/ja]
+ * @example
+ * <ons-carousel style="width: 100%; height: 200px">
+ *   <ons-carousel-item>
+ *    ...
+ *   </ons-carousel-item>
+ *   <ons-carousel-item>
+ *    ...
+ *   </ons-carousel-item>
+ * </ons-carousel>
+ */
+
+var CarouselElement = function (_BaseElement) {
+  inherits(CarouselElement, _BaseElement);
+
+  /**
+   * @event postchange
+   * @description
+   *   [en]Fired just after the current carousel item has changed.[/en]
+   *   [ja]現在表示しているカルーセルの要素が変わった時に発火します。[/ja]
+   * @param {Object} event
+   *   [en]Event object.[/en]
+   *   [ja]イベントオブジェクトです。[/ja]
+   * @param {Object} event.carousel
+   *   [en]Carousel object.[/en]
+   *   [ja]イベントが発火したCarouselオブジェクトです。[/ja]
+   * @param {Number} event.activeIndex
+   *   [en]Current active index.[/en]
+   *   [ja]現在アクティブになっている要素のインデックス。[/ja]
+   * @param {Number} event.lastActiveIndex
+   *   [en]Previous active index.[/en]
+   *   [ja]以前アクティブだった要素のインデックス。[/ja]
+   */
+
+  /**
+   * @event refresh
+   * @description
+   *   [en]Fired when the carousel has been refreshed.[/en]
+   *   [ja]カルーセルが更新された時に発火します。[/ja]
+   * @param {Object} event
+   *   [en]Event object.[/en]
+   *   [ja]イベントオブジェクトです。[/ja]
+   * @param {Object} event.carousel
+   *   [en]Carousel object.[/en]
+   *   [ja]イベントが発火したCarouselオブジェクトです。[/ja]
+   */
+
+  /**
+   * @event overscroll
+   * @description
+   *   [en]Fired when the carousel has been overscrolled.[/en]
+   *   [ja]カルーセルがオーバースクロールした時に発火します。[/ja]
+   * @param {Object} event
+   *   [en]Event object.[/en]
+   *   [ja]イベントオブジェクトです。[/ja]
+   * @param {Object} event.carousel
+   *   [en]Fired when the carousel has been refreshed.[/en]
+   *   [ja]カルーセルが更新された時に発火します。[/ja]
+   * @param {Number} event.activeIndex
+   *   [en]Current active index.[/en]
+   *   [ja]現在アクティブになっている要素のインデックス。[/ja]
+   * @param {String} event.direction
+   *   [en]Can be one of either "up", "down", "left" or "right".[/en]
+   *   [ja]オーバースクロールされた方向が得られます。"up", "down", "left", "right"のいずれかの方向が渡されます。[/ja]
+   * @param {Function} event.waitToReturn
+   *   [en]Takes a <code>Promise</code> object as an argument. The carousel will not scroll back until the promise has been resolved or rejected.[/en]
+   *   [ja]この関数はPromiseオブジェクトを引数として受け取ります。渡したPromiseオブジェクトがresolveされるかrejectされるまで、カルーセルはスクロールバックしません。[/ja]
+   */
+
+  /**
+   * @attribute direction
+   * @type {String}
+   * @description
+   *   [en]The direction of the carousel. Can be either "horizontal" or "vertical". Default is "horizontal".[/en]
+   *   [ja]カルーセルの方向を指定します。"horizontal"か"vertical"を指定できます。"horizontal"がデフォルト値です。[/ja]
+   */
+
+  /**
+   * @attribute fullscreen
+   * @description
+   *   [en]If this attribute is set the carousel will cover the whole screen.[/en]
+   *   [ja]この属性があると、absoluteポジションを使ってカルーセルが自動的に画面いっぱいに広がります。[/ja]
+   */
+
+  /**
+   * @attribute overscrollable
+   * @description
+   *   [en]If this attribute is set the carousel will be scrollable over the edge. It will bounce back when released.[/en]
+   *   [ja]この属性がある時、タッチやドラッグで端までスクロールした時に、バウンドするような効果が当たります。[/ja]
+   */
+
+  /**
+   * @attribute centered
+   * @description
+   *   [en]If this attribute is set the carousel then the selected item will be in the center of the carousel instead of the beginning. Useful only when the items are smaller than the carousel. [/en]
+   *   [ja]この属性がある時、選んでいるons-carousel-itemはカルーセルの真ん中へ行きます。項目がカルーセルよりも小さい場合にのみ、これは便利です。[/ja]
+   */
+
+  /**
+   * @attribute item-width
+   * @type {String}
+   * @description
+   *    [en]ons-carousel-item's width. Only works when the direction is set to "horizontal".[/en]
+   *    [ja]ons-carousel-itemの幅を指定します。この属性は、direction属性に"horizontal"を指定した時のみ有効になります。[/ja]
+   */
+
+  /**
+   * @attribute item-height
+   * @type {String}
+   * @description
+   *   [en]ons-carousel-item's height. Only works when the direction is set to "vertical".[/en]
+   *   [ja]ons-carousel-itemの高さを指定します。この属性は、direction属性に"vertical"を指定した時のみ有効になります。[/ja]
+   */
+
+  /**
+   * @attribute auto-scroll
+   * @description
+   *   [en]If this attribute is set the carousel will be automatically scrolled to the closest item border when released.[/en]
+   *   [ja]この属性がある時、一番近いcarousel-itemの境界まで自動的にスクロールするようになります。[/ja]
+   */
+
+  /**
+   * @attribute auto-scroll-ratio
+   * @type {Number}
+   * @description
+   *    [en]A number between 0.0 and 1.0 that specifies how much the user must drag the carousel in order for it to auto scroll to the next item.[/en]
+   *    [ja]0.0から1.0までの値を指定します。カルーセルの要素をどれぐらいの割合までドラッグすると次の要素に自動的にスクロールするかを指定します。[/ja]
+   */
+
+  /**
+   * @attribute swipeable
+   * @description
+   *   [en]If this attribute is set the carousel can be scrolled by drag or swipe.[/en]
+   *   [ja]この属性がある時、カルーセルをスワイプやドラッグで移動できるようになります。[/ja]
+   */
+
+  /**
+   * @attribute disabled
+   * @description
+   *   [en]If this attribute is set the carousel is disabled.[/en]
+   *   [ja]この属性がある時、dragやtouchやswipeを受け付けなくなります。[/ja]
+   */
+
+  /**
+   * @attribute initial-index
+   * @initonly
+   * @default 0
+   * @type {Number}
+   * @description
+   *   [en]Specify the index of the ons-carousel-item to show initially. Default is 0.[/en]
+   *   [ja]最初に表示するons-carousel-itemを0始まりのインデックスで指定します。デフォルト値は 0 です。[/ja]
+   */
+
+  /**
+   * @attribute auto-refresh
+   * @description
+   *   [en]When this attribute is set the carousel will automatically refresh when the number of child nodes change.[/en]
+   *   [ja]この属性がある時、子要素の数が変わるとカルーセルは自動的に更新されるようになります。[/ja]
+   */
+
+  /**
+   * @attribute animation
+   * @type {String}
+   * @description
+   *   [en]If this attribute is set to `"none"` the transitions will not be animated.[/en]
+   *   [ja][/ja]
+   */
+
+  /**
+   * @attribute animation-options
+   * @type {Expression}
+   * @description
+   *   [en]Specify the animation's duration, timing and delay with an object literal. E.g. `{duration: 0.2, delay: 1, timing: 'ease-in'}`.[/en]
+   *   [ja]アニメーション時のduration, timing, delayをオブジェクトリテラルで指定します。例：{duration: 0.2, delay: 1, timing: 'ease-in'}[/ja]
+   */
+
+  function CarouselElement() {
+    classCallCheck(this, CarouselElement);
+
+    var _this = possibleConstructorReturn(this, (CarouselElement.__proto__ || Object.getPrototypeOf(CarouselElement)).call(this));
+
+    contentReady(_this, function () {
+      return _this._compile();
+    });
+    return _this;
+  }
+
+  createClass(CarouselElement, [{
+    key: '_compile',
+    value: function _compile() {
+      var target = this.children[0] && this.children[0].tagName !== 'ONS-CAROUSEL-ITEM' && this.children[0] || document.createElement('div');
+      if (!target.parentNode) {
+        while (this.firstChild) {
+          target.appendChild(this.firstChild);
+        }
+        this.appendChild(target);
+      }
+
+      !this.children[1] && this.appendChild(document.createElement('div'));
+
+      this.appendChild = this.appendChild.bind(target);
+      this.insertBefore = this.insertBefore.bind(target);
+    }
+  }, {
+    key: 'connectedCallback',
+    value: function connectedCallback() {
+      var _this2 = this;
+
+      if (!this._swiper) {
+        this._swiper = new Swiper({
+          getElement: function getElement() {
+            return _this2;
+          },
+          getInitialIndex: function getInitialIndex() {
+            return _this2.getAttribute('initial-index');
+          },
+          getAutoScrollRatio: function getAutoScrollRatio() {
+            return _this2.autoScrollRatio;
+          },
+          isVertical: function isVertical() {
+            return _this2.vertical;
+          },
+          isOverScrollable: function isOverScrollable() {
+            return _this2.overscrollable;
+          },
+          isCentered: function isCentered() {
+            return _this2.centered;
+          },
+          isAutoScrollable: function isAutoScrollable() {
+            return _this2.autoScroll;
+          },
+          itemSize: this.itemSize,
+          overScrollHook: this._onOverScroll.bind(this),
+          preChangeHook: this._onChange.bind(this, 'prechange'),
+          postChangeHook: this._onChange.bind(this, 'postchange'),
+          refreshHook: this._onRefresh.bind(this),
+          scrollHook: function scrollHook() {
+            return _this2._onSwipe && _this2._onSwipe.apply(_this2, arguments);
+          }
+        });
+
+        contentReady(this, function () {
+          return _this2._swiper.init({
+            swipeable: _this2.hasAttribute('swipeable'),
+            autoRefresh: _this2.hasAttribute('auto-refresh')
+          });
+        });
+      }
+    }
+  }, {
+    key: 'disconnectedCallback',
+    value: function disconnectedCallback() {
+      if (this._swiper && this._swiper.initialized) {
+        this._swiper.dispose();
+        this._swiper = null;
+      }
+    }
+  }, {
+    key: 'attributeChangedCallback',
+    value: function attributeChangedCallback(name, last, current) {
+      if (!this._swiper) {
+        return;
+      }
+
+      switch (name) {
+        case 'swipeable':
+          this._swiper.updateSwipeable(this.hasAttribute('swipeable'));
+          break;
+        case 'auto-refresh':
+          this._swiper.updateAutoRefresh(this.hasAttribute('auto-refresh'));
+          break;
+        case 'item-height':
+          this.vertical && this._swiper.updateItemSize(this.itemSize);
+          break;
+        case 'item-width':
+          this.vertical || this._swiper.updateItemSize(this.itemSize);
+          break;
+        case 'direction':
+          this._swiper.refresh();
+      }
+    }
+  }, {
+    key: '_show',
+    value: function _show() {
+      this._swiper.show();
+    }
+  }, {
+    key: '_hide',
+    value: function _hide() {
+      this._swiper.hide();
+    }
+  }, {
+    key: '_onOverScroll',
+    value: function _onOverScroll(_ref) {
+      var direction = _ref.direction,
+          killOverScroll = _ref.killOverScroll;
+
+      var waitForAction = false;
+      util$1.triggerElementEvent(this, 'overscroll', {
+        carousel: this,
+        activeIndex: this.getActiveIndex(),
+        direction: direction,
+        waitToReturn: function waitToReturn(promise) {
+          waitForAction = true;
+          promise.then(killOverScroll);
+        }
+      });
+
+      return waitForAction;
+    }
+  }, {
+    key: '_onChange',
+    value: function _onChange(eventName, _ref2) {
+      var activeIndex = _ref2.activeIndex,
+          lastActiveIndex = _ref2.lastActiveIndex;
+
+      util$1.triggerElementEvent(this, eventName, { carousel: this, activeIndex: activeIndex, lastActiveIndex: lastActiveIndex });
+    }
+  }, {
+    key: '_onRefresh',
+    value: function _onRefresh() {
+      util$1.triggerElementEvent(this, 'refresh', { carousel: this });
+    }
+
+    /**
+     * @method setActiveIndex
+     * @signature setActiveIndex(index, [options])
+     * @param {Number} index
+     *   [en]The index that the carousel should be set to.[/en]
+     *   [ja]carousel要素のインデックスを指定します。[/ja]
+     * @param {Object} [options]
+     *   [en]Parameter object.[/en]
+     *   [ja][/ja]
+     * @param {Function} [options.callback]
+     *   [en]A function that will be called after the animation is finished.[/en]
+     *   [ja][/ja]
+     * @param {String} [options.animation]
+     *   [en]If this attribute is set to `"none"` the transitions will not be animated.[/en]
+     *   [ja][/ja]
+     * @param {Object} [options.animationOptions]
+     *   [en]An object that can be used to specify duration, delay and timing function of the animation.[/en]
+     *   [ja][/ja]
+     * @description
+     *   [en]Specify the index of the `<ons-carousel-item>` to show.[/en]
+     *   [ja]表示するons-carousel-itemをindexで指定します。[/ja]
+     * @return {Promise}
+     *   [en]Resolves to the carousel element.[/en]
+     *   [ja][/ja]
+     */
+
+  }, {
+    key: 'setActiveIndex',
+    value: function setActiveIndex(index) {
+      var _this3 = this;
+
+      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
+
+      options = _extends({
+        animation: this.getAttribute('animation'),
+        animationOptions: this.hasAttribute('animation-options') ? util$1.animationOptionsParse(this.getAttribute('animation-options')) : { duration: .3, timing: 'cubic-bezier(.4, .7, .5, 1)' }
+      }, options);
+
+      return this._swiper.setActiveIndex(index, options).then(function () {
+        options.callback instanceof Function && options.callback(_this3);
+        return Promise.resolve(_this3);
+      });
+    }
+
+    /**
+     * @method getActiveIndex
+     * @signature getActiveIndex()
+     * @return {Number}
+     *   [en]The current carousel item index.[/en]
+     *   [ja]現在表示しているカルーセル要素のインデックスが返されます。[/ja]
+     * @description
+     *   [en]Returns the index of the currently visible `<ons-carousel-item>`.[/en]
+     *   [ja]現在表示されているons-carousel-item要素のインデックスを返します。[/ja]
+     */
+
+  }, {
+    key: 'getActiveIndex',
+    value: function getActiveIndex() {
+      return this._swiper.getActiveIndex();
+    }
+
+    /**
+     * @method next
+     * @signature next([options])
+     * @param {Object} [options]
+     *   [en]Parameter object.[/en]
+     *   [ja][/ja]
+     * @param {Function} [options.callback]
+     *   [en]A function that will be executed after the animation has finished.[/en]
+     *   [ja][/ja]
+     * @param {String} [options.animation]
+     *   [en]If this attribute is set to `"none"` the transitions will not be animated.[/en]
+     *   [ja][/ja]
+     * @param {Object} [options.animationOptions]
+     *   [en]An object that can be used to specify the duration, delay and timing function of the animation.[/en]
+     *   [ja][/ja]
+     * @return {Promise}
+     *   [en]Resolves to the carousel element[/en]
+     *   [ja][/ja]
+     * @description
+     *   [en]Show next `<ons-carousel-item>`.[/en]
+     *   [ja]次のons-carousel-itemを表示します。[/ja]
+     */
+
+  }, {
+    key: 'next',
+    value: function next(options) {
+      return this.setActiveIndex(this.getActiveIndex() + 1, options);
+    }
+
+    /**
+     * @method prev
+     * @signature prev([options])
+     * @param {Object} [options]
+     *   [en]Parameter object.[/en]
+     *   [ja][/ja]
+     * @param {Function} [options.callback]
+     *   [en]A function that will be executed after the animation has finished.[/en]
+     *   [ja][/ja]
+     * @param {String} [options.animation]
+     *   [en]If this attribute is set to `"none"` the transitions will not be animated.[/en]
+     *   [ja][/ja]
+     * @param {Object} [options.animationOptions]
+     *   [en]An object that can be used to specify the duration, delay and timing function of the animation.[/en]
+     *   [ja][/ja]
+     * @return {Promise}
+     *   [en]Resolves to the carousel element[/en]
+     *   [ja][/ja]
+     * @description
+     *   [en]Show previous `<ons-carousel-item>`.[/en]
+     *   [ja]前のons-carousel-itemを表示します。[/ja]
+     */
+
+  }, {
+    key: 'prev',
+    value: function prev(options) {
+      return this.setActiveIndex(this.getActiveIndex() - 1, options);
+    }
+
+    /**
+     * @method first
+     * @signature first()
+     * @param {Object} [options]
+     *   [en]Parameter object.[/en]
+     *   [ja][/ja]
+     * @param {Function} [options.callback]
+     *   [en]A function that will be executed after the animation has finished.[/en]
+     *   [ja][/ja]
+     * @param {String} [options.animation]
+     *   [en]If this is set to `"none"`, the transitions will not be animated.[/en]
+     *   [ja][/ja]
+     * @param {Object} [options.animationOptions]
+     *   [en]An object that can be used to specify the duration, delay and timing function of the animation.[/en]
+     *   [ja][/ja]
+     * @return {Promise}
+     *   [en]Resolves to the carousel element[/en]
+     *   [ja][/ja]
+     * @description
+     *   [en]Show first `<ons-carousel-item>`.[/en]
+     *   [ja]最初のons-carousel-itemを表示します。[/ja]
+     */
+
+  }, {
+    key: 'first',
+    value: function first(options) {
+      return this.setActiveIndex(0, options);
+    }
+
+    /**
+     * @method last
+     * @signature last()
+     * @param {Object} [options]
+     *   [en]Parameter object.[/en]
+     *   [ja][/ja]
+     * @param {Function} [options.callback]
+     *   [en]A function that will be executed after the animation has finished.[/en]
+     *   [ja][/ja]
+     * @param {String} [options.animation]
+     *   [en]If this attribute is set to `"none"` the transitions will not be animated.[/en]
+     *   [ja][/ja]
+     * @param {Object} [options.animationOptions]
+     *   [en]An object that can be used to specify the duration, delay and timing function of the animation.[/en]
+     *   [ja][/ja]
+     * @return {Promise}
+     *   [en]Resolves to the carousel element[/en]
+     *   [ja]Resolves to the carousel element[/ja]
+     * @description
+     *   [en]Show last ons-carousel item.[/en]
+     *   [ja]最後のons-carousel-itemを表示します。[/ja]
+     */
+
+  }, {
+    key: 'last',
+    value: function last(options) {
+      this.setActiveIndex(Math.max(this.itemCount - 1, 0), options);
+    }
+
+    /**
+     * @method refresh
+     * @signature refresh()
+     * @description
+     *   [en]Update the layout of the carousel. Used when adding `<ons-carousel-items>` dynamically or to automatically adjust the size.[/en]
+     *   [ja]レイアウトや内部の状態を最新のものに更新します。ons-carousel-itemを動的に増やしたり、ons-carouselの大きさを動的に変える際に利用します。[/ja]
+     */
+
+  }, {
+    key: 'refresh',
+    value: function refresh() {
+      this._swiper.refresh();
+    }
+
+    /**
+     * @property itemCount
+     * @readonly
+     * @type {Number}
+     * @description
+     *   [en]The number of carousel items.[/en]
+     *   [ja]カルーセル要素の数です。[/ja]
+     */
+
+  }, {
+    key: 'itemCount',
+    get: function get$$1() {
+      return this._swiper.itemCount;
+    }
+
+    /**
+     * @property swipeable
+     * @type {Boolean}
+     * @description
+     *   [en]true if the carousel is swipeable.[/en]
+     *   [ja]swipeableであればtrueを返します。[/ja]
+     */
+
+  }, {
+    key: 'swipeable',
+    get: function get$$1() {
+      return this.hasAttribute('swipeable');
+    },
+    set: function set$$1(value) {
+      return util$1.toggleAttribute(this, 'swipeable', value);
+    }
+
+    /**
+     * @property onSwipe
+     * @type {Function}
+     * @description
+     *   [en]Hook called whenever the user slides the carousel. It gets a decimal index and an animationOptions object as arguments.[/en]
+     *   [ja][/ja]
+     */
+
+  }, {
+    key: 'onSwipe',
+    get: function get$$1() {
+      return this._onSwipe;
+    },
+    set: function set$$1(value) {
+      if (value && !(value instanceof Function)) {
+        util$1.throw('"onSwipe" must be a function');
+      }
+      this._onSwipe = value;
+    }
+
+    /**
+     * @property autoScroll
+     * @type {Boolean}
+     * @description
+     *   [en]true if auto scroll is enabled.[/en]
+     *   [ja]オートスクロールが有効であればtrueを返します。[/ja]
+     */
+
+  }, {
+    key: 'autoScroll',
+    get: function get$$1() {
+      return this.hasAttribute('auto-scroll');
+    },
+    set: function set$$1(value) {
+      return util$1.toggleAttribute(this, 'auto-scroll', value);
+    }
+  }, {
+    key: 'vertical',
+    get: function get$$1() {
+      return this.getAttribute('direction') === 'vertical';
+    }
+  }, {
+    key: 'itemSize',
+    get: function get$$1() {
+      var itemSizeAttr = (this.getAttribute('item-' + (this.vertical ? 'height' : 'width')) || '').trim();
+      return itemSizeAttr.match(/^\d+(px|%)$/) ? itemSizeAttr : '100%';
+    }
+
+    /**
+     * @property autoScrollRatio
+     * @type {Number}
+     * @description
+     *   [en]The current auto scroll ratio. [/en]
+     *   [ja]現在のオートスクロールのratio値。[/ja]
+     */
+
+  }, {
+    key: 'autoScrollRatio',
+    get: function get$$1() {
+      return parseFloat(this.getAttribute('auto-scroll-ratio'));
+    },
+    set: function set$$1(ratio) {
+      this.setAttribute('auto-scroll-ratio', ratio);
+    }
+
+    /**
+     * @property disabled
+     * @type {Boolean}
+     * @description
+     *   [en]Whether the carousel is disabled or not.[/en]
+     *   [ja]無効化されている場合に`true`。[/ja]
+     */
+
+  }, {
+    key: 'disabled',
+    get: function get$$1() {
+      return this.hasAttribute('disabled');
+    },
+    set: function set$$1(value) {
+      return util$1.toggleAttribute(this, 'disabled', value);
+    }
+
+    /**
+     * @property overscrollable
+     * @type {Boolean}
+     * @description
+     *   [en]Whether the carousel is overscrollable or not.[/en]
+     *   [ja]overscrollできればtrueを返します。[/ja]
+     */
+
+  }, {
+    key: 'overscrollable',
+    get: function get$$1() {
+      return this.hasAttribute('overscrollable');
+    },
+    set: function set$$1(value) {
+      return util$1.toggleAttribute(this, 'overscrollable', value);
+    }
+
+    /**
+     * @property centered
+     * @type {Boolean}
+     * @description
+     *   [en]Whether the carousel is centered or not.[/en]
+     *   [ja]centered状態になっていればtrueを返します。[/ja]
+     */
+
+  }, {
+    key: 'centered',
+    get: function get$$1() {
+      return this.hasAttribute('centered');
+    },
+    set: function set$$1(value) {
+      return util$1.toggleAttribute(this, 'centered', value);
+    }
+  }], [{
+    key: 'observedAttributes',
+    get: function get$$1() {
+      return ['swipeable', 'auto-refresh', 'direction', 'item-height', 'item-width'];
+    }
+  }, {
+    key: 'events',
+    get: function get$$1() {
+      return ['postchange', 'refresh', 'overscroll'];
+    }
+  }]);
+  return CarouselElement;
+}(BaseElement);
+
+onsElements.Carousel = CarouselElement;
+customElements.define('ons-carousel', CarouselElement);
+
+/*
+Copyright 2013-2015 ASIAL CORPORATION
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+   http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+*/
+
+/**
+ * @element ons-col
+ * @category grid
+ * @description
+ *   [en]Represents a column in the grid system. Use with `<ons-row>` to layout components.[/en]
+ *   [ja]グリッドシステムにて列を定義します。ons-rowとともに使用し、コンポーネントのレイアウトに利用します。[/ja]
+ * @note
+ *   [en]For Android 4.3 and earlier, and iOS6 and earlier, when using mixed alignment with ons-row and ons-column, they may not be displayed correctly. You can use only one alignment.[/en]
+ *   [ja]Android 4.3以前、もしくはiOS 6以前のOSの場合、ons-rowとons-columnを組み合わせた場合に描画が崩れる場合があります。[/ja]
+ * @codepen GgujC {wide}
+ * @guide theming.html [en]Layouting guide[/en][ja]レイアウト機能[/ja]
+ * @seealso ons-row
+ *   [en]The `<ons-row>` component is the parent of `<ons-col>`.[/en]
+ *   [ja]ons-rowコンポーネント[/ja]
+ * @example
+ * <ons-row>
+ *   <ons-col width="50px"><ons-icon icon="fa-twitter"></ons-icon></ons-col>
+ *   <ons-col>Text</ons-col>
+ * </ons-row>
+ */
+
+/**
+ * @attribute vertical-align
+ * @type {String}
+ * @description
+ *   [en]Vertical alignment of the column. Valid values are "top", "center", and "bottom".[/en]
+ *   [ja]縦の配置を指定する。"top", "center", "bottom"のいずれかを指定します。[/ja]
+ */
+
+/**
+ * @attribute width
+ * @type {String}
+ * @description
+ *   [en]The width of the column. Valid values are css width values ("10%", "50px").[/en]
+ *   [ja]カラムの横幅を指定する。パーセントもしくはピクセルで指定します（10%や50px）。[/ja]
+ */
+
+var ColElement = function (_BaseElement) {
+  inherits(ColElement, _BaseElement);
+
+  function ColElement() {
+    classCallCheck(this, ColElement);
+
+    var _this = possibleConstructorReturn(this, (ColElement.__proto__ || Object.getPrototypeOf(ColElement)).call(this));
+
+    if (_this.getAttribute('width')) {
+      _this._updateWidth();
+    }
+    return _this;
+  }
+
+  createClass(ColElement, [{
+    key: 'attributeChangedCallback',
+    value: function attributeChangedCallback(name, last, current) {
+      if (name === 'width') {
+        this._updateWidth();
+      }
+    }
+  }, {
+    key: '_updateWidth',
+    value: function _updateWidth() {
+      var width = this.getAttribute('width');
+      if (!width) {
+        styler.clear(this, 'flex maxWidth');
+      } else {
+        width = width.trim().match(/^\d+$/) ? width + '%' : width;
+
+        styler(this, {
+          flex: '0 0 ' + width,
+          maxWidth: width
+        });
+      }
+    }
+  }], [{
+    key: 'observedAttributes',
+    get: function get$$1() {
+      return ['width'];
+    }
+  }]);
+  return ColElement;
+}(BaseElement);
+
+onsElements.Col = ColElement;
+customElements.define('ons-col', ColElement);
+
+/*
+Copyright 2013-2015 ASIAL CORPORATION
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+   http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+*/
+
+var DialogAnimator = function (_BaseAnimator) {
+  inherits(DialogAnimator, _BaseAnimator);
+
+  function DialogAnimator() {
+    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
+        _ref$timing = _ref.timing,
+        timing = _ref$timing === undefined ? 'linear' : _ref$timing,
+        _ref$delay = _ref.delay,
+        delay = _ref$delay === undefined ? 0 : _ref$delay,
+        _ref$duration = _ref.duration,
+        duration = _ref$duration === undefined ? 0.2 : _ref$duration;
+
+    classCallCheck(this, DialogAnimator);
+    return possibleConstructorReturn(this, (DialogAnimator.__proto__ || Object.getPrototypeOf(DialogAnimator)).call(this, { timing: timing, delay: delay, duration: duration }));
+  }
+
+  /**
+   * @param {HTMLElement} dialog
+   * @param {Function} done
+   */
+
+
+  createClass(DialogAnimator, [{
+    key: 'show',
+    value: function show(dialog, done) {
+      done();
+    }
+
+    /**
+     * @param {HTMLElement} dialog
+     * @param {Function} done
+     */
+
+  }, {
+    key: 'hide',
+    value: function hide(dialog, done) {
+      done();
+    }
+  }]);
+  return DialogAnimator;
+}(BaseAnimator);
+
+/**
+ * Android style animator for dialog.
+ */
+var AndroidDialogAnimator = function (_DialogAnimator) {
+  inherits(AndroidDialogAnimator, _DialogAnimator);
+
+  function AndroidDialogAnimator() {
+    var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
+        _ref2$timing = _ref2.timing,
+        timing = _ref2$timing === undefined ? 'ease-in-out' : _ref2$timing,
+        _ref2$delay = _ref2.delay,
+        delay = _ref2$delay === undefined ? 0 : _ref2$delay,
+        _ref2$duration = _ref2.duration,
+        duration = _ref2$duration === undefined ? 0.3 : _ref2$duration;
+
+    classCallCheck(this, AndroidDialogAnimator);
+    return possibleConstructorReturn(this, (AndroidDialogAnimator.__proto__ || Object.getPrototypeOf(AndroidDialogAnimator)).call(this, { timing: timing, delay: delay, duration: duration }));
+  }
+
+  /**
+   * @param {Object} dialog
+   * @param {Function} callback
+   */
+
+
+  createClass(AndroidDialogAnimator, [{
+    key: 'show',
+    value: function show(dialog, callback) {
+      callback = callback ? callback : function () {};
+
+      Animit.runAll(Animit(dialog._mask, this.def).default({ opacity: 0 }, { opacity: 1 }), Animit(dialog._dialog, this.def).default({ transform: 'translate3d(-50%, -60%, 0)', opacity: 0 }, { transform: 'translate3d(-50%, -50%, 0)', opacity: 1 }).queue(function (done) {
+        callback();
+        done();
+      }));
+    }
+
+    /**
+     * @param {Object} dialog
+     * @param {Function} callback
+     */
+
+  }, {
+    key: 'hide',
+    value: function hide(dialog, callback) {
+      callback = callback ? callback : function () {};
+
+      Animit.runAll(Animit(dialog._mask, this.def).default({ opacity: 1 }, { opacity: 0 }), Animit(dialog._dialog, this.def).default({ transform: 'translate3d(-50%, -50%, 0)', opacity: 1 }, { transform: 'translate3d(-50%, -60%, 0)', opacity: 0 }).queue(function (done) {
+        callback();
+        done();
+      }));
+    }
+  }]);
+  return AndroidDialogAnimator;
+}(DialogAnimator);
+
+/**
+ * iOS style animator for dialog.
+ */
+var IOSDialogAnimator = function (_DialogAnimator2) {
+  inherits(IOSDialogAnimator, _DialogAnimator2);
+
+  function IOSDialogAnimator() {
+    var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
+        _ref3$timing = _ref3.timing,
+        timing = _ref3$timing === undefined ? 'ease-in-out' : _ref3$timing,
+        _ref3$delay = _ref3.delay,
+        delay = _ref3$delay === undefined ? 0 : _ref3$delay,
+        _ref3$duration = _ref3.duration,
+        duration = _ref3$duration === undefined ? 0.2 : _ref3$duration;
+
+    classCallCheck(this, IOSDialogAnimator);
+
+    var _this3 = possibleConstructorReturn(this, (IOSDialogAnimator.__proto__ || Object.getPrototypeOf(IOSDialogAnimator)).call(this, { timing: timing, delay: delay, duration: duration }));
+
+    _this3.bodyHeight = document.body.clientHeight; // avoid Forced Synchronous Layout
+    return _this3;
+  }
+
+  /**
+   * @param {Object} dialog
+   * @param {Function} callback
+   */
+
+
+  createClass(IOSDialogAnimator, [{
+    key: 'show',
+    value: function show(dialog, callback) {
+      callback = callback ? callback : function () {};
+
+      Animit.runAll(Animit(dialog._mask, this.def).default({ opacity: 0 }, { opacity: 1 }), Animit(dialog._dialog, this.def).default({ transform: 'translate3d(-50%, ' + (this.bodyHeight / 2.0 - 1) + 'px, 0)' }, { transform: 'translate3d(-50%, -50%, 0)' }).queue(function (done) {
+        callback();
+        done();
+      }));
+    }
+
+    /**
+     * @param {Object} dialog
+     * @param {Function} callback
+     */
+
+  }, {
+    key: 'hide',
+    value: function hide(dialog, callback) {
+      callback = callback ? callback : function () {};
+
+      Animit.runAll(Animit(dialog._mask, this.def).default({ opacity: 1 }, { opacity: 0 }), Animit(dialog._dialog, this.def).default({ transform: 'translate3d(-50%, -50%, 0)' }, { transform: 'translate3d(-50%, ' + (this.bodyHeight / 2.0 - 1) + 'px, 0)' }).queue(function (done) {
+        callback();
+        done();
+      }));
+    }
+  }]);
+  return IOSDialogAnimator;
+}(DialogAnimator);
+
+/**
+ * Slide animator for dialog.
+ */
+var SlideDialogAnimator = function (_DialogAnimator3) {
+  inherits(SlideDialogAnimator, _DialogAnimator3);
+
+  function SlideDialogAnimator() {
+    var _ref4 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
+        _ref4$timing = _ref4.timing,
+        timing = _ref4$timing === undefined ? 'cubic-bezier(.1, .7, .4, 1)' : _ref4$timing,
+        _ref4$delay = _ref4.delay,
+        delay = _ref4$delay === undefined ? 0 : _ref4$delay,
+        _ref4$duration = _ref4.duration,
+        duration = _ref4$duration === undefined ? 0.2 : _ref4$duration;
+
+    classCallCheck(this, SlideDialogAnimator);
+
+    var _this4 = possibleConstructorReturn(this, (SlideDialogAnimator.__proto__ || Object.getPrototypeOf(SlideDialogAnimator)).call(this, { timing: timing, delay: delay, duration: duration }));
+
+    _this4.bodyHeight = document.body.clientHeight; // avoid Forced Synchronous Layout
+    return _this4;
+  }
+
+  /**
+   * @param {Object} dialog
+   * @param {Function} callback
+   */
+
+
+  createClass(SlideDialogAnimator, [{
+    key: 'show',
+    value: function show(dialog, callback) {
+      callback = callback ? callback : function () {};
+
+      Animit.runAll(Animit(dialog._mask, this.def).default({ opacity: 0 }, { opacity: 1 }), Animit(dialog._dialog, this.def).default(
+      // FIXME: This should avoid Forced Synchronous Layout. Otherwise, fade animation of mask will be broken.
+      { transform: 'translate3d(-50%, ' + (-(this.bodyHeight / 2.0) + 1 - dialog._dialog.clientHeight) + 'px, 0)' }, { transform: 'translate3d(-50%, -50%, 0)' }).queue(function (done) {
+        callback();
+        done();
+      }));
+    }
+
+    /**
+     * @param {Object} dialog
+     * @param {Function} callback
+     */
+
+  }, {
+    key: 'hide',
+    value: function hide(dialog, callback) {
+      callback = callback ? callback : function () {};
+
+      Animit.runAll(Animit(dialog._mask, this.def).default({ opacity: 1 }, { opacity: 0 }), Animit(dialog._dialog, this.def).default({ transform: 'translate3d(-50%, -50%, 0)' },
+      // FIXME: This should avoid Forced Synchronous Layout. Otherwise, fade animation of mask will be broken.
+      { transform: 'translate3d(-50%, ' + (-(this.bodyHeight / 2.0) + 1 - dialog._dialog.clientHeight) + 'px, 0)' }).queue(function (done) {
+        callback();
+        done();
+      }));
+    }
+  }]);
+  return SlideDialogAnimator;
+}(DialogAnimator);
+
+/*
+Copyright 2013-2015 ASIAL CORPORATION
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+   http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+*/
+
+var scheme$6 = {
+  '.dialog': 'dialog--*',
+  '.dialog-container': 'dialog-container--*',
+  '.dialog-mask': 'dialog-mask--*'
+};
+
+var _animatorDict$2 = {
+  'default': function _default() {
+    return platform.isAndroid() ? AndroidDialogAnimator : IOSDialogAnimator;
+  },
+  'slide': SlideDialogAnimator,
+  'none': DialogAnimator
+};
+
+/**
+ * @element ons-dialog
+ * @category dialog
+ * @description
+ *   [en]
+ *     Dialog that is displayed on top of current screen. As opposed to the `<ons-alert-dialog>` element, this component can contain any kind of content.
+ *
+ *     To use the element it can either be attached directly to the `<body>` element or dynamically created from a template using the `ons.createDialog(template)` utility function and the `<template>` tag.
+ *
+ *     The dialog is useful for displaying menus, additional information or to ask the user to make a decision.
+ *
+ *     It will automatically be displayed as Material Design when running on an Android device.
+ *   [/en]
+ *   [ja][/ja]
+ * @modifier material
+ *   [en]Display a Material Design dialog.[/en]
+ *   [ja]マテリアルデザインのダイアログを表示します。[/ja]
+ * @codepen zxxaGa
+ * @tutorial vanilla/Reference/dialog
+ * @guide theming.html#modifiers [en]More details about the `modifier` attribute[/en][ja]modifier属性の使い方[/ja]
+ * @seealso ons-alert-dialog
+ *   [en]`<ons-alert-dialog>` component[/en]
+ *   [ja]ons-alert-dialogコンポーネント[/ja]
+ * @seealso ons-popover
+ *   [en]`<ons-popover>` component[/en]
+ *   [ja]ons-popoverコンポーネント[/ja]
+ * @seealso ons-modal
+ *   [en]`<ons-modal>` component[/en]
+ *   [ja]ons-modalコンポーネント[/ja]
+ * @example
+ * <ons-dialog id="dialog">
+ *   <p>This is a dialog!</p>
+ * </ons-dialog>
+ *
+ * <script>
+ *   document.getElementById('dialog').show();
+ * </script>
+ */
+
+var DialogElement = function (_BaseDialogElement) {
+  inherits(DialogElement, _BaseDialogElement);
+
+  /**
+   * @event preshow
+   * @description
+   * [en]Fired just before the dialog is displayed.[/en]
+   * [ja]ダイアログが表示される直前に発火します。[/ja]
+   * @param {Object} event [en]Event object.[/en]
+   * @param {Object} event.dialog
+   *   [en]Component object.[/en]
+   *   [ja]コンポーネントのオブジェクト。[/ja]
+   * @param {Function} event.cancel
+   *   [en]Execute this function to stop the dialog from being shown.[/en]
+   *   [ja]この関数を実行すると、ダイアログの表示がキャンセルされます。[/ja]
+   */
+
+  /**
+   * @event postshow
+   * @description
+   * [en]Fired just after the dialog is displayed.[/en]
+   * [ja]ダイアログが表示された直後に発火します。[/ja]
+   * @param {Object} event [en]Event object.[/en]
+   * @param {Object} event.dialog
+   *   [en]Component object.[/en]
+   *   [ja]コンポーネントのオブジェクト。[/ja]
+   */
+
+  /**
+   * @event prehide
+   * @description
+   * [en]Fired just before the dialog is hidden.[/en]
+   * [ja]ダイアログが隠れる直前に発火します。[/ja]
+   * @param {Object} event [en]Event object.[/en]
+   * @param {Object} event.dialog
+   *   [en]Component object.[/en]
+   *   [ja]コンポーネントのオブジェクト。[/ja]
+   * @param {Function} event.cancel
+   *   [en]Execute this function to stop the dialog from being hidden.[/en]
+   *   [ja]この関数を実行すると、ダイアログの非表示がキャンセルされます。[/ja]
+   */
+
+  /**
+   * @event posthide
+   * @description
+   * [en]Fired just after the dialog is hidden.[/en]
+   * [ja]ダイアログが隠れた後に発火します。[/ja]
+   * @param {Object} event [en]Event object.[/en]
+   * @param {Object} event.dialog
+   *   [en]Component object.[/en]
+   *   [ja]コンポーネントのオブジェクト。[/ja]
+   */
+
+  /**
+   * @attribute modifier
+   * @type {String}
+   * @description
+   *  [en]The appearance of the dialog.[/en]
+   *  [ja]ダイアログの表現を指定します。[/ja]
+   */
+
+  /**
+   * @attribute cancelable
+   * @description
+   *  [en]If this attribute is set the dialog can be closed by tapping the background or by pressing the back button on Android devices.[/en]
+   *  [ja][/ja]
+   */
+
+  /**
+   * @attribute disabled
+   * @description
+   *  [en]If this attribute is set the dialog is disabled.[/en]
+   *  [ja]この属性がある時、ダイアログはdisabled状態になります。[/ja]
+   */
+
+  /**
+   * @attribute animation
+   * @type {String}
+   * @default default
+   * @description
+   *  [en]The animation used when showing and hiding the dialog. Can be either `"none"` or `"default"`.[/en]
+   *  [ja]ダイアログを表示する際のアニメーション名を指定します。"none"もしくは"default"を指定できます。[/ja]
+   */
+
+  /**
+   * @attribute animation-options
+   * @type {Expression}
+   * @description
+   *  [en]Specify the animation's duration, timing and delay with an object literal. E.g. `{duration: 0.2, delay: 1, timing: 'ease-in'}`.[/en]
+   *  [ja]アニメーション時のduration, timing, delayをオブジェクトリテラルで指定します。e.g. `{duration: 0.2, delay: 1, timing: 'ease-in'}`[/ja]
+   */
+
+  /**
+   * @attribute mask-color
+   * @type {String}
+   * @default rgba(0, 0, 0, 0.2)
+   * @description
+   *  [en]Color of the background mask. Default is `"rgba(0, 0, 0, 0.2)"`.[/en]
+   *  [ja]背景のマスクの色を指定します。"rgba(0, 0, 0, 0.2)"がデフォルト値です。[/ja]
+   */
+
+  function DialogElement() {
+    classCallCheck(this, DialogElement);
+
+    var _this = possibleConstructorReturn(this, (DialogElement.__proto__ || Object.getPrototypeOf(DialogElement)).call(this));
+
+    contentReady(_this, function () {
+      return _this._compile();
+    });
+    return _this;
+  }
+
+  createClass(DialogElement, [{
+    key: '_updateAnimatorFactory',
+    value: function _updateAnimatorFactory() {
+      return new AnimatorFactory({
+        animators: _animatorDict$2,
+        baseClass: DialogAnimator,
+        baseClassName: 'DialogAnimator',
+        defaultAnimation: this.getAttribute('animation')
+      });
+    }
+  }, {
+    key: '_compile',
+    value: function _compile() {
+      autoStyle.prepare(this);
+
+      this.style.display = 'none';
+      this.style.zIndex = 10001;
+
+      /* Expected result:
+       *   <ons-dialog>
+       *     <div class="dialog-mask"></div>
+       *     <div class="dialog">
+       *       <div class="dialog-container">...</div>
+       *     </div>
+       *   </ons-dialog>
+       */
+
+      if (!this._dialog) {
+        var dialog = document.createElement('div');
+        dialog.classList.add('dialog');
+
+        var container = document.createElement('div');
+        container.classList.add('dialog-container');
+        while (this.firstChild) {
+          container.appendChild(this.firstChild);
+        }
+        dialog.appendChild(container);
+
+        this.appendChild(dialog);
+      }
+
+      if (!this._mask) {
+        var mask = document.createElement('div');
+        mask.classList.add('dialog-mask');
+        this.insertBefore(mask, this.firstChild);
+      }
+
+      this._dialog.style.zIndex = 20001;
+      this._mask.style.zIndex = 20000;
+
+      this.setAttribute('status-bar-fill', '');
+
+      ModifierUtil.initModifier(this, this._scheme);
+    }
+
+    /**
+     * @property onDeviceBackButton
+     * @type {Object}
+     * @description
+     *   [en]Back-button handler.[/en]
+     *   [ja]バックボタンハンドラ。[/ja]
+     */
+
+    /**
+     * @method show
+     * @signature show([options])
+     * @param {Object} [options]
+     *   [en]Parameter object.[/en]
+     *   [ja]オプションを指定するオブジェクト。[/ja]
+     * @param {String} [options.animation]
+     *   [en]Animation name. Available animations are `"none"` and `"slide"`.[/en]
+     *   [ja]アニメーション名を指定します。"none", "slide"のいずれかを指定します。[/ja]
+     * @param {String} [options.animationOptions]
+     *   [en]Specify the animation's duration, delay and timing. E.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}`.[/en]
+     *   [ja]アニメーション時のduration, delay, timingを指定します。e.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}` [/ja]
+     * @param {Function} [options.callback]
+     *   [en]This function is called after the dialog has been revealed.[/en]
+     *   [ja]ダイアログが表示され終わった後に呼び出される関数オブジェクトを指定します。[/ja]
+     * @description
+     *  [en]Show the dialog.[/en]
+     *  [ja]ダイアログを開きます。[/ja]
+     * @return {Promise} Resolves to the displayed element.
+     */
+
+    /**
+     * @method hide
+     * @signature hide([options])
+     * @param {Object} [options]
+     *   [en]Parameter object.[/en]
+     *   [ja]オプションを指定するオブジェクト。[/ja]
+     * @param {String} [options.animation]
+     *   [en]Animation name. Available animations are `"none"` and `"slide"`.[/en]
+     *   [ja]アニメーション名を指定します。"none", "slide"のいずれかを指定できます。[/ja]
+     * @param {String} [options.animationOptions]
+     *   [en]Specify the animation's duration, delay and timing. E.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}`.[/en]
+     *   [ja]アニメーション時のduration, delay, timingを指定します。e.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}`[/ja]
+     * @param {Function} [options.callback]
+     *   [en]This functions is called after the dialog has been hidden.[/en]
+     *   [ja]ダイアログが隠れた後に呼び出される関数オブジェクトを指定します。[/ja]
+     * @description
+     *   [en]Hide the dialog.[/en]
+     *   [ja]ダイアログを閉じます。[/ja]
+     * @return {Promise}
+     *   [en]Resolves to the hidden element[/en]
+     *   [ja][/ja]
+     */
+
+    /**
+     * @property visible
+     * @readonly
+     * @type {Boolean}
+     * @description
+     *   [en]Whether the dialog is visible or not.[/en]
+     *   [ja]要素が見える場合に`true`。[/ja]
+     */
+
+    /**
+     * @property disabled
+     * @type {Boolean}
+     * @description
+     *   [en]Whether the dialog is disabled or not.[/en]
+     *   [ja]無効化されている場合に`true`。[/ja]
+     */
+
+    /**
+     * @property cancelable
+     * @type {Boolean}
+     * @description
+     *   [en]Whether the dialog is cancelable or not. A cancelable dialog can be closed by tapping the background or by pressing the back button on Android devices.[/en]
+     *   [ja][/ja]
+     */
+
+    /**
+     * @param {String} name
+     * @param {DialogAnimator} Animator
+     */
+
+  }, {
+    key: '_scheme',
+    get: function get$$1() {
+      return scheme$6;
+    }
+  }, {
+    key: '_mask',
+    get: function get$$1() {
+      return util$1.findChild(this, '.dialog-mask');
+    }
+  }, {
+    key: '_dialog',
+    get: function get$$1() {
+      return util$1.findChild(this, '.dialog');
+    }
+  }], [{
+    key: 'registerAnimator',
+    value: function registerAnimator(name, Animator) {
+      if (!(Animator.prototype instanceof DialogAnimator)) {
+        util$1.throwAnimator('Dialog');
+      }
+      _animatorDict$2[name] = Animator;
+    }
+  }, {
+    key: 'animators',
+    get: function get$$1() {
+      return _animatorDict$2;
+    }
+  }, {
+    key: 'DialogAnimator',
+    get: function get$$1() {
+      return DialogAnimator;
+    }
+  }]);
+  return DialogElement;
+}(BaseDialogElement);
+
+onsElements.Dialog = DialogElement;
+customElements.define('ons-dialog', DialogElement);
+
+/*
+Copyright 2013-2015 ASIAL CORPORATION
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+   http://www.apache.org/licenses/LICENSE-2.0
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+*/
+
+var defaultClassName$3 = 'fab';
+
+var scheme$7 = {
+  '': 'fab--*',
+  '.fab__icon': 'fab--*__icon'
+};
+
+/**
+ * @element ons-fab
+ * @category form
+ * @description
+ *   [en]
+ *     The Floating action button is a circular button defined in the [Material Design specification](https://www.google.com/design/spec/components/buttons-floating-action-button.html). They are often used to promote the primary action of the app.
+ *
+ *     It can be displayed either as an inline element or in one of the corners. Normally it will be positioned in the lower right corner of the screen.
+ *   [/en]
+ *   [ja][/ja]
+ * @tutorial vanilla/Reference/fab
+ * @modifier mini
+ *   [en]Makes the `ons-fab` smaller.[/en]
+ *   [ja][/ja]
+ * @guide theming.html#cross-platform-styling-autostyling [en]Information about cross platform styling[/en][ja]Information about cross platform styling[/ja]
+ * @seealso ons-speed-dial
+ *   [en]The `<ons-speed-dial>` component is a Floating action button that displays a menu when tapped.[/en]
+ *   [ja][/ja]
+ */
+
+var FabElement = function (_BaseElement) {
+  inherits(FabElement, _BaseElement);
+
+  /**
+   * @attribute modifier
+   * @type {String}
+   * @description
+   *  [en]The appearance of the button.[/en]
+   *  [ja]ボタンの表現を指定します。[/ja]
+   */
+
+  /**
+   * @attribute ripple
+   * @description
+   *  [en]If this attribute is defined, the button will have a ripple effect when tapped.[/en]
+   *  [ja][/ja]
+   */
+
+  /**
+   * @attribute position
+   * @type {String}
+   * @description
+   *  [en]The position of the button. Should be a string like `"bottom right"` or `"top left"`. If this attribute is not defined it will be displayed as an inline element.[/en]
+   *  [ja][/ja]
+   */
+
+  /**
+   * @attribute disabled
+   * @description
+   *   [en]Specify if button should be disabled.[/en]
+   *   [ja]ボタンを無効化する場合は指定します。[/ja]
+   */
+
+  function FabElement() {
+    classCallCheck(this, FabElement);
+
+    // The following statements can be executed before contentReady
+    // since these do not access the children
+    var _this = possibleConstructorReturn(this, (FabElement.__proto__ || Object.getPrototypeOf(FabElement)).call(this));
+
+    _this._hide();
+    _this.classList.add(defaultClassName$3);
+
+    contentReady(_this, function () {
+      _this._compile();
+    });
+    return _this;
+  }
+
+  createClass(FabElement, [{
+    key: '_compile',
+    value: function _compile() {
+      autoStyle.prepare(this);
+
+      if (!util$1.findChild(this, '.fab__icon')) {
+        var content = document.createElement('span');
+        content.classList.add('fab__icon');
+
+        util$1.arrayFrom(this.childNodes).forEach(function (element) {
+          if (!element.tagName || element.tagName.toLowerCase() !== 'ons-ripple') {
+            content.appendChild(element);
+          }
+        });
+        this.appendChild(content);
+      }
+
+      this._updateRipple();
+
+      ModifierUtil.initModifier(this, scheme$7);
+
+      this._updatePosition();
+    }
+  }, {
+    key: 'connectedCallback',
+    value: function connectedCallback() {
+      var _this2 = this;
+
+      setImmediate(function () {
+        return _this2._show();
+      });
+    }
+  }, {
+    key: 'attributeChangedCallback',
+    value: function attributeChangedCallback(name, last, current) {
+      switch (name) {
+        case 'class':
+          util$1.restoreClass(this, defaultClassName$3, scheme$7);
+          break;
+        case 'modifier':
+          ModifierUtil.onModifierChanged(last, current, this, scheme$7);
+          break;
+        case 'ripple':
+          this._updateRipple();
+          break;
+        case 'position':
+          this._updatePosition();
+          break;
+      }
+    }
+  }, {
+    key: '_show',
+    value: function _show() {
+      if (!this._manuallyHidden) {
+        // if user has not called ons-fab.hide()
+        this._toggle(true);
+      }
+    }
+  }, {
+    key: '_hide',
+    value: function _hide() {
+      var _this3 = this;
+
+      setImmediate(function () {
+        return _this3._toggle(false);
+      });
+    }
+  }, {
+    key: '_updateRipple',
+    value: function _updateRipple() {
+      util$1.updateRipple(this);
+    }
+  }, {
+    key: '_updatePosition',
+    value: function _updatePosition() {
+      var position = this.getAttribute('position');
+      this.classList.remove('fab--top__left', 'fab--bottom__right', 'fab--bottom__left', 'fab--top__right', 'fab--top__center', 'fab--bottom__center');
+      switch (position) {
+        case 'top right':
+        case 'right top':
+          this.classList.add('fab--top__right');
+          break;
+        case 'top left':
+        case 'left top':
+          this.classList.add('fab--top__left');
+          break;
+        case 'bottom right':
+        case 'right bottom':
+          this.classList.add('fab--bottom__right');
+          break;
+        case 'bottom left':
+        case 'left bottom':
+          this.classList.add('fab--bottom__left');
+          break;
+        case 'center top':
+        case 'top center':
+          this.classList.add('fab--top__center');
+          break;
+        case 'center bottom':
+        case 'bottom center':
+          this.classList.add('fab--bottom__center');
+          break;
+        default:
+          break;
+      }
+    }
+
+    /**
+     * @method show
+     * @signature show()
+     * @description
+     *  [en]Show the floating action button.[/en]
+     *  [ja][/ja]
+     */
+
+  }, {
+    key: 'show',
+    value: function show() {
+      this.toggle(true);
+    }
+
+    /**
+     * @method hide
+     * @signature hide()
+     * @description
+     *  [en]Hide the floating action button.[/en]
+     *  [ja][/ja]
+     */
+
+  }, {
+    key: 'hide',
+    value: function hide() {
+      this.toggle(false);
+    }
+
+    /**
+     * @method toggle
+     * @signature toggle()
+     * @description
+     *   [en]Toggle the visibility of the button.[/en]
+     *   [ja][/ja]
+     */
+
+  }, {
+    key: 'toggle',
+    value: function toggle() {
+      var action = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : !this.visible;
+
+      this._manuallyHidden = !action;
+      this._toggle(action);
+    }
+  }, {
+    key: '_toggle',
+    value: function _toggle() {
+      var action = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : !this.visible;
+
+      var isBottom = (this.getAttribute('position') || '').indexOf('bottom') >= 0;
+      var translate = isBottom ? 'translate3d(0px, -' + (util$1.globals.fabOffset || 0) + 'px, 0px)' : '';
+
+      styler(this, { transform: translate + ' scale(' + Number(action) + ')' });
+    }
+
+    /**
+     * @property disabled
+     * @type {Boolean}
+     * @description
+     *   [en]Whether the element is disabled or not.[/en]
+     *   [ja]無効化されている場合に`true`。[/ja]
+     */
+
+  }, {
+    key: 'disabled',
+    set: function set$$1(value) {
+      return util$1.toggleAttribute(this, 'disabled', value);
+    },
+    get: function get$$1() {
+      return this.hasAttribute('disabled');
+    }
+
+    /**
+     * @property visible
+     * @readonly
+     * @type {Boolean}
+     * @description
+     *   [en]Whether the element is visible or not.[/en]
+     *   [ja]要素が見える場合に`true`。[/ja]
+     */
+
+  }, {
+    key: 'visible',
+    get: function get$$1() {
+      return this.style.transform.indexOf('scale(0)') === -1 && this.style.display !== 'none';
+    }
+  }], [{
+    key: 'observedAttributes',
+    get: function get$$1() {
+      return ['modifier', 'ripple', 'position', 'class'];
+    }
+  }]);
+  return FabElement;
+}(BaseElement);
+
+onsElements.Fab = FabElement;
+customElements.define('ons-fab', FabElement);
+
+/*
+Copyright 2013-2015 ASIAL CORPORATION
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+   http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+*/
+
+/**
+ * @element ons-gesture-detector
+ * @category gesture
+ * @description
+ *   [en]
+ *     Component to detect finger gestures within the wrapped element. Following gestures are supported:
+ *     - Drag gestures: `drag`, `dragleft`, `dragright`, `dragup`, `dragdown`
+ *     - Hold gestures: `hold`, `release`
+ *     - Swipe gestures: `swipe`, `swipeleft`, `swiperight`, `swipeup`, `swipedown`
+ *     - Tap gestures: `tap`, `doubletap`
+ *     - Pinch gestures: `pinch`, `pinchin`, `pinchout`
+ *     - Other gestures: `touch`, `transform`, `rotate`
+ *   [/en]
+ *   [ja]要素内のジェスチャー操作を検知します。詳しくはガイドを参照してください。[/ja]
+ * @guide features.html#gesture-detection
+ *   [en]Detecting finger gestures[/en]
+ *   [ja]ジェスチャー操作の検知[/ja]
+ * @example
+ * <ons-gesture-detector>
+ *   <div id="detect-area" style="width: 100px; height: 100px;">
+ *     Swipe Here
+ *   </div>
+ * </ons-gesture-detector>
+ *
+ * <script>
+ *   document.addEventListener('swipeleft', function(event) {
+ *     if (event.target.matches('#detect-area')) {
+ *       console.log('Swipe left is detected.');
+ *     }
+ *   });
+ * </script>
+ */
+
+var GestureDetectorElement = function (_BaseElement) {
+  inherits(GestureDetectorElement, _BaseElement);
+
+  function GestureDetectorElement() {
+    classCallCheck(this, GestureDetectorElement);
+
+    var _this = possibleConstructorReturn(this, (GestureDetectorElement.__proto__ || Object.getPrototypeOf(GestureDetectorElement)).call(this));
+
+    _this._gestureDetector = new GestureDetector(_this, { passive: true });
+    return _this;
+  }
+
+  return GestureDetectorElement;
+}(BaseElement);
+
+onsElements.GestureDetector = GestureDetectorElement;
+customElements.define('ons-gesture-detector', GestureDetectorElement);
+
+/*
+Copyright 2013-2015 ASIAL CORPORATION
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+   http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+*/
+
+var autoPrefix = 'fa'; // FIXME: To be removed in v3
+
+/**
+ * @element ons-icon
+ * @category visual
+ * @description
+ *   [en]
+ *     Displays an icon. The following icon suites are available:
+ *
+ *     * [Font Awesome](https://fortawesome.github.io/Font-Awesome/)
+ *     * [Ionicons](http://ionicons.com/)
+ *     * [Material Design Iconic Font](http://zavoloklom.github.io/material-design-iconic-font/)
+ *   [/en]
+ *   [ja][/ja]
+ * @codepen xAhvg
+ * @tutorial vanilla/Reference/icon
+ * @guide theming.html#cross-platform-styling-autostyling [en]Information about cross platform styling[/en][ja][/ja]
+ * @guide appsize.html#removing-icon-packs [en]Removing icon packs.[/en][ja][/ja]
+ * @guide faq.html#how-can-i-use-custom-icon-packs [en]Adding custom icon packs.[/en][ja][/ja]
+ * @example
+ * <ons-icon
+ *   icon="md-car"
+ *   size="20px"
+ *   style="color: red">
+ * </ons-icon>
+ *
+ * <ons-button>
+ *   <ons-icon icon="md-car"></ons-icon>
+ *   Car
+ * </ons-button>
+ */
+
+var IconElement = function (_BaseElement) {
+  inherits(IconElement, _BaseElement);
+
+  /**
+   * @attribute icon
+   * @type {String}
+   * @description
+   *   [en]
+   *     The icon name. `"md-"` prefix for Material Icons, `"fa-"` for Font Awesome and `"ion-"` prefix for Ionicons.
+   *
+   *     See all available icons on the element description (at the top).
+   *
+   *     Icons can also be styled based on modifier presence. Add comma-separated icons with `"modifierName:"` prefix.
+   *
+   *     The code `<ons-icon icon="ion-edit, material:md-edit"></ons-icon>` will display `"md-edit"` for Material Design and `"ion-edit"` as the default icon.
+   *
+   *     `fa-` prefix is added automatically if none is provided. Check [See also](#seealso) section for more information.
+   *   [/en]
+   *   [ja][/ja]
+   */
+
+  /**
+   * @attribute size
+   * @type {String}
+   * @description
+   *   [en]
+   *     The sizes of the icon. Valid values are lg, 2x, 3x, 4x, 5x, or in the size in pixels.
+   *     Icons can also be styled based on modifier presence. Add comma-separated icons with `"modifierName:"` prefix.
+   *
+   *     The code:
+   *
+   *     ```
+   *     <ons-icon
+   *       icon="ion-edit"
+   *       size="32px, material:24px">
+   *     </ons-icon>
+   *     ```
+   *
+   *     will render as a `24px` icon if the `"material"` modifier is present and `32px` otherwise.
+   *   [/en]
+   *   [ja][/ja]
+   */
+
+  /**
+   * @attribute rotate
+   * @type {Number}
+   * @description
+   *   [en]Number of degrees to rotate the icon. Valid values are 90, 180 and 270.[/en]
+   *   [ja]アイコンを回転して表示します。90, 180, 270から指定できます。[/ja]
+   */
+
+  /**
+   * @attribute fixed-width
+   * @type {Boolean}
+   * @default false
+   * @description
+   *  [en]When used in a list, you want the icons to have the same width so that they align vertically by defining this attribute.[/en]
+   *  [ja][/ja]
+   */
+
+  /**
+   * @attribute spin
+   * @description
+   *   [en]Specify whether the icon should be spinning.[/en]
+   *   [ja]アイコンを回転するかどうかを指定します。[/ja]
+   */
+
+  function IconElement() {
+    classCallCheck(this, IconElement);
+
+    var _this = possibleConstructorReturn(this, (IconElement.__proto__ || Object.getPrototypeOf(IconElement)).call(this));
+
+    contentReady(_this, function () {
+      _this._compile();
+    });
+    return _this;
+  }
+
+  createClass(IconElement, [{
+    key: 'attributeChangedCallback',
+    value: function attributeChangedCallback(name, last, current) {
+      this._cleanClassAttribute(name === 'icon' ? last : this.getAttribute('icon'), name === 'modifier' ? last : undefined);
+      this._update();
+    }
+  }, {
+    key: '_compile',
+    value: function _compile() {
+      autoStyle.prepare(this);
+      this._update();
+    }
+  }, {
+    key: '_update',
+    value: function _update() {
+      var _this2 = this;
+
+      var _buildClassAndStyle2 = this._buildClassAndStyle(this._parseAttr('icon'), this._parseAttr('size')),
+          classList = _buildClassAndStyle2.classList,
+          style = _buildClassAndStyle2.style;
+
+      util$1.extend(this.style, style);
+
+      classList.forEach(function (className) {
+        return _this2.classList.add(className);
+      });
+    }
+  }, {
+    key: '_parseAttr',
+    value: function _parseAttr(attrName) {
+      var modifier = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.getAttribute('modifier') || '';
+
+      var attr = this.getAttribute(attrName) || attrName || '';
+      var parts = attr.split(/\s*,\s*/);
+      var def = parts[0];
+      var md = parts[1];
+      md = (md || '').split(/\s*:\s*/);
+
+      return (modifier && RegExp('(^|\\s+)' + md[0] + '($|\\s+)', 'i').test(modifier) ? md[1] : def) || '';
+    }
+
+    /**
+     * Remove unneeded class value.
+     */
+
+  }, {
+    key: '_cleanClassAttribute',
+    value: function _cleanClassAttribute(lastIcon, lastModifier) {
+      var _this3 = this;
+
+      var _prefixIcon2 = this._prefixIcon(this._parseAttr(lastIcon, lastModifier)),
+          className = _prefixIcon2.className,
+          prefix = _prefixIcon2.prefix;
+
+      var customPrefixRE = className !== prefix ? '|' + prefix + '$|' + prefix + '-' : '|' + className + '$' || '';
+      var re = new RegExp('^(fa$|fa-|ion-|zmdi$|zmdi-|ons-icon--' + customPrefixRE + ')');
+
+      util$1.arrayFrom(this.classList).filter(function (className) {
+        return re.test(className);
+      }).forEach(function (className) {
+        return _this3.classList.remove(className);
+      });
+    }
+  }, {
+    key: '_prefixIcon',
+    value: function _prefixIcon(iconName) {
+      var className = autoPrefix + (autoPrefix ? '-' : '') + iconName;
+      return { className: className, prefix: className.split('-')[0] };
+    }
+  }, {
+    key: '_buildClassAndStyle',
+    value: function _buildClassAndStyle(iconName, size) {
+      var classList = ['ons-icon'];
+      var style = {};
+
+      // Icon
+      if (iconName.indexOf('ion-') === 0) {
+        classList.push(iconName);
+        classList.push('ons-icon--ion');
+      } else if (iconName.indexOf('fa-') === 0) {
+        classList.push(iconName);
+        // default icon style to Font Awesome Solid if icon style is not specified already
+        if (!(this.classList.contains('far') || this.classList.contains('fab') || this.classList.contains('fal'))) {
+          classList.push('fa');
+        }
+      } else if (iconName.indexOf('md-') === 0) {
+        classList.push('zmdi');
+        classList.push('zmdi-' + iconName.split(/-(.+)?/)[1]);
+      } else {
+        var _prefixIcon3 = this._prefixIcon(iconName),
+            className = _prefixIcon3.className,
+            prefix = _prefixIcon3.prefix;
+
+        prefix && classList.push(prefix);
+        className && classList.push(className);
+      }
+
+      // Size
+      if (size.match(/^[1-5]x|lg$/)) {
+        classList.push('ons-icon--' + size);
+        this.style.removeProperty('font-size');
+      } else {
+        style.fontSize = size;
+      }
+
+      return {
+        classList: classList,
+        style: style
+      };
+    }
+  }], [{
+    key: 'setAutoPrefix',
+    value: function setAutoPrefix(prefix) {
+      autoPrefix = prefix ? typeof prefix === 'string' && prefix || 'fa' : '';
+    }
+  }, {
+    key: 'observedAttributes',
+    get: function get$$1() {
+      return ['icon', 'size', 'modifier', 'class'];
+    }
+  }]);
+  return IconElement;
+}(BaseElement);
+
+onsElements.Icon = IconElement;
+customElements.define('ons-icon', IconElement);
+
+/*
+Copyright 2013-2015 ASIAL CORPORATION
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+   http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+*/
+
+var LazyRepeatDelegate = function () {
+  function LazyRepeatDelegate(userDelegate) {
+    var templateElement = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
+    classCallCheck(this, LazyRepeatDelegate);
+
+    if ((typeof userDelegate === 'undefined' ? 'undefined' : _typeof(userDelegate)) !== 'object' || userDelegate === null) {
+      util$1.throw('"delegate" parameter must be an object');
+    }
+    this._userDelegate = userDelegate;
+
+    if (!(templateElement instanceof Element) && templateElement !== null) {
+      util$1.throw('"templateElement" parameter must be an instance of Element or null');
+    }
+    this._templateElement = templateElement;
+  }
+
+  createClass(LazyRepeatDelegate, [{
+    key: 'hasRenderFunction',
+
+
+    /**
+     * @return {Boolean}
+     */
+    value: function hasRenderFunction() {
+      return this._userDelegate._render instanceof Function;
+    }
+
+    /**
+     * @return {void}
+     */
+
+  }, {
+    key: '_render',
+    value: function _render() {
+      this._userDelegate._render.apply(this._userDelegate, arguments);
+    }
+
+    /**
+     * @param {Number} index
+     * @param {Function} done A function that take item object as parameter.
+     */
+
+  }, {
+    key: 'loadItemElement',
+    value: function loadItemElement(index, done) {
+      if (this._userDelegate.loadItemElement instanceof Function) {
+        this._userDelegate.loadItemElement(index, done);
+      } else {
+        var element = this._userDelegate.createItemContent(index, this._templateElement);
+        if (!(element instanceof Element)) {
+          util$1.throw('"createItemContent" must return an instance of Element');
+        }
+
+        done({ element: element });
+      }
+    }
+
+    /**
+     * @return {Number}
+     */
+
+  }, {
+    key: 'countItems',
+    value: function countItems() {
+      var count = this._userDelegate.countItems();
+      if (typeof count !== 'number') {
+        util$1.throw('"countItems" must return a number');
+      }
+      return count;
+    }
+
+    /**
+     * @param {Number} index
+     * @param {Object} item
+     * @param {Element} item.element
+     */
+
+  }, {
+    key: 'updateItem',
+    value: function updateItem(index, item) {
+      if (this._userDelegate.updateItemContent instanceof Function) {
+        this._userDelegate.updateItemContent(index, item);
+      }
+    }
+
+    /**
+     * @return {Number}
+     */
+
+  }, {
+    key: 'calculateItemHeight',
+    value: function calculateItemHeight(index) {
+      if (this._userDelegate.calculateItemHeight instanceof Function) {
+        var height = this._userDelegate.calculateItemHeight(index);
+
+        if (typeof height !== 'number') {
+          util$1.throw('"calculateItemHeight" must return a number');
+        }
+
+        return height;
+      }
+
+      return 0;
+    }
+
+    /**
+     * @param {Number} index
+     * @param {Object} item
+     */
+
+  }, {
+    key: 'destroyItem',
+    value: function destroyItem(index, item) {
+      if (this._userDelegate.destroyItem instanceof Function) {
+        this._userDelegate.destroyItem(index, item);
+      }
+    }
+
+    /**
+     * @return {void}
+     */
+
+  }, {
+    key: 'destroy',
+    value: function destroy() {
+      if (this._userDelegate.destroy instanceof Function) {
+        this._userDelegate.destroy();
+      }
+
+      this._userDelegate = this._templateElement = null;
+    }
+  }, {
+    key: 'itemHeight',
+    get: function get$$1() {
+      return this._userDelegate.itemHeight;
+    }
+  }]);
+  return LazyRepeatDelegate;
+}();
+
+/**
+ * This class provide core functions for ons-lazy-repeat.
+ */
+var LazyRepeatProvider = function () {
+
+  /**
+   * @param {Element} wrapperElement
+   * @param {LazyRepeatDelegate} delegate
+   */
+  function LazyRepeatProvider(wrapperElement, delegate) {
+    classCallCheck(this, LazyRepeatProvider);
+
+    if (!(delegate instanceof LazyRepeatDelegate)) {
+      util$1.throw('"delegate" parameter must be an instance of LazyRepeatDelegate');
+    }
+
+    this._wrapperElement = wrapperElement;
+    this._delegate = delegate;
+    this._insertIndex = this._wrapperElement.children[0] && this._wrapperElement.children[0].tagName === 'ONS-LAZY-REPEAT' ? 1 : 0;
+
+    if (wrapperElement.tagName.toLowerCase() === 'ons-list') {
+      wrapperElement.classList.add('lazy-list');
+    }
+
+    this._pageContent = this._findPageContentElement(wrapperElement);
+
+    if (!this._pageContent) {
+      util$1.throw('LazyRepeat must be descendant of a Page element');
+    }
+
+    this.lastScrollTop = this._pageContent.scrollTop;
+    this.padding = 0;
+    this._topPositions = [0];
+    this._renderedItems = {};
+
+    if (!this._delegate.itemHeight && !this._delegate.calculateItemHeight(0)) {
+      this._unknownItemHeight = true;
+    }
+
+    this._addEventListeners();
+    this._onChange();
+  }
+
+  createClass(LazyRepeatProvider, [{
+    key: '_findPageContentElement',
+    value: function _findPageContentElement(wrapperElement) {
+      var pageContent = util$1.findParent(wrapperElement, '.page__content');
+
+      if (pageContent) {
+        return pageContent;
+      }
+
+      var page = util$1.findParent(wrapperElement, 'ons-page');
+      if (page) {
+        var content = util$1.findChild(page, '.content');
+        if (content) {
+          return content;
+        }
+      }
+
+      return null;
+    }
+  }, {
+    key: '_checkItemHeight',
+    value: function _checkItemHeight(callback) {
+      var _this = this;
+
+      this._delegate.loadItemElement(0, function (item) {
+        if (!_this._unknownItemHeight) {
+          util$1.throw('Invalid state');
+        }
+
+        _this._wrapperElement.appendChild(item.element);
+
+        var done = function done() {
+          _this._delegate.destroyItem(0, item);
+          item.element && item.element.remove();
+          delete _this._unknownItemHeight;
+          callback();
+        };
+
+        _this._itemHeight = item.element.offsetHeight;
+
+        if (_this._itemHeight > 0) {
+          done();
+          return;
+        }
+
+        // retry to measure offset height
+        // dirty fix for angular2 directive
+        _this._wrapperElement.style.visibility = 'hidden';
+        item.element.style.visibility = 'hidden';
+
+        setImmediate(function () {
+          _this._itemHeight = item.element.offsetHeight;
+          if (_this._itemHeight == 0) {
+            util$1.throw('Invalid state: "itemHeight" must be greater than zero');
+          }
+          _this._wrapperElement.style.visibility = '';
+          done();
+        });
+      });
+    }
+  }, {
+    key: '_countItems',
+    value: function _countItems() {
+      return this._delegate.countItems();
+    }
+  }, {
+    key: '_getItemHeight',
+    value: function _getItemHeight(i) {
+      // Item is rendered
+      if (this._renderedItems.hasOwnProperty(i)) {
+        if (!this._renderedItems[i].hasOwnProperty('height')) {
+          this._renderedItems[i].height = this._renderedItems[i].element.offsetHeight;
+        }
+        return this._renderedItems[i].height;
+      }
+
+      // Item is not rendered, scroll up
+      if (this._topPositions[i + 1] && this._topPositions[i]) {
+        return this._topPositions[i + 1] - this._topPositions[i];
+      }
+      // Item is not rendered, scroll down
+      return this.staticItemHeight || this._delegate.calculateItemHeight(i);
+    }
+  }, {
+    key: '_calculateRenderedHeight',
+    value: function _calculateRenderedHeight() {
+      var _this2 = this;
+
+      return Object.keys(this._renderedItems).reduce(function (a, b) {
+        return a + _this2._getItemHeight(+b);
+      }, 0);
+    }
+  }, {
+    key: '_onChange',
+    value: function _onChange() {
+      this._render();
+    }
+  }, {
+    key: '_lastItemRendered',
+    value: function _lastItemRendered() {
+      return Math.max.apply(Math, toConsumableArray(Object.keys(this._renderedItems)));
+    }
+  }, {
+    key: '_firstItemRendered',
+    value: function _firstItemRendered() {
+      return Math.min.apply(Math, toConsumableArray(Object.keys(this._renderedItems)));
+    }
+  }, {
+    key: 'refresh',
+    value: function refresh() {
+      var forceRender = { forceScrollDown: true };
+      var firstItemIndex = this._firstItemRendered();
+
+      if (util$1.isInteger(firstItemIndex)) {
+        this._wrapperElement.style.height = this._topPositions[firstItemIndex] + this._calculateRenderedHeight() + 'px';
+        this.padding = this._topPositions[firstItemIndex];
+        forceRender.forceFirstIndex = firstItemIndex;
+      }
+
+      this._removeAllElements();
+      this._render(forceRender);
+      this._wrapperElement.style.height = 'inherit';
+    }
+  }, {
+    key: '_render',
+    value: function _render() {
+      var _this3 = this;
+
+      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
+          _ref$forceScrollDown = _ref.forceScrollDown,
+          forceScrollDown = _ref$forceScrollDown === undefined ? false : _ref$forceScrollDown,
+          forceFirstIndex = _ref.forceFirstIndex,
+          forceLastIndex = _ref.forceLastIndex;
+
+      if (this._unknownItemHeight) {
+        return this._checkItemHeight(this._render.bind(this, arguments[0]));
+      }
+
+      var isScrollUp = !forceScrollDown && this.lastScrollTop > this._pageContent.scrollTop;
+      this.lastScrollTop = this._pageContent.scrollTop;
+      var keep = {};
+
+      var offset = this._wrapperElement.getBoundingClientRect().top;
+      var limit = 4 * window.innerHeight - offset;
+      var count = this._countItems();
+
+      var start = forceFirstIndex || Math.max(0, this._calculateStartIndex(offset) - 30); // Recalculate for 0 or undefined
+      var i = start;
+
+      for (var top = this._topPositions[i]; i < count && top < limit; i++) {
+        if (i >= this._topPositions.length) {
+          // perf optimization
+          this._topPositions.length += 100;
+        }
+
+        this._topPositions[i] = top;
+        top += this._getItemHeight(i);
+      }
+
+      if (this._delegate.hasRenderFunction && this._delegate.hasRenderFunction()) {
+        return this._delegate._render(start, i, function () {
+          _this3.padding = _this3._topPositions[start];
+        });
+      }
+
+      if (isScrollUp) {
+        for (var j = i - 1; j >= start; j--) {
+          keep[j] = true;
+          this._renderElement(j, isScrollUp);
+        }
+      } else {
+        var lastIndex = forceLastIndex || Math.max.apply(Math, [i - 1].concat(toConsumableArray(Object.keys(this._renderedItems)))); // Recalculate for 0 or undefined
+        for (var _j = start; _j <= lastIndex; _j++) {
+          keep[_j] = true;
+          this._renderElement(_j, isScrollUp);
+        }
+      }
+
+      Object.keys(this._renderedItems).forEach(function (key) {
+        return keep[key] || _this3._removeElement(key, isScrollUp);
+      });
+    }
+
+    /**
+     * @param {Number} index
+     * @param {Boolean} isScrollUp
+     */
+
+  }, {
+    key: '_renderElement',
+    value: function _renderElement(index, isScrollUp) {
+      var _this4 = this;
+
+      var item = this._renderedItems[index];
+      if (item) {
+        this._delegate.updateItem(index, item); // update if it exists
+        return;
+      }
+
+      this._delegate.loadItemElement(index, function (item) {
+        if (isScrollUp) {
+          _this4._wrapperElement.insertBefore(item.element, _this4._wrapperElement.children[_this4._insertIndex]);
+          _this4.padding = _this4._topPositions[index];
+          item.height = _this4._topPositions[index + 1] - _this4._topPositions[index];
+        } else {
+          _this4._wrapperElement.appendChild(item.element);
+        }
+
+        _this4._renderedItems[index] = item;
+      });
+    }
+
+    /**
+     * @param {Number} index
+     * @param {Boolean} isScrollUp
+     */
+
+  }, {
+    key: '_removeElement',
+    value: function _removeElement(index) {
+      var isScrollUp = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
+
+      index = +index;
+      var item = this._renderedItems[index];
+      this._delegate.destroyItem(index, item);
+
+      if (isScrollUp) {
+        this._topPositions[index + 1] = undefined;
+      } else {
+        this.padding = this.padding + this._getItemHeight(index);
+      }
+
+      if (item.element.parentElement) {
+        item.element.parentElement.removeChild(item.element);
+      }
+
+      delete this._renderedItems[index];
+    }
+  }, {
+    key: '_removeAllElements',
+    value: function _removeAllElements() {
+      var _this5 = this;
+
+      Object.keys(this._renderedItems).forEach(function (key) {
+        return _this5._removeElement(key);
+      });
+    }
+  }, {
+    key: '_recalculateTopPositions',
+    value: function _recalculateTopPositions(start, end) {
+      for (var i = start; i <= end; i++) {
+        this._topPositions[i + 1] = this._topPositions[i] + this._getItemHeight(i);
+      }
+    }
+  }, {
+    key: '_calculateStartIndex',
+    value: function _calculateStartIndex(current) {
+      var firstItemIndex = this._firstItemRendered();
+      var lastItemIndex = this._lastItemRendered();
+
+      // Fix for Safari scroll and Angular 2
+      this._recalculateTopPositions(firstItemIndex, lastItemIndex);
+
+      var start = 0;
+      var end = this._countItems() - 1;
+
+      // Binary search for index at top of screen so we can speed up rendering.
+      for (;;) {
+        var middle = Math.floor((start + end) / 2);
+        var value = current + this._topPositions[middle];
+
+        if (end < start) {
+          return 0;
+        } else if (value <= 0 && value + this._getItemHeight(middle) > 0) {
+          return middle;
+        } else if (isNaN(value) || value >= 0) {
+          end = middle - 1;
+        } else {
+          start = middle + 1;
+        }
+      }
+    }
+  }, {
+    key: '_debounce',
+    value: function _debounce(func, wait, immediate) {
+      var timeout = void 0;
+      return function () {
+        var _this6 = this,
+            _arguments = arguments;
+
+        var callNow = immediate && !timeout;
+        clearTimeout(timeout);
+        if (callNow) {
+          func.apply(this, arguments);
+        } else {
+          timeout = setTimeout(function () {
+            timeout = null;
+            func.apply(_this6, _arguments);
+          }, wait);
+        }
+      };
+    }
+  }, {
+    key: '_doubleFireOnTouchend',
+    value: function _doubleFireOnTouchend() {
+      this._render();
+      this._debounce(this._render.bind(this), 100);
+    }
+  }, {
+    key: '_addEventListeners',
+    value: function _addEventListeners() {
+      util$1.bindListeners(this, ['_onChange', '_doubleFireOnTouchend']);
+
+      if (platform.isIOS()) {
+        this._boundOnChange = this._debounce(this._boundOnChange, 30);
+      }
+
+      this._pageContent.addEventListener('scroll', this._boundOnChange, true);
+
+      if (platform.isIOS()) {
+        util$1.addEventListener(this._pageContent, 'touchmove', this._boundOnChange, { capture: true, passive: true });
+        this._pageContent.addEventListener('touchend', this._boundDoubleFireOnTouchend, true);
+      }
+
+      window.document.addEventListener('resize', this._boundOnChange, true);
+    }
+  }, {
+    key: '_removeEventListeners',
+    value: function _removeEventListeners() {
+      this._pageContent.removeEventListener('scroll', this._boundOnChange, true);
+
+      if (platform.isIOS()) {
+        util$1.removeEventListener(this._pageContent, 'touchmove', this._boundOnChange, { capture: true, passive: true });
+        this._pageContent.removeEventListener('touchend', this._boundDoubleFireOnTouchend, true);
+      }
+
+      window.document.removeEventListener('resize', this._boundOnChange, true);
+    }
+  }, {
+    key: 'destroy',
+    value: function destroy() {
+      this._removeAllElements();
+      this._delegate.destroy();
+      this._parentElement = this._delegate = this._renderedItems = null;
+      this._removeEventListeners();
+    }
+  }, {
+    key: 'padding',
+    get: function get$$1() {
+      return parseInt(this._wrapperElement.style.paddingTop, 10);
+    },
+    set: function set$$1(newValue) {
+      this._wrapperElement.style.paddingTop = newValue + 'px';
+    }
+  }, {
+    key: 'staticItemHeight',
+    get: function get$$1() {
+      return this._delegate.itemHeight || this._itemHeight;
+    }
+  }]);
+  return LazyRepeatProvider;
+}();
+
+/*
+Copyright 2013-2015 ASIAL CORPORATION
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+   http://www.apache.org/licenses/LICENSE-2.0
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+*/
+
+/**
+ * @element ons-lazy-repeat
+ * @category list
+ * @description
+ *   [en]
+ *     Using this component a list with millions of items can be rendered without a drop in performance.
+ *     It does that by "lazily" loading elements into the DOM when they come into view and
+ *     removing items from the DOM when they are not visible.
+ *   [/en]
+ *   [ja]
+ *     このコンポーネント内で描画されるアイテムのDOM要素の読み込みは、画面に見えそうになった時まで自動的に遅延され、
+ *     画面から見えなくなった場合にはその要素は動的にアンロードされます。
+ *     このコンポーネントを使うことで、パフォーマンスを劣化させること無しに巨大な数の要素を描画できます。
+ *   [/ja]
+ * @codepen QwrGBm
+ * @tutorial vanilla/Reference/lazy-repeat
+ * @seealso ons-list
+ *   [en]The `<ons-list>` element is used to render a list.[/en]
+ *   [ja]`<ons-list>`要素はリストを描画するのに使われます。[/ja]
+ * @example
+ * <script>
+ *   window.addEventListener('load', function() {
+ *     var lazyRepeat = document.querySelector('#list');
+ *     lazyRepeat.delegate = {
+ *      createItemContent: function(i, template) {
+ *        var dom = template.cloneNode(true);
+ *        dom.innerText = i;
+ *
+ *        return dom;
+ *      },
+ *      countItems: function() {
+ *        return 10000000;
+ *      },
+ *      destroyItem: function(index, item) {
+ *        console.log('Destroyed item with index: ' + index);
+ *      }
+ *     };
+ *   });
+ * </script>
+ *
+ * <ons-list id="list">
+ *   <ons-lazy-repeat>
+ *     <ons-list-item></ons-list-item>
+ *   </ons-lazy-repeat>
+ * </ons-list>
+ */
+
+var LazyRepeatElement = function (_BaseElement) {
+  inherits(LazyRepeatElement, _BaseElement);
+
+  function LazyRepeatElement() {
+    classCallCheck(this, LazyRepeatElement);
+    return possibleConstructorReturn(this, (LazyRepeatElement.__proto__ || Object.getPrototypeOf(LazyRepeatElement)).apply(this, arguments));
+  }
+
+  createClass(LazyRepeatElement, [{
+    key: 'connectedCallback',
+    value: function connectedCallback() {
+      // not very good idea and also not documented
+      if (this.hasAttribute('delegate')) {
+        this.delegate = window[this.getAttribute('delegate')];
+      }
+    }
+
+    /**
+     * @property delegate
+     * @type {Object}
+     * @description
+     *  [en]Specify a delegate object to load and unload item elements.[/en]
+     *  [ja]要素のロード、アンロードなどの処理を委譲するオブジェクトを指定します。[/ja]
+     */
+
+    /**
+     * @property delegate.createItemContent
+     * @type {Function}
+     * @description
+     *   [en]
+     *     This function should return a `HTMLElement`.
+     *
+     *     To help rendering the element, the current index and a template is supplied as arguments. The template is the initial content of the `<ons-lazy-repeat>` element.
+     *   [/en]
+     *   [ja]
+     *     この関数は`HTMLElement`を返してください。
+     *     要素を生成しやすくするために、現在のアイテムのインデックスとテンプレートが引数に渡されます。
+     *     このテンプレートは、`<ons-lazy-repeat>`要素のコンテンツが渡されます。
+     *   [/ja]
+     */
+
+    /**
+     * @property delegate.countItems
+     * @type {Function}
+     * @description
+     *   [en]Should return the number of items in the list.[/en]
+     *   [ja]リスト内のアイテム数を返してください。[/ja]
+     */
+
+    /**
+     * @property delegate.calculateItemHeight
+     * @type {Function}
+     * @description
+     *   [en]
+     *     Should return the height of an item. The index is provided as an argument.
+     *
+     *     This is important when rendering lists where the items have different height.
+     *
+     *     The function is optional and if it isn't present the height of the first item will be automatically calculated and used for all other items.
+     *   [/en]
+     *   [ja]
+     *     アイテムの高さ(ピクセル)を返してください。アイテムのインデックス値は引数で渡されます。
+     *     この関数は、それぞれのアイムが違った高さを持つリストをレンダリングする際に重要です。
+     *     この関数はオプショナルです。もしこの関数が無い場合には、
+     *     最初のアイテムの高さが他のすべてのアイテムの高さとして利用されます。
+     *   [/ja]
+     */
+
+    /**
+     * @property delegate.destroyItem
+     * @type {Function}
+     * @description
+     *   [en]
+     *     This function is used called when an item is removed from the DOM. The index and DOM element is provided as arguments.
+     *
+     *     The function is optional but may be important in order to avoid memory leaks.
+     *   [/en]
+     *   [ja]
+     *     この関数は、あるアイテムがDOMツリーから除かれた時に呼び出されます。
+     *     アイテムのインデックス値とDOM要素が引数として渡されます。
+     *     この関数はオプショナルですが、各アイテムの後処理が必要な場合にはメモリーリークを避けるために重要です。
+     *   [/ja]
+     */
+
+  }, {
+    key: 'refresh',
+
+
+    /**
+     * @method refresh
+     * @signature refresh()
+     * @description
+     *   [en]Refresh the list. Use this method when the data has changed.[/en]
+     *   [ja]リストを更新します。もしデータが変わった場合にはこのメソッドを使ってください。[/ja]
+     */
+    value: function refresh() {
+      this._lazyRepeatProvider && this._lazyRepeatProvider.refresh();
+    }
+  }, {
+    key: 'attributeChangedCallback',
+    value: function attributeChangedCallback(name, last, current) {}
+  }, {
+    key: 'disconnectedCallback',
+    value: function disconnectedCallback() {
+      if (this._lazyRepeatProvider) {
+        this._lazyRepeatProvider.destroy();
+        this._lazyRepeatProvider = null;
+      }
+    }
+  }, {
+    key: 'delegate',
+    set: function set$$1(userDelegate) {
+      this._lazyRepeatProvider && this._lazyRepeatProvider.destroy();
+
+      if (!this._templateElement && this.children[0]) {
+        this._templateElement = this.removeChild(this.children[0]);
+      }
+
+      var delegate = new LazyRepeatDelegate(userDelegate, this._templateElement || null);
+      this._lazyRepeatProvider = new LazyRepeatProvider(this.parentElement, delegate);
+    },
+    get: function get$$1() {
+      util$1.throw('No delegate getter');
+    }
+  }]);
+  return LazyRepeatElement;
+}(BaseElement);
+
+internal$1.LazyRepeatDelegate = LazyRepeatDelegate;
+internal$1.LazyRepeatProvider = LazyRepeatProvider;
+
+onsElements.LazyRepeat = LazyRepeatElement;
+customElements.define('ons-lazy-repeat', LazyRepeatElement);
+
+/*
+Copyright 2013-2015 ASIAL CORPORATION
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+   http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+*/
+
+var defaultClassName$4 = 'list-header';
+var scheme$8 = { '': 'list-header--*' };
+
+/**
+ * @element ons-list-header
+ * @category list
+ * @description
+ *   [en]Header element for list items. Must be put inside the `<ons-list>` component.[/en]
+ *   [ja]リスト要素に使用するヘッダー用コンポーネント。ons-listと共に使用します。[/ja]
+ * @seealso ons-list
+ *   [en]The `<ons-list>` component[/en]
+ *   [ja]ons-listコンポーネント[/ja]
+ * @seealso ons-list-item
+ *   [en]The `<ons-list-item>` component[/en]
+ *   [ja]ons-list-itemコンポーネント[/ja]
+ * @codepen yxcCt
+ * @tutorial vanilla/Reference/list
+ * @modifier material
+ *   [en]Display a Material Design list header.[/en]
+ *   [ja][/ja]
+ * @example
+ * <ons-list>
+ *   <ons-list-header>Header Text</ons-list-header>
+ *   <ons-list-item>Item</ons-list-item>
+ *   <ons-list-item>Item</ons-list-item>
+ * </ons-list>
+ */
+
+var ListHeaderElement = function (_BaseElement) {
+  inherits(ListHeaderElement, _BaseElement);
+
+  /**
+   * @attribute modifier
+   * @type {String}
+   * @description
+   *   [en]The appearance of the list header.[/en]
+   *   [ja]ヘッダーの表現を指定します。[/ja]
+   */
+
+  function ListHeaderElement() {
+    classCallCheck(this, ListHeaderElement);
+
+    var _this = possibleConstructorReturn(this, (ListHeaderElement.__proto__ || Object.getPrototypeOf(ListHeaderElement)).call(this));
+
+    _this._compile();
+    return _this;
+  }
+
+  createClass(ListHeaderElement, [{
+    key: '_compile',
+    value: function _compile() {
+      autoStyle.prepare(this);
+      this.classList.add(defaultClassName$4);
+      ModifierUtil.initModifier(this, scheme$8);
+    }
+  }, {
+    key: 'attributeChangedCallback',
+    value: function attributeChangedCallback(name, last, current) {
+      switch (name) {
+        case 'class':
+          util$1.restoreClass(this, defaultClassName$4, scheme$8);
+          break;
+        case 'modifier':
+          ModifierUtil.onModifierChanged(last, current, this, scheme$8);
+          break;
+      }
+    }
+  }], [{
+    key: 'observedAttributes',
+    get: function get$$1() {
+      return ['modifier', 'class'];
+    }
+  }]);
+  return ListHeaderElement;
+}(BaseElement);
+
+onsElements.ListHeader = ListHeaderElement;
+customElements.define('ons-list-header', ListHeaderElement);
+
+/*
+Copyright 2013-2015 ASIAL CORPORATION
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+   http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+*/
+
+var defaultClassName$5 = 'list-title';
+var scheme$9 = { '': 'list-title--*' };
+
+/**
+ * @element ons-list-title
+ * @category list
+ * @description
+ *   [en]Represents a list title.[/en]
+ *   [ja]リストのタイトルを表現します。[/ja]
+ * @example
+ * <ons-list-title>List Title</ons-list-title>
+ * <ons-list>
+ *   <ons-list-item>Item</ons-list-item>
+ * </ons-list>
+ * @modifier material
+ *   [en]Display a Material Design list title.[/en]
+ *   [ja][/ja]
+ */
+
+var ListTitleElement = function (_BaseElement) {
+  inherits(ListTitleElement, _BaseElement);
+
+  function ListTitleElement() {
+    classCallCheck(this, ListTitleElement);
+
+    var _this = possibleConstructorReturn(this, (ListTitleElement.__proto__ || Object.getPrototypeOf(ListTitleElement)).call(this));
+
+    _this._compile();
+    return _this;
+  }
+
+  createClass(ListTitleElement, [{
+    key: '_compile',
+    value: function _compile() {
+      autoStyle.prepare(this);
+      this.classList.add(defaultClassName$5);
+      ModifierUtil.initModifier(this, scheme$9);
+    }
+  }, {
+    key: 'attributeChangedCallback',
+    value: function attributeChangedCallback(name, last, current) {
+      switch (name) {
+        case 'class':
+          util$1.restoreClass(this, defaultClassName$5, scheme$9);
+          break;
+        case 'modifier':
+          ModifierUtil.onModifierChanged(last, current, this, scheme$9);
+          break;
+      }
+    }
+  }], [{
+    key: 'observedAttributes',
+    get: function get$$1() {
+      return ['modifier', 'class'];
+    }
+  }]);
+  return ListTitleElement;
+}(BaseElement);
+
+onsElements.ListTitle = ListTitleElement;
+customElements.define('ons-list-title', ListTitleElement);
+
+/*
+Copyright 2013-2018 ASIAL CORPORATION
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+   http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+*/
+
+var ListItemAnimator = function (_BaseAnimator) {
+  inherits(ListItemAnimator, _BaseAnimator);
+
+  function ListItemAnimator() {
+    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
+        _ref$timing = _ref.timing,
+        timing = _ref$timing === undefined ? 'linear' : _ref$timing,
+        _ref$delay = _ref.delay,
+        delay = _ref$delay === undefined ? 0 : _ref$delay,
+        _ref$duration = _ref.duration,
+        duration = _ref$duration === undefined ? 0.2 : _ref$duration;
+
+    classCallCheck(this, ListItemAnimator);
+    return possibleConstructorReturn(this, (ListItemAnimator.__proto__ || Object.getPrototypeOf(ListItemAnimator)).call(this, { timing: timing, delay: delay, duration: duration }));
+  }
+
+  createClass(ListItemAnimator, [{
+    key: 'showExpansion',
+    value: function showExpansion(listItem, callback) {
+      callback();
+    }
+  }, {
+    key: 'hideExpansion',
+    value: function hideExpansion(listItem, callback) {
+      callback();
+    }
+  }]);
+  return ListItemAnimator;
+}(BaseAnimator);
+
+var SlideListItemAnimator = function (_ListItemAnimator) {
+  inherits(SlideListItemAnimator, _ListItemAnimator);
+
+  function SlideListItemAnimator() {
+    classCallCheck(this, SlideListItemAnimator);
+    return possibleConstructorReturn(this, (SlideListItemAnimator.__proto__ || Object.getPrototypeOf(SlideListItemAnimator)).apply(this, arguments));
+  }
+
+  createClass(SlideListItemAnimator, [{
+    key: 'showExpansion',
+    value: function showExpansion(listItem, callback) {
+      this._animateExpansion(listItem, true, callback);
+    }
+  }, {
+    key: 'hideExpansion',
+    value: function hideExpansion(listItem, callback) {
+      this._animateExpansion(listItem, false, callback);
+    }
+  }, {
+    key: '_animateExpansion',
+    value: function _animateExpansion(listItem, shouldOpen, callback) {
+      var _animit;
+
+      // To animate the opening of the expansion panel correctly, we need to know its
+      // height. To calculate this, we set its height to auto, and then get the computed
+      // height and padding. Once this is done, we set the height back to its original value.
+      var oldHeight = listItem.expandableContent.style.height;
+      var oldDisplay = listItem.expandableContent.style.display;
+      listItem.expandableContent.style.height = 'auto';
+      listItem.expandableContent.style.display = 'block';
+      var computedStyle = window.getComputedStyle(listItem.expandableContent);
+
+      var expansionOpenTransition = [{ height: 0, paddingTop: 0, paddingBottom: 0 }, {
+        height: computedStyle.height,
+        paddingTop: computedStyle.paddingTop,
+        paddingBottom: computedStyle.paddingBottom
+      }];
+      var iconOpenTransition = [{ transform: 'rotate(45deg)' }, { transform: 'rotate(225deg)' }];
+
+      // Now that we have the values we need, reset the height back to its original state
+      listItem.expandableContent.style.height = oldHeight;
+
+      (_animit = Animit(listItem.expandableContent, { duration: this.duration, property: 'height padding-top padding-bottom' })).default.apply(_animit, toConsumableArray(shouldOpen ? expansionOpenTransition : expansionOpenTransition.reverse())).play(function () {
+        listItem.expandableContent.style.display = oldDisplay;
+        callback && callback();
+      });
+
+      if (listItem.expandChevron) {
+        var _animit2;
+
+        (_animit2 = Animit(listItem.expandChevron, { duration: this.duration, property: 'transform' })).default.apply(_animit2, toConsumableArray(shouldOpen ? iconOpenTransition : iconOpenTransition.reverse())).play();
+      }
+    }
+  }]);
+  return SlideListItemAnimator;
+}(ListItemAnimator);
+
+/*
+Copyright 2013-2015 ASIAL CORPORATION
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+   http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+*/
+
+var defaultClassName$6 = 'list-item';
+var scheme$10 = {
+  '.list-item': 'list-item--*',
+  '.list-item__left': 'list-item--*__left',
+  '.list-item__center': 'list-item--*__center',
+  '.list-item__right': 'list-item--*__right',
+  '.list-item__label': 'list-item--*__label',
+  '.list-item__title': 'list-item--*__title',
+  '.list-item__subtitle': 'list-item--*__subtitle',
+  '.list-item__thumbnail': 'list-item--*__thumbnail',
+  '.list-item__icon': 'list-item--*__icon'
+};
+
+var _animatorDict$3 = {
+  'default': SlideListItemAnimator,
+  'none': ListItemAnimator
+};
+
+/**
+ * @element ons-list-item
+ * @category list
+ * @modifier tappable
+ *   [en]Make the list item change appearance when it's tapped. On iOS it is better to use the "tappable" and "tap-background-color" attribute for better behavior when scrolling.[/en]
+ *   [ja]タップやクリックした時に効果が表示されるようになります。[/ja]
+ * @modifier chevron
+ *   [en]Display a chevron at the right end of the list item and make it change appearance when tapped.[/en]
+ *   [ja][/ja]
+ * @modifier longdivider
+ *   [en]Displays a long horizontal divider between items.[/en]
+ *   [ja][/ja]
+ * @modifier nodivider
+ *   [en]Removes the divider between list items.[/en]
+ *   [ja][/ja]
+ * @modifier material
+ *   [en]Display a Material Design list item.[/en]
+ *   [ja][/ja]
+ * @description
+ *   [en]
+ *     Component that represents each item in a list. The list item is composed of four parts that are represented with the `left`, `center`, `right` and `expandable-content` classes. These classes can be used to ensure that the content of the list items is properly aligned.
+ *
+ *     ```
+ *     <ons-list-item>
+ *       <div class="left">Left</div>
+ *       <div class="center">Center</div>
+ *       <div class="right">Right</div>
+ *       <div class="expandable-content">Expandable content</div>
+ *     </ons-list-item>
+ *     ```
+ *
+ *     There are also a number of classes (prefixed with `list-item__*`) that help when putting things like icons and thumbnails into the list items.
+ *   [/en]
+ *   [ja][/ja]
+ * @seealso ons-list
+ *   [en]ons-list component[/en]
+ *   [ja]ons-listコンポーネント[/ja]
+ * @seealso ons-list-header
+ *   [en]ons-list-header component[/en]
+ *   [ja]ons-list-headerコンポーネント[/ja]
+ * @codepen yxcCt
+ * @tutorial vanilla/Reference/list
+ * @example
+ * <ons-list-item>
+ *   <div class="left">
+ *     <ons-icon icon="md-face" class="list-item__icon"></ons-icon>
+ *   </div>
+ *   <div class="center">
+ *     <div class="list-item__title">Title</div>
+ *     <div class="list-item__subtitle">Subtitle</div>
+ *   </div>
+ *   <div class="right">
+ *     <ons-switch></ons-switch>
+ *   </div>
+ * </ons-list-item>
+ */
+
+var ListItemElement = function (_BaseElement) {
+  inherits(ListItemElement, _BaseElement);
+
+  /**
+   * @attribute modifier
+   * @type {String}
+   * @description
+   *   [en]The appearance of the list item.[/en]
+   *   [ja]各要素の表現を指定します。[/ja]
+   */
+
+  /**
+   * @attribute lock-on-drag
+   * @type {String}
+   * @description
+   *   [en]Prevent vertical scrolling when the user drags horizontally.[/en]
+   *   [ja]この属性があると、ユーザーがこの要素を横方向にドラッグしている時に、縦方向のスクロールが起きないようになります。[/ja]
+   */
+
+  /**
+   * @attribute tappable
+   * @type {Boolean}
+   * @description
+   *   [en]Makes the element react to taps. `prevent-tap` attribute can be added to child elements like buttons or inputs to prevent this effect. `ons-*` elements are ignored by default.[/en]
+   *   [ja][/ja]
+   */
+
+  /**
+   * @attribute tap-background-color
+   * @type {Color}
+   * @description
+   *   [en] Changes the background color when tapped. For this to work, the attribute "tappable" needs to be set. The default color is "#d9d9d9". It will display as a ripple effect on Android.[/en]
+   *   [ja][/ja]
+   */
+
+  /**
+   * @attribute expandable
+   * @type {Boolean}
+   * @description
+   *   [en]Makes the element able to be expanded to reveal extra content. For this to work, the expandable content must be defined in `div.expandable-content`.[/en]
+   *   [ja][/ja]
+   */
+
+  /**
+   * @attribute animation
+   * @type {String}
+   * @default default
+   * @description
+   *  [en]The animation used when showing and hiding the expandable content. Can be either `"default"` or `"none"`.[/en]
+   *  [ja][/ja]
+   */
+
+  function ListItemElement() {
+    classCallCheck(this, ListItemElement);
+
+    var _this = possibleConstructorReturn(this, (ListItemElement.__proto__ || Object.getPrototypeOf(ListItemElement)).call(this));
+
+    _this._animatorFactory = _this._updateAnimatorFactory();
+    _this.toggleExpansion = _this.toggleExpansion.bind(_this);
+
+    // Elements ignored when tapping
+    var re = /^ons-(?!col$|row$|if$)/i;
+    _this._shouldIgnoreTap = function (e) {
+      return e.hasAttribute('prevent-tap') || re.test(e.tagName);
+    };
+
+    // show and hide functions for Vue hidable mixin
+    _this.show = _this.showExpansion;
+    _this.hide = _this.hideExpansion;
+
+    contentReady(_this, function () {
+      _this._compile();
+    });
+    return _this;
+  }
+
+  /**
+   * Compiles the list item.
+   *
+   * Various elements are allowed in the body of a list item:
+   *
+   *  - div.left, div.right, and div.center are allowed as direct children
+   *  - if div.center is not defined, anything that isn't div.left, div.right or div.expandable-content will be put in a div.center
+   *  - if div.center is defined, anything that isn't div.left, div.right or div.expandable-content will be ignored
+   *  - if list item has expandable attribute:
+   *      - div.expandable-content is allowed as a direct child
+   *      - div.top is allowed as direct child
+   *      - if div.top is defined, anything that isn't div.expandable-content should be inside div.top - anything else will be ignored
+   *      - if div.right is not defined, a div.right will be created with a drop-down chevron
+   *
+   * See the tests for examples.
+   */
+
+
+  createClass(ListItemElement, [{
+    key: '_compile',
+    value: function _compile() {
+      autoStyle.prepare(this);
+      this.classList.add(defaultClassName$6);
+
+      var top = void 0,
+          expandableContent = void 0;
+      var topContent = [];
+      Array.from(this.childNodes).forEach(function (node) {
+        if (node.nodeType !== Node.ELEMENT_NODE) {
+          topContent.push(node);
+        } else if (node.classList.contains('top')) {
+          top = node;
+        } else if (node.classList.contains('expandable-content')) {
+          expandableContent = node;
+        } else {
+          topContent.push(node);
+        }
+
+        if (node.nodeName !== 'ONS-RIPPLE') {
+          node.remove();
+        }
+      });
+      topContent = top ? Array.from(top.childNodes) : topContent;
+
+      var left = void 0,
+          right = void 0,
+          center = void 0;
+      var centerContent = [];
+      topContent.forEach(function (node) {
+        if (node.nodeType !== Node.ELEMENT_NODE) {
+          centerContent.push(node);
+        } else if (node.classList.contains('left')) {
+          left = node;
+        } else if (node.classList.contains('right')) {
+          right = node;
+        } else if (node.classList.contains('center')) {
+          center = node;
+        } else {
+          centerContent.push(node);
+        }
+      });
+
+      if (this.hasAttribute('expandable')) {
+        this.classList.add('list-item--expandable');
+
+        if (!top) {
+          top = document.createElement('div');
+          top.classList.add('top');
+        }
+        top.classList.add('list-item__top');
+        this.appendChild(top);
+        this._top = top;
+
+        if (expandableContent) {
+          expandableContent.classList.add('list-item__expandable-content');
+          this.appendChild(expandableContent);
+        }
+
+        if (!right) {
+          right = document.createElement('div');
+          right.classList.add('list-item__right', 'right');
+
+          // We cannot use a pseudo-element for this chevron, as we cannot animate it using
+          // JS. So, we make a chevron span instead.
+          var chevron = document.createElement('span');
+          chevron.classList.add('list-item__expand-chevron');
+          right.appendChild(chevron);
+        }
+      } else {
+        top = this;
+      }
+
+      if (!center) {
+        center = document.createElement('div');
+        center.classList.add('center');
+        centerContent.forEach(function (node) {
+          return center.appendChild(node);
+        });
+      }
+      center.classList.add('list-item__center');
+      top.appendChild(center);
+
+      if (left) {
+        left.classList.add('list-item__left');
+        top.appendChild(left);
+      }
+      if (right) {
+        right.classList.add('list-item__right');
+        top.appendChild(right);
+      }
+
+      util$1.updateRipple(this);
+      ModifierUtil.initModifier(this, scheme$10);
+    }
+
+    /**
+     * @method showExpansion
+     * @signature showExpansion()
+     * @description
+     *   [en]Show the expandable content if the element is expandable.[/en]
+     *   [ja][/ja]
+     */
+
+  }, {
+    key: 'showExpansion',
+    value: function showExpansion() {
+      var _this2 = this;
+
+      if (this.hasAttribute('expandable') && !this._expanding) {
+        this.expanded = true;
+        this._expanding = true;
+
+        var animator = this._animatorFactory.newAnimator();
+        animator.showExpansion(this, function () {
+          _this2.classList.add('expanded');
+          _this2._expanding = false;
+        });
+      }
+    }
+
+    /**
+     * @method hideExpansion
+     * @signature hideExpansion()
+     * @description
+     *   [en]Hide the expandable content if the element expandable.[/en]
+     *   [ja][/ja]
+     */
+
+  }, {
+    key: 'hideExpansion',
+    value: function hideExpansion() {
+      var _this3 = this;
+
+      if (this.hasAttribute('expandable') && !this._expanding) {
+        this.expanded = false;
+        this._expanding = true;
+
+        var animator = this._animatorFactory.newAnimator();
+        animator.hideExpansion(this, function () {
+          _this3.classList.remove('expanded');
+          _this3._expanding = false;
+        });
+      }
+    }
+  }, {
+    key: 'toggleExpansion',
+    value: function toggleExpansion() {
+      this.classList.contains('expanded') ? this.hideExpansion() : this.showExpansion();
+      this.dispatchEvent(new Event('expansion'));
+    }
+  }, {
+    key: '_updateAnimatorFactory',
+    value: function _updateAnimatorFactory() {
+      return new AnimatorFactory({
+        animators: _animatorDict$3,
+        baseClass: ListItemAnimator,
+        baseClassName: 'ListItemAnimator',
+        defaultAnimation: this.getAttribute('animation') || 'default'
+      });
+    }
+  }, {
+    key: 'attributeChangedCallback',
+    value: function attributeChangedCallback(name, last, current) {
+      switch (name) {
+        case 'class':
+          util$1.restoreClass(this, defaultClassName$6, scheme$10);
+          break;
+        case 'modifier':
+          ModifierUtil.onModifierChanged(last, current, this, scheme$10);
+          break;
+        case 'ripple':
+          util$1.updateRipple(this);
+          break;
+        case 'animation':
+          this._animatorFactory = this._updateAnimatorFactory();
+          break;
+      }
+    }
+  }, {
+    key: 'connectedCallback',
+    value: function connectedCallback() {
+      var _this4 = this;
+
+      contentReady(this, function () {
+        _this4._setupListeners(true);
+        _this4._originalBackgroundColor = _this4.style.backgroundColor;
+        _this4.tapped = false;
+      });
+    }
+  }, {
+    key: 'disconnectedCallback',
+    value: function disconnectedCallback() {
+      this._setupListeners(false);
+    }
+  }, {
+    key: '_setupListeners',
+    value: function _setupListeners(add) {
+      var action = (add ? 'add' : 'remove') + 'EventListener';
+      util$1[action](this, 'touchstart', this._onTouch, { passive: true });
+      util$1[action](this, 'touchmove', this._onRelease, { passive: true });
+      this[action]('touchcancel', this._onRelease);
+      this[action]('touchend', this._onRelease);
+      this[action]('touchleave', this._onRelease);
+      this[action]('drag', this._onDrag);
+      this[action]('mousedown', this._onTouch);
+      this[action]('mouseup', this._onRelease);
+      this[action]('mouseout', this._onRelease);
+
+      if (this._top) {
+        this._top[action]('click', this.toggleExpansion);
+      }
+    }
+  }, {
+    key: '_onDrag',
+    value: function _onDrag(event) {
+      var gesture = event.gesture;
+      // Prevent vertical scrolling if the users pans left or right.
+      if (this.hasAttribute('lock-on-drag') && ['left', 'right'].indexOf(gesture.direction) > -1) {
+        gesture.preventDefault();
+      }
+    }
+  }, {
+    key: '_onTouch',
+    value: function _onTouch(e) {
+      var _this5 = this;
+
+      if (this.tapped || this !== e.target && (this._shouldIgnoreTap(e.target) || util$1.findParent(e.target, this._shouldIgnoreTap, function (p) {
+        return p === _this5;
+      }))) {
+        return; // Ignore tap
+      }
+
+      this.tapped = true;
+      var touchStyle = { transition: 'background-color 0.0s linear 0.02s, box-shadow 0.0s linear 0.02s' };
+
+      if (this.hasAttribute('tappable')) {
+        if (this.style.backgroundColor) {
+          this._originalBackgroundColor = this.style.backgroundColor;
+        }
+
+        touchStyle.backgroundColor = this.getAttribute('tap-background-color') || '#d9d9d9';
+        touchStyle.boxShadow = '0px -1px 0px 0px ' + touchStyle.backgroundColor;
+      }
+
+      styler(this, touchStyle);
+    }
+  }, {
+    key: '_onRelease',
+    value: function _onRelease() {
+      this.tapped = false;
+      this.style.backgroundColor = this._originalBackgroundColor || '';
+      styler.clear(this, 'transition boxShadow');
+    }
+  }, {
+    key: 'expandableContent',
+    get: function get$$1() {
+      return this.querySelector('.list-item__expandable-content');
+    }
+  }, {
+    key: 'expandChevron',
+    get: function get$$1() {
+      return this.querySelector('.list-item__expand-chevron');
+    }
+  }], [{
+    key: 'observedAttributes',
+    get: function get$$1() {
+      return ['modifier', 'class', 'ripple', 'animation'];
+    }
+  }]);
+  return ListItemElement;
+}(BaseElement);
+
+onsElements.ListItem = ListItemElement;
+customElements.define('ons-list-item', ListItemElement);
+
+/*
+Copyright 2013-2015 ASIAL CORPORATION
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+   http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+*/
+
+var defaultClassName$7 = 'list';
+var scheme$11 = { '': 'list--*' };
+
+/**
+ * @element ons-list
+ * @category list
+ * @modifier inset
+ *   [en]Inset list that doesn't cover the whole width of the parent.[/en]
+ *   [ja]親要素の画面いっぱいに広がらないリストを表示します。[/ja]
+ * @modifier noborder
+ *   [en]A list with no borders at the top and bottom.[/en]
+ *   [ja]リストの上下のボーダーが無いリストを表示します。[/ja]
+ * @description
+ *   [en]Component to define a list, and the container for ons-list-item(s).[/en]
+ *   [ja]リストを表現するためのコンポーネント。ons-list-itemのコンテナとして使用します。[/ja]
+ * @seealso ons-list-item
+ *   [en]ons-list-item component[/en]
+ *   [ja]ons-list-itemコンポーネント[/ja]
+ * @seealso ons-list-header
+ *   [en]ons-list-header component[/en]
+ *   [ja]ons-list-headerコンポーネント[/ja]
+ * @seealso ons-lazy-repeat
+ *   [en]ons-lazy-repeat component[/en]
+ *   [ja]ons-lazy-repeatコンポーネント[/ja]
+ * @codepen yxcCt
+ * @tutorial vanilla/Reference/list
+ * @example
+ * <ons-list>
+ *   <ons-list-header>Header Text</ons-list-header>
+ *   <ons-list-item>Item</ons-list-item>
+ *   <ons-list-item>Item</ons-list-item>
+ * </ons-list>
+ */
+
+var ListElement = function (_BaseElement) {
+  inherits(ListElement, _BaseElement);
+
+  /**
+   * @attribute modifier
+   * @type {String}
+   * @description
+   *   [en]The appearance of the list.[/en]
+   *   [ja]リストの表現を指定します。[/ja]
+   */
+
+  function ListElement() {
+    classCallCheck(this, ListElement);
+
+    var _this = possibleConstructorReturn(this, (ListElement.__proto__ || Object.getPrototypeOf(ListElement)).call(this));
+
+    _this._compile();
+    return _this;
+  }
+
+  createClass(ListElement, [{
+    key: '_compile',
+    value: function _compile() {
+      autoStyle.prepare(this);
+      this.classList.add(defaultClassName$7);
+      ModifierUtil.initModifier(this, scheme$11);
+    }
+  }, {
+    key: 'attributeChangedCallback',
+    value: function attributeChangedCallback(name, last, current) {
+      switch (name) {
+        case 'class':
+          util$1.restoreClass(this, defaultClassName$7, scheme$11);
+          break;
+        case 'modifier':
+          ModifierUtil.onModifierChanged(last, current, this, scheme$11);
+          break;
+      }
+    }
+  }], [{
+    key: 'observedAttributes',
+    get: function get$$1() {
+      return ['modifier', 'class'];
+    }
+  }]);
+  return ListElement;
+}(BaseElement);
+
+onsElements.List = ListElement;
+customElements.define('ons-list', ListElement);
+
+/*
+Copyright 2013-2015 ASIAL CORPORATION
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+   http://www.apache.org/licenses/LICENSE-2.0
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+*/
+
+var INPUT_ATTRIBUTES = ['autocapitalize', 'autocomplete', 'autocorrect', 'autofocus', 'disabled', 'inputmode', 'max', 'maxlength', 'min', 'minlength', 'name', 'pattern', 'placeholder', 'readonly', 'required', 'size', 'step', 'validator', 'value'];
+
+var BaseInputElement = function (_BaseElement) {
+  inherits(BaseInputElement, _BaseElement);
+  createClass(BaseInputElement, [{
+    key: '_update',
+    value: function _update() {} // Optionally implemented
+
+  }, {
+    key: '_scheme',
+    get: function get$$1() {
+      util$1.throwMember();
+    }
+  }, {
+    key: '_template',
+    get: function get$$1() {
+      util$1.throwMember();
+    }
+  }, {
+    key: 'type',
+    get: function get$$1() {
+      util$1.throwMember();
+    }
+  }]);
+
+  function BaseInputElement() {
+    classCallCheck(this, BaseInputElement);
+
+    var _this = possibleConstructorReturn(this, (BaseInputElement.__proto__ || Object.getPrototypeOf(BaseInputElement)).call(this));
+
+    if (_this.constructor === BaseInputElement) {
+      util$1.throwAbstract();
+    }
+
+    contentReady(_this, function () {
+      return _this._compile();
+    });
+    _this._boundDelegateEvent = _this._delegateEvent.bind(_this);
+    return _this;
+  }
+
+  createClass(BaseInputElement, [{
+    key: '_compile',
+    value: function _compile() {
+      autoStyle.prepare(this);
+      this._defaultClassName && this.classList.add(this._defaultClassName);
+
+      if (this.children.length !== 0) {
+        return;
+      }
+
+      this.appendChild(util$1.createFragment(this._template));
+
+      this._setInputId();
+
+      this._updateBoundAttributes();
+
+      ModifierUtil.initModifier(this, this._scheme);
+    }
+  }, {
+    key: '_updateBoundAttributes',
+    value: function _updateBoundAttributes() {
+      var _this2 = this;
+
+      INPUT_ATTRIBUTES.forEach(function (attr) {
+        if (_this2.hasAttribute(attr)) {
+          _this2._input.setAttribute(attr, _this2.getAttribute(attr));
+        } else {
+          _this2._input.removeAttribute(attr);
+        }
+      });
+
+      this._update();
+    }
+  }, {
+    key: '_delegateEvent',
+    value: function _delegateEvent(event) {
+      var e = new CustomEvent(event.type, {
+        bubbles: false,
+        cancelable: true
+      });
+
+      return this.dispatchEvent(e);
+    }
+  }, {
+    key: '_setInputId',
+    value: function _setInputId() {
+      if (this.hasAttribute('input-id')) {
+        this._input.id = this.getAttribute('input-id');
+      }
+    }
+  }, {
+    key: 'connectedCallback',
+    value: function connectedCallback() {
+      var _this3 = this;
+
+      contentReady(this, function () {
+        _this3._input.addEventListener('focus', _this3._boundDelegateEvent);
+        _this3._input.addEventListener('blur', _this3._boundDelegateEvent);
+      });
+    }
+  }, {
+    key: 'disconnectedCallback',
+    value: function disconnectedCallback() {
+      var _this4 = this;
+
+      contentReady(this, function () {
+        _this4._input.removeEventListener('focus', _this4._boundDelegateEvent);
+        _this4._input.removeEventListener('blur', _this4._boundDelegateEvent);
+      });
+    }
+  }, {
+    key: 'attributeChangedCallback',
+    value: function attributeChangedCallback(name, last, current) {
+      var _this5 = this;
+
+      switch (name) {
+        case 'modifier':
+          contentReady(this, function () {
+            return ModifierUtil.onModifierChanged(last, current, _this5, _this5._scheme);
+          });
+          break;
+        case 'input-id':
+          contentReady(this, function () {
+            return _this5._setInputId();
+          });
+          break;
+        case 'class':
+          util$1.restoreClass(this, this._defaultClassName, this._scheme);
+          break;
+      }
+
+      if (INPUT_ATTRIBUTES.indexOf(name) >= 0) {
+        contentReady(this, function () {
+          return _this5._updateBoundAttributes();
+        });
+      }
+    }
+  }, {
+    key: '_defaultClassName',
+    get: function get$$1() {
+      return '';
+    }
+  }, {
+    key: '_input',
+    get: function get$$1() {
+      return this.querySelector('input');
+    }
+  }, {
+    key: 'value',
+    get: function get$$1() {
+      return this._input === null ? this.getAttribute('value') : this._input.value;
+    },
+    set: function set$$1(val) {
+      var _this6 = this;
+
+      contentReady(this, function () {
+        if (val instanceof Date) {
+          val = val.toISOString().substring(0, 10);
+        }
+        _this6._input.value = val;
+        _this6._update();
+      });
+    }
+  }, {
+    key: 'disabled',
+    set: function set$$1(value) {
+      return util$1.toggleAttribute(this, 'disabled', value);
+    },
+    get: function get$$1() {
+      return this.hasAttribute('disabled');
+    }
+  }], [{
+    key: 'observedAttributes',
+    get: function get$$1() {
+      return ['modifier', 'input-id', 'class'].concat(INPUT_ATTRIBUTES);
+    }
+  }]);
+  return BaseInputElement;
+}(BaseElement);
+
+/*
+Copyright 2013-2015 ASIAL CORPORATION
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+   http://www.apache.org/licenses/LICENSE-2.0
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+*/
+
+var scheme$12 = {
+  '.text-input': 'text-input--*',
+  '.text-input__label': 'text-input--*__label'
+};
+
+/**
+ * @element ons-input
+ * @category form
+ * @modifier material
+ *  [en]Displays a Material Design input.[/en]
+ *  [ja][/ja]
+ * @modifier underbar
+ *  [en]Displays a horizontal line underneath a text input.[/en]
+ *  [ja][/ja]
+ * @modifier transparent
+ *  [en]Displays a transparent input. Works for Material Design.[/en]
+ *  [ja][/ja]
+ * @description
+ *  [en]
+ *    An input element. The `type` attribute can be used to change the input type. All text input types are supported.
+ *
+ *    The component will automatically render as a Material Design input on Android devices.
+ *
+ *    Most attributes that can be used for a normal `<input>` element can also be used on the `<ons-input>` element.
+ *  [/en]
+ *  [ja][/ja]
+ * @tutorial vanilla/Reference/input
+ * @seealso ons-checkbox
+ *   [en]The `<ons-checkbox>` element is used to display a checkbox.[/en]
+ *   [ja][/ja]
+ * @seealso ons-radio
+ *   [en]The `<ons-radio>` element is used to display a radio button.[/en]
+ *   [ja][/ja]
+ * @seealso ons-range
+ *   [en]The `<ons-range>` element is used to display a range slider.[/en]
+ *   [ja][/ja]
+ * @seealso ons-switch
+ *   [en]The `<ons-switch>` element is used to display a draggable toggle switch.[/en]
+ *   [ja][/ja]
+ * @seealso ons-select
+ *   [en]The `<ons-select>` element is used to display a select box.[/en]
+ *   [ja][/ja]
+ * @guide theming.html#modifiers [en]More details about the `modifier` attribute[/en][ja]modifier属性の使い方[/ja]
+ * @example
+ * <ons-input placeholder="Username" float></ons-input>
+ */
+
+var InputElement = function (_BaseInputElement) {
+  inherits(InputElement, _BaseInputElement);
+
+  function InputElement() {
+    classCallCheck(this, InputElement);
+
+    var _this = possibleConstructorReturn(this, (InputElement.__proto__ || Object.getPrototypeOf(InputElement)).call(this));
+
+    _this._boundOnInput = _this._update.bind(_this);
+    _this._boundOnFocusin = _this._update.bind(_this);
+    return _this;
+  }
+
+  /* Inherited props */
+
+  createClass(InputElement, [{
+    key: '_update',
+    value: function _update() {
+      this._updateLabel();
+      this._updateLabelClass();
+    }
+  }, {
+    key: '_updateLabel',
+
+
+    /* Own props */
+
+    value: function _updateLabel() {
+      var label = this.getAttribute('placeholder') || '';
+
+      if (typeof this._helper.textContent !== 'undefined') {
+        this._helper.textContent = label;
+      } else {
+        this._helper.innerText = label;
+      }
+    }
+  }, {
+    key: '_updateLabelClass',
+    value: function _updateLabelClass() {
+      if (this.value === '') {
+        this._helper.classList.remove('text-input--material__label--active');
+      } else {
+        this._helper.classList.add('text-input--material__label--active');
+      }
+    }
+  }, {
+    key: 'connectedCallback',
+    value: function connectedCallback() {
+      var _this2 = this;
+
+      get(InputElement.prototype.__proto__ || Object.getPrototypeOf(InputElement.prototype), 'connectedCallback', this).call(this);
+
+      contentReady(this, function () {
+        _this2._input.addEventListener('input', _this2._boundOnInput);
+        _this2._input.addEventListener('focusin', _this2._boundOnFocusin);
+      });
+
+      var type = this.getAttribute('type');
+      if (['checkbox', 'radio'].indexOf(type) >= 0) {
+        util$1.warn('Warn: <ons-input type="' + type + '"> is deprecated since v2.4.0. Use <ons-' + type + '> instead.');
+      }
+    }
+  }, {
+    key: 'disconnectedCallback',
+    value: function disconnectedCallback() {
+      var _this3 = this;
+
+      get(InputElement.prototype.__proto__ || Object.getPrototypeOf(InputElement.prototype), 'disconnectedCallback', this).call(this);
+
+      contentReady(this, function () {
+        _this3._input.removeEventListener('input', _this3._boundOnInput);
+        _this3._input.removeEventListener('focusin', _this3._boundOnFocusin);
+      });
+    }
+  }, {
+    key: 'attributeChangedCallback',
+    value: function attributeChangedCallback(name, last, current) {
+      var _this4 = this;
+
+      switch (name) {
+        case 'type':
+          contentReady(this, function () {
+            return _this4._input.setAttribute('type', _this4.type);
+          });
+          break;
+        default:
+          get(InputElement.prototype.__proto__ || Object.getPrototypeOf(InputElement.prototype), 'attributeChangedCallback', this).call(this, name, last, current);
+      }
+    }
+
+    /**
+     * @attribute placeholder
+     * @type {String}
+     * @description
+     *   [en]Placeholder text. In Material Design, this placeholder will be a floating label.[/en]
+     *   [ja][/ja]
+     */
+
+    /**
+     * @attribute float
+     * @description
+     *  [en]If this attribute is present, the placeholder will be animated in Material Design.[/en]
+     *  [ja]この属性が設定された時、ラベルはアニメーションするようになります。[/ja]
+     */
+
+    /**
+     * @attribute type
+     * @type {String}
+     * @description
+     *  [en]
+     *    Specify the input type. This is the same as the "type" attribute for normal inputs. It expects strict text types such as `text`, `password`, etc. For checkbox, radio button, select or range, please have a look at the corresponding elements.
+     *
+     *    Please take a look at [MDN](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#attr-type) for an exhaustive list of possible values. Depending on the platform and browser version some of these might not work.
+     *  [/en]
+     *  [ja][/ja]
+     */
+
+    /**
+     * @attribute input-id
+     * @type {String}
+     * @description
+     *  [en]Specify the "id" attribute of the inner `<input>` element. This is useful when using `<label for="...">` elements.[/en]
+     *  [ja][/ja]
+     */
+
+    /**
+     * @property value
+     * @type {String}
+     * @description
+     *   [en]The current value of the input.[/en]
+     *   [ja][/ja]
+     */
+
+    /**
+     * @property disabled
+     * @type {Boolean}
+     * @description
+     *   [en]Whether the input is disabled or not.[/en]
+     *   [ja]無効化されている場合に`true`。[/ja]
+     */
+
+  }, {
+    key: '_scheme',
+    get: function get$$1() {
+      return scheme$12;
+    }
+  }, {
+    key: '_template',
+    get: function get$$1() {
+      return '\n      <input type="' + this.type + '" class="text-input">\n      <span class="text-input__label"></span>\n    ';
+    }
+  }, {
+    key: 'type',
+    get: function get$$1() {
+      var type = this.getAttribute('type');
+      return ['checkbox', 'radio'].indexOf(type) < 0 && type || 'text';
+    }
+  }, {
+    key: '_helper',
+    get: function get$$1() {
+      return this.querySelector('span');
+    }
+  }], [{
+    key: 'observedAttributes',
+    get: function get$$1() {
+      return [].concat(toConsumableArray(get(InputElement.__proto__ || Object.getPrototypeOf(InputElement), 'observedAttributes', this)), ['type']);
+    }
+  }]);
+  return InputElement;
+}(BaseInputElement);
+
+onsElements.Input = InputElement;
+customElements.define('ons-input', InputElement);
+
+/*
+Copyright 2013-2015 ASIAL CORPORATION
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+   http://www.apache.org/licenses/LICENSE-2.0
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+*/
+
+var BaseCheckboxElement = function (_BaseInputElement) {
+  inherits(BaseCheckboxElement, _BaseInputElement);
+
+  function BaseCheckboxElement() {
+    classCallCheck(this, BaseCheckboxElement);
+
+    var _this = possibleConstructorReturn(this, (BaseCheckboxElement.__proto__ || Object.getPrototypeOf(BaseCheckboxElement)).call(this));
+
+    if (_this.constructor === BaseCheckboxElement) {
+      util.throwAbstract();
+    }
+
+    contentReady(_this, function () {
+      _this.attributeChangedCallback('checked', null, _this.getAttribute('checked'));
+    });
+    return _this;
+  }
+
+  /* Inherited props */
+
+  createClass(BaseCheckboxElement, [{
+    key: 'attributeChangedCallback',
+    value: function attributeChangedCallback(name, last, current) {
+      switch (name) {
+        case 'checked':
+          this.checked = current !== null;
+          break;
+        default:
+          get(BaseCheckboxElement.prototype.__proto__ || Object.getPrototypeOf(BaseCheckboxElement.prototype), 'attributeChangedCallback', this).call(this, name, last, current);
+      }
+    }
+  }, {
+    key: '_template',
+    get: function get$$1() {
+      return '\n      <input type="' + this.type + '" class="' + this._defaultClassName + '__input">\n      <span class="' + this._defaultClassName + '__checkmark"></span>\n    ';
+    }
+
+    /* Own props */
+
+  }, {
+    key: '_helper',
+    get: function get$$1() {
+      return this.querySelector('span');
+    }
+  }, {
+    key: 'checked',
+    get: function get$$1() {
+      return this._input.checked;
+    },
+    set: function set$$1(val) {
+      var _this2 = this;
+
+      contentReady(this, function () {
+        _this2._input.checked = val;
+      });
+    }
+  }], [{
+    key: 'observedAttributes',
+    get: function get$$1() {
+      return [].concat(toConsumableArray(get(BaseCheckboxElement.__proto__ || Object.getPrototypeOf(BaseCheckboxElement), 'observedAttributes', this)), ['checked']);
+    }
+  }]);
+  return BaseCheckboxElement;
+}(BaseInputElement);
+
+/*
+Copyright 2013-2015 ASIAL CORPORATION
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+   http://www.apache.org/licenses/LICENSE-2.0
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+*/
+
+var scheme$13 = {
+  '.checkbox': 'checkbox--*',
+  '.checkbox__input': 'checkbox--*__input',
+  '.checkbox__checkmark': 'checkbox--*__checkmark'
+};
+
+/**
+ * @element ons-checkbox
+ * @category form
+ * @modifier material
+ *  [en]Displays a Material Design checkbox.[/en]
+ *  [ja][/ja]
+ * @modifier noborder
+ *  [en]iOS borderless checkbox.[/en]
+ *  [ja][/ja]
+ * @description
+ *  [en]
+ *    A checkbox element. The component will automatically render as a Material Design checkbox on Android devices.
+ *
+ *    Most attributes that can be used for a normal `<input type="checkbox">` element can also be used on the `<ons-checkbox>` element.
+ *  [/en]
+ *  [ja][/ja]
+ * @tutorial vanilla/Reference/checkbox
+ * @seealso ons-switch
+ *   [en]The `<ons-switch>` element is used to display a draggable toggle switch.[/en]
+ *   [ja][/ja]
+ * @seealso ons-radio
+ *   [en]The `<ons-radio>` element is used to display a radio button.[/en]
+ *   [ja][/ja]
+ * @seealso ons-input
+ *   [en]The `<ons-input>` element is used to display a text input.[/en]
+ *   [ja][/ja]
+ * @seealso ons-search-input
+ *   [en]The `<ons-search-input>` element is used to display a search input.[/en]
+ *   [ja][/ja]
+ * @seealso ons-range
+ *   [en]The `<ons-range>` element is used to display a range slider.[/en]
+ *   [ja][/ja]
+ * @seealso ons-select
+ *   [en]The `<ons-select>` element is used to display a select box.[/en]
+ *   [ja][/ja]
+ * @guide theming.html#modifiers [en]More details about the `modifier` attribute[/en][ja]modifier属性の使い方[/ja]
+ * @example
+ * <ons-checkbox checked></ons-checkbox>
+ */
+
+var CheckboxElement = function (_BaseCheckboxElement) {
+  inherits(CheckboxElement, _BaseCheckboxElement);
+
+  function CheckboxElement() {
+    classCallCheck(this, CheckboxElement);
+    return possibleConstructorReturn(this, (CheckboxElement.__proto__ || Object.getPrototypeOf(CheckboxElement)).apply(this, arguments));
+  }
+
+  createClass(CheckboxElement, [{
+    key: '_scheme',
+    get: function get$$1() {
+      return scheme$13;
+    }
+  }, {
+    key: '_defaultClassName',
+    get: function get$$1() {
+      return 'checkbox';
+    }
+  }, {
+    key: 'type',
+    get: function get$$1() {
+      return 'checkbox';
+    }
+
+    /**
+     * @attribute input-id
+     * @type {String}
+     * @description
+     *  [en]Specify the "id" attribute of the inner `<input>` element. This is useful when using `<label for="...">` elements.[/en]
+     *  [ja][/ja]
+     */
+
+    /**
+     * @property value
+     * @type {String}
+     * @description
+     *   [en]The current value of the checkbox.[/en]
+     *   [ja][/ja]
+     */
+
+    /**
+     * @property checked
+     * @type {Boolean}
+     * @description
+     *   [en]Whether the checkbox is checked or not.[/en]
+     *   [ja][/ja]
+     */
+
+    /**
+     * @property disabled
+     * @type {Boolean}
+     * @description
+     *   [en]Whether the checkbox is disabled or not.[/en]
+     *   [ja]無効化されている場合に`true`。[/ja]
+     */
+
+  }]);
+  return CheckboxElement;
+}(BaseCheckboxElement);
+
+onsElements.Checkbox = CheckboxElement;
+customElements.define('ons-checkbox', CheckboxElement);
+
+/*
+Copyright 2013-2015 ASIAL CORPORATION
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+   http://www.apache.org/licenses/LICENSE-2.0
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+*/
+
+var scheme$14 = {
+  '.radio-button': 'radio-button--*',
+  '.radio-button__input': 'radio-button--*__input',
+  '.radio-button__checkmark': 'radio-button--*__checkmark'
+};
+
+/**
+ * @element ons-radio
+ * @category form
+ * @modifier material
+ *  [en]Displays a Material Design radio button.[/en]
+ *  [ja][/ja]
+ * @description
+ *  [en]
+ *    A radio button element. The component will automatically render as a Material Design radio button on Android devices.
+ *
+ *    Most attributes that can be used for a normal `<input type="radio">` element can also be used on the `<ons-radio>` element.
+ *  [/en]
+ *  [ja][/ja]
+ * @tutorial vanilla/Reference/radio
+ * @seealso ons-select
+ *   [en]The `<ons-select>` element is used to display a select box.[/en]
+ *   [ja][/ja]
+ * @seealso ons-checkbox
+ *   [en]The `<ons-checkbox>` element is used to display a checkbox.[/en]
+ *   [ja][/ja]
+ * @seealso ons-switch
+ *   [en]The `<ons-switch>` element is used to display a draggable toggle switch.[/en]
+ *   [ja][/ja]
+ * @seealso ons-input
+ *   [en]The `<ons-input>` element is used to display a text input.[/en]
+ *   [ja][/ja]
+ * @seealso ons-search-input
+ *   [en]The `<ons-search-input>` element is used to display a search input.[/en]
+ *   [ja][/ja]
+ * @seealso ons-range
+ *   [en]The `<ons-range>` element is used to display a range slider.[/en]
+ *   [ja][/ja]
+ * @guide theming.html#modifiers [en]More details about the `modifier` attribute[/en][ja]modifier属性の使い方[/ja]
+ * @example
+ * <ons-radio checked></ons-radio>
+ */
+
+var RadioElement = function (_BaseCheckboxElement) {
+  inherits(RadioElement, _BaseCheckboxElement);
+
+  function RadioElement() {
+    classCallCheck(this, RadioElement);
+    return possibleConstructorReturn(this, (RadioElement.__proto__ || Object.getPrototypeOf(RadioElement)).apply(this, arguments));
+  }
+
+  createClass(RadioElement, [{
+    key: '_scheme',
+    get: function get$$1() {
+      return scheme$14;
+    }
+  }, {
+    key: '_defaultClassName',
+    get: function get$$1() {
+      return 'radio-button';
+    }
+  }, {
+    key: 'type',
+    get: function get$$1() {
+      return 'radio';
+    }
+
+    /**
+     * @attribute input-id
+     * @type {String}
+     * @description
+     *  [en]Specify the "id" attribute of the inner `<input>` element. This is useful when using `<label for="...">` elements.[/en]
+     *  [ja][/ja]
+     */
+
+    /**
+     * @property value
+     * @type {String}
+     * @description
+     *   [en]The current value of the radio button.[/en]
+     *   [ja][/ja]
+     */
+
+    /**
+     * @property checked
+     * @type {Boolean}
+     * @description
+     *   [en]Whether the radio button is checked or not.[/en]
+     *   [ja][/ja]
+     */
+
+    /**
+     * @property disabled
+     * @type {Boolean}
+     * @description
+     *   [en]Whether the radio button is disabled or not.[/en]
+     *   [ja]無効化されている場合に`true`。[/ja]
+     */
+
+  }]);
+  return RadioElement;
+}(BaseCheckboxElement);
+
+onsElements.Radio = RadioElement;
+customElements.define('ons-radio', RadioElement);
+
+/*
+Copyright 2013-2015 ASIAL CORPORATION
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+   http://www.apache.org/licenses/LICENSE-2.0
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+*/
+
+var scheme$15 = {
+  '.search-input': 'search-input--*'
+};
+
+/**
+ * @element ons-search-input
+ * @category form
+ * @modifier material
+ *  [en]Displays a Material Design search input.[/en]
+ *  [ja][/ja]
+ * @description
+ *  [en]
+ *    A search input element. The component will automatically render as a Material Design search input on Android devices.
+ *
+ *    Most attributes that can be used for a normal `<input>` element can also be used on the `<ons-search-input>` element.
+ *  [/en]
+ *  [ja][/ja]
+ * @tutorial vanilla/Reference/search-input
+ * @seealso ons-input
+ *   [en]The `<ons-input>` element is used to display a text input.[/en]
+ *   [ja][/ja]
+ * @seealso ons-range
+ *   [en]The `<ons-range>` element is used to display a range slider.[/en]
+ *   [ja][/ja]
+ * @seealso ons-switch
+ *   [en]The `<ons-switch>` element is used to display a draggable toggle switch.[/en]
+ *   [ja][/ja]
+ * @seealso ons-select
+ *   [en]The `<ons-select>` element is used to display a select box.[/en]
+ *   [ja][/ja]
+ * @seealso ons-checkbox
+ *   [en]The `<ons-checkbox>` element is used to display a checkbox.[/en]
+ *   [ja][/ja]
+ * @seealso ons-radio
+ *   [en]The `<ons-radio>` element is used to display a radio button.[/en]
+ *   [ja][/ja]
+ * @guide theming.html#modifiers [en]More details about the `modifier` attribute[/en][ja]modifier属性の使い方[/ja]
+ * @example
+ * <ons-search-input placeholder="Search"></ons-search-input>
+ */
+
+var SearchInputElement = function (_BaseInputElement) {
+  inherits(SearchInputElement, _BaseInputElement);
+
+  function SearchInputElement() {
+    classCallCheck(this, SearchInputElement);
+    return possibleConstructorReturn(this, (SearchInputElement.__proto__ || Object.getPrototypeOf(SearchInputElement)).apply(this, arguments));
+  }
+
+  createClass(SearchInputElement, [{
+    key: '_scheme',
+    get: function get$$1() {
+      return scheme$15;
+    }
+  }, {
+    key: '_template',
+    get: function get$$1() {
+      return '\n      <input type="' + this.type + '" class="search-input">\n    ';
+    }
+  }, {
+    key: 'type',
+    get: function get$$1() {
+      return 'search';
+    }
+
+    /**
+     * @attribute input-id
+     * @type {String}
+     * @description
+     *  [en]Specify the "id" attribute of the inner `<input>` element. This is useful when using `<label for="...">` elements.[/en]
+     *  [ja][/ja]
+     */
+
+    /**
+     * @property value
+     * @type {String}
+     * @description
+     *   [en]The current value of the input.[/en]
+     *   [ja][/ja]
+     */
+
+    /**
+     * @property disabled
+     * @type {Boolean}
+     * @description
+     *   [en]Whether the input is disabled or not.[/en]
+     *   [ja]無効化されている場合に`true`。[/ja]
+     */
+
+  }]);
+  return SearchInputElement;
+}(BaseInputElement);
+
+onsElements.SearchInput = SearchInputElement;
+customElements.define('ons-search-input', SearchInputElement);
+
+/*
+Copyright 2013-2015 ASIAL CORPORATION
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+   http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+*/
+
+var ModalAnimator = function (_BaseAnimator) {
+  inherits(ModalAnimator, _BaseAnimator);
+
+  /**
+   * @param {Object} options
+   * @param {String} options.timing
+   * @param {Number} options.duration
+   * @param {Number} options.delay
+   */
+  function ModalAnimator() {
+    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
+        _ref$timing = _ref.timing,
+        timing = _ref$timing === undefined ? 'linear' : _ref$timing,
+        _ref$delay = _ref.delay,
+        delay = _ref$delay === undefined ? 0 : _ref$delay,
+        _ref$duration = _ref.duration,
+        duration = _ref$duration === undefined ? 0.2 : _ref$duration;
+
+    classCallCheck(this, ModalAnimator);
+    return possibleConstructorReturn(this, (ModalAnimator.__proto__ || Object.getPrototypeOf(ModalAnimator)).call(this, { timing: timing, delay: delay, duration: duration }));
+  }
+
+  /**
+   * @param {HTMLElement} modal
+   * @param {Function} callback
+   */
+
+
+  createClass(ModalAnimator, [{
+    key: 'show',
+    value: function show(modal, callback) {
+      callback();
+    }
+
+    /**
+     * @param {HTMLElement} modal
+     * @param {Function} callback
+     */
+
+  }, {
+    key: 'hide',
+    value: function hide(modal, callback) {
+      callback();
+    }
+  }]);
+  return ModalAnimator;
+}(BaseAnimator);
+
+/*
+Copyright 2013-2015 ASIAL CORPORATION
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+   http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+*/
+
+/**
+ * iOS style animator for dialog.
+ */
+
+var FadeModalAnimator = function (_ModalAnimator) {
+  inherits(FadeModalAnimator, _ModalAnimator);
+
+  function FadeModalAnimator() {
+    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
+        _ref$timing = _ref.timing,
+        timing = _ref$timing === undefined ? 'linear' : _ref$timing,
+        _ref$delay = _ref.delay,
+        delay = _ref$delay === undefined ? 0 : _ref$delay,
+        _ref$duration = _ref.duration,
+        duration = _ref$duration === undefined ? 0.3 : _ref$duration;
+
+    classCallCheck(this, FadeModalAnimator);
+    return possibleConstructorReturn(this, (FadeModalAnimator.__proto__ || Object.getPrototypeOf(FadeModalAnimator)).call(this, { timing: timing, delay: delay, duration: duration }));
+  }
+
+  /**
+   * @param {HTMLElement} modal
+   * @param {Function} callback
+   */
+
+
+  createClass(FadeModalAnimator, [{
+    key: 'show',
+    value: function show(modal, callback) {
+      callback = callback ? callback : function () {};
+
+      Animit(modal, this.def).default({ opacity: 0 }, { opacity: 1 }).queue(function (done) {
+        callback();
+        done();
+      }).play();
+    }
+
+    /**
+     * @param {HTMLElement} modal
+     * @param {Function} callback
+     */
+
+  }, {
+    key: 'hide',
+    value: function hide(modal, callback) {
+      callback = callback ? callback : function () {};
+
+      Animit(modal, this.def).default({ opacity: 1 }, { opacity: 0 }).queue(function (done) {
+        callback();
+        done();
+      }).play();
+    }
+  }]);
+  return FadeModalAnimator;
+}(ModalAnimator);
+
+/*
+Copyright 2013-2015 ASIAL CORPORATION
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+   http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+*/
+
+/**
+ * iOS style animator for modal.
+ */
+
+var LiftModalAnimator = function (_ModalAnimator) {
+  inherits(LiftModalAnimator, _ModalAnimator);
+
+  function LiftModalAnimator() {
+    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
+        _ref$timing = _ref.timing,
+        timing = _ref$timing === undefined ? 'cubic-bezier( .1, .7, .1, 1)' : _ref$timing,
+        _ref$delay = _ref.delay,
+        delay = _ref$delay === undefined ? 0 : _ref$delay,
+        _ref$duration = _ref.duration,
+        duration = _ref$duration === undefined ? 0.4 : _ref$duration;
+
+    classCallCheck(this, LiftModalAnimator);
+    return possibleConstructorReturn(this, (LiftModalAnimator.__proto__ || Object.getPrototypeOf(LiftModalAnimator)).call(this, { timing: timing, delay: delay, duration: duration }));
+  }
+
+  /**
+   * @param {HTMLElement} modal
+   * @param {Function} callback
+   */
+
+
+  createClass(LiftModalAnimator, [{
+    key: 'show',
+    value: function show(modal, callback) {
+      callback = callback ? callback : function () {};
+
+      Animit(modal, this.def).default({ transform: 'translate3d(0, 100%, 0)' }, { transform: 'translate3d(0, 0, 0)' }).queue(function (done) {
+        callback();
+        done();
+      }).play();
+    }
+
+    /**
+     * @param {HTMLElement} modal
+     * @param {Function} callback
+     */
+
+  }, {
+    key: 'hide',
+    value: function hide(modal, callback) {
+      callback = callback ? callback : function () {};
+
+      Animit(modal, this.def).default({ transform: 'translate3d(0, 0, 0)' }, { transform: 'translate3d(0, 100%, 0)' }).queue(function (done) {
+        callback();
+        done();
+      }).play();
+    }
+  }]);
+  return LiftModalAnimator;
+}(ModalAnimator);
+
+/*
+Copyright 2013-2015 ASIAL CORPORATION
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+   http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+*/
+
+var scheme$16 = {
+  '': 'modal--*',
+  'modal__content': 'modal--*__content'
+};
+
+var defaultClassName$8 = 'modal';
+
+var _animatorDict$4 = {
+  'default': ModalAnimator,
+  'fade': FadeModalAnimator,
+  'lift': LiftModalAnimator,
+  'none': ModalAnimator
+};
+
+/**
+ * @element ons-modal
+ * @category dialog
+ * @description
+ *   [en]
+ *     Modal component that masks current screen. Underlying components are not subject to any events while the modal component is shown.
+ *
+ *     This component can be used to block user input while some operation is running or to show some information to the user.
+ *   [/en]
+ *   [ja]
+ *     画面全体をマスクするモーダル用コンポーネントです。下側にあるコンポーネントは、
+ *     モーダルが表示されている間はイベント通知が行われません。
+ *   [/ja]
+ * @seealso ons-dialog
+ *   [en]The `<ons-dialog>` component can be used to create a modal dialog.[/en]
+ *   [ja][/ja]
+ * @codepen devIg
+ * @tutorial vanilla/reference/modal
+ * @example
+ * <ons-modal id="modal">
+ *   Modal content
+ * </ons-modal>
+ * <script>
+ *   var modal = document.getElementById('modal');
+ *   modal.show();
+ * </script>
+ */
+
+var ModalElement = function (_BaseDialogElement) {
+  inherits(ModalElement, _BaseDialogElement);
+
+  /**
+   * @event preshow
+   * @description
+   * [en]Fired just before the modal is displayed.[/en]
+   * [ja]モーダルが表示される直前に発火します。[/ja]
+   * @param {Object} event [en]Event object.[/en]
+   * @param {Object} event.modal
+   *   [en]Component object.[/en]
+   *   [ja]コンポーネントのオブジェクト。[/ja]
+   * @param {Function} event.cancel
+   *   [en]Execute this function to stop the modal from being shown.[/en]
+   *   [ja]この関数を実行すると、ダイアログの表示がキャンセルされます。[/ja]
+   */
+
+  /**
+   * @event postshow
+   * @description
+   * [en]Fired just after the modal is displayed.[/en]
+   * [ja]モーダルが表示された直後に発火します。[/ja]
+   * @param {Object} event [en]Event object.[/en]
+   * @param {Object} event.modal
+   *   [en]Component object.[/en]
+   *   [ja]コンポーネントのオブジェクト。[/ja]
+   */
+
+  /**
+   * @event prehide
+   * @description
+   * [en]Fired just before the modal is hidden.[/en]
+   * [ja]モーダルが隠れる直前に発火します。[/ja]
+   * @param {Object} event [en]Event object.[/en]
+   * @param {Object} event.modal
+   *   [en]Component object.[/en]
+   *   [ja]コンポーネントのオブジェクト。[/ja]
+   * @param {Function} event.cancel
+   *   [en]Execute this function to stop the modal from being hidden.[/en]
+   *   [ja]この関数を実行すると、ダイアログの非表示がキャンセルされます。[/ja]
+   */
+
+  /**
+   * @event posthide
+   * @description
+   * [en]Fired just after the modal is hidden.[/en]
+   * [ja]モーダルが隠れた後に発火します。[/ja]
+   * @param {Object} event [en]Event object.[/en]
+   * @param {Object} event.modal
+   *   [en]Component object.[/en]
+   *   [ja]コンポーネントのオブジェクト。[/ja]
+   */
+
+  /**
+   * @attribute animation
+   * @type {String}
+   * @default default
+   * @description
+   *  [en]The animation used when showing and hiding the modal. Can be either `"none"`, `"fade"` or `"lift"`.[/en]
+   *  [ja]モーダルを表示する際のアニメーション名を指定します。"none"もしくは"fade","lift"を指定できます。[/ja]
+   */
+
+  /**
+   * @attribute animation-options
+   * @type {Expression}
+   * @description
+   *  [en]Specify the animation's duration, timing and delay with an object literal. E.g. `{duration: 0.2, delay: 1, timing: 'ease-in'}`.[/en]
+   *  [ja]アニメーション時のduration, timing, delayをオブジェクトリテラルで指定します。e.g. <code>{duration: 0.2, delay: 1, timing: 'ease-in'}</code>[/ja]
+   */
+
+  function ModalElement() {
+    classCallCheck(this, ModalElement);
+
+    var _this = possibleConstructorReturn(this, (ModalElement.__proto__ || Object.getPrototypeOf(ModalElement)).call(this));
+
+    _this._defaultDBB = function () {
+      return undefined;
+    };
+    contentReady(_this, function () {
+      return _this._compile();
+    });
+    return _this;
+  }
+
+  createClass(ModalElement, [{
+    key: '_updateAnimatorFactory',
+    value: function _updateAnimatorFactory() {
+      return new AnimatorFactory({
+        animators: _animatorDict$4,
+        baseClass: ModalAnimator,
+        baseClassName: 'ModalAnimator',
+        defaultAnimation: this.getAttribute('animation')
+      });
+    }
+
+    /**
+     * @property onDeviceBackButton
+     * @type {Object}
+     * @description
+     *   [en]Back-button handler.[/en]
+     *   [ja]バックボタンハンドラ。[/ja]
+     */
+
+  }, {
+    key: '_compile',
+    value: function _compile() {
+      this.style.display = 'none';
+      this.style.zIndex = 10001;
+      this.classList.add(defaultClassName$8);
+
+      if (!util$1.findChild(this, '.modal__content')) {
+        var content = document.createElement('div');
+        content.classList.add('modal__content');
+
+        while (this.childNodes[0]) {
+          var node = this.childNodes[0];
+          this.removeChild(node);
+          content.insertBefore(node, null);
+        }
+
+        this.appendChild(content);
+      }
+
+      ModifierUtil.initModifier(this, this._scheme);
+    }
+  }, {
+    key: '_toggleStyle',
+    value: function _toggleStyle(shouldShow) {
+      this.style.display = shouldShow ? 'table' : 'none';
+    }
+  }, {
+    key: 'connectedCallback',
+    value: function connectedCallback() {
+      get(ModalElement.prototype.__proto__ || Object.getPrototypeOf(ModalElement.prototype), 'connectedCallback', this).call(this);
+    }
+  }, {
+    key: 'disconnectedCallback',
+    value: function disconnectedCallback() {
+      get(ModalElement.prototype.__proto__ || Object.getPrototypeOf(ModalElement.prototype), 'disconnectedCallback', this).call(this);
+    }
+
+    /**
+     * @property visible
+     * @readonly
+     * @type {Boolean}
+     * @description
+     *   [en]Whether the element is visible or not.[/en]
+     *   [ja]要素が見える場合に`true`。[/ja]
+     */
+
+    /**
+     * @method show
+     * @signature show([options])
+     * @param {Object} [options]
+     *   [en]Parameter object.[/en]
+     *   [ja]オプションを指定するオブジェクト。[/ja]
+     * @param {String} [options.animation]
+     *   [en]Animation name. Available animations are `"none"` and `"fade"`.[/en]
+     *   [ja]アニメーション名を指定します。"none", "fade"のいずれかを指定します。[/ja]
+     * @param {String} [options.animationOptions]
+     *   [en]Specify the animation's duration, delay and timing. E.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}`.[/en]
+     *   [ja]アニメーション時のduration, delay, timingを指定します。e.g. {duration: 0.2, delay: 0.4, timing: 'ease-in'}[/ja]
+     * @param {Function} [options.callback]
+     *   [en]This function is called after the modal has been revealed.[/en]
+     *   [ja]モーダルが表示され終わった後に呼び出される関数オブジェクトを指定します。[/ja]
+     * @description
+     *   [en]Show modal.[/en]
+     *   [ja]モーダルを表示します。[/ja]
+     * @return {Promise}
+     *   [en]Resolves to the displayed element[/en]
+     *   [ja][/ja]
+     */
+
+    /**
+     * @method toggle
+     * @signature toggle([options])
+     * @param {Object} [options]
+     *   [en]Parameter object.[/en]
+     *   [ja]オプションを指定するオブジェクト。[/ja]
+     * @param {String} [options.animation]
+     *   [en]Animation name. Available animations are `"none"` and `"fade"`.[/en]
+     *   [ja]アニメーション名を指定します。"none", "fade"のいずれかを指定します。[/ja]
+     * @param {String} [options.animationOptions]
+     *   [en]Specify the animation's duration, delay and timing. E.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}`.[/en]
+     *   [ja]アニメーション時のduration, delay, timingを指定します。e.g. {duration: 0.2, delay: 0.4, timing: 'ease-in'}[/ja]
+     * @param {Function} [options.callback]
+     *   [en]This function is called after the modal has been revealed.[/en]
+     *   [ja]モーダルが表示され終わった後に呼び出される関数オブジェクトを指定します。[/ja]
+     * @description
+     *   [en]Toggle modal visibility.[/en]
+     *   [ja]モーダルの表示を切り替えます。[/ja]
+     */
+
+    /**
+     * @method hide
+     * @signature hide([options])
+     * @param {Object} [options]
+     *   [en]Parameter object.[/en]
+     *   [ja]オプションを指定するオブジェクト。[/ja]
+     * @param {String} [options.animation]
+     *   [en]Animation name. Available animations are `"none"` and `"fade"`.[/en]
+     *   [ja]アニメーション名を指定します。"none", "fade"のいずれかを指定します。[/ja]
+     * @param {String} [options.animationOptions]
+     *   [en]Specify the animation's duration, delay and timing. E.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}`.[/en]
+     *   [ja]アニメーション時のduration, delay, timingを指定します。e.g. {duration: 0.2, delay: 0.4, timing: 'ease-in'}[/ja]
+     * @param {Function} [options.callback]
+     *   [en]This function is called after the modal has been revealed.[/en]
+     *   [ja]モーダルが表示され終わった後に呼び出される関数オブジェクトを指定します。[/ja]
+     * @description
+     *   [en]Hide modal.[/en]
+     *   [ja]モーダルを非表示にします。[/ja]
+     * @return {Promise}
+     *   [en]Resolves to the hidden element[/en]
+     *   [ja][/ja]
+     */
+
+  }, {
+    key: 'attributeChangedCallback',
+    value: function attributeChangedCallback(name, last, current) {
+      if (name === 'class') {
+        util$1.restoreClass(this, defaultClassName$8, scheme$16);
+      } else {
+        get(ModalElement.prototype.__proto__ || Object.getPrototypeOf(ModalElement.prototype), 'attributeChangedCallback', this).call(this, name, last, current);
+      }
+    }
+
+    /**
+     * @param {String} name
+     * @param {Function} Animator
+     */
+
+  }, {
+    key: '_scheme',
+    get: function get$$1() {
+      return scheme$16;
+    }
+  }], [{
+    key: 'registerAnimator',
+    value: function registerAnimator(name, Animator) {
+      if (!(Animator.prototype instanceof ModalAnimator)) {
+        util$1.throwAnimator('Modal');
+      }
+      _animatorDict$4[name] = Animator;
+    }
+  }, {
+    key: 'observedAttributes',
+    get: function get$$1() {
+      return [].concat(toConsumableArray(get(ModalElement.__proto__ || Object.getPrototypeOf(ModalElement), 'observedAttributes', this)), ['class']);
+    }
+  }, {
+    key: 'animators',
+    get: function get$$1() {
+      return _animatorDict$4;
+    }
+  }, {
+    key: 'ModalAnimator',
+    get: function get$$1() {
+      return ModalAnimator;
+    }
+  }]);
+  return ModalElement;
+}(BaseDialogElement);
+
+onsElements.Modal = ModalElement;
+customElements.define('ons-modal', ModalElement);
+
+/*
+Copyright 2013-2015 ASIAL CORPORATION
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+   http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+*/
+
+var widthToPx = function widthToPx(width) {
+  var _ref = [parseInt(width, 10), /px/.test(width)],
+      value = _ref[0],
+      px = _ref[1];
+
+  return px ? value : Math.round(document.body.offsetWidth * value / 100);
+};
+
+var SwipeReveal = function () {
+  function SwipeReveal(params) {
+    var _this = this;
+
+    classCallCheck(this, SwipeReveal);
+
+    'element ignoreSwipe isInitialState onDragCallback swipeMax swipeMin swipeMid'.split(/\s+/).forEach(function (key) {
+      return _this[key] = params[key];
+    });
+
+    this.elementHandler = params.elementHandler || params.element;
+    this.getThreshold = params.getThreshold || function () {
+      return .5;
+    };
+    this.getSide = params.getSide || function () {
+      return 'left';
+    };
+
+    this.handleGesture = this.handleGesture.bind(this);
+
+    this._shouldFixScroll = util$1.globals.actualMobileOS === 'ios';
+  }
+
+  createClass(SwipeReveal, [{
+    key: 'update',
+    value: function update() {
+      var swipeable = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.element.hasAttribute('swipeable');
+
+      if (!this.gestureDetector) {
+        this.gestureDetector = new GestureDetector(this.elementHandler, { dragMinDistance: 1, passive: !this._shouldFixScroll });
+      }
+
+      var action = swipeable ? 'on' : 'off';
+      this.gestureDetector[action]('drag dragstart dragend', this.handleGesture);
+    }
+  }, {
+    key: 'handleGesture',
+    value: function handleGesture(e) {
+      if (e.gesture) {
+        if (e.type === 'dragstart') {
+          this.onDragStart(e);
+        } else if (!this._ignoreDrag) {
+          e.type === 'dragend' ? this.onDragEnd(e) : this.onDrag(e);
+        }
+      }
+    }
+  }, {
+    key: 'onDragStart',
+    value: function onDragStart(event) {
+      var _this2 = this;
+
+      var getDistance = function getDistance() {
+        return _this2.getSide() === 'left' ? event.gesture.center.clientX : window.innerWidth - event.gesture.center.clientX;
+      };
+      this._ignoreDrag = event.consumed || !util$1.isValidGesture(event) || this.ignoreSwipe(event, getDistance());
+
+      if (!this._ignoreDrag) {
+        event.consume && event.consume();
+        event.consumed = true;
+
+        this._width = widthToPx(this.element.style.width || '100%');
+        this._startDistance = this._distance = !(this.isInitialState instanceof Function) || this.isInitialState() ? 0 : this._width;
+
+        util$1.iosPreventScroll(this.gestureDetector);
+      }
+    }
+  }, {
+    key: 'onDrag',
+    value: function onDrag(event) {
+      event.stopPropagation();
+
+      var delta = this.getSide() === 'left' ? event.gesture.deltaX : -event.gesture.deltaX;
+      var distance = Math.max(0, Math.min(this._width, this._startDistance + delta));
+      if (distance !== this._distance) {
+        this._distance = distance;
+        this.swipeMid(this._distance, this._width);
+      }
+    }
+  }, {
+    key: 'onDragEnd',
+    value: function onDragEnd(event) {
+      event.stopPropagation();
+
+      var direction = event.gesture.interimDirection;
+      var isSwipeMax = this.getSide() !== direction && this._distance > this._width * this.getThreshold();
+      isSwipeMax ? this.swipeMax() : this.swipeMin();
+    }
+  }, {
+    key: 'dispose',
+    value: function dispose() {
+      this.gestureDetector && this.gestureDetector.dispose();
+      this.gestureDetector = this.element = this.elementHandler = null;
+    }
+  }]);
+  return SwipeReveal;
+}();
+
+/*
+Copyright 2013-2015 ASIAL CORPORATION
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+   http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+*/
+
+var NavigatorAnimator = function (_BaseAnimator) {
+  inherits(NavigatorAnimator, _BaseAnimator);
+
+  /**
+   * @param {Object} options
+   * @param {String} options.timing
+   * @param {Number} options.duration
+   * @param {Number} options.delay
+   */
+  function NavigatorAnimator(options) {
+    classCallCheck(this, NavigatorAnimator);
+
+    options = util$1.extend({
+      timing: 'linear',
+      duration: '0.4',
+      delay: '0'
+    }, options || {});
+
+    return possibleConstructorReturn(this, (NavigatorAnimator.__proto__ || Object.getPrototypeOf(NavigatorAnimator)).call(this, options));
+  }
+
+  createClass(NavigatorAnimator, [{
+    key: 'push',
+    value: function push(enterPage, leavePage, callback) {
+      callback();
+    }
+  }, {
+    key: 'pop',
+    value: function pop(enterPage, leavePage, callback) {
+      callback();
+    }
+  }, {
+    key: 'block',
+    value: function block(page) {
+      var blocker = util$1.createElement('\n      <div style="position: absolute; background-color: transparent; width: 100%; height: 100%; z-index: 100000"></div>\n    ');
+      page.parentNode.appendChild(blocker);
+      return function () {
+        return blocker.remove();
+      };
+    }
+  }]);
+  return NavigatorAnimator;
+}(BaseAnimator);
+
+/*
+Copyright 2013-2015 ASIAL CORPORATION
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+   http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+*/
+
+/**
+ * Abstract swipe animator for iOS navigator transition.
+ */
+
+var IOSSwipeNavigatorAnimator = function (_NavigatorAnimator) {
+  inherits(IOSSwipeNavigatorAnimator, _NavigatorAnimator);
+  createClass(IOSSwipeNavigatorAnimator, null, [{
+    key: 'swipeable',
+    get: function get$$1() {
+      return true;
+    }
+  }]);
+
+  function IOSSwipeNavigatorAnimator() {
+    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
+
+    var _ref$durationRestore = _ref.durationRestore,
+        durationRestore = _ref$durationRestore === undefined ? 0.1 : _ref$durationRestore,
+        _ref$durationSwipe = _ref.durationSwipe,
+        durationSwipe = _ref$durationSwipe === undefined ? 0.15 : _ref$durationSwipe,
+        _ref$timingSwipe = _ref.timingSwipe,
+        timingSwipe = _ref$timingSwipe === undefined ? 'linear' : _ref$timingSwipe,
+        rest = objectWithoutProperties(_ref, ['durationRestore', 'durationSwipe', 'timingSwipe']);
+    classCallCheck(this, IOSSwipeNavigatorAnimator);
+
+    var _this = possibleConstructorReturn(this, (IOSSwipeNavigatorAnimator.__proto__ || Object.getPrototypeOf(IOSSwipeNavigatorAnimator)).call(this, _extends({}, rest)));
+
+    if (_this.constructor === IOSSwipeNavigatorAnimator) {
+      util$1.throwAbstract();
+    }
+
+    _this.durationRestore = durationRestore;
+    _this.durationSwipe = durationSwipe;
+    _this.timingSwipe = timingSwipe;
+
+    _this.optSwipe = { timing: timingSwipe, duration: durationSwipe };
+    _this.optRestore = { timing: timingSwipe, duration: durationRestore };
+
+    _this.swipeShadow = util$1.createElement('<div style="position: absolute; height: 100%; width: 12px; right: 100%; top: 0; bottom: 0; z-index: -1;' + 'background: linear-gradient(to right, transparent 0, rgba(0,0,0,.04) 40%, rgba(0,0,0,.12) 80%, rgba(0,0,0,.16) 100%);"></div>');
+
+    _this.isDragStart = true;
+    return _this;
+  }
+
+  createClass(IOSSwipeNavigatorAnimator, [{
+    key: '_decompose',
+    value: function _decompose() {
+      util$1.throwMember();
+    }
+  }, {
+    key: '_shouldAnimateToolbar',
+    value: function _shouldAnimateToolbar() {
+      util$1.throwMember();
+    }
+  }, {
+    key: '_calculateDelta',
+    value: function _calculateDelta() {
+      util$1.throwMember();
+    }
+  }, {
+    key: '_dragStartSetup',
+    value: function _dragStartSetup(enterPage, leavePage) {
+      this.isDragStart = false;
+
+      // Avoid content clicks
+      this.unblock = get(IOSSwipeNavigatorAnimator.prototype.__proto__ || Object.getPrototypeOf(IOSSwipeNavigatorAnimator.prototype), 'block', this).call(this, leavePage);
+
+      // Mask
+      enterPage.parentElement.insertBefore(this.backgroundMask, enterPage);
+
+      // Decomposition
+      this.target = {
+        enter: util$1.findToolbarPage(enterPage) || enterPage,
+        leave: util$1.findToolbarPage(leavePage) || leavePage
+      };
+      this.decomp = {
+        enter: this._decompose(this.target.enter),
+        leave: this._decompose(this.target.leave)
+      };
+
+      // Animation values
+      this.delta = this._calculateDelta(leavePage, this.decomp.leave);
+      this.shouldAnimateToolbar = this._shouldAnimateToolbar(this.target.enter, this.target.leave);
+
+      // Shadow && styles
+      if (this.shouldAnimateToolbar) {
+        this.swipeShadow.style.top = this.decomp.leave.toolbar.offsetHeight + 'px';
+        this.target.leave.appendChild(this.swipeShadow);
+        this._saveStyle(this.target.enter, this.target.leave);
+      } else {
+        leavePage.appendChild(this.swipeShadow);
+        this._saveStyle(enterPage, leavePage);
+      }
+      leavePage.classList.add('overflow-visible');
+      this.overflowElement = leavePage;
+      this.decomp.leave.content.classList.add('content-swiping');
+    }
+  }, {
+    key: 'translate',
+    value: function translate(distance, maxWidth, enterPage, leavePage) {
+      this.isSwiping = true;
+
+      if (enterPage.style.display === 'none') {
+        enterPage.style.display = '';
+      }
+
+      if (this.isDragStart) {
+        this.maxWidth = maxWidth;
+        this._dragStartSetup(enterPage, leavePage);
+      }
+
+      var swipeRatio = (distance - maxWidth) / maxWidth;
+
+      if (this.shouldAnimateToolbar) {
+
+        Animit.runAll(
+
+        /* Enter page */
+
+        Animit([this.decomp.enter.content, this.decomp.enter.bottomToolbar, this.decomp.enter.background]).queue({
+          transform: 'translate3d(' + swipeRatio * 25 + '%, 0, 0)',
+          opacity: 1 + swipeRatio * 10 / 100 // 0.9 -> 1
+        }), Animit(this.decomp.enter.toolbarCenter).queue({
+          transform: 'translate3d(' + this.delta.title * swipeRatio + 'px, 0, 0)',
+          opacity: 1 + swipeRatio // 0 -> 1
+        }), Animit(this.decomp.enter.backButtonLabel).queue({
+          opacity: 1 + swipeRatio * 10 / 100, // 0.9 -> 1
+          transform: 'translate3d(' + this.delta.label * swipeRatio + 'px, 0, 0)'
+        }), Animit(this.decomp.enter.other).queue({
+          opacity: 1 + swipeRatio // 0 -> 1
+        }),
+
+        /* Leave page */
+
+        Animit([this.decomp.leave.content, this.decomp.leave.bottomToolbar, this.decomp.leave.background, this.swipeShadow]).queue({
+          transform: 'translate3d(' + distance + 'px, 0, 0)'
+        }), Animit(this.decomp.leave.toolbar).queue({
+          opacity: -1 * swipeRatio // 1 -> 0
+        }), Animit(this.decomp.leave.toolbarCenter).queue({
+          transform: 'translate3d(' + (1 + swipeRatio) * 125 + '%, 0, 0)'
+        }), Animit(this.decomp.leave.backButtonLabel).queue({
+          opacity: -1 * swipeRatio, // 1 -> 0
+          transform: 'translate3d(' + this.delta.title * (1 + swipeRatio) + 'px, 0, 0)'
+        }),
+
+        /* Other */
+
+        Animit(this.swipeShadow).queue({
+          opacity: -1 * swipeRatio // 1 -> 0
+        }));
+      } else {
+        Animit.runAll(Animit(leavePage).queue({
+          transform: 'translate3d(' + distance + 'px, 0, 0)'
+        }), Animit(enterPage).queue({
+          transform: 'translate3d(' + swipeRatio * 25 + '%, 0, 0)',
+          opacity: 1 + swipeRatio * 10 / 100 // 0.9 -> 1
+        }), Animit(this.swipeShadow).queue({
+          opacity: -1 * swipeRatio // 1 -> 0
+        }));
+      }
+    }
+  }, {
+    key: 'restore',
+    value: function restore(enterPage, leavePage, callback) {
+      var _this2 = this;
+
+      if (this.isDragStart) {
+        return;
+      }
+
+      if (this.shouldAnimateToolbar) {
+
+        Animit.runAll(
+
+        /* Enter page */
+
+        Animit([this.decomp.enter.content, this.decomp.enter.bottomToolbar, this.decomp.enter.background]).queue({
+          transform: 'translate3d(-25%, 0, 0)',
+          opacity: 0.9
+        }, this.optRestore), Animit(this.decomp.enter.toolbarCenter).queue({
+          transform: 'translate3d(-' + this.delta.title + 'px, 0, 0)',
+          transition: 'opacity ' + this.durationRestore + 's linear, transform ' + this.durationRestore + 's ' + this.timingSwipe,
+          opacity: 0
+        }), Animit(this.decomp.enter.backButtonLabel).queue({
+          transform: 'translate3d(-' + this.delta.label + 'px, 0, 0)'
+        }, this.optRestore), Animit(this.decomp.enter.other).queue({
+          opacity: 0
+        }, this.optRestore),
+
+        /* Leave page */
+
+        Animit([this.decomp.leave.content, this.decomp.leave.bottomToolbar, this.decomp.leave.background, this.swipeShadow]).queue({
+          transform: 'translate3d(0, 0, 0)'
+        }, this.optRestore), Animit(this.decomp.leave.toolbar).queue({
+          opacity: 1
+        }, this.optRestore), Animit(this.decomp.leave.toolbarCenter).queue({
+          transform: 'translate3d(0, 0, 0)'
+        }, this.optRestore), Animit(this.decomp.leave.backButtonLabel).queue({
+          opacity: 1,
+          transform: 'translate3d(0, 0, 0)',
+          transition: 'opacity ' + this.durationRestore + 's linear, transform ' + this.durationRestore + 's ' + this.timingSwipe
+        }),
+
+        /* Other */
+
+        Animit(this.swipeShadow).queue({
+          opacity: 0
+        }, this.optRestore).queue(function (done) {
+          _this2._reset(_this2.target.enter, _this2.target.leave);
+          enterPage.style.display = 'none';
+          callback && callback();
+          done();
+        }));
+      } else {
+        Animit.runAll(Animit(enterPage).queue({
+          transform: 'translate3D(-25%, 0, 0)',
+          opacity: 0.9
+        }, this.optRestore), Animit(leavePage).queue({
+          transform: 'translate3D(0, 0, 0)'
+        }, this.optRestore).queue(function (done) {
+          _this2._reset(enterPage, leavePage);
+          enterPage.style.display = 'none';
+          callback && callback();
+          done();
+        }));
+      }
+    }
+  }, {
+    key: 'popSwipe',
+    value: function popSwipe(enterPage, leavePage, callback) {
+      var _this3 = this;
+
+      if (this.isDragStart) {
+        return;
+      }
+
+      if (this.shouldAnimateToolbar) {
+
+        Animit.runAll(
+
+        /* Enter page */
+
+        Animit([this.decomp.enter.content, this.decomp.enter.bottomToolbar, this.decomp.enter.background]).queue({
+          transform: 'translate3d(0, 0, 0)',
+          opacity: 1
+        }, this.optSwipe), Animit(this.decomp.enter.toolbarCenter).queue({
+          transform: 'translate3d(0, 0, 0)',
+          transition: 'opacity ' + this.durationSwipe + 's linear, transform ' + this.durationSwipe + 's ' + this.timingSwipe,
+          opacity: 1
+        }), Animit(this.decomp.enter.backButtonLabel).queue({
+          transform: 'translate3d(0, 0, 0)'
+        }, this.optSwipe), Animit(this.decomp.enter.other).queue({
+          opacity: 1
+        }, this.optSwipe),
+
+        /* Leave page */
+
+        Animit([this.decomp.leave.content, this.decomp.leave.bottomToolbar, this.decomp.leave.background]).queue({
+          transform: 'translate3d(100%, 0, 0)'
+        }, this.optSwipe), Animit(this.decomp.leave.toolbar).queue({
+          opacity: 0
+        }, this.optSwipe), Animit(this.decomp.leave.toolbarCenter).queue({
+          transform: 'translate3d(125%, 0, 0)'
+        }, this.optSwipe), Animit(this.decomp.leave.backButtonLabel).queue({
+          opacity: 0,
+          transform: 'translate3d(' + this.delta.title + 'px, 0, 0)',
+          transition: 'opacity ' + this.durationSwipe + 's linear, transform ' + this.durationSwipe + 's ' + this.timingSwipe
+        }),
+
+        /* Other */
+
+        Animit(this.swipeShadow).queue({
+          opacity: 0,
+          transform: 'translate3d(' + this.maxWidth + 'px, 0, 0)'
+        }, this.optSwipe).queue(function (done) {
+          _this3._reset(_this3.target.enter, _this3.target.leave);
+          callback && callback();
+          done();
+        }));
+      } else {
+        Animit.runAll(Animit(enterPage).queue({
+          transform: 'translate3D(0, 0, 0)',
+          opacity: 1.0
+        }, this.optSwipe), Animit(leavePage).queue({
+          transform: 'translate3D(100%, 0, 0)'
+        }, this.optSwipe).queue(function (done) {
+          _this3._reset(enterPage, leavePage);
+          callback && callback();
+          done();
+        }));
+      }
+    }
+  }, {
+    key: '_saveStyle',
+    value: function _saveStyle() {
+      var _this4 = this;
+
+      this._savedStyle = new WeakMap();
+      var save = function save(el) {
+        return _this4._savedStyle.set(el, el.getAttribute('style'));
+      };
+
+      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
+        args[_key] = arguments[_key];
+      }
+
+      args.forEach(save);
+
+      Object.keys(this.decomp).forEach(function (p) {
+        Object.keys(_this4.decomp[p]).forEach(function (k) {
+          (_this4.decomp[p][k] instanceof Array ? _this4.decomp[p][k] : [_this4.decomp[p][k]]).forEach(save);
+        });
+      });
+    }
+  }, {
+    key: '_restoreStyle',
+    value: function _restoreStyle() {
+      var _this5 = this;
+
+      var restore = function restore(el) {
+        _this5._savedStyle.get(el) === null ? el.removeAttribute('style') : el.setAttribute('style', _this5._savedStyle.get(el));
+        _this5._savedStyle.delete(el);
+      };
+
+      for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
+        args[_key2] = arguments[_key2];
+      }
+
+      args.forEach(restore);
+
+      Object.keys(this.decomp).forEach(function (p) {
+        Object.keys(_this5.decomp[p]).forEach(function (k) {
+          (_this5.decomp[p][k] instanceof Array ? _this5.decomp[p][k] : [_this5.decomp[p][k]]).forEach(restore);
+        });
+      });
+    }
+  }, {
+    key: '_reset',
+    value: function _reset() {
+      this.isSwiping = false;
+      this._savedStyle && this._restoreStyle.apply(this, arguments);
+      this.unblock && this.unblock();
+      this.swipeShadow.remove();
+      this.backgroundMask.remove();
+      this.overflowElement.classList.remove('overflow-visible');
+      this.decomp.leave.content.classList.remove('content-swiping');
+      this.decomp = this.target = this.overflowElement = this._savedStyle = null;
+      this.isDragStart = true;
+    }
+  }]);
+  return IOSSwipeNavigatorAnimator;
+}(NavigatorAnimator);
+
+/*
+Copyright 2013-2015 ASIAL CORPORATION
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+   http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+*/
+
+var translate3d = function translate3d() {
+  var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
+  var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
+  var z = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
+  return 'translate3d(' + x + ', ' + y + ', ' + z + ')';
+};
+
+/**
+ * Slide animator for navigator transition like iOS's screen slide transition.
+ */
+
+var IOSSlideNavigatorAnimator = function (_IOSSwipeNavigatorAni) {
+  inherits(IOSSlideNavigatorAnimator, _IOSSwipeNavigatorAni);
+
+  function IOSSlideNavigatorAnimator() {
+    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
+
+    var _ref$timing = _ref.timing,
+        timing = _ref$timing === undefined ? 'cubic-bezier(0.3, .4, 0, .9)' : _ref$timing,
+        _ref$delay = _ref.delay,
+        delay = _ref$delay === undefined ? 0 : _ref$delay,
+        _ref$duration = _ref.duration,
+        duration = _ref$duration === undefined ? 0.4 : _ref$duration,
+        rest = objectWithoutProperties(_ref, ['timing', 'delay', 'duration']);
+    classCallCheck(this, IOSSlideNavigatorAnimator);
+
+    var _this = possibleConstructorReturn(this, (IOSSlideNavigatorAnimator.__proto__ || Object.getPrototypeOf(IOSSlideNavigatorAnimator)).call(this, _extends({ timing: timing, delay: delay, duration: duration }, rest)));
+
+    _this.backgroundMask = util$1.createElement('<div style="position: absolute; width: 100%; height: 100%;' + 'background-color: black; z-index: 2"></div>');
+    return _this;
+  }
+
+  createClass(IOSSlideNavigatorAnimator, [{
+    key: '_decompose',
+    value: function _decompose(page) {
+      var toolbar = page._getToolbarElement();
+      var left = toolbar._getToolbarLeftItemsElement();
+      var right = toolbar._getToolbarRightItemsElement();
+
+      var excludeBackButton = function excludeBackButton(elements) {
+        var result = [];
+
+        for (var i = 0; i < elements.length; i++) {
+          if (elements[i].nodeName.toLowerCase() !== 'ons-back-button') {
+            result.push(elements[i]);
+          }
+        }
+
+        return result;
+      };
+
+      var other = [].concat(left.children.length === 0 ? left : excludeBackButton(left.children)).concat(right.children.length === 0 ? right : excludeBackButton(right.children));
+
+      return {
+        toolbarCenter: toolbar._getToolbarCenterItemsElement(),
+        backButtonIcon: toolbar._getToolbarBackButtonIconElement(),
+        backButtonLabel: toolbar._getToolbarBackButtonLabelElement(),
+        other: other,
+        content: page._getContentElement(),
+        background: page._getBackgroundElement(),
+        toolbar: toolbar,
+        bottomToolbar: page._getBottomToolbarElement()
+      };
+    }
+  }, {
+    key: '_shouldAnimateToolbar',
+    value: function _shouldAnimateToolbar(enterPage, leavePage) {
+      var toolbars = enterPage._canAnimateToolbar() && leavePage._canAnimateToolbar();
+
+      var enterToolbar = enterPage._getToolbarElement();
+      var leaveToolbar = leavePage._getToolbarElement();
+
+      var isStatic = enterToolbar.hasAttribute('static') || leaveToolbar.hasAttribute('static');
+      var isMaterial = util$1.hasModifier(enterToolbar, 'material') || util$1.hasModifier(leaveToolbar, 'material');
+      var isTransparent = util$1.hasModifier(enterToolbar, 'transparent') || util$1.hasModifier(leaveToolbar, 'transparent');
+
+      return toolbars && !isStatic && !isMaterial && !isTransparent;
+    }
+  }, {
+    key: '_calculateDelta',
+    value: function _calculateDelta(element, decomposition) {
+      var title = void 0,
+          label = void 0;
+
+      var pageRect = element.getBoundingClientRect();
+      if (decomposition.backButtonLabel.classList.contains('back-button__label')) {
+        var labelRect = decomposition.backButtonLabel.getBoundingClientRect();
+        title = Math.round(pageRect.width / 2 - labelRect.width / 2 - labelRect.left);
+      } else {
+        title = Math.round(pageRect.width / 2 * 0.6);
+      }
+
+      if (decomposition.backButtonIcon.classList.contains('back-button__icon')) {
+        label = decomposition.backButtonIcon.getBoundingClientRect().right - 2;
+      }
+
+      return { title: title, label: label };
+    }
+
+    /**
+     * @param {Object} enterPage
+     * @param {Object} leavePage
+     * @param {Function} callback
+     */
+
+  }, {
+    key: 'push',
+    value: function push(enterPage, leavePage, callback) {
+      var _this2 = this;
+
+      this.backgroundMask.remove();
+      leavePage.parentNode.insertBefore(this.backgroundMask, leavePage);
+
+      var unblock = get(IOSSlideNavigatorAnimator.prototype.__proto__ || Object.getPrototypeOf(IOSSlideNavigatorAnimator.prototype), 'block', this).call(this, enterPage);
+
+      contentReady(enterPage, function () {
+        var enterPageTarget = util$1.findToolbarPage(enterPage) || enterPage;
+        var leavePageTarget = util$1.findToolbarPage(leavePage) || leavePage;
+        var enterPageDecomposition = _this2._decompose(enterPageTarget);
+        var leavePageDecomposition = _this2._decompose(leavePageTarget);
+
+        var delta = _this2._calculateDelta(leavePage, enterPageDecomposition);
+
+        var shouldAnimateToolbar = _this2._shouldAnimateToolbar(enterPageTarget, leavePageTarget);
+
+        if (shouldAnimateToolbar) {
+
+          Animit.runAll(Animit([enterPageDecomposition.content, enterPageDecomposition.bottomToolbar, enterPageDecomposition.background], _this2.def).default({ transform: translate3d('100%') }, { transform: translate3d() }), Animit(enterPageDecomposition.toolbar, _this2.def).default({ opacity: 0 }, { opacity: 1 }), Animit(enterPageDecomposition.toolbarCenter, _this2.def).default({ transform: translate3d('125%'), opacity: 1 }, { transform: translate3d(), opacity: 1 }), Animit(enterPageDecomposition.backButtonLabel, _this2.def).default({ transform: translate3d(delta.title + 'px'), opacity: 0 }, {
+            transform: translate3d(),
+            opacity: 1,
+            transition: 'opacity ' + _this2.duration + 's linear, transform ' + _this2.duration + 's ' + _this2.timing
+          }), Animit(enterPageDecomposition.other, _this2.def).default({ opacity: 0 }, { css: { opacity: 1 }, timing: 'linear' }), Animit([leavePageDecomposition.content, leavePageDecomposition.bottomToolbar, leavePageDecomposition.background], _this2.def).default({ transform: translate3d(), opacity: 1 }, { transform: translate3d('-25%'), opacity: 0.9 }).queue(function (done) {
+            _this2.backgroundMask.remove();
+            unblock();
+            callback();
+            done();
+          }), Animit(leavePageDecomposition.toolbarCenter, _this2.def).default({ transform: translate3d(), opacity: 1 }, {
+            transform: translate3d('-' + delta.title + 'px'),
+            opacity: 0,
+            transition: 'opacity ' + _this2.duration + 's linear, transform ' + _this2.duration + 's ' + _this2.timing
+          }), Animit(leavePageDecomposition.backButtonLabel, _this2.def).default({ transform: translate3d(), opacity: 1 }, { transform: translate3d('-' + delta.label + 'px'), opacity: 0 }), Animit(leavePageDecomposition.other, _this2.def).default({ opacity: 1 }, { css: { opacity: 0 }, timing: 'linear' }));
+        } else {
+
+          Animit.runAll(Animit(enterPage, _this2.def).default({ transform: translate3d('100%') }, { transform: translate3d() }), Animit(leavePage, _this2.def).default({ transform: translate3d(), opacity: 1 }, { transform: translate3d('-25%'), opacity: .9 }).queue(function (done) {
+            _this2.backgroundMask.remove();
+            unblock();
+            callback();
+            done();
+          }));
+        }
+      });
+    }
+
+    /**
+     * @param {Object} enterPage
+     * @param {Object} leavePage
+     * @param {Function} callback
+     */
+
+  }, {
+    key: 'pop',
+    value: function pop(enterPage, leavePage, callback) {
+      var _this3 = this;
+
+      if (this.isSwiping) {
+        return this.popSwipe(enterPage, leavePage, callback);
+      }
+
+      this.backgroundMask.remove();
+      enterPage.parentNode.insertBefore(this.backgroundMask, enterPage);
+
+      var unblock = get(IOSSlideNavigatorAnimator.prototype.__proto__ || Object.getPrototypeOf(IOSSlideNavigatorAnimator.prototype), 'block', this).call(this, enterPage);
+
+      var enterPageTarget = util$1.findToolbarPage(enterPage) || enterPage;
+      var leavePageTarget = util$1.findToolbarPage(leavePage) || leavePage;
+      var enterPageDecomposition = this._decompose(enterPageTarget);
+      var leavePageDecomposition = this._decompose(leavePageTarget);
+
+      var delta = this._calculateDelta(leavePage, leavePageDecomposition);
+
+      var shouldAnimateToolbar = this._shouldAnimateToolbar(enterPageTarget, leavePageTarget);
+
+      if (shouldAnimateToolbar) {
+        Animit.runAll(Animit([enterPageDecomposition.content, enterPageDecomposition.bottomToolbar, enterPageDecomposition.background], this.def).default({ transform: translate3d('-25%'), opacity: .9 }, { transform: translate3d(), opacity: 1 }), Animit(enterPageDecomposition.toolbarCenter, this.def).default({ transform: translate3d('-' + delta.title + 'px'), opacity: 0 }, {
+          transform: translate3d(),
+          opacity: 1,
+          transition: 'opacity ' + this.duration + 's linear, transform ' + this.duration + 's ' + this.timing
+        }), Animit(enterPageDecomposition.backButtonLabel, this.def).default({ transform: translate3d('-' + delta.label + 'px') }, { transform: translate3d() }), Animit(enterPageDecomposition.other, this.def).default({ opacity: 0 }, { css: { opacity: 1 }, timing: 'linear' }), Animit([leavePageDecomposition.content, leavePageDecomposition.bottomToolbar, leavePageDecomposition.background], this.def).default({ transform: translate3d() }, { transform: translate3d('100%') }).wait(0).queue(function (done) {
+          _this3.backgroundMask.remove();
+          unblock();
+          callback();
+          done();
+        }), Animit(leavePageDecomposition.toolbar, this.def).default({ opacity: 1 }, { opacity: 0 }), Animit(leavePageDecomposition.toolbarCenter, this.def).default({ transform: translate3d() }, { transform: translate3d('125%') }), Animit(leavePageDecomposition.backButtonLabel, this.def).default({ transform: translate3d(), opacity: 1 }, {
+          transform: translate3d(delta.title + 'px'),
+          opacity: 0,
+          transition: 'opacity ' + this.duration + 's linear, transform ' + this.duration + 's ' + this.timing
+        }));
+      } else {
+        Animit.runAll(Animit(enterPage, this.def).default({ transform: translate3d('-25%'), opacity: .9 }, { transform: translate3d(), opacity: 1 }), Animit(leavePage, this.def).default({ transform: translate3d() }, { transform: translate3d('100%') }).queue(function (done) {
+          _this3.backgroundMask.remove();
+          unblock();
+          callback();
+          done();
+        }));
+      }
+    }
+  }]);
+  return IOSSlideNavigatorAnimator;
+}(IOSSwipeNavigatorAnimator);
+
+/*
+Copyright 2013-2015 ASIAL CORPORATION
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+   http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+*/
+
+/**
+ * Lift screen transition.
+ */
+
+var IOSLiftNavigatorAnimator = function (_NavigatorAnimator) {
+  inherits(IOSLiftNavigatorAnimator, _NavigatorAnimator);
+
+  function IOSLiftNavigatorAnimator() {
+    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
+        _ref$timing = _ref.timing,
+        timing = _ref$timing === undefined ? 'cubic-bezier(.1, .7, .1, 1)' : _ref$timing,
+        _ref$delay = _ref.delay,
+        delay = _ref$delay === undefined ? 0 : _ref$delay,
+        _ref$duration = _ref.duration,
+        duration = _ref$duration === undefined ? 0.4 : _ref$duration;
+
+    classCallCheck(this, IOSLiftNavigatorAnimator);
+
+    var _this = possibleConstructorReturn(this, (IOSLiftNavigatorAnimator.__proto__ || Object.getPrototypeOf(IOSLiftNavigatorAnimator)).call(this, { timing: timing, delay: delay, duration: duration }));
+
+    _this.backgroundMask = util$1.createElement('<div style="position: absolute; width: 100%; height: 100%;' + 'background: linear-gradient(black, white);"></div>');
+    return _this;
+  }
+
+  /**
+   * @param {Object} enterPage
+   * @param {Object} leavePage
+   * @param {Function} callback
+   */
+
+
+  createClass(IOSLiftNavigatorAnimator, [{
+    key: 'push',
+    value: function push(enterPage, leavePage, callback) {
+      var _this2 = this;
+
+      this.backgroundMask.remove();
+      leavePage.parentNode.insertBefore(this.backgroundMask, leavePage);
+
+      var unblock = get(IOSLiftNavigatorAnimator.prototype.__proto__ || Object.getPrototypeOf(IOSLiftNavigatorAnimator.prototype), 'block', this).call(this, enterPage);
+
+      Animit.runAll(Animit(enterPage, this.def).default({ transform: 'translate3D(0, 100%, 0)' }, { transform: 'translate3D(0, 0, 0)' }), Animit(leavePage, this.def).default({ transform: 'translate3D(0, 0, 0)', opacity: 1 }, { transform: 'translate3D(0, -10%, 0)', opacity: .9 }).queue(function (done) {
+        _this2.backgroundMask.remove();
+        unblock();
+        callback();
+        done();
+      }));
+    }
+
+    /**
+     * @param {Object} enterPage
+     * @param {Object} leavePage
+     * @param {Function} callback
+     */
+
+  }, {
+    key: 'pop',
+    value: function pop(enterPage, leavePage, callback) {
+      var _this3 = this;
+
+      this.backgroundMask.remove();
+      enterPage.parentNode.insertBefore(this.backgroundMask, enterPage);
+
+      var unblock = get(IOSLiftNavigatorAnimator.prototype.__proto__ || Object.getPrototypeOf(IOSLiftNavigatorAnimator.prototype), 'block', this).call(this, enterPage);
+
+      Animit.runAll(Animit(enterPage, this.def).default({ transform: 'translate3D(0, -43px, 0)', opacity: .9 }, { transform: 'translate3D(0, 0, 0)', opacity: 1 }).queue(function (done) {
+        _this3.backgroundMask.remove();
+        unblock();
+        callback();
+        done();
+      }), Animit(leavePage, this.def).default({ transform: 'translate3D(0, 0, 0)' }, { transform: 'translate3D(0, 100%, 0)' }));
+    }
+  }]);
+  return IOSLiftNavigatorAnimator;
+}(NavigatorAnimator);
+
+/*
+Copyright 2013-2015 ASIAL CORPORATION
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+   http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+*/
+
+var transform = 'translate3d(0, 0, 0)';
+
+/**
+ * Fade-in screen transition.
+ */
+
+var IOSFadeNavigatorAnimator = function (_NavigatorAnimator) {
+  inherits(IOSFadeNavigatorAnimator, _NavigatorAnimator);
+
+  function IOSFadeNavigatorAnimator() {
+    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
+        _ref$timing = _ref.timing,
+        timing = _ref$timing === undefined ? 'linear' : _ref$timing,
+        _ref$delay = _ref.delay,
+        delay = _ref$delay === undefined ? 0 : _ref$delay,
+        _ref$duration = _ref.duration,
+        duration = _ref$duration === undefined ? 0.4 : _ref$duration;
+
+    classCallCheck(this, IOSFadeNavigatorAnimator);
+    return possibleConstructorReturn(this, (IOSFadeNavigatorAnimator.__proto__ || Object.getPrototypeOf(IOSFadeNavigatorAnimator)).call(this, { timing: timing, delay: delay, duration: duration }));
+  }
+
+  /**
+   * @param {Object} enterPage
+   * @param {Object} leavePage
+   * @param {Function} callback
+   */
+
+
+  createClass(IOSFadeNavigatorAnimator, [{
+    key: 'push',
+    value: function push(enterPage, leavePage, callback) {
+      var unblock = get(IOSFadeNavigatorAnimator.prototype.__proto__ || Object.getPrototypeOf(IOSFadeNavigatorAnimator.prototype), 'block', this).call(this, enterPage);
+
+      Animit.runAll(Animit(enterPage, this.def).default({ transform: transform, opacity: 0 }, { transform: transform, opacity: 1 }).queue(function (done) {
+        unblock();
+        callback();
+        done();
+      }));
+    }
+
+    /**
+     * @param {Object} enterPage
+     * @param {Object} leavePage
+     * @param {Function} done
+     */
+
+  }, {
+    key: 'pop',
+    value: function pop(enterPage, leavePage, callback) {
+      var unblock = get(IOSFadeNavigatorAnimator.prototype.__proto__ || Object.getPrototypeOf(IOSFadeNavigatorAnimator.prototype), 'block', this).call(this, enterPage);
+
+      Animit.runAll(Animit(leavePage, this.def).default({ transform: transform, opacity: 1 }, { transform: transform, opacity: 0 }).queue(function (done) {
+        unblock();
+        callback();
+        done();
+      }));
+    }
+  }]);
+  return IOSFadeNavigatorAnimator;
+}(NavigatorAnimator);
+
+/*
+Copyright 2013-2015 ASIAL CORPORATION
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+   http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+*/
+
+/**
+ * Slide animator for navigator transition.
+ */
+
+var MDSlideNavigatorAnimator = function (_NavigatorAnimator) {
+  inherits(MDSlideNavigatorAnimator, _NavigatorAnimator);
+
+  function MDSlideNavigatorAnimator() {
+    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
+        _ref$timing = _ref.timing,
+        timing = _ref$timing === undefined ? 'cubic-bezier(.1, .7, .4, 1)' : _ref$timing,
+        _ref$delay = _ref.delay,
+        delay = _ref$delay === undefined ? 0 : _ref$delay,
+        _ref$duration = _ref.duration,
+        duration = _ref$duration === undefined ? 0.3 : _ref$duration;
+
+    classCallCheck(this, MDSlideNavigatorAnimator);
+
+    var _this = possibleConstructorReturn(this, (MDSlideNavigatorAnimator.__proto__ || Object.getPrototypeOf(MDSlideNavigatorAnimator)).call(this, { timing: timing, delay: delay, duration: duration }));
+
+    _this.blackMaskOpacity = 0.4;
+    _this.backgroundMask = util$1.createElement('<div style="position: absolute; width: 100%; height: 100%; z-index: 2;' + 'background-color: black; opacity: 0;"></div>');
+    return _this;
+  }
+
+  /**
+   * @param {Object} enterPage
+   * @param {Object} leavePage
+   * @param {Function} callback
+   */
+
+
+  createClass(MDSlideNavigatorAnimator, [{
+    key: 'push',
+    value: function push(enterPage, leavePage, callback) {
+      var _this2 = this;
+
+      this.backgroundMask.remove();
+      leavePage.parentElement.insertBefore(this.backgroundMask, leavePage.nextSibling);
+
+      var unblock = get(MDSlideNavigatorAnimator.prototype.__proto__ || Object.getPrototypeOf(MDSlideNavigatorAnimator.prototype), 'block', this).call(this, enterPage);
+
+      Animit.runAll(Animit(this.backgroundMask, this.def).default({ transform: 'translate3d(0, 0, 0)', opacity: 0 }, { opacity: this.blackMaskOpacity }).queue(function (done) {
+        _this2.backgroundMask.remove();
+        done();
+      }), Animit(enterPage, this.def).default({ transform: 'translate3d(100%, 0, 0)' }, { transform: 'translate3d(0, 0, 0)' }), Animit(leavePage, this.def).default({ transform: 'translate3d(0, 0, 0)' }, { transform: 'translate3d(-45%, 0, 0)' }).queue(function (done) {
+        unblock();
+        callback();
+        done();
+      }));
+    }
+
+    /**
+     * @param {Object} enterPage
+     * @param {Object} leavePage
+     * @param {Function} callback
+     */
+
+  }, {
+    key: 'pop',
+    value: function pop(enterPage, leavePage, callback) {
+      var _this3 = this;
+
+      this.backgroundMask.remove();
+      enterPage.parentNode.insertBefore(this.backgroundMask, enterPage.nextSibling);
+
+      var unblock = get(MDSlideNavigatorAnimator.prototype.__proto__ || Object.getPrototypeOf(MDSlideNavigatorAnimator.prototype), 'block', this).call(this, enterPage);
+
+      Animit.runAll(Animit(this.backgroundMask, this.def).default({ transform: 'translate3d(0, 0, 0)', opacity: this.blackMaskOpacity }, { opacity: 0 }).queue(function (done) {
+        _this3.backgroundMask.remove();
+        done();
+      }), Animit(enterPage, this.def).default({ transform: 'translate3d(-45%, 0, 0)', opacity: .9 }, { transform: 'translate3d(0, 0, 0)', opacity: 1 }), Animit(leavePage, this.def).default({ transform: 'translate3d(0, 0, 0)' }, { transform: 'translate3d(100%, 0, 0)' }).queue(function (done) {
+        unblock();
+        callback();
+        done();
+      }));
+    }
+  }]);
+  return MDSlideNavigatorAnimator;
+}(NavigatorAnimator);
+
+/*
+Copyright 2013-2015 ASIAL CORPORATION
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+   http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+*/
+
+/**
+ * Lift screen transition.
+ */
+
+var MDLiftNavigatorAnimator = function (_NavigatorAnimator) {
+  inherits(MDLiftNavigatorAnimator, _NavigatorAnimator);
+
+  function MDLiftNavigatorAnimator() {
+    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
+        _ref$timing = _ref.timing,
+        timing = _ref$timing === undefined ? 'cubic-bezier(.1, .7, .1, 1)' : _ref$timing,
+        _ref$delay = _ref.delay,
+        delay = _ref$delay === undefined ? 0.05 : _ref$delay,
+        _ref$duration = _ref.duration,
+        duration = _ref$duration === undefined ? 0.4 : _ref$duration;
+
+    classCallCheck(this, MDLiftNavigatorAnimator);
+
+    var _this = possibleConstructorReturn(this, (MDLiftNavigatorAnimator.__proto__ || Object.getPrototypeOf(MDLiftNavigatorAnimator)).call(this, { timing: timing, delay: delay, duration: duration }));
+
+    _this.backgroundMask = util$1.createElement('<div style="position: absolute; width: 100%; height: 100%;' + 'background-color: black;"></div>');
+    return _this;
+  }
+
+  /**
+   * @param {Object} enterPage
+   * @param {Object} leavePage
+   * @param {Function} callback
+   */
+
+
+  createClass(MDLiftNavigatorAnimator, [{
+    key: 'push',
+    value: function push(enterPage, leavePage, callback) {
+      var _this2 = this;
+
+      this.backgroundMask.remove();
+      leavePage.parentNode.insertBefore(this.backgroundMask, leavePage);
+
+      var unblock = get(MDLiftNavigatorAnimator.prototype.__proto__ || Object.getPrototypeOf(MDLiftNavigatorAnimator.prototype), 'block', this).call(this, enterPage);
+
+      var maskClear = Animit(this.backgroundMask).wait(this.delay + this.duration).queue(function (done) {
+        _this2.backgroundMask.remove();
+        done();
+      });
+
+      Animit.runAll(maskClear, Animit(enterPage, this.def).default({ transform: 'translate3d(0, 100%, 0)' }, { transform: 'translate3d(0, 0, 0)' }), Animit(leavePage, this.def).default({ opacity: 1 }, { opacity: .4 }).queue(function (done) {
+        unblock();
+        callback();
+        done();
+      }));
+    }
+
+    /**
+     * @param {Object} enterPage
+     * @param {Object} leavePage
+     * @param {Function} callback
+     */
+
+  }, {
+    key: 'pop',
+    value: function pop(enterPage, leavePage, callback) {
+      var _this3 = this;
+
+      this.backgroundMask.remove();
+      enterPage.parentNode.insertBefore(this.backgroundMask, enterPage);
+
+      var unblock = get(MDLiftNavigatorAnimator.prototype.__proto__ || Object.getPrototypeOf(MDLiftNavigatorAnimator.prototype), 'block', this).call(this, enterPage);
+
+      Animit.runAll(Animit(this.backgroundMask).wait(this.delay + this.duration).queue(function (done) {
+        _this3.backgroundMask.remove();
+        done();
+      }), Animit(enterPage, this.def).default({ opacity: .4 }, { opacity: 1 }).queue(function (done) {
+        unblock();
+        callback();
+        done();
+      }), Animit(leavePage, this.def).default({ transform: 'translate3d(0, 0, 0)' }, { transform: 'translate3d(0, 100%, 0)' }));
+    }
+  }]);
+  return MDLiftNavigatorAnimator;
+}(NavigatorAnimator);
+
+/*
+Copyright 2013-2015 ASIAL CORPORATION
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+   http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+*/
+
+/**
+ * Fade-in + Lift screen transition.
+ */
+
+var MDFadeNavigatorAnimator = function (_NavigatorAnimator) {
+  inherits(MDFadeNavigatorAnimator, _NavigatorAnimator);
+
+  function MDFadeNavigatorAnimator() {
+    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
+        _ref$timing = _ref.timing,
+        timing = _ref$timing === undefined ? 'cubic-bezier(0.4, 0, 0.2, 1)' : _ref$timing,
+        _ref$timingPop = _ref.timingPop,
+        timingPop = _ref$timingPop === undefined ? 'cubic-bezier(0.4, 0, 1, 1)' : _ref$timingPop,
+        _ref$delay = _ref.delay,
+        delay = _ref$delay === undefined ? 0 : _ref$delay,
+        _ref$duration = _ref.duration,
+        duration = _ref$duration === undefined ? 0.2 : _ref$duration;
+
+    classCallCheck(this, MDFadeNavigatorAnimator);
+
+    var _this = possibleConstructorReturn(this, (MDFadeNavigatorAnimator.__proto__ || Object.getPrototypeOf(MDFadeNavigatorAnimator)).call(this, { timing: timing, delay: delay, duration: duration }));
+
+    _this.timingPop = timingPop;
+    return _this;
+  }
+
+  /**
+   * @param {Object} enterPage
+   * @param {Object} leavePage
+   * @param {Function} callback
+   */
+
+
+  createClass(MDFadeNavigatorAnimator, [{
+    key: 'push',
+    value: function push(enterPage, leavePage, callback) {
+      var unblock = get(MDFadeNavigatorAnimator.prototype.__proto__ || Object.getPrototypeOf(MDFadeNavigatorAnimator.prototype), 'block', this).call(this, enterPage);
+
+      Animit.runAll(Animit(enterPage, this.def).default({ transform: 'translate3D(0, 42px, 0)', opacity: 0 }, { transform: 'translate3D(0, 0, 0)', opacity: 1 }).queue(function (done) {
+        unblock();
+        callback();
+        done();
+      }));
+    }
+
+    /**
+     * @param {Object} enterPage
+     * @param {Object} leavePage
+     * @param {Function} done
+     */
+
+  }, {
+    key: 'pop',
+    value: function pop(enterPage, leavePage, callback) {
+      var unblock = get(MDFadeNavigatorAnimator.prototype.__proto__ || Object.getPrototypeOf(MDFadeNavigatorAnimator.prototype), 'block', this).call(this, enterPage);
+
+      Animit.runAll(Animit(leavePage, this.def).default({ transform: 'translate3D(0, 0, 0)', opacity: 1 }, { css: { transform: 'translate3D(0, 38px, 0)', opacity: 0 }, timing: this.timingPop }).queue(function (done) {
+        unblock();
+        callback();
+        done();
+      }));
+    }
+  }]);
+  return MDFadeNavigatorAnimator;
+}(NavigatorAnimator);
+
+/*
+Copyright 2013-2015 ASIAL CORPORATION
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+   http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+*/
+
+var NoneNavigatorAnimator = function (_NavigatorAnimator) {
+  inherits(NoneNavigatorAnimator, _NavigatorAnimator);
+
+  function NoneNavigatorAnimator(options) {
+    classCallCheck(this, NoneNavigatorAnimator);
+    return possibleConstructorReturn(this, (NoneNavigatorAnimator.__proto__ || Object.getPrototypeOf(NoneNavigatorAnimator)).call(this, options));
+  }
+
+  createClass(NoneNavigatorAnimator, [{
+    key: 'push',
+    value: function push(enterPage, leavePage, callback) {
+      callback();
+    }
+  }, {
+    key: 'pop',
+    value: function pop(enterPage, leavePage, callback) {
+      callback();
+    }
+  }]);
+  return NoneNavigatorAnimator;
+}(NavigatorAnimator);
+
+/*
+Copyright 2013-2015 ASIAL CORPORATION
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+   http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+*/
+
+var _animatorDict$5 = {
+  'default': function _default() {
+    return platform.isAndroid() ? MDFadeNavigatorAnimator : IOSSlideNavigatorAnimator;
+  },
+  'slide': function slide() {
+    return platform.isAndroid() ? MDSlideNavigatorAnimator : IOSSlideNavigatorAnimator;
+  },
+  'lift': function lift() {
+    return platform.isAndroid() ? MDLiftNavigatorAnimator : IOSLiftNavigatorAnimator;
+  },
+  'fade': function fade() {
+    return platform.isAndroid() ? MDFadeNavigatorAnimator : IOSFadeNavigatorAnimator;
+  },
+  'slide-ios': IOSSlideNavigatorAnimator,
+  'slide-md': MDSlideNavigatorAnimator,
+  'lift-ios': IOSLiftNavigatorAnimator,
+  'lift-md': MDLiftNavigatorAnimator,
+  'fade-ios': IOSFadeNavigatorAnimator,
+  'fade-md': MDFadeNavigatorAnimator,
+  'none': NoneNavigatorAnimator
+};
+
+var rewritables = {
+  /**
+   * @param {Element} navigatorSideElement
+   * @param {Function} callback
+   */
+  ready: function ready(navigatorElement, callback) {
+    callback();
+  }
+};
+
+var verifyPageElement = function verifyPageElement(el) {
+  return el.nodeName !== 'ONS-PAGE' && util$1.throw('Only page elements can be children of navigator');
+};
+
+/**
+ * @element ons-navigator
+ * @category navigation
+ * @description
+ *   [en]
+ *     A component that provides page stack management and navigation. Stack navigation is the most common navigation pattern for mobile apps.
+ *
+ *     When a page is pushed on top of the stack it is displayed with a transition animation. When the user returns to the previous page the top page will be popped from the top of the stack and hidden with an opposite transition animation.
+ *   [/en]
+ *   [ja][/ja]
+ * @codepen yrhtv
+ * @tutorial vanilla/Reference/navigator
+ * @guide lifecycle.html#events
+ *   [en]Overview of page events[/en]
+ *   [ja]Overview of page events[/ja]
+ * @seealso ons-toolbar
+ *   [en]The `<ons-toolbar>` component is used to display a toolbar on the top of a page.[/en]
+ *   [ja][/ja]
+ * @seealso ons-back-button
+ *   [en]The `<ons-back-button>` component lets the user return to the previous page.[/en]
+ *   [ja][/ja]
+ * @example
+ * <ons-navigator id="navigator">
+ *   <ons-page>
+ *     <ons-toolbar>
+ *       <div class="center">
+ *         Title
+ *       </div>
+ *     </ons-toolbar>
+ *     <p>
+ *       <ons-button
+ *         onclick="document.getElementById('navigator').pushPage('page.html')">
+ *         Push page
+ *       </ons-button>
+ *     </p>
+ *   </ons-page>
+ * </ons-navigator>
+ *
+ * <template id="page.html">
+ *   <ons-page>
+ *     <ons-toolbar>
+ *       <div class="left">
+ *         <ons-back-button>Back</ons-back-button>
+ *       </div>
+ *       <div class="center">
+ *         Another page
+ *       </div>
+ *     </ons-toolbar>
+ *   </ons-page>
+ * </template>
+ */
+
+var NavigatorElement = function (_BaseElement) {
+  inherits(NavigatorElement, _BaseElement);
+  createClass(NavigatorElement, [{
+    key: 'animatorFactory',
+
+
+    /**
+     * @attribute page
+     * @initonly
+     * @type {String}
+     * @description
+     *   [en]First page to show when navigator is initialized.[/en]
+     *   [ja]ナビゲーターが初期化された時に表示するページを指定します。[/ja]
+     */
+
+    /**
+     * @attribute swipeable
+     * @type {Boolean}
+     * @description
+     *   [en]Enable iOS "swipe to pop" feature.[/en]
+     *   [ja][/ja]
+     */
+
+    /**
+     * @attribute swipe-target-width
+     * @type {String}
+     * @default 20px
+     * @description
+     *   [en]The width of swipeable area calculated from the edge (in pixels). Use this to enable swipe only when the finger touch on the screen edge.[/en]
+     *   [ja]スワイプの判定領域をピクセル単位で指定します。画面の端から指定した距離に達するとページが表示されます。[/ja]
+     */
+
+    /**
+     * @attribute swipe-threshold
+     * @type {Number}
+     * @default 0.2
+     * @description
+     *  [en]Specify how much the page needs to be swiped before popping. A value between `0` and `1`.[/en]
+     *  [ja][/ja]
+     */
+
+    /**
+     * @attribute animation
+     * @type {String}
+     * @default default
+     * @description
+     *   [en]
+     *     Animation name. Available animations are `"slide"`, `"lift"`, `"fade"` and `"none"`.
+     *
+     *     These are platform based animations. For fixed animations, add `"-ios"` or `"-md"` suffix to the animation name. E.g. `"lift-ios"`, `"lift-md"`. Defaults values are `"slide-ios"` and `"fade-md"` depending on the platform.
+     *   [/en]
+     *   [ja][/ja]
+     */
+
+    /**
+     * @attribute animation-options
+     * @type {Expression}
+     * @description
+     *  [en]Specify the animation's duration, timing and delay with an object literal. E.g. `{duration: 0.2, delay: 1, timing: 'ease-in'}`[/en]
+     *  [ja]アニメーション時のduration, timing, delayをオブジェクトリテラルで指定します。e.g. `{duration: 0.2, delay: 1, timing: 'ease-in'}`[/ja]
+     */
+
+    /**
+     * @event prepush
+     * @description
+     *   [en]Fired just before a page is pushed.[/en]
+     *   [ja]pageがpushされる直前に発火されます。[/ja]
+     * @param {Object} event [en]Event object.[/en]
+     * @param {Object} event.navigator
+     *   [en]Component object.[/en]
+     *   [ja]コンポーネントのオブジェクト。[/ja]
+     * @param {Object} event.currentPage
+     *   [en]Current page object.[/en]
+     *   [ja]現在のpageオブジェクト。[/ja]
+     * @param {Function} event.cancel
+     *   [en]Call this function to cancel the push.[/en]
+     *   [ja]この関数を呼び出すと、push処理がキャンセルされます。[/ja]
+     */
+
+    /**
+     * @event prepop
+     * @description
+     *   [en]Fired just before a page is popped.[/en]
+     *   [ja]pageがpopされる直前に発火されます。[/ja]
+     * @param {Object} event [en]Event object.[/en]
+     * @param {Object} event.navigator
+     *   [en]Component object.[/en]
+     *   [ja]コンポーネントのオブジェクト。[/ja]
+     * @param {Object} event.currentPage
+     *   [en]Current page object.[/en]
+     *   [ja]現在のpageオブジェクト。[/ja]
+     * @param {Function} event.cancel
+     *   [en]Call this function to cancel the pop.[/en]
+     *   [ja]この関数を呼び出すと、pageのpopがキャンセルされます。[/ja]
+     */
+
+    /**
+     * @event postpush
+     * @description
+     *   [en]Fired just after a page is pushed.[/en]
+     *   [ja]pageがpushされてアニメーションが終了してから発火されます。[/ja]
+     * @param {Object} event [en]Event object.[/en]
+     * @param {Object} event.navigator
+     *   [en]Component object.[/en]
+     *   [ja]コンポーネントのオブジェクト。[/ja]
+     * @param {Object} event.enterPage
+     *   [en]Object of the next page.[/en]
+     *   [ja]pushされたpageオブジェクト。[/ja]
+     * @param {Object} event.leavePage
+     *   [en]Object of the previous page.[/en]
+     *   [ja]以前のpageオブジェクト。[/ja]
+     */
+
+    /**
+     * @event postpop
+     * @description
+     *   [en]Fired just after a page is popped.[/en]
+     *   [ja]pageがpopされてアニメーションが終わった後に発火されます。[/ja]
+     * @param {Object} event [en]Event object.[/en]
+     * @param {Object} event.navigator
+     *   [en]Component object.[/en]
+     *   [ja]コンポーネントのオブジェクト。[/ja]
+     * @param {Object} event.enterPage
+     *   [en]Object of the next page.[/en]
+     *   [ja]popされて表示されるページのオブジェクト。[/ja]
+     * @param {Object} event.leavePage
+     *   [en]Object of the previous page.[/en]
+     *   [ja]popされて消えるページのオブジェクト。[/ja]
+     */
+
+    get: function get$$1() {
+      return this._animatorFactory;
+    }
+  }]);
+
+  function NavigatorElement() {
+    classCallCheck(this, NavigatorElement);
+
+    var _this = possibleConstructorReturn(this, (NavigatorElement.__proto__ || Object.getPrototypeOf(NavigatorElement)).call(this));
+
+    _this._isRunning = false;
+    _this._initialized = false;
+    _this._pageLoader = defaultPageLoader;
+    _this._pageMap = new WeakMap();
+
+    _this._updateAnimatorFactory();
+    return _this;
+  }
+
+  /**
+   * @property pageLoader
+   * @type {PageLoader}
+   * @description
+   *   [en]PageLoader instance. It can be overriden to change the way pages are loaded by this element. Useful for lib developers.[/en]
+   *   [ja]PageLoaderインスタンスを格納しています。[/ja]
+   */
+
+
+  createClass(NavigatorElement, [{
+    key: '_getPageTarget',
+    value: function _getPageTarget() {
+      return this._page || this.getAttribute('page');
+    }
+
+    /**
+     * @property page
+     * @type {*}
+     * @description
+     *   [en]Specify the page to be loaded during initialization. This value takes precedence over the `page` attribute. Useful for lib developers.[/en]
+     *   [ja]初期化時に読み込むページを指定します。`page`属性で指定した値よりも`page`プロパティに指定した値を優先します。[/ja]
+     */
+
+  }, {
+    key: 'connectedCallback',
+    value: function connectedCallback() {
+      var _this2 = this;
+
+      this.onDeviceBackButton = this._onDeviceBackButton.bind(this);
+
+      if (!platform.isAndroid() || this.getAttribute('swipeable') === 'force') {
+        var swipeAnimator = void 0;
+
+        this._swipe = new SwipeReveal({
+          element: this,
+          getThreshold: function getThreshold() {
+            return Math.max(0.2, parseFloat(_this2.getAttribute('swipe-threshold')) || 0);
+          },
+
+          swipeMax: function swipeMax() {
+            _this2._onSwipe && _this2._onSwipe(1, { duration: swipeAnimator.durationSwipe, timing: swipeAnimator.timingSwipe });
+            _this2[_this2.swipeMax ? 'swipeMax' : 'popPage']({ animator: swipeAnimator });
+            swipeAnimator = null;
+          },
+          swipeMid: function swipeMid(distance, width) {
+            _this2._onSwipe && _this2._onSwipe(distance / width);
+            swipeAnimator.translate(distance, width, _this2.topPage.previousElementSibling, _this2.topPage);
+          },
+          swipeMin: function swipeMin() {
+            _this2._onSwipe && _this2._onSwipe(0, { duration: swipeAnimator.durationRestore, timing: swipeAnimator.timingSwipe });
+            swipeAnimator.restore(_this2.topPage.previousElementSibling, _this2.topPage);
+            swipeAnimator = null;
+          },
+
+          ignoreSwipe: function ignoreSwipe(event, distance) {
+            // Basic conditions
+            if (!_this2._isRunning && _this2.children.length > 1) {
+
+              // Area or directional issues
+              var area = parseInt(_this2.getAttribute('swipe-target-width') || 25, 10);
+              if (event.gesture.direction === 'right' && area > distance) {
+
+                // Swipes on ons-back-button and its children
+                var isBB = function isBB(el) {
+                  return (/ons-back-button/i.test(el.tagName)
+                  );
+                };
+                if (!isBB(event.target) && !util$1.findParent(event.target, isBB, function (p) {
+                  return (/ons-page/i.test(p.tagName)
+                  );
+                })) {
+
+                  // Animator is swipeable
+                  var animation = (_this2.topPage.pushedOptions || {}).animation || _this2.animatorFactory._animation;
+                  var Animator = _animatorDict$5[animation] instanceof Function ? _animatorDict$5[animation].call() : _animatorDict$5[animation];
+
+                  if (typeof Animator !== 'undefined' && Animator.swipeable) {
+                    swipeAnimator = new Animator(); // Prepare for the swipe
+                    return false;
+                  }
+                }
+              }
+            }
+
+            return true; // Ignore swipe
+          }
+        });
+
+        this.attributeChangedCallback('swipeable');
+      }
+
+      if (this._initialized) {
+        return;
+      }
+
+      this._initialized = true;
+
+      var deferred = util$1.defer();
+      this.loaded = deferred.promise;
+
+      rewritables.ready(this, function () {
+        var show = !util$1.hasAnyComponentAsParent(_this2);
+        var options = { animation: 'none', show: show };
+
+        if (_this2.pages.length === 0 && _this2._getPageTarget()) {
+          _this2.pushPage(_this2._getPageTarget(), options).then(function () {
+            return deferred.resolve();
+          });
+        } else if (_this2.pages.length > 0) {
+          for (var i = 0; i < _this2.pages.length; i++) {
+            verifyPageElement(_this2.pages[i]);
+          }
+
+          if (_this2.topPage) {
+            contentReady(_this2.topPage, function () {
+              return setTimeout(function () {
+                deferred.resolve();
+                show && _this2.topPage._show();
+                _this2._updateLastPageBackButton();
+              }, 0);
+            });
+          }
+        } else {
+          contentReady(_this2, function () {
+            if (_this2.pages.length === 0 && _this2._getPageTarget()) {
+              _this2.pushPage(_this2._getPageTarget(), options).then(function () {
+                return deferred.resolve();
+              });
+            } else {
+              deferred.resolve();
+            }
+          });
+        }
+      });
+    }
+  }, {
+    key: '_updateAnimatorFactory',
+    value: function _updateAnimatorFactory() {
+      this._animatorFactory = new AnimatorFactory({
+        animators: _animatorDict$5,
+        baseClass: NavigatorAnimator,
+        baseClassName: 'NavigatorAnimator',
+        defaultAnimation: this.getAttribute('animation')
+      });
+    }
+  }, {
+    key: 'disconnectedCallback',
+    value: function disconnectedCallback() {
+      this._backButtonHandler.destroy();
+      this._backButtonHandler = null;
+
+      this._swipe && this._swipe.dispose();
+      this._swipe = null;
+    }
+  }, {
+    key: 'attributeChangedCallback',
+    value: function attributeChangedCallback(name, last, current) {
+      switch (name) {
+        case 'animation':
+          this._updateAnimatorFactory();
+          break;
+        case 'swipeable':
+          this._swipe && this._swipe.update();
+          break;
+      }
+    }
+
+    /**
+     * @method popPage
+     * @signature popPage([options])
+     * @param {Object} [options]
+     *   [en]Parameter object.[/en]
+     *   [ja]オプションを指定するオブジェクト。[/ja]
+     * @param {String} [options.animation]
+     *   [en]
+     *     Animation name. Available animations are `"slide"`, `"lift"`, `"fade"` and `"none"`.
+     *
+     *     These are platform based animations. For fixed animations, add `"-ios"` or `"-md"` suffix to the animation name. E.g. `"lift-ios"`, `"lift-md"`. Defaults values are `"slide-ios"` and `"fade-md"`.
+     *   [/en]
+     *   [ja][/ja]
+     * @param {String} [options.animationOptions]
+     *   [en]Specify the animation's duration, delay and timing. E.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}`.[/en]
+     *   [ja]アニメーション時のduration, delay, timingを指定します。e.g. {duration: 0.2, delay: 0.4, timing: 'ease-in'}[/ja]
+     * @param {Function} [options.callback]
+     *   [en]Function that is called when the transition has ended.[/en]
+     *   [ja]このメソッドによる画面遷移が終了した際に呼び出される関数オブジェクトを指定します。[/ja]
+     * @param {Object} [options.data]
+     *   [en]Custom data that will be stored in the new page element.[/en]
+     *   [ja][/ja]
+     * @param {Number} [options.times]
+     *   [en]Number of pages to be popped. Only one animation will be shown.[/en]
+     *   [ja][/ja]
+     * @return {Promise}
+     *   [en]Promise which resolves to the revealed page.[/en]
+     *   [ja]明らかにしたページを解決するPromiseを返します。[/ja]
+     * @description
+     *   [en]Pops the current page from the page stack. The previous page will be displayed.[/en]
+     *   [ja]現在表示中のページをページスタックから取り除きます。一つ前のページに戻ります。[/ja]
+     */
+
+  }, {
+    key: 'popPage',
+    value: function popPage() {
+      var _this3 = this;
+
+      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
+
+      var _preparePageAndOption = this._preparePageAndOptions(null, options);
+
+      options = _preparePageAndOption.options;
+
+
+      if (util$1.isInteger(options.times) && options.times > 1) {
+        this._removePages(options.times);
+      }
+
+      var popUpdate = function popUpdate() {
+        return new Promise(function (resolve) {
+          _this3._pageLoader.unload(_this3.pages[_this3.pages.length - 1]);
+          resolve();
+        });
+      };
+
+      return this._popPage(options, popUpdate);
+    }
+  }, {
+    key: '_popPage',
+    value: function _popPage(options) {
+      var _this4 = this;
+
+      var update = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {
+        return Promise.resolve();
+      };
+
+      if (this._isRunning) {
+        return Promise.reject('popPage is already running.');
+      }
+
+      if (this.pages.length <= 1) {
+        return Promise.reject('ons-navigator\'s page stack is empty.');
+      }
+
+      if (this._emitPrePopEvent()) {
+        return Promise.reject('Canceled in prepop event.');
+      }
+
+      var length = this.pages.length;
+
+      this._isRunning = true;
+
+      this.pages[length - 2].updateBackButton(length - 2 > 0);
+
+      return new Promise(function (resolve) {
+        var leavePage = _this4.pages[length - 1];
+        var enterPage = _this4.pages[length - 2];
+
+        options = util$1.extend({}, _this4.options || {}, leavePage.pushedOptions || {}, options);
+
+        if (options.data) {
+          enterPage.data = util$1.extend({}, enterPage.data || {}, options.data || {});
+        }
+
+        var done = function done() {
+          update().then(function () {
+            _this4._isRunning = false;
+
+            enterPage._show();
+            util$1.triggerElementEvent(_this4, 'postpop', { leavePage: leavePage, enterPage: enterPage, navigator: _this4 });
+
+            options.callback && options.callback(enterPage);
+
+            resolve(enterPage);
+          });
+        };
+
+        leavePage._hide();
+        enterPage.style.display = '';
+
+        var animator = options.animator || _this4._animatorFactory.newAnimator(options);
+        animator.pop(_this4.pages[length - 2], _this4.pages[length - 1], done);
+      }).catch(function () {
+        return _this4._isRunning = false;
+      });
+    }
+
+    /**
+     * @method pushPage
+     * @signature pushPage(page, [options])
+     * @param {String} page
+     *   [en]Page URL. Can be either a HTML document or a template defined with the `<template>` tag.[/en]
+     *   [ja]pageのURLか、もしくは`<template>`で宣言したテンプレートのid属性の値を指定できます。[/ja]
+     * @param {Object} [options]
+     *   [en]Parameter object.[/en]
+     *   [ja]オプションを指定するオブジェクト。[/ja]
+     * @param {String} [options.page]
+     *   [en]Page URL. Only necessary if `page` parameter is null or undefined.[/en]
+     *   [ja][/ja]
+     * @param {String} [options.pageHTML]
+     *   [en]HTML code that will be computed as a new page. Overwrites `page` parameter.[/en]
+     *   [ja][/ja]
+     * @param {String} [options.animation]
+     *   [en]
+     *     Animation name. Available animations are `"slide"`, `"lift"`, `"fade"` and `"none"`.
+     *
+     *     These are platform based animations. For fixed animations, add `"-ios"` or `"-md"` suffix to the animation name. E.g. `"lift-ios"`, `"lift-md"`. Defaults values are `"slide-ios"` and `"fade-md"`.
+     *   [/en]
+     *   [ja][/ja]
+     * @param {String} [options.animationOptions]
+     *   [en]Specify the animation's duration, delay and timing. E.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}`[/en]
+     *   [ja]アニメーション時のduration, delay, timingを指定します。e.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}` [/ja]
+     * @param {Function} [options.callback]
+     *   [en]Function that is called when the transition has ended.[/en]
+     *   [ja]pushPage()による画面遷移が終了した時に呼び出される関数オブジェクトを指定します。[/ja]
+     * @param {Object} [options.data]
+     *   [en]Custom data that will be stored in the new page element.[/en]
+     *   [ja][/ja]
+     * @return {Promise}
+     *   [en]Promise which resolves to the pushed page.[/en]
+     *   [ja]追加したページを解決するPromiseを返します。[/ja]
+     * @description
+     *   [en]Pushes the specified page into the stack.[/en]
+     *   [ja]指定したpageを新しいページスタックに追加します。新しいページが表示されます。[/ja]
+     */
+
+  }, {
+    key: 'pushPage',
+    value: function pushPage(page) {
+      var _this5 = this;
+
+      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
+
+      var _preparePageAndOption2 = this._preparePageAndOptions(page, options);
+
+      page = _preparePageAndOption2.page;
+      options = _preparePageAndOption2.options;
+
+
+      var prepare = function prepare(pageElement) {
+        verifyPageElement(pageElement);
+        _this5._pageMap.set(pageElement, page);
+        pageElement = util$1.extend(pageElement, {
+          data: options.data
+        });
+        pageElement.style.visibility = 'hidden';
+      };
+
+      if (options.pageHTML) {
+        return this._pushPage(options, function () {
+          return new Promise(function (resolve) {
+            instantPageLoader.load({ page: options.pageHTML, parent: _this5, params: options.data }, function (pageElement) {
+              prepare(pageElement);
+              resolve();
+            });
+          });
+        });
+      }
+
+      return this._pushPage(options, function () {
+        return new Promise(function (resolve) {
+          _this5._pageLoader.load({ page: page, parent: _this5, params: options.data }, function (pageElement) {
+            prepare(pageElement);
+            resolve();
+          });
+        });
+      });
+    }
+  }, {
+    key: '_pushPage',
+    value: function _pushPage() {
+      var _this6 = this;
+
+      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
+      var update = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {
+        return Promise.resolve();
+      };
+
+      if (this._isRunning) {
+        return Promise.reject('pushPage is already running.');
+      }
+
+      if (this._emitPrePushEvent()) {
+        return Promise.reject('Canceled in prepush event.');
+      }
+
+      this._isRunning = true;
+
+      var animationOptions = AnimatorFactory.parseAnimationOptionsString(this.getAttribute('animation-options'));
+      options = util$1.extend({}, this.options || {}, { animationOptions: animationOptions }, options);
+
+      var animator = this._animatorFactory.newAnimator(options);
+
+      return update().then(function () {
+        var pageLength = _this6.pages.length;
+
+        var enterPage = _this6.pages[pageLength - 1];
+        var leavePage = options.leavePage || _this6.pages[pageLength - 2];
+
+        verifyPageElement(enterPage);
+
+        enterPage.updateBackButton(pageLength > (options._replacePage ? 2 : 1));
+
+        enterPage.pushedOptions = util$1.extend({}, enterPage.pushedOptions || {}, options || {});
+        enterPage.data = util$1.extend({}, enterPage.data || {}, options.data || {});
+        enterPage.unload = enterPage.unload || options.unload;
+
+        return new Promise(function (resolve) {
+          var done = function done() {
+            _this6._isRunning = false;
+
+            options.show !== false && setImmediate(function () {
+              return enterPage._show();
+            });
+            util$1.triggerElementEvent(_this6, 'postpush', { leavePage: leavePage, enterPage: enterPage, navigator: _this6 });
+
+            if (leavePage) {
+              leavePage.style.display = 'none';
+            }
+
+            options.callback && options.callback(enterPage);
+
+            resolve(enterPage);
+          };
+
+          enterPage.style.visibility = '';
+          if (leavePage) {
+            leavePage._hide();
+            animator.push(enterPage, leavePage, done);
+          } else {
+            done();
+          }
+        });
+      }).catch(function (error) {
+        _this6._isRunning = false;
+        throw error;
+      });
+    }
+
+    /**
+     * @method replacePage
+     * @signature replacePage(page, [options])
+     * @return {Promise}
+     *   [en]Promise which resolves to the new page.[/en]
+     *   [ja]新しいページを解決するPromiseを返します。[/ja]
+     * @description
+     *   [en]Replaces the current top page with the specified one. Extends `pushPage()` parameters.[/en]
+     *   [ja]現在表示中のページをを指定したページに置き換えます。[/ja]
+     */
+
+  }, {
+    key: 'replacePage',
+    value: function replacePage(page) {
+      var _this7 = this;
+
+      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
+
+      return this.pushPage(page, options).then(function (resolvedValue) {
+        if (_this7.pages.length > 1) {
+          _this7._pageLoader.unload(_this7.pages[_this7.pages.length - 2]);
+        }
+        _this7._updateLastPageBackButton();
+
+        return Promise.resolve(resolvedValue);
+      });
+    }
+
+    /**
+     * @method insertPage
+     * @signature insertPage(index, page, [options])
+     * @param {Number} index
+     *   [en]The index where it should be inserted.[/en]
+     *   [ja]スタックに挿入する位置のインデックスを指定します。[/ja]
+     * @return {Promise}
+     *   [en]Promise which resolves to the inserted page.[/en]
+     *   [ja]指定したページを解決するPromiseを返します。[/ja]
+     * @description
+     *   [en]Insert the specified page into the stack with at a position defined by the `index` argument. Extends `pushPage()` parameters.[/en]
+     *   [ja]指定したpageをページスタックのindexで指定した位置に追加します。[/ja]
+     */
+
+  }, {
+    key: 'insertPage',
+    value: function insertPage(index, page) {
+      var _this8 = this;
+
+      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
+
+      var _preparePageAndOption3 = this._preparePageAndOptions(page, options);
+
+      page = _preparePageAndOption3.page;
+      options = _preparePageAndOption3.options;
+
+      index = this._normalizeIndex(index);
+
+      if (index >= this.pages.length) {
+        return this.pushPage(page, options);
+      }
+
+      page = typeof options.pageHTML === 'string' ? options.pageHTML : page;
+      var loader = typeof options.pageHTML === 'string' ? instantPageLoader : this._pageLoader;
+
+      return new Promise(function (resolve) {
+        loader.load({ page: page, parent: _this8 }, function (pageElement) {
+          verifyPageElement(pageElement);
+          _this8._pageMap.set(pageElement, page);
+          pageElement = util$1.extend(pageElement, {
+            data: options.data,
+            pushedOptions: options
+          });
+
+          options.animationOptions = util$1.extend({}, AnimatorFactory.parseAnimationOptionsString(_this8.getAttribute('animation-options')), options.animationOptions || {});
+
+          pageElement.style.display = 'none';
+          _this8.insertBefore(pageElement, _this8.pages[index]);
+          _this8.topPage.updateBackButton(true);
+
+          setTimeout(function () {
+            pageElement = null;
+            resolve(_this8.pages[index]);
+          }, 1000 / 60);
+        });
+      });
+    }
+
+    /**
+     * @method removePage
+     * @signature removePage(index, [options])
+     * @param {Number} index
+     *   [en]The index where it should be removed.[/en]
+     *   [ja]スタックから削除するページのインデックスを指定します。[/ja]
+     * @return {Promise}
+     *   [en]Promise which resolves to the revealed page.[/en]
+     *   [ja]削除によって表示されたページを解決するPromiseを返します。[/ja]
+     * @description
+     *   [en]Remove the specified page at a position in the stack defined by the `index` argument. Extends `popPage()` parameters.[/en]
+     *   [ja]指定したインデックスにあるページを削除します。[/ja]
+     */
+
+  }, {
+    key: 'removePage',
+    value: function removePage(index) {
+      var _this9 = this;
+
+      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
+
+      index = this._normalizeIndex(index);
+
+      if (index < this.pages.length - 1) {
+        return new Promise(function (resolve) {
+          var leavePage = _this9.pages[index];
+          var enterPage = _this9.topPage;
+
+          _this9._pageMap.delete(leavePage);
+          _this9._pageLoader.unload(leavePage);
+          if (_this9.pages.length === 1) {
+            // edge case
+            _this9.topPage.updateBackButton(false);
+          }
+
+          resolve(enterPage);
+        });
+      } else {
+        return this.popPage(options);
+      }
+    }
+
+    /**
+     * @method resetToPage
+     * @signature resetToPage(page, [options])
+     * @return {Promise}
+     *   [en]Promise which resolves to the new top page.[/en]
+     *   [ja]新しいトップページを解決するPromiseを返します。[/ja]
+     * @param {Boolean} [options.pop]
+     *   [en]Performs 'pop' effect if `true` instead of 'push' or none. This also sets `options.animation` value to `default` instead of `none`.[/en]
+     *   [ja][/ja]
+     * @description
+     *   [en]Clears page stack and adds the specified page to the stack. Extends `pushPage()` parameters.[/en]
+     *   [ja]ページスタックをリセットし、指定したページを表示します。[/ja]
+     */
+
+  }, {
+    key: 'resetToPage',
+    value: function resetToPage(page) {
+      var _this10 = this;
+
+      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
+
+      var _preparePageAndOption4 = this._preparePageAndOptions(page, options);
+
+      page = _preparePageAndOption4.page;
+      options = _preparePageAndOption4.options;
+
+
+      if (!options.animator && !options.animation && !options.pop) {
+        options.animation = 'none';
+      }
+
+      if (!options.page && !options.pageHTML && this._getPageTarget()) {
+        page = options.page = this._getPageTarget();
+      }
+
+      if (options.pop) {
+        this._removePages();
+        return this.insertPage(0, page, { data: options.data }).then(function () {
+          return _this10.popPage(options);
+        });
+      }
+
+      // Tip: callback runs before resolved promise
+      var callback = options.callback;
+      options.callback = function (newPage) {
+        _this10._removePages();
+        newPage.updateBackButton(false);
+        callback && callback(newPage);
+      };
+
+      return this.pushPage(page, options);
+    }
+
+    /**
+     * @method bringPageTop
+     * @signature bringPageTop(item, [options])
+     * @param {String|Number} item
+     *   [en]Page URL or index of an existing page in navigator's stack.[/en]
+     *   [ja]ページのURLかもしくはons-navigatorのページスタックのインデックス値を指定します。[/ja]
+     * @return {Promise}
+     *   [en]Promise which resolves to the new top page.[/en]
+     *   [ja]新しいトップページを解決するPromiseを返します。[/ja]
+     * @description
+     *   [en]Brings the given page to the top of the page stack if it already exists or pushes it into the stack if doesn't. Extends `pushPage()` parameters.[/en]
+     *   [ja]指定したページをページスタックの一番上に移動します。もし指定したページが無かった場合新しくpushされます。[/ja]
+     */
+
+  }, {
+    key: 'bringPageTop',
+    value: function bringPageTop(item) {
+      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
+
+      if (['number', 'string'].indexOf(typeof item === 'undefined' ? 'undefined' : _typeof(item)) === -1) {
+        util$1.throw('First argument must be a page name or the index of an existing page. You supplied ' + item);
+      }
+      var index = typeof item === 'number' ? this._normalizeIndex(item) : this._lastIndexOfPage(item);
+      var page = this.pages[index];
+
+      if (index < 0) {
+        return this.pushPage(item, options);
+      }
+
+      var _preparePageAndOption5 = this._preparePageAndOptions(page, options);
+
+      options = _preparePageAndOption5.options;
+
+
+      if (index === this.pages.length - 1) {
+        return Promise.resolve(page);
+      }
+      if (!page) {
+        util$1.throw('Failed to find item ' + item);
+      }
+      if (this._isRunning) {
+        return Promise.reject('pushPage is already running.');
+      }
+      if (this._emitPrePushEvent()) {
+        return Promise.reject('Canceled in prepush event.');
+      }
+
+      page.style.display = '';
+      page.style.visibility = 'hidden';
+      page.parentNode.appendChild(page);
+      return this._pushPage(options);
+    }
+  }, {
+    key: '_preparePageAndOptions',
+    value: function _preparePageAndOptions(page) {
+      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
+
+      if ((typeof options === 'undefined' ? 'undefined' : _typeof(options)) != 'object') {
+        util$1.throw('options must be an object. You supplied ' + options);
+      }
+
+      if ((page === null || page === undefined) && options.page) {
+        page = options.page;
+      }
+
+      options = util$1.extend({}, this.options || {}, options, { page: page });
+
+      return { page: page, options: options };
+    }
+  }, {
+    key: '_removePages',
+    value: function _removePages(times) {
+      var pages = this.pages;
+      var until = times === undefined ? 0 : pages.length - times;
+      until = until < 0 ? 1 : until;
+
+      for (var i = pages.length - 2; i >= until; i--) {
+        this._pageMap.delete(pages[i]);
+        this._pageLoader.unload(pages[i]);
+      }
+    }
+  }, {
+    key: '_updateLastPageBackButton',
+    value: function _updateLastPageBackButton() {
+      var index = this.pages.length - 1;
+      if (index >= 0) {
+        this.pages[index].updateBackButton(index > 0);
+      }
+    }
+  }, {
+    key: '_normalizeIndex',
+    value: function _normalizeIndex(index) {
+      return index >= 0 ? index : Math.abs(this.pages.length + index) % this.pages.length;
+    }
+  }, {
+    key: '_onDeviceBackButton',
+    value: function _onDeviceBackButton(event) {
+      if (this.pages.length > 1) {
+        this.popPage();
+      } else {
+        event.callParentHandler();
+      }
+    }
+  }, {
+    key: '_lastIndexOfPage',
+    value: function _lastIndexOfPage(pageName) {
+      var index = void 0;
+      for (index = this.pages.length - 1; index >= 0; index--) {
+        if (pageName === this._pageMap.get(this.pages[index])) {
+          break;
+        }
+      }
+      return index;
+    }
+  }, {
+    key: '_emitPreEvent',
+    value: function _emitPreEvent(name) {
+      var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
+
+      var isCanceled = false;
+
+      util$1.triggerElementEvent(this, 'pre' + name, util$1.extend({
+        navigator: this,
+        currentPage: this.pages[this.pages.length - 1],
+        cancel: function cancel() {
+          return isCanceled = true;
+        }
+      }, data));
+
+      return isCanceled;
+    }
+  }, {
+    key: '_emitPrePushEvent',
+    value: function _emitPrePushEvent() {
+      return this._emitPreEvent('push');
+    }
+  }, {
+    key: '_emitPrePopEvent',
+    value: function _emitPrePopEvent() {
+      var l = this.pages.length;
+      return this._emitPreEvent('pop', {
+        leavePage: this.pages[l - 1],
+        enterPage: this.pages[l - 2]
+      });
+    }
+
+    // TODO: 書き直す
+
+  }, {
+    key: '_createPageElement',
+    value: function _createPageElement(templateHTML) {
+      var pageElement = util$1.createElement(internal$1.normalizePageHTML(templateHTML));
+      verifyPageElement(pageElement);
+      return pageElement;
+    }
+
+    /**
+     * @property onDeviceBackButton
+     * @type {Object}
+     * @description
+     *   [en]Back-button handler.[/en]
+     *   [ja]バックボタンハンドラ。[/ja]
+     */
+
+  }, {
+    key: '_show',
+    value: function _show() {
+      var _this11 = this;
+
+      this.loaded.then(function () {
+        return _this11.topPage && _this11.topPage._show();
+      });
+    }
+  }, {
+    key: '_hide',
+    value: function _hide() {
+      this.topPage && this.topPage._hide();
+    }
+  }, {
+    key: '_destroy',
+    value: function _destroy() {
+      for (var i = this.pages.length - 1; i >= 0; i--) {
+        this._pageLoader.unload(this.pages[i]);
+      }
+
+      this.remove();
+    }
+
+    /**
+     * @param {String} name
+     * @param {Function} Animator
+     */
+
+  }, {
+    key: 'pageLoader',
+    get: function get$$1() {
+      return this._pageLoader;
+    },
+    set: function set$$1(pageLoader) {
+      if (!(pageLoader instanceof PageLoader)) {
+        util$1.throwPageLoader();
+      }
+      this._pageLoader = pageLoader;
+    }
+  }, {
+    key: 'page',
+    get: function get$$1() {
+      return this._page;
+    },
+    set: function set$$1(page) {
+      this._page = page;
+    }
+  }, {
+    key: 'onDeviceBackButton',
+    get: function get$$1() {
+      return this._backButtonHandler;
+    },
+    set: function set$$1(callback) {
+      if (this._backButtonHandler) {
+        this._backButtonHandler.destroy();
+      }
+
+      this._backButtonHandler = deviceBackButtonDispatcher.createHandler(this, callback);
+    }
+
+    /**
+     * @property topPage
+     * @readonly
+     * @type {HTMLElement}
+     * @description
+     *   [en]Current top page element. Use this method to access options passed by `pushPage()`-like methods.[/en]
+     *   [ja]現在のページを取得します。pushPage()やresetToPage()メソッドの引数を取得できます。[/ja]
+     */
+
+  }, {
+    key: 'topPage',
+    get: function get$$1() {
+      var last = this.lastElementChild;
+      while (last && last.tagName !== 'ONS-PAGE') {
+        last = last.previousElementSibling;
+      }
+      return last;
+    }
+
+    /**
+     * @property pages
+     * @readonly
+     * @type {Array}
+     * @description
+     *   [en]Copy of the navigator's page stack.[/en]
+     *   [ja][/ja]
+     */
+
+  }, {
+    key: 'pages',
+    get: function get$$1() {
+      return util$1.arrayFrom(this.children).filter(function (element) {
+        return element.tagName === 'ONS-PAGE';
+      });
+    }
+
+    /**
+     * @property onSwipe
+     * @type {Function}
+     * @description
+     *   [en]Hook called whenever the user slides the navigator (swipe-to-pop). It gets a decimal ratio (0-1) and an animationOptions object as arguments.[/en]
+     *   [ja][/ja]
+     */
+
+  }, {
+    key: 'onSwipe',
+    get: function get$$1() {
+      return this._onSwipe;
+    },
+    set: function set$$1(value) {
+      if (value && !(value instanceof Function)) {
+        util$1.throw('"onSwipe" must be a function');
+      }
+      this._onSwipe = value;
+    }
+
+    /**
+     * @property options
+     * @type {Object}
+     * @description
+     *   [en]Default options object. Attributes have priority over this property.[/en]
+     *   [ja][/ja]
+     */
+
+    /**
+     * @property options.animation
+     * @type {String}
+     * @description
+     *   [en]
+     *     Animation name. Available animations are `"slide"`, `"lift"`, `"fade"` and `"none"`.
+     *     These are platform based animations. For fixed animations, add `"-ios"` or `"-md"` suffix to the animation name. E.g. `"lift-ios"`, `"lift-md"`. Defaults values are `"slide-ios"` and `"fade-md"`.
+     *   [/en]
+     *   [ja][/ja]
+     */
+
+    /**
+     * @property options.animationOptions
+     * @type {String}
+     * @description
+     *   [en]Specify the animation's duration, delay and timing. E.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}`.[/en]
+     *   [ja]アニメーション時のduration, delay, timingを指定します。e.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}` [/ja]
+     */
+
+    /**
+     * @property options.callback
+     * @type {String}
+     * @description
+     *   [en]Function that is called when the transition has ended.[/en]
+     *   [ja]このメソッドによる画面遷移が終了した際に呼び出される関数オブジェクトを指定します。[/ja]
+     */
+
+  }, {
+    key: 'options',
+    get: function get$$1() {
+      return this._options;
+    },
+    set: function set$$1(object) {
+      this._options = object;
+    }
+  }, {
+    key: '_isRunning',
+    set: function set$$1(value) {
+      this.setAttribute('_is-running', value ? 'true' : 'false');
+    },
+    get: function get$$1() {
+      return JSON.parse(this.getAttribute('_is-running'));
+    }
+  }], [{
+    key: 'registerAnimator',
+    value: function registerAnimator(name, Animator) {
+      if (!(Animator.prototype instanceof NavigatorAnimator)) {
+        util$1.throwAnimator('Navigator');
+      }
+
+      _animatorDict$5[name] = Animator;
+    }
+  }, {
+    key: 'observedAttributes',
+    get: function get$$1() {
+      return ['animation', 'swipeable'];
+    }
+  }, {
+    key: 'animators',
+    get: function get$$1() {
+      return _animatorDict$5;
+    }
+  }, {
+    key: 'NavigatorAnimator',
+    get: function get$$1() {
+      return NavigatorAnimator;
+    }
+  }, {
+    key: 'events',
+    get: function get$$1() {
+      return ['prepush', 'postpush', 'prepop', 'postpop'];
+    }
+  }, {
+    key: 'rewritables',
+    get: function get$$1() {
+      return rewritables;
+    }
+  }]);
+  return NavigatorElement;
+}(BaseElement);
+
+onsElements.Navigator = NavigatorElement;
+customElements.define('ons-navigator', NavigatorElement);
+
+/*
+Copyright 2013-2015 ASIAL CORPORATION
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+   http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+*/
+
+var defaultClassName$10 = 'toolbar';
+
+var scheme$18 = {
+  '': 'toolbar--*',
+  '.toolbar__left': 'toolbar--*__left',
+  '.toolbar__center': 'toolbar--*__center',
+  '.toolbar__right': 'toolbar--*__right'
+};
+
+/**
+ * @element ons-toolbar
+ * @category page
+ * @modifier material
+ *   [en]Material Design toolbar.[/en]
+ *   [ja][/ja]
+ * @modifier transparent
+ *   [en]Transparent toolbar.[/en]
+ *   [ja]透明な背景を持つツールバーを表示します。[/ja]
+ * @modifier cover-content
+ *   [en]Displays the toolbar on top of the page's content. Should be combined with `transparent` modifier.[/en]
+ *   [ja][/ja]
+ * @modifier noshadow
+ *   [en]Toolbar without shadow.[/en]
+ *   [ja]ツールバーに影を付けずに表示します。[/ja]
+ * @description
+ *   [en]
+ *     Toolbar component that can be used with navigation.
+ *
+ *     Left, center and right containers can be specified by class names.
+ *
+ *     This component will automatically display as a Material Design toolbar when running on Android devices.
+ *   [/en]
+ *   [ja]ナビゲーションで使用するツールバー用コンポーネントです。クラス名により、左、中央、右のコンテナを指定できます。[/ja]
+ * @codepen aHmGL
+ * @tutorial vanilla/Reference/toolbar
+ * @guide compilation.html#toolbar-compilation [en]Adding a toolbar[/en][ja]ツールバーの追加[/ja]
+ * @seealso ons-bottom-toolbar
+ *   [en]The `<ons-bottom-toolbar>` displays a toolbar on the bottom of the page.[/en]
+ *   [ja]ons-bottom-toolbarコンポーネント[/ja]
+ * @seealso ons-back-button
+ *   [en]The `<ons-back-button>` component displays a back button inside the toolbar.[/en]
+ *   [ja]ons-back-buttonコンポーネント[/ja]
+ * @seealso ons-toolbar-button
+ *   [en]The `<ons-toolbar-button>` component displays a toolbar button inside the toolbar.[/en]
+ *   [ja]ons-toolbar-buttonコンポーネント[/ja]
+ * @example
+ * <ons-page>
+ *   <ons-toolbar>
+ *     <div class="left">
+ *       <ons-back-button>
+ *         Back
+ *       </ons-back-button>
+ *     </div>
+ *     <div class="center">
+ *       Title
+ *     </div>
+ *     <div class="right">
+ *       <ons-toolbar-button>
+ *         <ons-icon icon="md-menu"></ons-icon>
+ *       </ons-toolbar-button>
+ *     </div>
+ *   </ons-toolbar>
+ * </ons-page>
+ */
+
+var ToolbarElement = function (_BaseElement) {
+  inherits(ToolbarElement, _BaseElement);
+
+  /**
+   * @attribute inline
+   * @initonly
+   * @description
+   *   [en]Display the toolbar as an inline element.[/en]
+   *   [ja]ツールバーをインラインに置きます。スクロール領域内にそのまま表示されます。[/ja]
+   */
+
+  /**
+   * @attribute static
+   * @description
+   *   [en]Static toolbars are not animated by `ons-navigator` when pushing or popping pages. This can be useful to improve performance in some situations.[/en]
+   *   [ja][/ja]
+   */
+
+  /**
+   * @attribute modifier
+   * @description
+   *   [en]The appearance of the toolbar.[/en]
+   *   [ja]ツールバーの表現を指定します。[/ja]
+   */
+
+  function ToolbarElement() {
+    classCallCheck(this, ToolbarElement);
+
+    var _this = possibleConstructorReturn(this, (ToolbarElement.__proto__ || Object.getPrototypeOf(ToolbarElement)).call(this));
+
+    contentReady(_this, function () {
+      _this._compile();
+    });
+    return _this;
+  }
+
+  createClass(ToolbarElement, [{
+    key: 'attributeChangedCallback',
+    value: function attributeChangedCallback(name, last, current) {
+      switch (name) {
+        case 'class':
+          util$1.restoreClass(this, defaultClassName$10, scheme$18);
+          break;
+        case 'modifier':
+          ModifierUtil.onModifierChanged(last, current, this, scheme$18);
+          break;
+      }
+    }
+
+    /**
+     * @method setVisibility
+     * @signature setVisibility(visible)
+     * @param {Boolean} visible
+     *   [en]Set to true to show the toolbar, false to hide it[/en]
+     *   [ja][/ja]
+     * @description
+     *   [en]Shows the toolbar if visible is true, otherwise hides it.[/en]
+     *   [ja][/ja]
+     */
+
+  }, {
+    key: 'setVisibility',
+    value: function setVisibility(visible) {
+      var _this2 = this;
+
+      contentReady(this, function () {
+        _this2.style.display = visible ? '' : 'none';
+
+        if (_this2.parentNode) {
+          var siblingBackground = util$1.findChild(_this2.parentNode, '.page__background');
+          if (siblingBackground) {
+            siblingBackground.style.top = visible ? null : 0;
+          }
+
+          var siblingContent = util$1.findChild(_this2.parentNode, '.page__content');
+          if (siblingContent) {
+            siblingContent.style.top = visible ? null : 0;
+          }
+        }
+      });
+    }
+
+    /**
+     * @method show
+     * @signature show()
+     * @description
+     *   [en]Show the toolbar.[/en]
+     *   [ja][/ja]
+     */
+
+  }, {
+    key: 'show',
+    value: function show() {
+      this.setVisibility(true);
+    }
+
+    /**
+     * @method hide
+     * @signature hide()
+     * @description
+     *   [en]Hide the toolbar.[/en]
+     *   [ja][/ja]
+     */
+
+  }, {
+    key: 'hide',
+    value: function hide() {
+      this.setVisibility(false);
+    }
+
+    /**
+     * @return {HTMLElement}
+     */
+
+  }, {
+    key: '_getToolbarLeftItemsElement',
+    value: function _getToolbarLeftItemsElement() {
+      return this.querySelector('.left') || internal$1.nullElement;
+    }
+
+    /**
+     * @return {HTMLElement}
+     */
+
+  }, {
+    key: '_getToolbarCenterItemsElement',
+    value: function _getToolbarCenterItemsElement() {
+      return this.querySelector('.center') || internal$1.nullElement;
+    }
+
+    /**
+     * @return {HTMLElement}
+     */
+
+  }, {
+    key: '_getToolbarRightItemsElement',
+    value: function _getToolbarRightItemsElement() {
+      return this.querySelector('.right') || internal$1.nullElement;
+    }
+
+    /**
+     * @return {HTMLElement}
+     */
+
+  }, {
+    key: '_getToolbarBackButtonLabelElement',
+    value: function _getToolbarBackButtonLabelElement() {
+      return this.querySelector('ons-back-button .back-button__label') || internal$1.nullElement;
+    }
+
+    /**
+     * @return {HTMLElement}
+     */
+
+  }, {
+    key: '_getToolbarBackButtonIconElement',
+    value: function _getToolbarBackButtonIconElement() {
+      return this.querySelector('ons-back-button .back-button__icon') || internal$1.nullElement;
+    }
+  }, {
+    key: '_compile',
+    value: function _compile() {
+      autoStyle.prepare(this);
+      this.classList.add(defaultClassName$10);
+      this._ensureToolbarItemElements();
+      ModifierUtil.initModifier(this, scheme$18);
+    }
+  }, {
+    key: '_ensureToolbarItemElements',
+    value: function _ensureToolbarItemElements() {
+      for (var i = this.childNodes.length - 1; i >= 0; i--) {
+        // case of not element
+        if (this.childNodes[i].nodeType != 1) {
+          this.removeChild(this.childNodes[i]);
+        }
+      }
+
+      var center = this._ensureToolbarElement('center');
+      center.classList.add('toolbar__title');
+
+      if (this.children.length !== 1 || !this.children[0].classList.contains('center')) {
+        var left = this._ensureToolbarElement('left');
+        var right = this._ensureToolbarElement('right');
+
+        if (this.children[0] !== left || this.children[1] !== center || this.children[2] !== right) {
+          this.appendChild(left);
+          this.appendChild(center);
+          this.appendChild(right);
+        }
+      }
+    }
+  }, {
+    key: '_ensureToolbarElement',
+    value: function _ensureToolbarElement(name) {
+      if (util$1.findChild(this, '.toolbar__' + name)) {
+        var _element = util$1.findChild(this, '.toolbar__' + name);
+        _element.classList.add(name);
+        return _element;
+      }
+
+      var element = util$1.findChild(this, '.' + name) || util$1.create('.' + name);
+      element.classList.add('toolbar__' + name);
+
+      return element;
+    }
+  }], [{
+    key: 'observedAttributes',
+    get: function get$$1() {
+      return ['modifier', 'class'];
+    }
+  }]);
+  return ToolbarElement;
+}(BaseElement);
+
+onsElements.Toolbar = ToolbarElement;
+customElements.define('ons-toolbar', ToolbarElement);
+
+/*
+Copyright 2013-2015 ASIAL CORPORATION
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+   http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+*/
+
+var defaultClassName$9 = 'page';
+var scheme$17 = {
+  '': 'page--*',
+  '.page__content': 'page--*__content',
+  '.page__background': 'page--*__background'
+};
+
+/**
+ * @element ons-page
+ * @category page
+ * @modifier material
+ *   [en]Material Design style[/en]
+ *   [ja][/ja]
+ * @description
+ *   [en]
+ *     This component defines the root of each page. If the content is large it will become scrollable.
+ *
+ *     A navigation bar can be added to the top of the page using the `<ons-toolbar>` element.
+ *   [/en]
+ *   [ja]ページ定義のためのコンポーネントです。このコンポーネントの内容はスクロールが許可されます。[/ja]
+ * @tutorial vanilla/Reference/page
+ * @guide lifecycle.html#events
+ *   [en]Overview of page events[/en]
+ *   [ja]Overview of page events[/ja]
+ * @guide fundamentals.html#managing-pages
+ *   [en]Managing multiple pages[/en]
+ *   [ja]複数のページを管理する[/ja]
+ * @guide theming.html#modifiers [en]More details about the `modifier` attribute[/en][ja]modifier属性の使い方[/ja]
+ * @seealso ons-toolbar
+ *   [en]Use the `<ons-toolbar>` element to add a navigation bar to the top of the page.[/en]
+ *   [ja][/ja]
+ * @example
+ * <ons-page>
+ *   <ons-toolbar>
+ *     <div class="left">
+ *       <ons-back-button>Back</ons-back-button>
+ *     </div>
+ *     <div class="center">Title</div>
+ *     <div class="right">
+ *       <ons-toolbar-button>
+ *         <ons-icon icon="md-menu"></ons-icon>
+ *       </ons-toolbar-button>
+ *     </div>
+ *   </ons-toolbar>
+ *
+ *   <p>Page content</p>
+ * </ons-page>
+ *
+ * @example
+ * <script>
+ *   myApp.handler = function(done) {
+ *     loadMore().then(done);
+ *   }
+ * </script>
+ *
+ * <ons-page on-infinite-scroll="myApp.handler">
+ *   <ons-toolbar>
+ *     <div class="center">List</div>
+ *   </ons-toolbar>
+ *
+ *   <ons-list>
+ *     <ons-list-item>#1</ons-list-item>
+ *     <ons-list-item>#2</ons-list-item>
+ *     <ons-list-item>#3</ons-list-item>
+ *     ...
+ *   </ons-list>
+ * </ons-page>
+ */
+
+var PageElement = function (_BaseElement) {
+  inherits(PageElement, _BaseElement);
+
+  /**
+   * @event init
+   * @description
+   *   [en]Fired right after the page is attached.[/en]
+   *   [ja]ページがアタッチされた後に発火します。[/ja]
+   * @param {Object} event [en]Event object.[/en]
+   */
+
+  /**
+   * @event show
+   * @description
+   *   [en]Fired right after the page is shown.[/en]
+   *   [ja]ページが表示された後に発火します。[/ja]
+   * @param {Object} event [en]Event object.[/en]
+   */
+
+  /**
+   * @event hide
+   * @description
+   *   [en]Fired right after the page is hidden.[/en]
+   *   [ja]ページが隠れた後に発火します。[/ja]
+   * @param {Object} event [en]Event object.[/en]
+   */
+
+  /**
+   * @event destroy
+   * @description
+   *   [en]Fired right before the page is destroyed.[/en]
+   *   [ja]ページが破棄される前に発火します。[/ja]
+   * @param {Object} event [en]Event object.[/en]
+   */
+
+  /**
+   * @attribute modifier
+   * @type {String}
+   * @description
+   *   [en]Specify modifier name to specify custom styles.[/en]
+   *   [ja]スタイル定義をカスタマイズするための名前を指定します。[/ja]
+   */
+
+  /**
+   * @attribute on-infinite-scroll
+   * @type {String}
+   * @description
+   *   [en]Path of the function to be executed on infinite scrolling. Example: `app.loadData`. The function receives a done callback that must be called when it's finished.[/en]
+   *   [ja][/ja]
+   */
+
+  function PageElement() {
+    classCallCheck(this, PageElement);
+
+    var _this = possibleConstructorReturn(this, (PageElement.__proto__ || Object.getPrototypeOf(PageElement)).call(this));
+
+    _this._deriveHooks();
+
+    _this._defaultClassName = defaultClassName$9;
+    _this.classList.add(defaultClassName$9);
+
+    _this._initialized = false;
+
+    contentReady(_this, function () {
+      _this._compile();
+
+      _this._isShown = false;
+      _this._contentElement = _this._getContentElement();
+      _this._backgroundElement = _this._getBackgroundElement();
+    });
+    return _this;
+  }
+
+  createClass(PageElement, [{
+    key: '_compile',
+    value: function _compile() {
+      var _this2 = this;
+
+      autoStyle.prepare(this);
+
+      var toolbar = util$1.findChild(this, 'ons-toolbar');
+
+      var background = util$1.findChild(this, '.page__background') || util$1.findChild(this, '.background') || document.createElement('div');
+      background.classList.add('page__background');
+      this.insertBefore(background, !toolbar && this.firstChild || toolbar && toolbar.nextSibling);
+
+      var content = util$1.findChild(this, '.page__content') || util$1.findChild(this, '.content') || document.createElement('div');
+      content.classList.add('page__content');
+      if (!content.parentElement) {
+        util$1.arrayFrom(this.childNodes).forEach(function (node) {
+          if (node.nodeType !== 1 || _this2._elementShouldBeMoved(node)) {
+            content.appendChild(node); // Can trigger detached connectedCallbacks
+          }
+        });
+      }
+
+      this._tryToFillStatusBar(content); // Must run before child pages try to fill status bar.
+      this.insertBefore(content, background.nextSibling); // Can trigger attached connectedCallbacks
+
+      if ((!toolbar || !util$1.hasModifier(toolbar, 'transparent')) && content.children.length === 1 && util$1.isPageControl(content.children[0])) {
+        this._defaultClassName += ' page--wrapper';
+        this.attributeChangedCallback('class');
+      }
+
+      var bottomToolbar = util$1.findChild(this, 'ons-bottom-toolbar');
+      if (bottomToolbar) {
+        this._defaultClassName += ' page-with-bottom-toolbar';
+        this.attributeChangedCallback('class');
+      }
+
+      ModifierUtil.initModifier(this, scheme$17);
+    }
+  }, {
+    key: '_elementShouldBeMoved',
+    value: function _elementShouldBeMoved(el) {
+      if (el.classList.contains('page__background')) {
+        return false;
+      }
+      var tagName = el.tagName.toLowerCase();
+      if (tagName === 'ons-fab') {
+        return !el.hasAttribute('position');
+      }
+      var fixedElements = ['script', 'ons-toolbar', 'ons-bottom-toolbar', 'ons-modal', 'ons-speed-dial', 'ons-dialog', 'ons-alert-dialog', 'ons-popover', 'ons-action-sheet'];
+      return el.hasAttribute('inline') || fixedElements.indexOf(tagName) === -1;
+    }
+  }, {
+    key: '_tryToFillStatusBar',
+    value: function _tryToFillStatusBar() {
+      var _this3 = this;
+
+      var content = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._contentElement;
+
+      internal$1.autoStatusBarFill(function () {
+        util$1.toggleAttribute(_this3, 'status-bar-fill', !util$1.findParent(_this3, function (e) {
+          return e.hasAttribute('status-bar-fill');
+        }) // Not already filled
+        && (_this3._canAnimateToolbar(content) || !util$1.findChild(content, util$1.isPageControl)) // Has toolbar or cannot delegate
+        );
+      });
+    }
+  }, {
+    key: '_canAnimateToolbar',
+    value: function _canAnimateToolbar() {
+      var content = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._contentElement;
+
+      if (util$1.findChild(this, 'ons-toolbar')) {
+        return true;
+      }
+
+      return !!util$1.findChild(content, function (el) {
+        return util$1.match(el, 'ons-toolbar') && !el.hasAttribute('inline');
+      });
+    }
+  }, {
+    key: 'connectedCallback',
+    value: function connectedCallback() {
+      var _this4 = this;
+
+      if (!util$1.isAttached(this)) {
+        // Avoid detached calls
+        return;
+      }
+
+      contentReady(this, function () {
+        _this4._tryToFillStatusBar(); // Ensure status bar when the element was compiled before connected
+
+        if (_this4.hasAttribute('on-infinite-scroll')) {
+          _this4.attributeChangedCallback('on-infinite-scroll', null, _this4.getAttribute('on-infinite-scroll'));
+        }
+
+        if (!_this4._initialized) {
+          _this4._initialized = true;
+
+          setImmediate(function () {
+            _this4.onInit && _this4.onInit();
+            util$1.triggerElementEvent(_this4, 'init');
+          });
+
+          if (!util$1.hasAnyComponentAsParent(_this4)) {
+            setImmediate(function () {
+              return _this4._show();
+            });
+          }
+        }
+      });
+    }
+  }, {
+    key: 'updateBackButton',
+    value: function updateBackButton(show) {
+      if (this.backButton) {
+        show ? this.backButton.show() : this.backButton.hide();
+      }
+    }
+  }, {
+    key: '_onScroll',
+    value: function _onScroll() {
+      var _this5 = this;
+
+      var c = this._contentElement,
+          overLimit = (c.scrollTop + c.clientHeight) / c.scrollHeight >= this._infiniteScrollLimit;
+
+      if (this._onInfiniteScroll && !this._loadingContent && overLimit) {
+        this._loadingContent = true;
+        this._onInfiniteScroll(function () {
+          return _this5._loadingContent = false;
+        });
+      }
+    }
+
+    /**
+     * @property onDeviceBackButton
+     * @type {Object}
+     * @description
+     *   [en]Back-button handler.[/en]
+     *   [ja]バックボタンハンドラ。[/ja]
+     */
+
+  }, {
+    key: '_getContentElement',
+    value: function _getContentElement() {
+      var result = util$1.findChild(this, '.page__content');
+      if (result) {
+        return result;
+      }
+      util$1.throw('Fail to get ".page__content" element');
+    }
+  }, {
+    key: '_getBackgroundElement',
+    value: function _getBackgroundElement() {
+      var result = util$1.findChild(this, '.page__background');
+      if (result) {
+        return result;
+      }
+      util$1.throw('Fail to get ".page__background" element');
+    }
+  }, {
+    key: '_getBottomToolbarElement',
+    value: function _getBottomToolbarElement() {
+      return util$1.findChild(this, 'ons-bottom-toolbar') || internal$1.nullElement;
+    }
+  }, {
+    key: '_getToolbarElement',
+    value: function _getToolbarElement() {
+      return util$1.findChild(this, 'ons-toolbar') || document.createElement('ons-toolbar');
+    }
+  }, {
+    key: 'attributeChangedCallback',
+    value: function attributeChangedCallback(name, last, current) {
+      var _this6 = this;
+
+      switch (name) {
+        case 'class':
+          util$1.restoreClass(this, this._defaultClassName, scheme$17);
+          break;
+        case 'modifier':
+          ModifierUtil.onModifierChanged(last, current, this, scheme$17);
+          break;
+        case 'on-infinite-scroll':
+          if (current === null) {
+            this.onInfiniteScroll = null;
+          } else {
+            this.onInfiniteScroll = function (done) {
+              var f = util$1.findFromPath(current);
+              _this6.onInfiniteScroll = f;
+              f(done);
+            };
+          }
+          break;
+      }
+    }
+  }, {
+    key: '_show',
+    value: function _show() {
+      if (!this._isShown && util$1.isAttached(this)) {
+        this._isShown = true;
+        this.setAttribute('shown', '');
+        this.onShow && this.onShow();
+        util$1.triggerElementEvent(this, 'show');
+        util$1.propagateAction(this, '_show');
+      }
+    }
+  }, {
+    key: '_hide',
+    value: function _hide() {
+      if (this._isShown) {
+        this._isShown = false;
+        this.removeAttribute('shown');
+        this.onHide && this.onHide();
+        util$1.triggerElementEvent(this, 'hide');
+        util$1.propagateAction(this, '_hide');
+      }
+    }
+  }, {
+    key: '_destroy',
+    value: function _destroy() {
+      this._hide();
+
+      this.onDestroy && this.onDestroy();
+      util$1.triggerElementEvent(this, 'destroy');
+
+      if (this.onDeviceBackButton) {
+        this.onDeviceBackButton.destroy();
+      }
+
+      util$1.propagateAction(this, '_destroy');
+
+      this.remove();
+    }
+  }, {
+    key: '_deriveHooks',
+    value: function _deriveHooks() {
+      var _this7 = this;
+
+      this.constructor.events.forEach(function (event) {
+        var key = 'on' + event.charAt(0).toUpperCase() + event.slice(1);
+        Object.defineProperty(_this7, key, {
+          configurable: true,
+          enumerable: true,
+          get: function get$$1() {
+            return _this7['_' + key];
+          },
+          set: function set$$1(value) {
+            if (!(value instanceof Function)) {
+              util$1.throw('"' + key + '" hook must be a function');
+            }
+            _this7['_' + key] = value.bind(_this7);
+          }
+        });
+      });
+    }
+  }, {
+    key: 'name',
+    set: function set$$1(str) {
+      this.setAttribute('name', str);
+    },
+    get: function get$$1() {
+      return this.getAttribute('name');
+    }
+  }, {
+    key: 'backButton',
+    get: function get$$1() {
+      return this.querySelector('ons-back-button');
+    }
+
+    /**
+     * @property onInfiniteScroll
+     * @description
+     *  [en]Function to be executed when scrolling to the bottom of the page. The function receives a done callback as an argument that must be called when it's finished.[/en]
+     *  [ja][/ja]
+     */
+
+  }, {
+    key: 'onInfiniteScroll',
+    set: function set$$1(value) {
+      var _this8 = this;
+
+      if (value && !(value instanceof Function)) {
+        util$1.throw('"onInfiniteScroll" must be function or null');
+      }
+
+      contentReady(this, function () {
+        if (!value) {
+          _this8._contentElement.removeEventListener('scroll', _this8._boundOnScroll);
+        } else if (!_this8._onInfiniteScroll) {
+          _this8._infiniteScrollLimit = 0.9;
+          _this8._boundOnScroll = _this8._onScroll.bind(_this8);
+          setImmediate(function () {
+            return _this8._contentElement.addEventListener('scroll', _this8._boundOnScroll);
+          });
+        }
+        _this8._onInfiniteScroll = value;
+      });
+    },
+    get: function get$$1() {
+      return this._onInfiniteScroll;
+    }
+  }, {
+    key: 'onDeviceBackButton',
+    get: function get$$1() {
+      return this._backButtonHandler;
+    },
+    set: function set$$1(callback) {
+      if (this._backButtonHandler) {
+        this._backButtonHandler.destroy();
+      }
+
+      this._backButtonHandler = deviceBackButtonDispatcher.createHandler(this, callback);
+    }
+  }, {
+    key: 'scrollTop',
+    get: function get$$1() {
+      return this._contentElement.scrollTop;
+    },
+    set: function set$$1(newValue) {
+      this._contentElement.scrollTop = newValue;
+    }
+  }], [{
+    key: 'observedAttributes',
+    get: function get$$1() {
+      return ['modifier', 'on-infinite-scroll', 'class'];
+    }
+  }, {
+    key: 'events',
+    get: function get$$1() {
+      return ['init', 'show', 'hide', 'destroy'];
+    }
+
+    /**
+     * @property data
+     * @type {*}
+     * @description
+     *   [en]User's custom data passed to `pushPage()`-like methods.[/en]
+     *   [ja][/ja]
+     */
+
+  }]);
+  return PageElement;
+}(BaseElement);
+
+onsElements.Page = PageElement;
+customElements.define('ons-page', PageElement);
+
+/*
+Copyright 2013-2015 ASIAL CORPORATION
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+   http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+*/
+var PopoverAnimator = function (_BaseAnimator) {
+  inherits(PopoverAnimator, _BaseAnimator);
+
+  /**
+   * @param {Object} options
+   * @param {String} options.timing
+   * @param {Number} options.duration
+   * @param {Number} options.delay
+   */
+  function PopoverAnimator() {
+    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
+        _ref$timing = _ref.timing,
+        timing = _ref$timing === undefined ? 'cubic-bezier(.1, .7, .4, 1)' : _ref$timing,
+        _ref$delay = _ref.delay,
+        delay = _ref$delay === undefined ? 0 : _ref$delay,
+        _ref$duration = _ref.duration,
+        duration = _ref$duration === undefined ? 0.2 : _ref$duration;
+
+    classCallCheck(this, PopoverAnimator);
+    return possibleConstructorReturn(this, (PopoverAnimator.__proto__ || Object.getPrototypeOf(PopoverAnimator)).call(this, { timing: timing, delay: delay, duration: duration }));
+  }
+
+  createClass(PopoverAnimator, [{
+    key: 'show',
+    value: function show(popover, callback) {
+      callback();
+    }
+  }, {
+    key: 'hide',
+    value: function hide(popover, callback) {
+      callback();
+    }
+  }, {
+    key: '_animate',
+    value: function _animate(element, _ref2) {
+      var from = _ref2.from,
+          to = _ref2.to,
+          options = _ref2.options,
+          callback = _ref2.callback,
+          _ref2$restore = _ref2.restore,
+          restore = _ref2$restore === undefined ? false : _ref2$restore,
+          animation = _ref2.animation;
+
+      options = util$1.extend({}, this.options, options);
+
+      if (animation) {
+        from = animation.from;
+        to = animation.to;
+      }
+
+      animation = Animit(element);
+      if (restore) {
+        animation = animation.saveStyle();
+      }
+      animation = animation.queue(from).wait(this.delay).queue({
+        css: to,
+        duration: this.duration,
+        timing: this.timing
+      });
+      if (restore) {
+        animation = animation.restoreStyle();
+      }
+      if (callback) {
+        animation = animation.queue(function (done) {
+          callback();
+          done();
+        });
+      }
+      return animation;
+    }
+  }, {
+    key: '_animateAll',
+    value: function _animateAll(element, animations) {
+      var _this2 = this;
+
+      Object.keys(animations).forEach(function (key) {
+        return _this2._animate(element[key], animations[key]).play();
+      });
+    }
+  }]);
+  return PopoverAnimator;
+}(BaseAnimator);
+
+var fade = {
+  out: {
+    from: { opacity: 1.0 },
+    to: { opacity: 0 }
+  },
+  in: {
+    from: { opacity: 0 },
+    to: { opacity: 1.0 }
+  }
+};
+
+var MDFadePopoverAnimator = function (_PopoverAnimator) {
+  inherits(MDFadePopoverAnimator, _PopoverAnimator);
+
+  function MDFadePopoverAnimator() {
+    classCallCheck(this, MDFadePopoverAnimator);
+    return possibleConstructorReturn(this, (MDFadePopoverAnimator.__proto__ || Object.getPrototypeOf(MDFadePopoverAnimator)).apply(this, arguments));
+  }
+
+  createClass(MDFadePopoverAnimator, [{
+    key: 'show',
+    value: function show(popover, callback) {
+      this._animateAll(popover, {
+        _mask: fade.in,
+        _popover: { animation: fade.in, restore: true, callback: callback }
+      });
+    }
+  }, {
+    key: 'hide',
+    value: function hide(popover, callback) {
+      this._animateAll(popover, {
+        _mask: fade.out,
+        _popover: { animation: fade.out, restore: true, callback: callback }
+      });
+    }
+  }]);
+  return MDFadePopoverAnimator;
+}(PopoverAnimator);
+
+var IOSFadePopoverAnimator = function (_MDFadePopoverAnimato) {
+  inherits(IOSFadePopoverAnimator, _MDFadePopoverAnimato);
+
+  function IOSFadePopoverAnimator() {
+    classCallCheck(this, IOSFadePopoverAnimator);
+    return possibleConstructorReturn(this, (IOSFadePopoverAnimator.__proto__ || Object.getPrototypeOf(IOSFadePopoverAnimator)).apply(this, arguments));
+  }
+
+  createClass(IOSFadePopoverAnimator, [{
+    key: 'show',
+    value: function show(popover, callback) {
+      this._animateAll(popover, {
+        _mask: fade.in,
+        _popover: {
+          from: {
+            transform: 'scale3d(1.3, 1.3, 1.0)',
+            opacity: 0
+          },
+          to: {
+            transform: 'scale3d(1.0, 1.0,  1.0)',
+            opacity: 1.0
+          },
+          restore: true,
+          callback: callback
+        }
+      });
+    }
+  }]);
+  return IOSFadePopoverAnimator;
+}(MDFadePopoverAnimator);
+
+/*
+Copyright 2013-2015 ASIAL CORPORATION
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+   http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+*/
+
+var scheme$19 = {
+  '.popover': 'popover--*',
+  '.popover-mask': 'popover-mask--*',
+  '.popover__content': 'popover--*__content',
+  '.popover__arrow': 'popover--*__arrow'
+};
+
+var _animatorDict$6 = {
+  'default': function _default() {
+    return platform.isAndroid() ? MDFadePopoverAnimator : IOSFadePopoverAnimator;
+  },
+  'none': PopoverAnimator,
+  'fade-ios': IOSFadePopoverAnimator,
+  'fade-md': MDFadePopoverAnimator
+};
+
+var positions = {
+  up: 'bottom',
+  left: 'right',
+  down: 'top',
+  right: 'left'
+};
+
+/**
+ * @element ons-popover
+ * @category dialog
+ * @description
+ *  [en]
+ *    A component that displays a popover next to an element. The popover can be used to display extra information about a component or a tooltip.
+ *
+ *    To use the element it can either be attached directly to the `<body>` element or dynamically created from a template using the `ons.createPopover(template)` utility function and the `<template>` tag.
+ *
+ *    Another common way to use the popover is to display a menu when a button on the screen is tapped. For Material Design, popover looks exactly as a dropdown menu.
+ *  [/en]
+ *  [ja]ある要素を対象とするポップオーバーを表示するコンポーネントです。[/ja]
+ * @codepen ZYYRKo
+ * @tutorial vanilla/Reference/popover
+ * @guide theming.html#modifiers [en]More details about the `modifier` attribute[/en][ja]modifier属性の使い方[/ja]
+ * @example
+ * <ons-button onclick="showPopover(this)">
+ *   Click me!
+ * </ons-button>
+ *
+ * <ons-popover direction="down" id="popover">
+ *   <p>This is a popover!</p>
+ * </ons-popover>
+ *
+ * <script>
+ *   var showPopover = function(element) {
+ *     var popover = document.getElementById('popover');
+ *     popover.show(element);
+ *   };
+ * </script>
+ */
+
+var PopoverElement = function (_BaseDialogElement) {
+  inherits(PopoverElement, _BaseDialogElement);
+
+  /**
+   * @event preshow
+   * @description
+   *   [en]Fired just before the popover is displayed.[/en]
+   *   [ja]ポップオーバーが表示される直前に発火します。[/ja]
+   * @param {Object} event [en]Event object.[/en]
+   * @param {Object} event.popover
+   *   [en]Component object.[/en]
+   *   [ja]コンポーネントのオブジェクト。[/ja]
+   * @param {Function} event.cancel
+   *   [en]Call this function to stop the popover from being shown.[/en]
+   *   [ja]この関数を呼び出すと、ポップオーバーの表示がキャンセルされます。[/ja]
+   */
+
+  /**
+   * @event postshow
+   * @description
+   *   [en]Fired just after the popover is displayed.[/en]
+   *   [ja]ポップオーバーが表示された直後に発火します。[/ja]
+   * @param {Object} event [en]Event object.[/en]
+   * @param {Object} event.popover
+   *   [en]Component object.[/en]
+   *   [ja]コンポーネントのオブジェクト。[/ja]
+   */
+
+  /**
+   * @event prehide
+   * @description
+   *   [en]Fired just before the popover is hidden.[/en]
+   *   [ja]ポップオーバーが隠れる直前に発火します。[/ja]
+   * @param {Object} event [en]Event object.[/en]
+   * @param {Object} event.popover
+   *   [en]Component object.[/en]
+   *   [ja]コンポーネントのオブジェクト。[/ja]
+   * @param {Function} event.cancel
+   *   [en]Call this function to stop the popover from being hidden.[/en]
+   *   [ja]この関数を呼び出すと、ポップオーバーが隠れる処理をキャンセルします。[/ja]
+   */
+
+  /**
+   * @event posthide
+   * @description
+   *   [en]Fired just after the popover is hidden.[/en]
+   *   [ja]ポップオーバーが隠れた後に発火します。[/ja]
+   * @param {Object} event [en]Event object.[/en]
+   * @param {Object} event.popover
+   *   [en]Component object.[/en]
+   *   [ja]コンポーネントのオブジェクト。[/ja]
+   */
+
+  /**
+   * @attribute modifier
+   * @type {String}
+   * @description
+   *  [en]The appearance of the popover.[/en]
+   *  [ja]ポップオーバーの表現を指定します。[/ja]
+   */
+
+  /**
+   * @attribute direction
+   * @type {String}
+   * @description
+   *  [en]
+   *    A space separated list of directions. If more than one direction is specified,
+   *    it will be chosen automatically. Valid directions are `"up"`, `"down"`, `"left"` and `"right"`.
+   *  [/en]
+   *  [ja]
+   *    ポップオーバーを表示する方向を空白区切りで複数指定できます。
+   *    指定できる方向は、"up", "down", "left", "right"の4つです。空白区切りで複数指定することもできます。
+   *    複数指定された場合、対象とする要素に合わせて指定した値から自動的に選択されます。
+   *  [/ja]
+   */
+
+  /**
+   * @attribute cancelable
+   * @description
+   *   [en]If this attribute is set the popover can be closed by tapping the background or by pressing the back button.[/en]
+   *   [ja]この属性があると、ポップオーバーが表示された時に、背景やバックボタンをタップした時にをポップオーバー閉じます。[/ja]
+   */
+
+  /**
+   * @attribute cover-target
+   * @description
+   *   [en]If set the popover will cover the target on the screen.[/en]
+   *   [ja][/ja]
+   */
+
+  /**
+   * @attribute animation
+   * @type {String}
+   * @description
+   *   [en]The animation used when showing an hiding the popover. Can be either `"none"`, `"default"`, `"fade-ios"` or `"fade-md"`.[/en]
+   *   [ja]ポップオーバーを表示する際のアニメーション名を指定します。[/ja]
+   */
+
+  /**
+   * @attribute animation-options
+   * @type {Expression}
+   * @description
+   *  [en]Specify the animation's duration, timing and delay with an object literal. E.g. `{duration: 0.2, delay: 1, timing: 'ease-in'}`.[/en]
+   *  [ja]アニメーション時のduration, timing, delayをオブジェクトリテラルで指定します。e.g. {duration: 0.2, delay: 1, timing: 'ease-in'}[/ja]
+   */
+
+  /**
+   * @attribute mask-color
+   * @type {Color}
+   * @description
+   *   [en]Color of the background mask. Default is `"rgba(0, 0, 0, 0.2)"`.[/en]
+   *   [ja]背景のマスクの色を指定します。デフォルトは"rgba(0, 0, 0, 0.2)"です。[/ja]
+   */
+
+  function PopoverElement() {
+    classCallCheck(this, PopoverElement);
+
+    var _this = possibleConstructorReturn(this, (PopoverElement.__proto__ || Object.getPrototypeOf(PopoverElement)).call(this));
+
+    _this._boundOnChange = _this._onChange.bind(_this);
+
+    contentReady(_this, function () {
+      _this._compile();
+      _this.style.display = 'none';
+    });
+    return _this;
+  }
+
+  createClass(PopoverElement, [{
+    key: '_updateAnimatorFactory',
+    value: function _updateAnimatorFactory() {
+      return new AnimatorFactory({
+        animators: _animatorDict$6,
+        baseClass: PopoverAnimator,
+        baseClassName: 'PopoverAnimator',
+        defaultAnimation: this.getAttribute('animation') || 'default'
+      });
+    }
+  }, {
+    key: '_toggleStyle',
+    value: function _toggleStyle(shouldShow) {
+      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
+
+      if (shouldShow) {
+        this.style.display = 'block';
+        this._currentTarget = options.target;
+        this._positionPopover(options.target);
+      } else {
+        this.style.display = 'none';
+        this._clearStyles();
+      }
+    }
+  }, {
+    key: '_positionPopover',
+    value: function _positionPopover(target) {
+      var radius = this._radius,
+          contentElement = this._content,
+          margin = this._margin;
+
+      var safeAreaLengths = iPhoneXPatch.getSafeAreaLengths();
+      var safeAreaRect = iPhoneXPatch.getSafeAreaDOMRect();
+      var targetRect = target.getBoundingClientRect();
+      var isMD = util$1.hasModifier(this, 'material');
+      var cover = isMD && this.hasAttribute('cover-target');
+      var parent = util$1.findParent(this, 'ons-page') || document.body;
+      var parentDimensions = parent.getBoundingClientRect();
+      var maxPositions = {
+        top: Math.max(parentDimensions.top, safeAreaRect.top),
+        left: Math.max(parentDimensions.left, safeAreaRect.left),
+        bottom: Math.min(parentDimensions.bottom, safeAreaRect.bottom),
+        right: Math.min(parentDimensions.right, safeAreaRect.right)
+      };
+
+      // Distance from each side of the safe area (with margin) to the target element
+      var targetDistance = {
+        top: targetRect.top - (maxPositions.top + margin),
+        left: targetRect.left - (maxPositions.left + margin),
+        bottom: maxPositions.bottom - margin - targetRect.bottom,
+        right: maxPositions.right - margin - targetRect.right
+      };
+
+      // Distance from each side of the safe area (with margin) to the geometric center of the target element
+      var targetCenterDistanceFrom = {
+        top: targetRect.top + Math.round(targetRect.height / 2) - (maxPositions.top + margin),
+        left: targetRect.left + Math.round(targetRect.width / 2) - (maxPositions.left + margin),
+        bottom: maxPositions.bottom - margin - targetRect.bottom + Math.round(targetRect.height / 2),
+        right: maxPositions.right - margin - targetRect.right + Math.round(targetRect.width / 2)
+      };
+
+      var _calculateDirections2 = this._calculateDirections(targetDistance),
+          vertical = _calculateDirections2.vertical,
+          primaryDirection = _calculateDirections2.primary,
+          secondaryDirection = _calculateDirections2.secondary;
+
+      this._currentDirection = primaryDirection;
+      util$1.addModifier(this, primaryDirection);
+
+      var sizeName = vertical ? 'width' : 'height';
+      // Get .popover__content size
+      var contentSize = function (style) {
+        return {
+          width: parseInt(style.getPropertyValue('width'), 10),
+          height: parseInt(style.getPropertyValue('height'), 10)
+        };
+      }(window.getComputedStyle(contentElement));
+
+      // Setting .popover position.
+      var targetAndArrowLength = cover ? 0 : (vertical ? targetRect.height : targetRect.width) + (isMD ? 0 : 14);
+      var primaryOffset = Math.max(safeAreaLengths[primaryDirection] + margin, safeAreaLengths[primaryDirection] + margin + targetDistance[primaryDirection] + targetAndArrowLength);
+      var secondaryOffset = Math.max(safeAreaLengths[secondaryDirection] + margin, safeAreaLengths[secondaryDirection] + margin + targetCenterDistanceFrom[secondaryDirection] - contentSize[sizeName] / 2);
+      this._popover.style[primaryDirection] = primaryOffset + 'px';
+      this._popover.style[secondaryDirection] = secondaryOffset + 'px';
+
+      // Setting .popover__arrow position.
+      this._arrow.style[secondaryDirection] = Math.max(radius, safeAreaLengths[secondaryDirection] + margin + targetCenterDistanceFrom[secondaryDirection] - secondaryOffset) + 'px';
+    }
+  }, {
+    key: '_calculateDirections',
+    value: function _calculateDirections(distance) {
+      var options = (this.getAttribute('direction') || 'up down left right').split(/\s+/).map(function (e) {
+        return positions[e];
+      });
+      var primary = options.sort(function (a, b) {
+        return distance[a] - distance[b];
+      })[0];
+      var vertical = 'top' == primary || 'bottom' == primary;
+      var secondary = void 0;
+
+      if (vertical) {
+        secondary = distance.left < distance.right ? 'left' : 'right';
+      } else {
+        secondary = distance.top < distance.bottom ? 'top' : 'bottom';
+      }
+
+      return { vertical: vertical, primary: primary, secondary: secondary };
+    }
+  }, {
+    key: '_clearStyles',
+    value: function _clearStyles() {
+      var _this2 = this;
+
+      this._currentDirection = null;
+      ['top', 'bottom', 'left', 'right'].forEach(function (e) {
+        _this2._arrow.style[e] = _this2._content.style[e] = _this2._popover.style[e] = '';
+        util$1.removeModifier(_this2, e);
+      });
+    }
+  }, {
+    key: '_onChange',
+    value: function _onChange() {
+      var _this3 = this;
+
+      setImmediate(function () {
+        if (_this3._currentTarget) {
+          _this3._positionPopover(_this3._currentTarget);
+        }
+      });
+    }
+  }, {
+    key: '_compile',
+    value: function _compile() {
+      autoStyle.prepare(this);
+
+      if (this._popover && this._mask) {
+        return;
+      }
+
+      var hasDefaultContainer = this._popover && this._content;
+
+      if (hasDefaultContainer) {
+
+        if (!this._mask) {
+          var mask = document.createElement('div');
+          mask.classList.add('popover-mask');
+          this.insertBefore(mask, this.firstChild);
+        }
+
+        if (!this._arrow) {
+          var arrow = document.createElement('div');
+          arrow.classList.add('popover__arrow');
+          this._popover.appendChild(arrow);
+        }
+      } else {
+
+        var template = util$1.createFragment('\n        <div class="popover-mask"></div>\n        <div class="popover">\n          <div class="popover__content"></div>\n          <div class="popover__arrow"></div>\n        </div>\n      ');
+        var content = template.querySelector('.popover__content');
+
+        while (this.childNodes[0]) {
+          content.appendChild(this.childNodes[0]);
+        }
+
+        this.appendChild(template);
+      }
+
+      // FIXME!
+      if (this.hasAttribute('style')) {
+        this._popover.setAttribute('style', this.getAttribute('style'));
+        this.removeAttribute('style');
+      }
+
+      ModifierUtil.initModifier(this, this._scheme);
+    }
+
+    /**
+     * @method show
+     * @signature show(target, [options])
+     * @param {String|Event|HTMLElement} target
+     *   [en]Target element. Can be either a CSS selector, an event object or a DOM element. It can be also provided as 'options.target' instead. [/en]
+     *   [ja]ポップオーバーのターゲットとなる要素を指定します。CSSセレクタかeventオブジェクトかDOM要素のいずれかを渡せます。[/ja]
+     * @param {Object} [options]
+     *   [en]Parameter object.[/en]
+     *   [ja]オプションを指定するオブジェクト。[/ja]
+     * @param {String} [options.animation]
+     *   [en]Animation name.  Use one of `"fade-ios"`, `"fade-md"`, `"none"` and `"default"`.[/en]
+     *   [ja]アニメーション名を指定します。"fade-ios", "fade-md", "none", "default"のいずれかを指定できます。[/ja]
+     * @param {String} [options.animationOptions]
+     *   [en]Specify the animation's duration, delay and timing. E.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}`.[/en]
+     *   [ja]アニメーション時のduration, delay, timingを指定します。e.g. {duration: 0.2, delay: 0.4, timing: 'ease-in'}[/ja]
+     * @param {Function} [options.callback]
+     *   [en]This function is called after the popover has been revealed.[/en]
+     *   [ja]ポップオーバーが表示され終わった後に呼び出される関数オブジェクトを指定します。[/ja]
+     * @description
+     *   [en]Open the popover and point it at a target. The target can be either an event, a CSS selector or a DOM element..[/en]
+     *   [ja]対象とする要素にポップオーバーを表示します。target引数には、$eventオブジェクトやDOMエレメントやCSSセレクタを渡すことが出来ます。[/ja]
+     * @return {Promise}
+     *   [en]Resolves to the displayed element[/en]
+     *   [ja][/ja]
+     */
+
+  }, {
+    key: 'show',
+    value: function show(target) {
+      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
+
+      // Copy options and include options.target
+      if (target && (typeof target === 'undefined' ? 'undefined' : _typeof(target)) === 'object' && !(target instanceof Event) && !(target instanceof HTMLElement)) {
+        options = _extends({}, target);
+      } else {
+        options = _extends({}, options, { target: target });
+      }
+
+      if (typeof options.target === 'string') {
+        options.target = document.querySelector(options.target);
+      } else if (options.target instanceof Event) {
+        options.target = options.target.target;
+      }
+
+      if (!(options.target instanceof HTMLElement)) {
+        util$1.throw('Invalid target type or undefined');
+      }
+
+      return get(PopoverElement.prototype.__proto__ || Object.getPrototypeOf(PopoverElement.prototype), 'show', this).call(this, options);
+    }
+
+    /**
+     * @method hide
+     * @signature hide([options])
+     * @param {Object} [options]
+     *   [en]Parameter object.[/en]
+     *   [ja]オプションを指定するオブジェクト。[/ja]
+     * @param {String} [options.animation]
+     *   [en]Animation name.  Use one of `"fade-ios"`, `"fade-md"`, `"none"` and `"default"`.[/en]
+     *   [ja]アニメーション名を指定します。"fade-ios", "fade-md", "none", "default"のいずれかを指定できます。[/ja]
+     * @param {String} [options.animationOptions]
+     *   [en]Specify the animation's duration, delay and timing. E.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}`.[/en]
+     *   [ja]アニメーション時のduration, delay, timingを指定します。e.g. {duration: 0.2, delay: 0.4, timing: 'ease-in'}[/ja]
+     * @param {Function} [options.callback]
+     *   [en]This functions is called after the popover has been hidden.[/en]
+     *   [ja]ポップオーバーが隠れた後に呼び出される関数オブジェクトを指定します。[/ja]
+     * @description
+     *   [en]Close the popover.[/en]
+     *   [ja]ポップオーバーを閉じます。[/ja]
+     * @return {Promise}
+     *   [en]Resolves to the hidden element[/en]
+     *   [ja][/ja]
+     */
+
+    /**
+     * @property visible
+     * @readonly
+     * @type {Boolean}
+     * @description
+     *   [en]Whether the element is visible or not.[/en]
+     *   [ja]要素が見える場合に`true`。[/ja]
+     */
+
+    /**
+     * @property cancelable
+     * @type {Boolean}
+     * @description
+     *   [en]
+     *     A boolean value that specifies whether the popover is cancelable or not.
+     *
+     *     When the popover is cancelable it can be closed by tapping the background or by pressing the back button on Android devices.
+     *   [/en]
+     *   [ja][/ja]
+     */
+
+    /**
+     * @property onDeviceBackButton
+     * @type {Object}
+     * @description
+     *   [en]Back-button handler.[/en]
+     *   [ja]バックボタンハンドラ。[/ja]
+     */
+
+  }, {
+    key: 'connectedCallback',
+    value: function connectedCallback() {
+      var _this4 = this;
+
+      get(PopoverElement.prototype.__proto__ || Object.getPrototypeOf(PopoverElement.prototype), 'connectedCallback', this).call(this);
+
+      window.addEventListener('resize', this._boundOnChange, false);
+      this._margin = this._margin || parseInt(window.getComputedStyle(this).getPropertyValue('top'));
+      this._margin = this._margin || 6; // Fix for iframes
+
+      contentReady(this, function () {
+        _this4._radius = parseInt(window.getComputedStyle(_this4._content).getPropertyValue('border-top-left-radius'));
+      });
+    }
+  }, {
+    key: 'disconnectedCallback',
+    value: function disconnectedCallback() {
+      get(PopoverElement.prototype.__proto__ || Object.getPrototypeOf(PopoverElement.prototype), 'disconnectedCallback', this).call(this);
+      window.removeEventListener('resize', this._boundOnChange, false);
+    }
+  }, {
+    key: 'attributeChangedCallback',
+    value: function attributeChangedCallback(name, last, current) {
+      if (name === 'direction') {
+        return this._boundOnChange();
+      } else if (name === 'modifier') {
+        this._currentDirection && util$1.addModifier(this, this._currentDirection);
+      }
+      get(PopoverElement.prototype.__proto__ || Object.getPrototypeOf(PopoverElement.prototype), 'attributeChangedCallback', this).call(this, name, last, current);
+    }
+
+    /**
+     * @param {String} name
+     * @param {PopoverAnimator} Animator
+     */
+
+  }, {
+    key: '_scheme',
+    get: function get$$1() {
+      return scheme$19;
+    }
+  }, {
+    key: '_mask',
+    get: function get$$1() {
+      return util$1.findChild(this, '.popover-mask');
+    }
+  }, {
+    key: '_popover',
+    get: function get$$1() {
+      return util$1.findChild(this, '.popover');
+    }
+  }, {
+    key: '_content',
+    get: function get$$1() {
+      return util$1.findChild(this._popover, '.popover__content');
+    }
+  }, {
+    key: '_arrow',
+    get: function get$$1() {
+      return util$1.findChild(this._popover, '.popover__arrow');
+    }
+  }], [{
+    key: 'registerAnimator',
+    value: function registerAnimator(name, Animator) {
+      if (!(Animator.prototype instanceof PopoverAnimator)) {
+        util$1.throwAnimator('Popover');
+      }
+      _animatorDict$6[name] = Animator;
+    }
+  }, {
+    key: 'observedAttributes',
+    get: function get$$1() {
+      return [].concat(toConsumableArray(get(PopoverElement.__proto__ || Object.getPrototypeOf(PopoverElement), 'observedAttributes', this)), ['direction']);
+    }
+  }, {
+    key: 'animators',
+    get: function get$$1() {
+      return _animatorDict$6;
+    }
+  }, {
+    key: 'PopoverAnimator',
+    get: function get$$1() {
+      return PopoverAnimator;
+    }
+  }]);
+  return PopoverElement;
+}(BaseDialogElement);
+
+onsElements.Popover = PopoverElement;
+customElements.define('ons-popover', PopoverElement);
+
+/*
+Copyright 2013-2015 ASIAL CORPORATION
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+   http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+*/
+
+var scheme$20 = {
+  '.progress-bar': 'progress-bar--*',
+  '.progress-bar__primary': 'progress-bar--*__primary',
+  '.progress-bar__secondary': 'progress-bar--*__secondary'
+};
+
+var template = util$1.createElement('\n  <div class="progress-bar">\n    <div class="progress-bar__secondary"></div>\n    <div class="progress-bar__primary"></div>\n  </div>\n');
+
+var INDET = 'indeterminate';
+
+/**
+ * @element ons-progress-bar
+ * @category visual
+ * @modifier material
+ *   [en]Display a Material Design progress bar.[/en]
+ *   [ja]マテリアルデザインのスタイルでプログレスバーを表示します。[/ja]
+ * @description
+ *   [en]
+ *     The component is used to display a linear progress bar. It can either display a progress bar that shows the user how much of a task has been completed. In the case where the percentage is not known it can be used to display an animated progress bar so the user can see that an operation is in progress.
+ *   [/en]
+ *   [ja][/ja]
+ * @codepen zvQbGj
+ * @tutorial vanilla/Reference/progress
+ * @seealso ons-progress-circular
+ *   [en]The `<ons-progress-circular>` component displays a circular progress indicator.[/en]
+ *   [ja][/ja]
+ * @example
+ * <ons-progress-bar
+ *  value="55"
+ *  secondary-value="87">
+ * </ons-progress-bar>
+ *
+ * <ons-progress-bar
+ *  indeterminate>
+ * </ons-progress-bar>
+ */
+
+var ProgressBarElement = function (_BaseElement) {
+  inherits(ProgressBarElement, _BaseElement);
+
+  /**
+   * @attribute modifier
+   * @type {String}
+   * @description
+   *   [en]Change the appearance of the progress indicator.[/en]
+   *   [ja]プログレスインジケータの見た目を変更します。[/ja]
+   */
+
+  /**
+   * @attribute value
+   * @type {Number}
+   * @description
+   *   [en]Current progress. Should be a value between 0 and 100.[/en]
+   *   [ja]現在の進行状況の値を指定します。0から100の間の値を指定して下さい。[/ja]
+   */
+
+  /**
+   * @attribute secondary-value
+   * @type {Number}
+   * @description
+   *   [en]Current secondary progress. Should be a value between 0 and 100.[/en]
+   *   [ja]現在の２番目の進行状況の値を指定します。0から100の間の値を指定して下さい。[/ja]
+   */
+
+  /**
+   * @attribute indeterminate
+   * @description
+   *   [en]If this attribute is set, an infinite looping animation will be shown.[/en]
+   *   [ja]この属性が設定された場合、ループするアニメーションが表示されます。[/ja]
+   */
+
+  function ProgressBarElement() {
+    classCallCheck(this, ProgressBarElement);
+
+    var _this = possibleConstructorReturn(this, (ProgressBarElement.__proto__ || Object.getPrototypeOf(ProgressBarElement)).call(this));
+
+    contentReady(_this, function () {
+      return _this._compile();
+    });
+    return _this;
+  }
+
+  createClass(ProgressBarElement, [{
+    key: '_compile',
+    value: function _compile() {
+      if (!this._isCompiled()) {
+        this._template = template.cloneNode(true);
+      } else {
+        this._template = util$1.findChild(this, '.progress-bar');
+      }
+
+      this._primary = util$1.findChild(this._template, '.progress-bar__primary');
+      this._secondary = util$1.findChild(this._template, '.progress-bar__secondary');
+
+      this._updateDeterminate();
+      this._updateValue();
+
+      this.appendChild(this._template);
+
+      autoStyle.prepare(this);
+      ModifierUtil.initModifier(this, scheme$20);
+    }
+  }, {
+    key: '_isCompiled',
+    value: function _isCompiled() {
+      if (!util$1.findChild(this, '.progress-bar')) {
+        return false;
+      }
+
+      var barElement = util$1.findChild(this, '.progress-bar');
+
+      if (!util$1.findChild(barElement, '.progress-bar__secondary')) {
+        return false;
+      }
+
+      if (!util$1.findChild(barElement, '.progress-bar__primary')) {
+        return false;
+      }
+
+      return true;
+    }
+  }, {
+    key: 'attributeChangedCallback',
+    value: function attributeChangedCallback(name, last, current) {
+      if (name === 'modifier') {
+        ModifierUtil.onModifierChanged(last, current, this, scheme$20);
+        this.hasAttribute(INDET) && this._updateDeterminate();
+      } else if (name === 'value' || name === 'secondary-value') {
+        this._updateValue();
+      } else if (name === INDET) {
+        this._updateDeterminate();
+      }
+    }
+  }, {
+    key: '_updateDeterminate',
+    value: function _updateDeterminate() {
+      var _this2 = this;
+
+      contentReady(this, function () {
+        return util$1.toggleModifier(_this2, INDET, { force: _this2.hasAttribute(INDET) });
+      });
+    }
+  }, {
+    key: '_updateValue',
+    value: function _updateValue() {
+      var _this3 = this;
+
+      contentReady(this, function () {
+        _this3._primary.style.width = _this3.hasAttribute('value') ? _this3.getAttribute('value') + '%' : '0%';
+        _this3._secondary.style.width = _this3.hasAttribute('secondary-value') ? _this3.getAttribute('secondary-value') + '%' : '0%';
+      });
+    }
+
+    /**
+     * @property value
+     * @type {Number}
+     * @description
+     *   [en]Current progress. Should be a value between 0 and 100.[/en]
+     *   [ja]現在の進行状況の値を指定します。0から100の間の値を指定して下さい。[/ja]
+     */
+
+  }, {
+    key: 'value',
+    set: function set$$1(value) {
+      if (typeof value !== 'number' || value < 0 || value > 100) {
+        util$1.throw('Invalid value');
+      }
+
+      this.setAttribute('value', Math.floor(value));
+    },
+    get: function get$$1() {
+      return parseInt(this.getAttribute('value') || '0');
+    }
+
+    /**
+     * @property secondaryValue
+     * @type {Number}
+     * @description
+     *   [en]Current secondary progress. Should be a value between 0 and 100.[/en]
+     *   [ja]現在の２番目の進行状況の値を指定します。0から100の間の値を指定して下さい。[/ja]
+     */
+
+  }, {
+    key: 'secondaryValue',
+    set: function set$$1(value) {
+      if (typeof value !== 'number' || value < 0 || value > 100) {
+        util$1.throw('Invalid value');
+      }
+
+      this.setAttribute('secondary-value', Math.floor(value));
+    },
+    get: function get$$1() {
+      return parseInt(this.getAttribute('secondary-value') || '0');
+    }
+
+    /**
+     * @property indeterminate
+     * @type {Boolean}
+     * @description
+     *   [en]If this property is `true`, an infinite looping animation will be shown.[/en]
+     *   [ja]この属性が設定された場合、ループするアニメーションが表示されます。[/ja]
+     */
+
+  }, {
+    key: 'indeterminate',
+    set: function set$$1(value) {
+      if (value) {
+        this.setAttribute(INDET, '');
+      } else {
+        this.removeAttribute(INDET);
+      }
+    },
+    get: function get$$1() {
+      return this.hasAttribute(INDET);
+    }
+  }], [{
+    key: 'observedAttributes',
+    get: function get$$1() {
+      return ['modifier', 'value', 'secondary-value', INDET];
+    }
+  }]);
+  return ProgressBarElement;
+}(BaseElement);
+
+onsElements.ProgressBar = ProgressBarElement;
+customElements.define('ons-progress-bar', ProgressBarElement);
+
+/*
+Copyright 2013-2015 ASIAL CORPORATION
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+   http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+*/
+
+var scheme$21 = {
+  '.progress-circular': 'progress-circular--*',
+  '.progress-circular__background': 'progress-circular--*__background',
+  '.progress-circular__primary': 'progress-circular--*__primary',
+  '.progress-circular__secondary': 'progress-circular--*__secondary'
+};
+
+var template$1 = util$1.createElement('\n  <svg class="progress-circular">\n    <circle class="progress-circular__background" />\n    <circle class="progress-circular__secondary" cx="50%" cy="50%" r="40%" />\n    <circle class="progress-circular__primary" cx="50%" cy="50%" r="40%" />\n  </svg>\n');
+
+var INDET$1 = 'indeterminate';
+
+/**
+ * @element ons-progress-circular
+ * @category visual
+ * @description
+ *   [en]
+ *     This component displays a circular progress indicator. It can either be used to show how much of a task has been completed or to show a looping animation to indicate that an operation is currently running.
+ *   [/en]
+ *   [ja][/ja]
+ * @codepen EVzMjR
+ * @tutorial vanilla/Reference/progress-circular
+ * @seealso ons-progress-bar
+ *   [en]The `<ons-progress-bar>` component displays a bar progress indicator.[/en]
+ *   [ja][/ja]
+ * @example
+ * <ons-progress-circular
+ *  value="55"
+ *  secondary-value="87">
+ * </ons-progress-circular>
+ *
+ * <ons-progress-circular
+ *  indeterminate>
+ * </ons-progress-circular>
+ */
+
+var ProgressCircularElement = function (_BaseElement) {
+  inherits(ProgressCircularElement, _BaseElement);
+
+  /**
+   * @attribute modifier
+   * @type {String}
+   * @description
+   *   [en]Change the appearance of the progress indicator.[/en]
+   *   [ja]プログレスインジケータの見た目を変更します。[/ja]
+   */
+
+  /**
+   * @attribute value
+   * @type {Number}
+   * @description
+   *   [en]Current progress. Should be a value between 0 and 100.[/en]
+   *   [ja]現在の進行状況の値を指定します。0から100の間の値を指定して下さい。[/ja]
+   */
+
+  /**
+   * @attribute secondary-value
+   * @type {Number}
+   * @description
+   *   [en]Current secondary progress. Should be a value between 0 and 100.[/en]
+   *   [ja]現在の２番目の進行状況の値を指定します。0から100の間の値を指定して下さい。[/ja]
+   */
+
+  /**
+   * @attribute indeterminate
+   * @description
+   *   [en]If this attribute is set, an infinite looping animation will be shown.[/en]
+   *   [ja]この属性が設定された場合、ループするアニメーションが表示されます。[/ja]
+   */
+
+  function ProgressCircularElement() {
+    classCallCheck(this, ProgressCircularElement);
+
+    var _this = possibleConstructorReturn(this, (ProgressCircularElement.__proto__ || Object.getPrototypeOf(ProgressCircularElement)).call(this));
+
+    contentReady(_this, function () {
+      return _this._compile();
+    });
+    return _this;
+  }
+
+  createClass(ProgressCircularElement, [{
+    key: 'attributeChangedCallback',
+    value: function attributeChangedCallback(name, last, current) {
+      if (name === 'modifier') {
+        ModifierUtil.onModifierChanged(last, current, this, scheme$21);
+        this.hasAttribute(INDET$1) && this._updateDeterminate();
+      } else if (name === 'value' || name === 'secondary-value') {
+        this._updateValue();
+      } else if (name === INDET$1) {
+        this._updateDeterminate();
+      }
+    }
+  }, {
+    key: '_updateDeterminate',
+    value: function _updateDeterminate() {
+      var _this2 = this;
+
+      contentReady(this, function () {
+        return util$1.toggleModifier(_this2, INDET$1, { force: _this2.hasAttribute(INDET$1) });
+      });
+    }
+  }, {
+    key: '_updateValue',
+    value: function _updateValue() {
+      var _this3 = this;
+
+      if (this.hasAttribute('value')) {
+        contentReady(this, function () {
+          var per = Math.ceil(_this3.getAttribute('value') * 251.32 * 0.01);
+          _this3._primary.style['stroke-dasharray'] = per + '%, 251.32%';
+        });
+      }
+      if (this.hasAttribute('secondary-value')) {
+        contentReady(this, function () {
+          var per = Math.ceil(_this3.getAttribute('secondary-value') * 251.32 * 0.01);
+          _this3._secondary.style.display = null;
+          _this3._secondary.style['stroke-dasharray'] = per + '%, 251.32%';
+        });
+      } else {
+        contentReady(this, function () {
+          _this3._secondary.style.display = 'none';
+        });
+      }
+    }
+
+    /**
+     * @property value
+     * @type {Number}
+     * @description
+     *   [en]Current progress. Should be a value between 0 and 100.[/en]
+     *   [ja]現在の進行状況の値を指定します。0から100の間の値を指定して下さい。[/ja]
+     */
+
+  }, {
+    key: '_compile',
+    value: function _compile() {
+      if (this._isCompiled()) {
+        this._template = util$1.findChild(this, '.progress-circular');
+      } else {
+        this._template = template$1.cloneNode(true);
+      }
+
+      this._primary = util$1.findChild(this._template, '.progress-circular__primary');
+      this._secondary = util$1.findChild(this._template, '.progress-circular__secondary');
+
+      this._updateDeterminate();
+      this._updateValue();
+
+      this.appendChild(this._template);
+
+      autoStyle.prepare(this);
+      ModifierUtil.initModifier(this, scheme$21);
+    }
+  }, {
+    key: '_isCompiled',
+    value: function _isCompiled() {
+      if (!util$1.findChild(this, '.progress-circular')) {
+        return false;
+      }
+
+      var svg = util$1.findChild(this, '.progress-circular');
+
+      if (!util$1.findChild(svg, '.progress-circular__secondary')) {
+        return false;
+      }
+
+      if (!util$1.findChild(svg, '.progress-circular__primary')) {
+        return false;
+      }
+
+      return true;
+    }
+  }, {
+    key: 'value',
+    set: function set$$1(value) {
+      if (typeof value !== 'number' || value < 0 || value > 100) {
+        util$1.throw('Invalid value');
+      }
+
+      this.setAttribute('value', Math.floor(value));
+    },
+    get: function get$$1() {
+      return parseInt(this.getAttribute('value') || '0');
+    }
+
+    /**
+     * @property secondaryValue
+     * @type {Number}
+     * @description
+     *   [en]Current secondary progress. Should be a value between 0 and 100.[/en]
+     *   [ja]現在の２番目の進行状況の値を指定します。0から100の間の値を指定して下さい。[/ja]
+     */
+
+  }, {
+    key: 'secondaryValue',
+    set: function set$$1(value) {
+      if (typeof value !== 'number' || value < 0 || value > 100) {
+        util$1.throw('Invalid value');
+      }
+
+      this.setAttribute('secondary-value', Math.floor(value));
+    },
+    get: function get$$1() {
+      return parseInt(this.getAttribute('secondary-value') || '0');
+    }
+
+    /**
+     * @property indeterminate
+     * @type {Boolean}
+     * @description
+     *   [en]If this property is `true`, an infinite looping animation will be shown.[/en]
+     *   [ja]この属性が設定された場合、ループするアニメーションが表示されます。[/ja]
+     */
+
+  }, {
+    key: 'indeterminate',
+    set: function set$$1(value) {
+      if (value) {
+        this.setAttribute(INDET$1, '');
+      } else {
+        this.removeAttribute(INDET$1);
+      }
+    },
+    get: function get$$1() {
+      return this.hasAttribute(INDET$1);
+    }
+  }], [{
+    key: 'observedAttributes',
+    get: function get$$1() {
+      return ['modifier', 'value', 'secondary-value', INDET$1];
+    }
+  }]);
+  return ProgressCircularElement;
+}(BaseElement);
+
+onsElements.ProgressCircular = ProgressCircularElement;
+customElements.define('ons-progress-circular', ProgressCircularElement);
+
+/*
+Copyright 2013-2015 ASIAL CORPORATION
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+   http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+*/
+
+var STATE_INITIAL = 'initial';
+var STATE_PREACTION = 'preaction';
+var STATE_ACTION = 'action';
+
+var throwType = function throwType(el, type) {
+  return util$1.throw('"' + el + '" must be ' + type);
+};
+
+/**
+ * @element ons-pull-hook
+ * @category control
+ * @description
+ *   [en]
+ *     Component that adds **Pull to refresh** functionality to an `<ons-page>` element.
+ *
+ *     It can be used to perform a task when the user pulls down at the top of the page. A common usage is to refresh the data displayed in a page.
+ *   [/en]
+ *   [ja][/ja]
+ * @codepen WbJogM
+ * @tutorial vanilla/Reference/pull-hook
+ * @example
+ * <ons-page>
+ *   <ons-pull-hook>
+ *     Release to refresh
+ *   </ons-pull-hook>
+ * </ons-page>
+ *
+ * <script>
+ *   document.querySelector('ons-pull-hook').onAction = function(done) {
+ *     setTimeout(done, 1000);
+ *   };
+ * </script>
+ */
+
+var PullHookElement = function (_BaseElement) {
+  inherits(PullHookElement, _BaseElement);
+
+  /**
+   * @event changestate
+   * @description
+   *   [en]Fired when the state is changed. The state can be either "initial", "preaction" or "action".[/en]
+   *   [ja]コンポーネントの状態が変わった場合に発火します。状態は、"initial", "preaction", "action"のいずれかです。[/ja]
+   * @param {Object} event
+   *   [en]Event object.[/en]
+   *   [ja]イベントオブジェクト。[/ja]
+   * @param {Object} event.pullHook
+   *   [en]Component object.[/en]
+   *   [ja]コンポーネントのオブジェクト。[/ja]
+   * @param {String} event.state
+   *   [en]Current state.[/en]
+   *   [ja]現在の状態名を参照できます。[/ja]
+   */
+
+  /**
+   * @attribute disabled
+   * @description
+   *   [en]If this attribute is set the "pull-to-refresh" functionality is disabled.[/en]
+   *   [ja]この属性がある時、disabled状態になりアクションが実行されなくなります[/ja]
+   */
+
+  /**
+   * @attribute height
+   * @type {String}
+   * @description
+   *   [en]Specify the height of the component. When pulled down further than this value it will switch to the "preaction" state. The default value is "64px".[/en]
+   *   [ja]コンポーネントの高さを指定します。この高さ以上にpull downすると"preaction"状態に移行します。デフォルトの値は"64px"です。[/ja]
+   */
+
+  /**
+   * @attribute threshold-height
+   * @type {String}
+   * @description
+   *   [en]Specify the threshold height. The component automatically switches to the "action" state when pulled further than this value. The default value is "96px". A negative value will disable this property. If this value is lower than the height, it will skip "preaction" state.[/en]
+   *   [ja]閾値となる高さを指定します。この値で指定した高さよりもpull downすると、このコンポーネントは自動的に"action"状態に移行します。[/ja]
+   */
+
+  /**
+   * @attribute fixed-content
+   * @description
+   *   [en]If this attribute is set the content of the page will not move when pulling.[/en]
+   *   [ja]この属性がある時、プルフックが引き出されている時にもコンテンツは動きません。[/ja]
+   */
+
+  function PullHookElement() {
+    classCallCheck(this, PullHookElement);
+
+    var _this = possibleConstructorReturn(this, (PullHookElement.__proto__ || Object.getPrototypeOf(PullHookElement)).call(this));
+
+    _this._shouldFixScroll = util$1.globals.isUIWebView;
+
+    _this._onDrag = _this._onDrag.bind(_this);
+    _this._onDragStart = _this._onDragStart.bind(_this);
+    _this._onDragEnd = _this._onDragEnd.bind(_this);
+    _this._onScroll = _this._onScroll.bind(_this);
+
+    _this._setState(STATE_INITIAL, true);
+    _this._hide(); // Fix for transparent toolbar transitions
+    return _this;
+  }
+
+  createClass(PullHookElement, [{
+    key: '_setStyle',
+    value: function _setStyle() {
+      var height = this.height + 'px';
+      styler(this, { height: height, lineHeight: height });
+      this.style.display === '' && this._show();
+    }
+  }, {
+    key: '_onScroll',
+    value: function _onScroll(event) {
+      var element = this._pageElement;
+
+      if (element.scrollTop < 0) {
+        element.scrollTop = 0;
+      }
+    }
+  }, {
+    key: '_canConsumeGesture',
+    value: function _canConsumeGesture(gesture) {
+      return gesture.direction === 'up' || gesture.direction === 'down';
+    }
+  }, {
+    key: '_onDragStart',
+    value: function _onDragStart(event) {
+      var _this2 = this;
+
+      if (!event.gesture || this.disabled) {
+        return;
+      }
+
+      var tapY = event.gesture.center.clientY + this._pageElement.scrollTop;
+      var maxY = window.innerHeight;
+      // Only use drags that start near the pullHook to reduce flickerings
+      var draggableAreaRatio = this._shouldFixScroll ? .8 : 1;
+
+      this._ignoreDrag = event.consumed || tapY > maxY * draggableAreaRatio;
+
+      if (!this._ignoreDrag) {
+        var consume = event.consume;
+        event.consume = function () {
+          consume && consume();
+          _this2._ignoreDrag = true;
+          // This elements resizes .page__content so it is safer
+          // to hide it when other components are dragged.
+          _this2._hide();
+        };
+
+        if (this._canConsumeGesture(event.gesture)) {
+          consume && consume();
+          event.consumed = true;
+          this._show(); // Not enough due to 'dragLockAxis'
+        }
+      }
+
+      this._startScroll = this._pageElement.scrollTop;
+    }
+  }, {
+    key: '_onDrag',
+    value: function _onDrag(event) {
+      var _this3 = this;
+
+      if (!event.gesture || this.disabled || this._ignoreDrag || !this._canConsumeGesture(event.gesture)) {
+        return;
+      }
+
+      // Necessary due to 'dragLockAxis' (25px)
+      if (this.style.display === 'none') {
+        this._show();
+      }
+
+      event.stopPropagation();
+
+      var tapY = event.gesture.center.clientY + this._pageElement.scrollTop;
+      var maxY = window.innerHeight;
+
+      // Hack to make it work on Android 4.4 WebView and iOS UIWebView. Scrolls manually
+      // near the top of the page so there will be no inertial scroll when scrolling down.
+      // Allowing default scrolling will kill all 'touchmove' events.
+      if (this._shouldFixScroll) {
+        this._pageElement.scrollTop = this._startScroll - event.gesture.deltaY;
+        // Allow inertia when scrolling down below 50% of the view to reduce flickerings
+        if (event.gesture.interimDirection !== 'up' || tapY <= maxY * .5) {
+          event.gesture.preventDefault();
+        }
+      }
+
+      var scroll = Math.max(event.gesture.deltaY - this._startScroll, 0);
+      if (scroll !== this._currentTranslation) {
+
+        var th = this.thresholdHeight;
+        if (th > 0 && scroll >= th) {
+          event.gesture.stopDetect();
+          setImmediate(function () {
+            return _this3._finish();
+          });
+        } else if (scroll >= this.height) {
+          this._setState(STATE_PREACTION);
+        } else {
+          this._setState(STATE_INITIAL);
+        }
+
+        this._translateTo(scroll);
+      }
+    }
+  }, {
+    key: '_onDragEnd',
+    value: function _onDragEnd(event) {
+      if (!event.gesture || this.disabled || this._ignoreDrag) {
+        return;
+      }
+
+      event.stopPropagation();
+
+      if (this._currentTranslation > 0) {
+        var scroll = this._currentTranslation;
+
+        if (scroll > this.height) {
+          this._finish();
+        } else {
+          this._translateTo(0, { animate: true });
+        }
+      }
+    }
+
+    /**
+     * @property onAction
+     * @type {Function}
+     * @description
+     *   [en]This will be called in the `action` state if it exists. The function will be given a `done` callback as it's first argument.[/en]
+     *   [ja][/ja]
+     */
+
+  }, {
+    key: '_finish',
+    value: function _finish() {
+      var _this4 = this;
+
+      this._setState(STATE_ACTION);
+      this._translateTo(this.height, { animate: true });
+      var action = this.onAction || function (done) {
+        return done();
+      };
+      action(function () {
+        _this4._translateTo(0, { animate: true });
+        _this4._setState(STATE_INITIAL);
+      });
+    }
+
+    /**
+     * @property height
+     * @type {Number}
+     * @description
+     *   [en]The height of the pull hook in pixels. The default value is `64px`.[/en]
+     *   [ja][/ja]
+     */
+
+  }, {
+    key: '_setState',
+    value: function _setState(state, noEvent) {
+      var lastState = this.state;
+
+      this.setAttribute('state', state);
+
+      if (!noEvent && lastState !== this.state) {
+        util$1.triggerElementEvent(this, 'changestate', {
+          pullHook: this,
+          state: state,
+          lastState: lastState
+        });
+      }
+    }
+
+    /**
+     * @property state
+     * @readonly
+     * @type {String}
+     * @description
+     *   [en]Current state of the element.[/en]
+     *   [ja][/ja]
+     */
+
+  }, {
+    key: '_show',
+    value: function _show() {
+      var _this5 = this;
+
+      // Run asyncrhonously to avoid conflicts with Animit's style clean
+      setImmediate(function () {
+        _this5.style.display = '';
+        if (_this5._pageElement) {
+          _this5._pageElement.style.marginTop = '-' + _this5.height + 'px';
+        }
+      });
+    }
+  }, {
+    key: '_hide',
+    value: function _hide() {
+      this.style.display = 'none';
+      if (this._pageElement) {
+        this._pageElement.style.marginTop = '';
+      }
+    }
+
+    /**
+     * @param {Number} scroll
+     * @param {Object} options
+     * @param {Function} [options.callback]
+     */
+
+  }, {
+    key: '_translateTo',
+    value: function _translateTo(scroll) {
+      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
+
+      if (this._currentTranslation == 0 && scroll == 0) {
+        return;
+      }
+
+      this._currentTranslation = scroll;
+      var opt = options.animate ? { duration: .3, timing: 'cubic-bezier(.1, .7, .1, 1)' } : {};
+      this._onPull && this._onPull((scroll / this.height).toFixed(2), opt);
+      var scrollElement = this.hasAttribute('fixed-content') ? this : this._pageElement;
+
+      Animit(scrollElement).queue({ transform: 'translate3d(0px, ' + scroll + 'px, 0px)' }, opt).play(function () {
+        scroll === 0 && styler.clear(scrollElement, 'transition transform');
+        options.callback instanceof Function && options.callback();
+      });
+    }
+  }, {
+    key: '_disableDragLock',
+    value: function _disableDragLock() {
+      // e2e tests need it
+      this._dragLockDisabled = true;
+      this._setupListeners(true);
+    }
+  }, {
+    key: '_setupListeners',
+    value: function _setupListeners(add) {
+      var _this6 = this;
+
+      var scrollToggle = function scrollToggle(action) {
+        return _this6._pageElement[action + 'EventListener']('scroll', _this6._onScroll, false);
+      };
+      var gdToggle = function gdToggle(action) {
+        var passive = { passive: true };
+        _this6._gestureDetector[action]('drag', _this6._onDrag, passive);
+        _this6._gestureDetector[action]('dragstart', _this6._onDragStart, passive);
+        _this6._gestureDetector[action]('dragend', _this6._onDragEnd, passive);
+      };
+
+      if (this._gestureDetector) {
+        gdToggle('off');
+        this._gestureDetector.dispose();
+        this._gestureDetector = null;
+      }
+      scrollToggle('remove');
+
+      if (add) {
+        this._gestureDetector = new GestureDetector(this._pageElement, {
+          dragMinDistance: 1,
+          dragDistanceCorrection: false,
+          dragLockToAxis: !this._dragLockDisabled,
+          passive: !this._shouldFixScroll
+        });
+
+        gdToggle('on');
+        scrollToggle('add');
+      }
+    }
+  }, {
+    key: 'connectedCallback',
+    value: function connectedCallback() {
+      this._currentTranslation = 0;
+      this._pageElement = this.parentNode;
+
+      this._setupListeners(true);
+      this._setStyle();
+    }
+  }, {
+    key: 'disconnectedCallback',
+    value: function disconnectedCallback() {
+      this._hide();
+      this._setupListeners(false);
+    }
+  }, {
+    key: 'attributeChangedCallback',
+    value: function attributeChangedCallback(name, last, current) {
+      if (name === 'height' && this._pageElement) {
+        this._setStyle();
+      }
+    }
+  }, {
+    key: 'onAction',
+    get: function get$$1() {
+      return this._onAction;
+    },
+    set: function set$$1(value) {
+      if (value && !(value instanceof Function)) {
+        throwType('onAction', 'function or null');
+      }
+      this._onAction = value;
+    }
+
+    /**
+     * @property onPull
+     * @type {Function}
+     * @description
+     *   [en]Hook called whenever the user pulls the element. It gets the pulled distance ratio (scroll / height) and an animationOptions object as arguments.[/en]
+     *   [ja][/ja]
+     */
+
+  }, {
+    key: 'onPull',
+    get: function get$$1() {
+      return this._onPull;
+    },
+    set: function set$$1(value) {
+      if (value && !(value instanceof Function)) {
+        throwType('onPull', 'function or null');
+      }
+      this._onPull = value;
+    }
+  }, {
+    key: 'height',
+    set: function set$$1(value) {
+      if (!util$1.isInteger(value)) {
+        throwType('height', 'integer');
+      }
+
+      this.setAttribute('height', value + 'px');
+    },
+    get: function get$$1() {
+      return parseInt(this.getAttribute('height') || '64', 10);
+    }
+
+    /**
+     * @property thresholdHeight
+     * @type {Number}
+     * @description
+     *   [en]The thresholdHeight of the pull hook in pixels. The default value is `96px`.[/en]
+     *   [ja][/ja]
+     */
+
+  }, {
+    key: 'thresholdHeight',
+    set: function set$$1(value) {
+      if (!util$1.isInteger(value)) {
+        throwType('thresholdHeight', 'integer');
+      }
+
+      this.setAttribute('threshold-height', value + 'px');
+    },
+    get: function get$$1() {
+      return parseInt(this.getAttribute('threshold-height') || '96', 10);
+    }
+  }, {
+    key: 'state',
+    get: function get$$1() {
+      return this.getAttribute('state');
+    }
+
+    /**
+     * @property pullDistance
+     * @readonly
+     * @type {Number}
+     * @description
+     *   [en]The current number of pixels the pull hook has moved.[/en]
+     *   [ja]現在のプルフックが引き出された距離をピクセル数。[/ja]
+     */
+
+  }, {
+    key: 'pullDistance',
+    get: function get$$1() {
+      return this._currentTranslation;
+    }
+
+    /**
+     * @property disabled
+     * @type {Boolean}
+     * @description
+     *   [en]Whether the element is disabled or not.[/en]
+     *   [ja]無効化されている場合に`true`。[/ja]
+     */
+
+  }, {
+    key: 'disabled',
+    set: function set$$1(value) {
+      return util$1.toggleAttribute(this, 'disabled', value);
+    },
+    get: function get$$1() {
+      return this.hasAttribute('disabled');
+    }
+  }], [{
+    key: 'observedAttributes',
+    get: function get$$1() {
+      return ['height'];
+    }
+  }, {
+    key: 'events',
+    get: function get$$1() {
+      return ['changestate'];
+    }
+  }]);
+  return PullHookElement;
+}(BaseElement);
+
+onsElements.PullHook = PullHookElement;
+customElements.define('ons-pull-hook', PullHookElement);
+
+/*
+Copyright 2013-2015 ASIAL CORPORATION
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+   http://www.apache.org/licenses/LICENSE-2.0
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+*/
+
+var scheme$22 = {
+  '': 'range--*',
+  '.range__input': 'range--*__input',
+  '.range__focus-ring': 'range--*__focus-ring'
+};
+
+var activeClassToken = 'range__input--active';
+
+/**
+ * @element ons-range
+ * @category form
+ * @modifier material
+ *   [en]Material Design slider[/en]
+ *   [ja][/ja]
+ * @description
+ *   [en]
+ *     Range input component. Used to display a draggable slider.
+ *
+ *     Works very similar to the `<input type="range">` element.
+ *   [/en]
+ *   [ja][/ja]
+ * @codepen xZQomM
+ * @tutorial vanilla/Reference/range
+ * @guide theming.html#modifiers [en]More details about the `modifier` attribute[/en][ja]modifier属性の使い方[/ja]
+ * @seealso ons-input
+ *   [en]The `<ons-input>` component is used to display text inputs, radio buttons and checkboxes.[/en]
+ *   [ja][/ja]
+ * @example
+ * <ons-range value="20"></ons-range>
+ * <ons-range modifier="material" value="10"></range>
+ */
+
+var RangeElement = function (_BaseInputElement) {
+  inherits(RangeElement, _BaseInputElement);
+
+  function RangeElement() {
+    classCallCheck(this, RangeElement);
+
+    var _this = possibleConstructorReturn(this, (RangeElement.__proto__ || Object.getPrototypeOf(RangeElement)).call(this));
+
+    _this._onMouseDown = _this._onMouseDown.bind(_this);
+    _this._onMouseUp = _this._onMouseUp.bind(_this);
+    _this._onTouchStart = _this._onTouchStart.bind(_this);
+    _this._onTouchEnd = _this._onTouchEnd.bind(_this);
+    _this._onInput = _this._update.bind(_this);
+    _this._onDragstart = _this._onDragstart.bind(_this);
+    _this._onDragend = _this._onDragend.bind(_this);
+    return _this;
+  }
+
+  createClass(RangeElement, [{
+    key: '_compile',
+    value: function _compile() {
+      get(RangeElement.prototype.__proto__ || Object.getPrototypeOf(RangeElement.prototype), '_compile', this).call(this);
+      this._updateDisabled(this.hasAttribute('disabled'));
+    }
+
+    /* Inherited props */
+
+  }, {
+    key: '_update',
+    value: function _update() {
+      var input = this._input;
+      var focusRing = this._focusRing;
+
+      input.style.backgroundSize = 100 * this._ratio + '% 2px';
+      focusRing.value = this.value;
+
+      // NOTE: "_zero" attribute is used for CSS styling.
+      if (input.min === '' && input.value === '0' || input.min === input.value) {
+        input.setAttribute('_zero', '');
+      } else {
+        input.removeAttribute('_zero');
+      }
+
+      ['min', 'max'].forEach(function (attr) {
+        return focusRing[attr] = input[attr];
+      });
+    }
+  }, {
+    key: '_onMouseDown',
+
+
+    /* Own props */
+
+    value: function _onMouseDown(e) {
+      var _this2 = this;
+
+      this._input.classList.add(activeClassToken);
+      setImmediate(function () {
+        return _this2._input.focus();
+      });
+    }
+  }, {
+    key: '_onTouchStart',
+    value: function _onTouchStart(e) {
+      this._onMouseDown();
+    }
+  }, {
+    key: '_onMouseUp',
+    value: function _onMouseUp(e) {
+      this._input.classList.remove(activeClassToken);
+    }
+  }, {
+    key: '_onTouchEnd',
+    value: function _onTouchEnd(e) {
+      this._onMouseUp(e);
+    }
+  }, {
+    key: '_onDragstart',
+    value: function _onDragstart(e) {
+      e.consumed = true;
+      e.gesture.stopPropagation();
+      this._input.classList.add(activeClassToken);
+      this.addEventListener('drag', this._onDrag);
+    }
+  }, {
+    key: '_onDrag',
+    value: function _onDrag(e) {
+      e.stopPropagation();
+    }
+  }, {
+    key: '_onDragend',
+    value: function _onDragend(e) {
+      this._input.classList.remove(activeClassToken);
+      this.removeEventListener('drag', this._onDrag);
+    }
+  }, {
+    key: 'attributeChangedCallback',
+    value: function attributeChangedCallback(name, last, current) {
+      if (name === 'disabled') {
+        this._updateDisabled(current);
+      }
+      get(RangeElement.prototype.__proto__ || Object.getPrototypeOf(RangeElement.prototype), 'attributeChangedCallback', this).call(this, name, last, current);
+    }
+
+    /**
+     * @param {boolean} disabled
+     */
+
+  }, {
+    key: '_updateDisabled',
+    value: function _updateDisabled(disabled) {
+      if (disabled) {
+        this.classList.add('range--disabled');
+      } else {
+        this.classList.remove('range--disabled');
+      }
+    }
+  }, {
+    key: 'connectedCallback',
+    value: function connectedCallback() {
+      this._setupListeners(true);
+    }
+  }, {
+    key: 'disconnectedCallback',
+    value: function disconnectedCallback() {
+      this._setupListeners(false);
+    }
+  }, {
+    key: '_setupListeners',
+    value: function _setupListeners(add) {
+      var action = (add ? 'add' : 'remove') + 'EventListener';
+      util$1[action](this, 'touchstart', this._onTouchStart, { passive: true });
+      this[action]('mousedown', this._onMouseDown);
+      this[action]('mouseup', this._onMouseUp);
+      this[action]('touchend', this._onTouchEnd);
+      this[action]('dragstart', this._onDragstart);
+      this[action]('dragend', this._onDragend);
+      this[action]('input', this._onInput);
+    }
+
+    /**
+     * @attribute disabled
+     * @description
+     *   [en]Whether the element is disabled or not.[/en]
+     *   [ja]無効化されている場合に`true`。[/ja]
+     */
+
+    /**
+     * @property disabled
+     * @type {Boolean}
+     * @description
+     *   [en]Whether the element is disabled or not.[/en]
+     *   [ja]無効化されている場合に`true`。[/ja]
+     */
+
+    /**
+     * @property value
+     * @type {Number}
+     * @description
+     *   [en]Current value.[/en]
+     *   [ja][/ja]
+     */
+
+  }, {
+    key: '_scheme',
+    get: function get$$1() {
+      return scheme$22;
+    }
+  }, {
+    key: '_template',
+    get: function get$$1() {
+      return '\n      <input type="' + this.type + '" class="' + this._defaultClassName + '__input">\n      <input type="range" class="range__focus-ring" tabIndex="-1">\n    ';
+    }
+  }, {
+    key: '_defaultClassName',
+    get: function get$$1() {
+      return 'range';
+    }
+  }, {
+    key: 'type',
+    get: function get$$1() {
+      return 'range';
+    }
+  }, {
+    key: '_focusRing',
+    get: function get$$1() {
+      return this.children[1];
+    }
+  }, {
+    key: '_ratio',
+    get: function get$$1() {
+      // Returns the current ratio.
+      var min = this._input.min === '' ? 0 : parseInt(this._input.min);
+      var max = this._input.max === '' ? 100 : parseInt(this._input.max);
+
+      return (this.value - min) / (max - min);
+    }
+  }], [{
+    key: 'observedAttributes',
+    get: function get$$1() {
+      return ['disabled'].concat(toConsumableArray(BaseInputElement.observedAttributes));
+    }
+  }]);
+  return RangeElement;
+}(BaseInputElement);
+
+onsElements.Range = RangeElement;
+customElements.define('ons-range', RangeElement);
+
+/*
+Copyright 2013-2016 ASIAL CORPORATION
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+   http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+*/
+
+/**
+ * @class AnimatorCSS - implementation of Animator class using css transitions
+ */
+
+var AnimatorCSS = function () {
+  createClass(AnimatorCSS, [{
+    key: 'animate',
+
+
+    /**
+     * @method animate
+     * @desc main animation function
+     * @param {Element} element
+     * @param {Object} finalCSS
+     * @param {number} [duration=200] - duration in milliseconds
+     * @return {Object} result
+     * @return {Function} result.then(callback) - sets a callback to be executed after the animation has stopped
+     * @return {Function} result.stop(options) - stops the animation; if options.stopNext is true then it doesn't call the callback
+     * @return {Function} result.finish(ms) - finishes the animation in the specified time in milliseconds
+     * @return {Function} result.speed(ms) - sets the animation speed so that it finishes as if the original duration was the one specified here
+     * @example
+     * ````
+     *  var result = animator.animate(el, {opacity: 0.5}, 1000);
+     *
+     *  el.addEventListener('click', function(e){
+     *    result.speed(200).then(function(){
+     *      console.log('done');
+     *    });
+     *  }, 300);
+     * ````
+     */
+    value: function animate(el, final) {
+      var duration = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 200;
+
+      var start = new Date().getTime(),
+          initial = {},
+          stopped = false,
+          next = false,
+          timeout = false,
+          properties = Object.keys(final);
+
+      var updateStyles = function updateStyles() {
+        var s = window.getComputedStyle(el);
+        properties.forEach(s.getPropertyValue.bind(s));
+        s = el.offsetHeight;
+      };
+
+      var result = {
+        stop: function stop() {
+          var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
+
+          timeout && clearTimeout(timeout);
+          var k = Math.min(1, (new Date().getTime() - start) / duration);
+          properties.forEach(function (i) {
+            el.style[i] = (1 - k) * initial[i] + k * final[i] + (i == 'opacity' ? '' : 'px');
+          });
+          el.style.transitionDuration = '0s';
+
+          if (options.stopNext) {
+            next = false;
+          } else if (!stopped) {
+            stopped = true;
+            next && next();
+          }
+          return result;
+        },
+        then: function then(cb) {
+          next = cb;
+          if (stopped) {
+            next && next();
+          }
+          return result;
+        },
+        speed: function speed(newDuration) {
+          if (internal$1.config.animationsDisabled) {
+            newDuration = 0;
+          }
+          if (!stopped) {
+            timeout && clearTimeout(timeout);
+
+            var passed = new Date().getTime() - start;
+            var k = passed / duration;
+            var remaining = newDuration * (1 - k);
+
+            properties.forEach(function (i) {
+              el.style[i] = (1 - k) * initial[i] + k * final[i] + (i == 'opacity' ? '' : 'px');
+            });
+
+            updateStyles();
+
+            start = el.speedUpTime;
+            duration = remaining;
+
+            el.style.transitionDuration = duration / 1000 + 's';
+
+            properties.forEach(function (i) {
+              el.style[i] = final[i] + (i == 'opacity' ? '' : 'px');
+            });
+
+            timeout = setTimeout(result.stop, remaining);
+          }
+          return result;
+        },
+        finish: function finish() {
+          var milliseconds = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 50;
+
+          var k = (new Date().getTime() - start) / duration;
+
+          result.speed(milliseconds / (1 - k));
+          return result;
+        }
+      };
+
+      if (el.hasAttribute('disabled') || stopped || internal$1.config.animationsDisabled) {
+        return result;
+      }
+
+      var style = window.getComputedStyle(el);
+      properties.forEach(function (e) {
+        var v = parseFloat(style.getPropertyValue(e));
+        initial[e] = isNaN(v) ? 0 : v;
+      });
+
+      if (!stopped) {
+        el.style.transitionProperty = properties.join(',');
+        el.style.transitionDuration = duration / 1000 + 's';
+
+        properties.forEach(function (e) {
+          el.style[e] = final[e] + (e == 'opacity' ? '' : 'px');
+        });
+      }
+
+      timeout = setTimeout(result.stop, duration);
+      this._onStopAnimations(el, result.stop);
+
+      return result;
+    }
+  }]);
+
+  function AnimatorCSS() {
+    classCallCheck(this, AnimatorCSS);
+
+    this._queue = [];
+    this._index = 0;
+  }
+
+  createClass(AnimatorCSS, [{
+    key: '_onStopAnimations',
+    value: function _onStopAnimations(el, listener) {
+      var queue = this._queue;
+      var i = this._index++;
+      queue[el] = queue[el] || [];
+      queue[el][i] = function (options) {
+        delete queue[el][i];
+        if (queue[el] && queue[el].length == 0) {
+          delete queue[el];
+        }
+        return listener(options);
+      };
+    }
+
+    /**
+    * @method stopAnimations
+    * @desc stops active animations on a specified element
+    * @param {Element|Array} element - element or array of elements
+    * @param {Object} [options={}]
+    * @param {Boolean} [options.stopNext] - the callbacks after the animations won't be called if this option is true
+    */
+
+  }, {
+    key: 'stopAnimations',
+    value: function stopAnimations(el) {
+      var _this = this;
+
+      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
+
+      if (Array.isArray(el)) {
+        return el.forEach(function (el) {
+          _this.stopAnimations(el, options);
+        });
+      }
+
+      (this._queue[el] || []).forEach(function (e) {
+        e(options || {});
+      });
+    }
+
+    /**
+    * @method stopAll
+    * @desc stops all active animations
+    * @param {Object} [options={}]
+    * @param {Boolean} [options.stopNext] - the callbacks after the animations won't be called if this option is true
+    */
+
+  }, {
+    key: 'stopAll',
+    value: function stopAll() {
+      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
+
+      this.stopAnimations(Object.keys(this._queue), options);
+    }
+
+    /**
+    * @method fade
+    * @desc fades the element (short version for animate(el, {opacity: 0}))
+    * @param {Element} element
+    * @param {number} [duration=200]
+    */
+
+  }, {
+    key: 'fade',
+    value: function fade(el) {
+      var duration = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 200;
+
+      return this.animate(el, { opacity: 0 }, duration);
+    }
+  }]);
+  return AnimatorCSS;
+}();
+
+/*
+Copyright 2013-2015 ASIAL CORPORATION
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+   http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+*/
+
+var defaultClassName$11 = 'ripple';
+var scheme$23 = {
+  '': 'ripple--*',
+  '.ripple__wave': 'ripple--*__wave',
+  '.ripple__background': 'ripple--*__background'
+};
+
+/**
+ * @element ons-ripple
+ * @category visual
+ * @description
+ *   [en]
+ *     Adds a Material Design "ripple" effect to an element. The ripple effect will spread from the position where the user taps.
+ *
+ *     Some elements such as `<ons-button>` and `<ons-fab>`  support a `ripple` attribute.
+ *   [/en]
+ *   [ja]マテリアルデザインのリップル効果をDOM要素に追加します。[/ja]
+ * @codepen wKQWdZ
+ * @tutorial vanilla/Reference/ripple
+ * @modifier light-gray
+ *   [en]Change the color of effects to light gray.[/en]
+ *   [ja]エフェクトの色が明るい灰色になります。[/ja]
+ * @guide theming.html#cross-platform-styling-autostyling
+ *  [en]Cross platform styling[/en]
+ *  [ja]Cross platform styling[/ja]
+ * @example
+ * <div class="my-div">
+ *  <ons-ripple></ons-ripple>
+ * </div>
+ *
+ * @example
+ * <ons-button ripple>Click me!</ons-button>
+ */
+
+var RippleElement = function (_BaseElement) {
+  inherits(RippleElement, _BaseElement);
+
+  /**
+   * @attribute color
+   * @type {String}
+   * @description
+   *   [en]Color of the ripple effect.[/en]
+   *   [ja]リップルエフェクトの色を指定します。[/ja]
+   */
+
+  /**
+   * @attribute modifier
+   * @type {String}
+   * @description
+   *   [en]The appearance of the ripple effect.[/en]
+   *   [ja]エフェクトの表現を指定します。[/ja]
+   */
+
+  /**
+   * @attribute background
+   * @type {String}
+   * @description
+   *   [en]Color of the background.[/en]
+   *   [ja]背景の色を設定します。[/ja]
+   */
+
+  /**
+   * @attribute size
+   * @type {String}
+   * @description
+   *   [en]Sizing of the wave on ripple effect. Set "cover" or "contain". Default is "cover".[/en]
+   *   [ja]エフェクトのサイズを指定します。"cover"もしくは"contain"を指定します。デフォルトは"cover"です。[/ja]
+   */
+
+  /**
+   * @attribute center
+   * @type {Boolean}
+   * @description
+   *   [en]If this attribute presents, change the position of wave effect to center of the target element.[/en]
+   *   [ja]この要素を設定すると、エフェクトの位置が要素の真ん中から始まります。[/ja]
+   */
+
+  /**
+   * @attribute disabled
+   * @description
+   *   [en]If this attribute is set, the ripple effect will be disabled.[/en]
+   *   [ja]この属性が設定された場合、リップルエフェクトは無効になります。[/ja]
+   */
+
+  function RippleElement() {
+    classCallCheck(this, RippleElement);
+
+    var _this = possibleConstructorReturn(this, (RippleElement.__proto__ || Object.getPrototypeOf(RippleElement)).call(this));
+
+    _this._onTap = _this._onTap.bind(_this);
+    _this._onHold = _this._onHold.bind(_this);
+    _this._onDragStart = _this._onDragStart.bind(_this);
+    _this._onRelease = _this._onRelease.bind(_this);
+
+    contentReady(_this, function () {
+      return _this._compile();
+    });
+
+    _this._animator = new AnimatorCSS();
+
+    ['color', 'center', 'start-radius', 'background', 'modifier'].forEach(function (e) {
+      _this.attributeChangedCallback(e, null, _this.getAttribute(e));
+    });
+    return _this;
+  }
+
+  createClass(RippleElement, [{
+    key: '_compile',
+    value: function _compile() {
+      this.classList.add(defaultClassName$11);
+
+      this._wave = this.getElementsByClassName('ripple__wave')[0];
+      this._background = this.getElementsByClassName('ripple__background')[0];
+
+      if (!(this._background && this._wave)) {
+        this._wave = util$1.create('.ripple__wave');
+        this._background = util$1.create('.ripple__background');
+
+        this.appendChild(this._wave);
+        this.appendChild(this._background);
+      }
+
+      ModifierUtil.initModifier(this, scheme$23);
+    }
+  }, {
+    key: '_getEffectSize',
+    value: function _getEffectSize() {
+      var sizes = ['cover', 'contain'];
+      if (this.hasAttribute('size')) {
+        var size = this.getAttribute('size');
+        if (sizes.indexOf(size) !== -1) {
+          return size;
+        }
+      }
+
+      return 'cover';
+    }
+  }, {
+    key: '_calculateCoords',
+    value: function _calculateCoords(e) {
+      var x = void 0,
+          y = void 0,
+          h = void 0,
+          w = void 0,
+          r = void 0;
+      var b = this.getBoundingClientRect();
+      var size = this._getEffectSize();
+      var error = function error() {
+        return util$1.throw('Ripple invalid state');
+      };
+
+      if (this._center) {
+        x = b.width / 2;
+        y = b.height / 2;
+
+        if (size === 'cover') {
+          r = Math.sqrt(x * x + y * y);
+        } else if (size === 'contain') {
+          r = Math.min(x, y);
+        } else {
+          error();
+        }
+      } else {
+        x = (typeof e.clientX === 'number' ? e.clientX : e.changedTouches[0].clientX) - b.left;
+        y = (typeof e.clientY === 'number' ? e.clientY : e.changedTouches[0].clientY) - b.top;
+        h = Math.max(y, b.height - y);
+        w = Math.max(x, b.width - x);
+
+        if (size === 'cover') {
+          r = Math.sqrt(h * h + w * w);
+        } else if (size === 'contain') {
+          r = Math.min(Math.round(h / 2), Math.round(w / 2));
+        } else {
+          error();
+        }
+      }
+
+      return { x: x, y: y, r: r };
+    }
+  }, {
+    key: '_rippleAnimation',
+    value: function _rippleAnimation(e) {
+      var duration = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 300;
+      var _animator = this._animator,
+          _wave = this._wave,
+          _background = this._background,
+          _minR = this._minR;
+
+      var _calculateCoords2 = this._calculateCoords(e),
+          x = _calculateCoords2.x,
+          y = _calculateCoords2.y,
+          r = _calculateCoords2.r;
+
+      _animator.stopAll({ stopNext: 1 });
+      _animator.animate(_background, { opacity: 1 }, duration);
+
+      util$1.extend(_wave.style, {
+        opacity: 1,
+        top: y - _minR + 'px',
+        left: x - _minR + 'px',
+        width: 2 * _minR + 'px',
+        height: 2 * _minR + 'px'
+      });
+
+      return _animator.animate(_wave, {
+        top: y - r,
+        left: x - r,
+        height: 2 * r,
+        width: 2 * r
+      }, duration);
+    }
+  }, {
+    key: '_updateParent',
+    value: function _updateParent() {
+      if (!this._parentUpdated && this.parentNode) {
+        var computedStyle = window.getComputedStyle(this.parentNode);
+        if (computedStyle.getPropertyValue('position') === 'static') {
+          this.parentNode.style.position = 'relative';
+        }
+        this._parentUpdated = true;
+      }
+    }
+  }, {
+    key: '_onTap',
+    value: function _onTap(e) {
+      var _this2 = this;
+
+      if (!this.disabled && !e.ripple) {
+        e.ripple = true;
+        this._updateParent();
+        this._rippleAnimation(e.gesture.srcEvent).then(function () {
+          _this2._animator.fade(_this2._wave);
+          _this2._animator.fade(_this2._background);
+        });
+      }
+    }
+  }, {
+    key: '_onHold',
+    value: function _onHold(e) {
+      if (!this.disabled && !e.ripple) {
+        e.ripple = true;
+        this._updateParent();
+        this._holding = this._rippleAnimation(e.gesture.srcEvent, 2000);
+        document.addEventListener('release', this._onRelease);
+      }
+    }
+  }, {
+    key: '_onRelease',
+    value: function _onRelease(e) {
+      var _this3 = this;
+
+      if (this._holding && !e.ripple) {
+        e.ripple = true;
+        this._holding.speed(300).then(function () {
+          _this3._animator.stopAll({ stopNext: true });
+          _this3._animator.fade(_this3._wave);
+          _this3._animator.fade(_this3._background);
+        });
+
+        this._holding = false;
+      }
+
+      document.removeEventListener('release', this._onRelease);
+    }
+  }, {
+    key: '_onDragStart',
+    value: function _onDragStart(e) {
+      if (this._holding) {
+        return this._onRelease(e);
+      }
+      if (['left', 'right'].indexOf(e.gesture.direction) != -1) {
+        this._onTap(e);
+      }
+    }
+  }, {
+    key: 'connectedCallback',
+    value: function connectedCallback() {
+      this._parentNode = this.parentNode;
+
+      if (internal$1.config.animationsDisabled) {
+        this.disabled = true;
+      } else {
+        this._parentNode.addEventListener('tap', this._onTap);
+        this._parentNode.addEventListener('hold', this._onHold);
+        this._parentNode.addEventListener('dragstart', this._onDragStart);
+      }
+    }
+  }, {
+    key: 'disconnectedCallback',
+    value: function disconnectedCallback() {
+      var pn = this._parentNode || this.parentNode;
+      pn.removeEventListener('tap', this._onTap);
+      pn.removeEventListener('hold', this._onHold);
+      pn.removeEventListener('dragstart', this._onDragStart);
+    }
+  }, {
+    key: 'attributeChangedCallback',
+    value: function attributeChangedCallback(name, last, current) {
+      var _this4 = this;
+
+      switch (name) {
+
+        case 'class':
+          util$1.restoreClass(this, defaultClassName$11, scheme$23);
+          break;
+
+        case 'modifier':
+          ModifierUtil.onModifierChanged(last, current, this, scheme$23);
+          break;
+
+        case 'start-radius':
+          this._minR = Math.max(0, parseFloat(current) || 0);
+          break;
+
+        case 'color':
+          if (current) {
+            contentReady(this, function () {
+              _this4._wave.style.background = current;
+              if (!_this4.hasAttribute('background')) {
+                _this4._background.style.background = current;
+              }
+            });
+          }
+          break;
+
+        case 'background':
+          if (current || last) {
+            if (current === 'none') {
+              contentReady(this, function () {
+                _this4._background.setAttribute('disabled', 'disabled');
+                _this4._background.style.background = 'transparent';
+              });
+            } else {
+              contentReady(this, function () {
+                if (_this4._background.hasAttribute('disabled')) {
+                  _this4._background.removeAttribute('disabled');
+                }
+                _this4._background.style.background = current;
+              });
+            }
+          }
+          break;
+
+        case 'center':
+          if (name === 'center') {
+            this._center = current != null && current != 'false';
+          }
+          break;
+
+      }
+    }
+
+    /**
+     * @property disabled
+     * @type {Boolean}
+     * @description
+     *   [en]Whether the element is disabled or not.[/en]
+     *   [ja]無効化されている場合に`true`。[/ja]
+     */
+
+  }, {
+    key: 'disabled',
+    set: function set$$1(value) {
+      return util$1.toggleAttribute(this, 'disabled', value);
+    },
+    get: function get$$1() {
+      return this.hasAttribute('disabled');
+    }
+  }], [{
+    key: 'observedAttributes',
+    get: function get$$1() {
+      return ['start-radius', 'color', 'background', 'center', 'class', 'modifier'];
+    }
+  }]);
+  return RippleElement;
+}(BaseElement);
+
+onsElements.Ripple = RippleElement;
+customElements.define('ons-ripple', RippleElement);
+
+/*
+Copyright 2013-2015 ASIAL CORPORATION
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+   http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+*/
+
+/**
+ * @element ons-row
+ * @category grid
+ * @description
+ *   [en]Represents a row in the grid system. Use with `<ons-col>` to layout components.[/en]
+ *   [ja]グリッドシステムにて行を定義します。ons-colとともに使用し、コンポーネントの配置に使用します。[/ja]
+ * @codepen GgujC {wide}
+ * @guide theming.html
+ *   [en]Layouting guide[/en]
+ *   [ja]レイアウト調整[/ja]
+ * @seealso ons-col
+ *   [en]The `<ons-col>` component is used as children of `<ons-row>`.[/en]
+ *   [ja]ons-colコンポーネント[/ja]
+ * @note
+ *   [en]For Android 4.3 and earlier, and iOS6 and earlier, when using mixed alignment with ons-row and ons-col, they may not be displayed correctly. You can use only one vertical-align.[/en]
+ *   [ja]Android 4.3以前、もしくはiOS 6以前のOSの場合、ons-rowとons-colを組み合わせてそれぞれのons-col要素のvertical-align属性の値に別々の値を指定すると、描画が崩れる場合があります。vertical-align属性の値には一つの値だけを指定できます。[/ja]
+ * @example
+ * <ons-row>
+ *   <ons-col width="50px"><ons-icon icon="fa-twitter"></ons-icon></ons-col>
+ *   <ons-col>Text</ons-col>
+ * </ons-row>
+ */
+
+/**
+ * @attribute vertical-align
+ * @type {String}
+ * @description
+ *   [en]Short hand attribute for aligning vertically. Valid values are top, bottom, and center.[/en]
+ *   [ja]縦に整列するために指定します。top、bottom、centerのいずれかを指定できます。[/ja]
+ */
+
+var RowElement = function (_BaseElement) {
+  inherits(RowElement, _BaseElement);
+
+  function RowElement() {
+    classCallCheck(this, RowElement);
+    return possibleConstructorReturn(this, (RowElement.__proto__ || Object.getPrototypeOf(RowElement)).apply(this, arguments));
+  }
+
+  return RowElement;
+}(BaseElement);
+
+onsElements.Row = RowElement;
+customElements.define('ons-row', RowElement);
+
+/*
+Copyright 2013-2015 ASIAL CORPORATION
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+   http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+*/
+
+var defaultClassName$12 = 'segment';
+var scheme$24 = {
+  '': 'segment--*',
+  '.segment__item': 'segment--*__item',
+  '.segment__input': 'segment--*__input',
+  '.segment__button': 'segment--*__button'
+};
+
+var generateId$1 = function () {
+  var i = 0;
+  return function () {
+    return 'ons-segment-gen-' + i++;
+  };
+}();
+
+/**
+ * @element ons-segment
+ * @category control
+ * @modifier material
+ *   [en]Material Design segment[/en]
+ *   [ja][/ja]
+ * @description
+ *   [en]
+ *     Segment component. Use this component to have a button bar with automatic styles that switch on click of another button.
+ *
+ *     Will automatically display as a Material Design segment on Android.
+ *   [/en]
+ *   [ja][/ja]
+ * @codepen hLayx
+ * @tutorial vanilla/Reference/segment
+ * @guide theming.html#modifiers [en]More details about the `modifier` attribute[/en][ja]modifier属性の使い方[/ja]
+ * @guide theming.html#cross-platform-styling-autostyling [en]Information about cross platform styling[/en][ja]Information about cross platform styling[/ja]
+ * @example
+ * <ons-segment>
+ *   <ons-button>Label 1</ons-button>
+ *   <ons-button>Label 2</ons-button>
+ *   <ons-button>Label 3</ons-button>
+ * </ons-segment>
+ */
+
+var SegmentElement = function (_BaseElement) {
+  inherits(SegmentElement, _BaseElement);
+
+  /**
+   * @event postchange
+   * @description
+   *   [en]Fires after the active button is changed.[/en]
+   *   [ja][/ja]
+   * @param {Object} event
+   *   [en]Event object.[/en]
+   *   [ja][/ja]
+   * @param {Number} event.index
+   *   [en]Tapped button index.[/en]
+   *   [ja][/ja]
+   * @param {Object} event.segmentItem
+   *   [en]Segment item object.[/en]
+   *   [ja][/ja]
+   */
+
+  /**
+   * @attribute modifier
+   * @type {String}
+   * @description
+   *  [en]The appearance of the segment.[/en]
+   *  [ja][/ja]
+   */
+
+  /**
+   * @attribute tabbar-id
+   * @initonly
+   * @type {String}
+   * @description
+   *  [en]ID of the tabbar element to "connect" to the segment. Must be inside the same page.[/en]
+   *  [ja][/ja]
+   */
+
+  /**
+   * @attribute active-index
+   * @initonly
+   * @default 0
+   * @type {Number}
+   * @description
+   *  [en]Index of the first active button, only works if there is no connected tabbar (in which case the active tab sets the active button).[/en]
+   *  [ja][/ja]
+   */
+
+  /**
+   * @attribute disabled
+   * @description
+   *   [en]Specify if segment should be disabled.[/en]
+   *   [ja]ボタンを無効化する場合は指定します。[/ja]
+   */
+
+  function SegmentElement() {
+    classCallCheck(this, SegmentElement);
+
+    var _this = possibleConstructorReturn(this, (SegmentElement.__proto__ || Object.getPrototypeOf(SegmentElement)).call(this));
+
+    _this._segmentId = generateId$1();
+    _this._tabbar = null;
+    _this._onChange = _this._onChange.bind(_this);
+    _this._onTabbarPreChange = _this._onTabbarPreChange.bind(_this);
+
+    contentReady(_this, function () {
+      _this._compile();
+      setImmediate(function () {
+        return _this._lastActiveIndex = _this._tabbar ? _this._tabbar.getActiveTabIndex() : _this.getActiveButtonIndex();
+      });
+    });
+    return _this;
+  }
+
+  createClass(SegmentElement, [{
+    key: '_compile',
+    value: function _compile() {
+      autoStyle.prepare(this);
+      this.classList.add(defaultClassName$12);
+
+      for (var index = this.children.length - 1; index >= 0; index--) {
+        var item = this.children[index];
+        item.classList.add('segment__item');
+
+        var input = util$1.findChild(item, '.segment__input') || util$1.create('input.segment__input');
+        input.type = 'radio';
+        input.value = index;
+        input.name = input.name || this._segmentId;
+        input.checked = !this.hasAttribute('tabbar-id') && index === (parseInt(this.getAttribute('active-index')) || 0);
+
+        var button = util$1.findChild(item, '.segment__button') || util$1.create('.segment__button');
+        if (button.parentElement !== item) {
+          while (item.firstChild) {
+            button.appendChild(item.firstChild);
+          }
+        }
+
+        item.appendChild(input);
+        item.appendChild(button);
+      }
+
+      ModifierUtil.initModifier(this, scheme$24);
+    }
+  }, {
+    key: 'connectedCallback',
+    value: function connectedCallback() {
+      var _this2 = this;
+
+      contentReady(this, function () {
+        if (_this2.hasAttribute('tabbar-id')) {
+          var page = util$1.findParent(_this2, 'ons-page');
+          _this2._tabbar = page && page.querySelector('#' + _this2.getAttribute('tabbar-id'));
+          if (!_this2._tabbar || _this2._tabbar.tagName !== 'ONS-TABBAR') {
+            util$1.throw('No tabbar with id ' + _this2.getAttribute('tabbar-id') + ' was found.');
+          }
+
+          _this2._tabbar.setAttribute('hide-tabs', '');
+          setImmediate(function () {
+            return _this2._setChecked(_this2._tabbar.getActiveTabIndex());
+          });
+
+          _this2._tabbar.addEventListener('prechange', _this2._onTabbarPreChange);
+        }
+      });
+
+      this.addEventListener('change', this._onChange);
+    }
+  }, {
+    key: 'disconnectedCallback',
+    value: function disconnectedCallback() {
+      var _this3 = this;
+
+      contentReady(this, function () {
+        if (_this3._tabbar) {
+          _this3._tabbar.removeEventListener('prechange', _this3._onTabbarPreChange);
+          _this3._tabbar = null;
+        }
+      });
+      this.removeEventListener('change', this._onChange);
+    }
+  }, {
+    key: '_setChecked',
+    value: function _setChecked(index) {
+      this.children[index].firstElementChild.checked = true;
+    }
+
+    /**
+     * @method setActiveButton
+     * @signature setActiveButton(index, [options])
+     * @param {Number} index
+     *   [en]Button index.[/en]
+     *   [ja][/ja]
+     * @param {Object} [options]
+     *   [en]Parameter object, works only if there is a connected tabbar. Supports the same options as `ons-tabbar`'s `setActiveTab` method.[/en]
+     *   [ja][/ja]
+     * @description
+     *   [en]Make button with the specified index active. If there is a connected tabbar it shows the corresponding tab page. In this case animations and their options can be specified by the second parameter.[/en]
+     *   [ja][/ja]
+     * @return {Promise}
+     *   [en]Resolves to the selected index or to the new page element if there is a connected tabbar.[/en]
+     *   [ja][/ja]
+     */
+
+  }, {
+    key: 'setActiveButton',
+    value: function setActiveButton(index, options) {
+      if (this._tabbar) {
+        return this._tabbar.setActiveTab(index, options);
+      }
+
+      this._setChecked(index);
+      this._postChange(index);
+      return Promise.resolve(index);
+    }
+
+    /**
+     * @method getActiveButtonIndex
+     * @signature getActiveButtonIndex()
+     * @return {Number}
+     *   [en]The index of the currently active button.[/en]
+     *   [ja][/ja]
+     * @description
+     *   [en]Returns button index of current active button. If active button is not found, returns -1.[/en]
+     *   [ja][/ja]
+     */
+
+  }, {
+    key: 'getActiveButtonIndex',
+    value: function getActiveButtonIndex() {
+      for (var i = this.children.length - 1; i >= 0; i--) {
+        // Array.findIndex
+        if (this.children[i].firstElementChild.checked) {
+          return i;
+        }
+      }
+      return -1;
+    }
+  }, {
+    key: '_onChange',
+    value: function _onChange(event) {
+      event.stopPropagation();
+      this._tabbar ? this._tabbar.setActiveTab(this.getActiveButtonIndex(), { reject: false }) : this._postChange(this.getActiveButtonIndex());
+    }
+  }, {
+    key: '_onTabbarPreChange',
+    value: function _onTabbarPreChange(event) {
+      var _this4 = this;
+
+      setImmediate(function () {
+        if (!event.detail.canceled) {
+          _this4._setChecked(event.index);
+          _this4._postChange(event.index);
+        }
+      });
+    }
+  }, {
+    key: '_postChange',
+    value: function _postChange(index) {
+      util$1.triggerElementEvent(this, 'postchange', {
+        index: index,
+        activeIndex: index,
+        lastActiveIndex: this._lastActiveIndex,
+        segmentItem: this.children[index]
+      });
+      this._lastActiveIndex = index;
+    }
+
+    /**
+     * @property disabled
+     * @type {Boolean}
+     * @description
+     *   [en]Whether the segment is disabled or not.[/en]
+     *   [ja]無効化されている場合に`true`。[/ja]
+     */
+
+  }, {
+    key: 'attributeChangedCallback',
+    value: function attributeChangedCallback(name, last, current) {
+      switch (name) {
+        case 'class':
+          util$1.restoreClass(this, defaultClassName$12, scheme$24);
+          break;
+        case 'modifier':
+          ModifierUtil.onModifierChanged(last, current, this, scheme$24);
+          break;
+      }
+    }
+  }, {
+    key: 'disabled',
+    set: function set$$1(value) {
+      return util$1.toggleAttribute(this, 'disabled', value);
+    },
+    get: function get$$1() {
+      return this.hasAttribute('disabled');
+    }
+  }], [{
+    key: 'observedAttributes',
+    get: function get$$1() {
+      return ['class', 'modifier'];
+    }
+  }, {
+    key: 'events',
+    get: function get$$1() {
+      return ['postchange'];
+    }
+  }]);
+  return SegmentElement;
+}(BaseElement);
+
+onsElements.Segment = SegmentElement;
+customElements.define('ons-segment', SegmentElement);
+
+/*
+Copyright 2013-2015 ASIAL CORPORATION
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+   http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+*/
+
+var scheme$25 = {
+  '': 'select-* select--*',
+  '.select-input': 'select-input--*'
+};
+
+var defaultClassName$13 = 'select';
+
+var INPUT_ATTRIBUTES$1 = ['autofocus', 'disabled', 'form', 'multiple', 'name', 'required', 'size'];
+
+/**
+ * @element ons-select
+ * @category form
+ * @modifier material
+ *  [en]Displays a Material Design select input.[/en]
+ *  [ja][/ja]
+ * @modifier underbar
+ *  [en]Displays a horizontal line underneath a select input.[/en]
+ *  [ja][/ja]
+ * @description
+ *   [en]
+ *     Select component. If you want to place a select with an ID of `my-id` on a page, use `<ons-select select-id="my-id">`.
+ *
+ *     The component will automatically display as a Material Design select on Android.
+ *
+ *     Most attributes that can be used for a normal `<select>` element can also be used on the `<ons-select>` element.
+ *   [/en]
+ *   [ja]セレクトボックスを表示するコンポーネントです。`select` 要素に使用できる属性の多くが `ons-select` 要素でも利用できます。[/ja]
+ * @codepen hLayx
+ * @tutorial vanilla/Reference/select
+ * @guide theming.html#modifiers [en]More details about the `modifier` attribute[/en][ja]modifier属性の使い方[/ja]
+ * @guide theming.html#cross-platform-styling-autostyling [en]Information about cross platform styling[/en][ja]Information about cross platform styling[/ja]
+ * @example
+ * <ons-select>
+ *   <option value="1">1</option>
+ *   <option value="2">2nd</option>
+ *   <option value="3">3rd option</option>
+ * </ons-select>
+ */
+
+var SelectElement = function (_BaseElement) {
+  inherits(SelectElement, _BaseElement);
+
+  /**
+   * @attribute autofocus
+   * @type {Boolean}
+   * @default false
+   * @description
+   *  [en]Element automatically gains focus on page load.[/en]
+   *  [ja]ページロード時にこのセレクトボックスにフォーカスが移るようにします。[/ja]
+   */
+
+  /**
+   * @attribute disabled
+   * @type {Boolean}
+   * @default false
+   * @description
+   *   [en]Specify if select input should be disabled.[/en]
+   *   [ja]このセレクトボックスを無効化する場合に指定します。[/ja]
+   */
+
+  /**
+   * @attribute form
+   * @type {String}
+   * @description
+   *   [en]Associate a select element to an existing form on the page, even if not nested.[/en]
+   *   [ja]このセレクトボックスを、指定した `form` 要素に紐付けます。セレクトボックスを `form` 要素の外側に配置する際に使用します。[/ja]
+   */
+
+  /**
+   * @attribute multiple
+   * @type {Boolean}
+   * @default false
+   * @description
+   *  [en]If this attribute is defined, multiple options can be selected at once.[/en]
+   *  [ja]選択肢の複数選択を有効にします。[/ja]
+   */
+
+  /**
+   * @attribute name
+   * @type {String}
+   * @description
+   *   [en]Name the select element, useful for instance if it is part of a form.[/en]
+   *   [ja]このセレクトボックスの名前を指定します。通常 `form` 要素と共に使用します。[/ja]
+   */
+
+  /**
+   * @attribute required
+   * @type {Boolean}
+   * @description
+   *   [en]Make the select input required for submitting the form it is part of.[/en]
+   *   [ja]このセレクトボックスを入力必須にする場合に指定します。通常 `form` 要素と共に使用します。[/ja]
+   */
+
+  /**
+   * @attribute select-id
+   * @type {String}
+   * @description
+   *   [en]ID given to the inner select, useful for dynamic manipulation.[/en]
+   *   [ja]このセレクトボックスが内部に持つ select 要素に与える ID を指定します。セレクトボックスの内容を動的に変更する必要がある場合に使用します。[/ja]
+   */
+
+  /**
+   * @attribute size
+   * @type {Number}
+   * @default 1
+   * @description
+   *   [en]How many options are displayed; if there are more than the size then a scroll appears to navigate them.[/en]
+   *   [ja]一度に表示する選択肢の個数を指定します。選択肢がこの属性で指定した個数よりも多い場合、スクロールが有効になります。[/ja]
+   */
+
+  function SelectElement() {
+    classCallCheck(this, SelectElement);
+
+    var _this = possibleConstructorReturn(this, (SelectElement.__proto__ || Object.getPrototypeOf(SelectElement)).call(this));
+
+    contentReady(_this, function () {
+      return _this._compile();
+    });
+
+    _this._deriveGetters();
+    return _this;
+  }
+
+  createClass(SelectElement, [{
+    key: 'attributeChangedCallback',
+    value: function attributeChangedCallback(name, last, current) {
+      var _this2 = this;
+
+      switch (name) {
+        case 'class':
+          util$1.restoreClass(this, defaultClassName$13, scheme$25);
+          break;
+        case 'modifier':
+          ModifierUtil.onModifierChanged(last, current, this, scheme$25);
+          break;
+      }
+
+      if (INPUT_ATTRIBUTES$1.indexOf(name) >= 0) {
+        contentReady(this, function () {
+          return _this2._updateBoundAttributes();
+        });
+      }
+    }
+  }, {
+    key: '_updateBoundAttributes',
+    value: function _updateBoundAttributes() {
+      var _this3 = this;
+
+      INPUT_ATTRIBUTES$1.forEach(function (attr) {
+        if (_this3.hasAttribute(attr)) {
+          _this3._select.setAttribute(attr, _this3.getAttribute(attr));
+        } else {
+          _this3._select.removeAttribute(attr);
+        }
+      });
+    }
+
+    /**
+     * @property length
+     * @description
+     *   [en]Number of options in the select box.[/en]
+     *   [ja]このセレクトボックスに含まれる選択肢の個数を返します。 `select` 要素[/ja]
+     */
+
+    /**
+     * @property options
+     * @description
+     *   [en]Several options for handling the select DOM object.[/en]
+     *   [ja]このセレクトボックスに含まれる `option` 要素の配列を返します。[/ja]
+     */
+
+    /**
+     * @property selectedIndex
+     * @description
+     *   [en]Index of the currently selected option.[/en]
+     *   [ja]現在選択されている選択肢のインデックスを返します。[/ja]
+     */
+
+    /**
+     * @property value
+     * @description
+     *   [en]Value of the currently selected option.[/en]
+     *   [ja]現在選択されている選択肢の値を返します。[/ja]
+     */
+
+  }, {
+    key: '_compile',
+    value: function _compile() {
+      autoStyle.prepare(this);
+
+      this.classList.add(defaultClassName$13);
+      var sel = this._select || document.createElement('select');
+      if (!sel.id && this.hasAttribute('select-id')) {
+        sel.id = this.getAttribute('select-id');
+      }
+      sel.classList.add('select-input');
+      if (!this._select) {
+        util$1.arrayFrom(this.childNodes).forEach(function (element) {
+          return sel.appendChild(element);
+        });
+        this.appendChild(sel);
+      }
+
+      ModifierUtil.initModifier(this, scheme$25);
+    }
+  }, {
+    key: '_deriveGetters',
+    value: function _deriveGetters() {
+      var _this4 = this;
+
+      ['disabled', 'length', 'multiple', 'name', 'options', 'selectedIndex', 'size', 'value', 'form', 'type'].forEach(function (key) {
+        Object.defineProperty(_this4, key, {
+          configurable: true,
+          enumerable: true,
+          get: function get$$1() {
+            return _this4._select[key];
+          },
+          set: ['form', 'type'].indexOf(key) === -1 ? function (value) {
+            return contentReady(_this4, function () {
+              return _this4._select[key] = value;
+            });
+          } : undefined
+        });
+      });
+    }
+  }, {
+    key: 'add',
+    value: function add(option) {
+      var index = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
+
+      this._select.add(option, index);
+    }
+  }, {
+    key: 'remove',
+    value: function remove(index) {
+      this._select.remove(index);
+    }
+  }, {
+    key: '_select',
+    get: function get$$1() {
+      return this.querySelector('select');
+    }
+  }], [{
+    key: 'observedAttributes',
+    get: function get$$1() {
+      return ['modifier', 'class'].concat(INPUT_ATTRIBUTES$1);
+    }
+  }]);
+  return SelectElement;
+}(BaseElement);
+
+onsElements.Select = SelectElement;
+customElements.define('ons-select', SelectElement);
+
+/*
+Copyright 2013-2015 ASIAL CORPORATION
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+   http://www.apache.org/licenses/LICENSE-2.0
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+*/
+
+var defaultClassName$14 = 'fab fab--mini speed-dial__item';
+
+var scheme$26 = {
+  '': 'fab--* speed-dial__item--*'
+};
+
+/**
+ * @element ons-speed-dial-item
+ * @category control
+ * @description
+ *   [en]
+ *     This component displays the child elements of the Material Design Speed dial component.
+ *   [/en]
+ *   [ja]
+ *     Material DesignのSpeed dialの子要素を表現する要素です。
+ *   [/ja]
+ * @codepen dYQYLg
+ * @tutorial vanilla/Reference/speed-dial
+ * @seealso ons-speed-dial
+ *   [en]The `<ons-speed-dial>` component.[/en]
+ *   [ja]ons-speed-dialコンポーネント[/ja]
+ * @seealso ons-fab
+ *   [en]ons-fab component[/en]
+ *   [ja]ons-fabコンポーネント[/ja]
+ * @example
+ * <ons-speed-dial position="left bottom">
+ *   <ons-fab>
+ *     <ons-icon icon="fa-twitter"></ons-icon>
+ *   </ons-fab>
+ *   <ons-speed-dial-item>A</ons-speed-dial-item>
+ *   <ons-speed-dial-item>B</ons-speed-dial-item>
+ *   <ons-speed-dial-item>C</ons-speed-dial-item>
+ * </ons-speed-dial>
+ */
+
+var SpeedDialItemElement = function (_BaseElement) {
+  inherits(SpeedDialItemElement, _BaseElement);
+
+  /**
+   * @attribute modifier
+   * @type {String}
+   * @description
+   *   [en]The appearance of the component.[/en]
+   *   [ja]このコンポーネントの表現を指定します。[/ja]
+   */
+
+  /**
+   * @attribute ripple
+   * @description
+   *  [en]If this attribute is defined, the button will have a ripple effect when tapped.[/en]
+   *  [ja][/ja]
+   */
+
+  function SpeedDialItemElement() {
+    classCallCheck(this, SpeedDialItemElement);
+
+    var _this = possibleConstructorReturn(this, (SpeedDialItemElement.__proto__ || Object.getPrototypeOf(SpeedDialItemElement)).call(this));
+
+    _this._compile();
+    _this._boundOnClick = _this._onClick.bind(_this);
+    return _this;
+  }
+
+  createClass(SpeedDialItemElement, [{
+    key: 'attributeChangedCallback',
+    value: function attributeChangedCallback(name, last, current) {
+      switch (name) {
+        case 'class':
+          util$1.restoreClass(this, defaultClassName$14, scheme$26);
+          break;
+        case 'modifier':
+          ModifierUtil.onModifierChanged(last, current, this, scheme$26);
+          util$1.addModifier(this, 'mini');
+          break;
+        case 'ripple':
+          this._updateRipple();
+      }
+    }
+  }, {
+    key: 'connectedCallback',
+    value: function connectedCallback() {
+      this.addEventListener('click', this._boundOnClick, false);
+    }
+  }, {
+    key: 'disconnectedCallback',
+    value: function disconnectedCallback() {
+      this.removeEventListener('click', this._boundOnClick, false);
+    }
+  }, {
+    key: '_updateRipple',
+    value: function _updateRipple() {
+      util$1.updateRipple(this);
+    }
+  }, {
+    key: '_onClick',
+    value: function _onClick(e) {
+      e.stopPropagation();
+    }
+  }, {
+    key: '_compile',
+    value: function _compile() {
+      var _this2 = this;
+
+      autoStyle.prepare(this);
+
+      defaultClassName$14.split(/\s+/).forEach(function (token) {
+        return _this2.classList.add(token);
+      });
+
+      util$1.addModifier(this, 'mini');
+      this._updateRipple();
+
+      ModifierUtil.initModifier(this, scheme$26);
+    }
+  }], [{
+    key: 'observedAttributes',
+    get: function get$$1() {
+      return ['modifier', 'ripple', 'class'];
+    }
+  }]);
+  return SpeedDialItemElement;
+}(BaseElement);
+
+onsElements.SpeedDialItem = SpeedDialItemElement;
+customElements.define('ons-speed-dial-item', SpeedDialItemElement);
+
+/*
+Copyright 2013-2015 ASIAL CORPORATION
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+   http://www.apache.org/licenses/LICENSE-2.0
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+*/
+
+var defaultClassName$15 = 'speed-dial';
+var scheme$27 = {
+  '': 'speed-dial--*'
+};
+
+/**
+ * @element ons-speed-dial
+ * @category control
+ * @description
+ *   [en]
+ *     Element that displays a Material Design Speed Dialog component. It is useful when there are more than one primary action that can be performed in a page.
+ *
+ *     The Speed dial looks like a `<ons-fab>` element but will expand a menu when tapped.
+ *   [/en]
+ *   [ja][/ja]
+ * @codepen dYQYLg
+ * @tutorial vanilla/Reference/speed-dial
+ * @seealso ons-speed-dial-item
+ *   [en]The `<ons-speed-dial-item>` represents a menu item.[/en]
+ *   [ja]ons-speed-dial-itemコンポーネント[/ja]
+ * @seealso ons-fab
+ *   [en]ons-fab component[/en]
+ *   [ja]ons-fabコンポーネント[/ja]
+ * @example
+ * <ons-speed-dial position="left bottom">
+ *   <ons-fab>
+ *     <ons-icon icon="fa-twitter"></ons-icon>
+ *   </ons-fab>
+ *   <ons-speed-dial-item>A</ons-speed-dial-item>
+ *   <ons-speed-dial-item>B</ons-speed-dial-item>
+ *   <ons-speed-dial-item>C</ons-speed-dial-item>
+ * </ons-speed-dial>
+ */
+
+var SpeedDialElement = function (_BaseElement) {
+  inherits(SpeedDialElement, _BaseElement);
+
+  /**
+   * @event open
+   * @description
+   *   [en]Fired when the menu items are shown.[/en]
+   *   [ja][/ja]
+   */
+
+  /**
+   * @event close
+   * @description
+   *   [en]Fired when the menu items are hidden.[/en]
+   *   [ja][/ja]
+   */
+
+  /**
+   * @attribute modifier
+   * @type {String}
+   * @description
+   *   [en]The appearance of the component.[/en]
+   *   [ja]このコンポーネントの表現を指定します。[/ja]
+   */
+
+  /**
+   * @attribute ripple
+   * @description
+   *  [en]If this attribute is defined, the button will have a ripple effect when tapped.[/en]
+   *  [ja][/ja]
+   */
+
+  /**
+   * @attribute position
+   * @type {String}
+   * @description
+   *   [en]
+   *     Specify the vertical and horizontal position of the component.
+   *     I.e. to display it in the top right corner specify "right top".
+   *     Choose from "right", "left", "top" and "bottom".
+   *   [/en]
+   *   [ja]
+   *     この要素を表示する左右と上下の位置を指定します。
+   *     例えば、右上に表示する場合には"right top"を指定します。
+   *     左右と上下の位置の指定には、rightとleft、topとbottomがそれぞれ指定できます。
+   *   [/ja]
+   */
+
+  /**
+   * @attribute direction
+   * @type {String}
+   * @description
+   *   [en]Specify the direction the items are displayed. Possible values are "up", "down", "left" and "right".[/en]
+   *   [ja]
+   *     要素が表示する方向を指定します。up, down, left, rightが指定できます。
+   *   [/ja]
+   */
+
+  /**
+   * @attribute disabled
+   * @description
+   *   [en]Specify if button should be disabled.[/en]
+   *   [ja]無効化する場合に指定します。[/ja]
+   */
+
+  function SpeedDialElement() {
+    classCallCheck(this, SpeedDialElement);
+
+    var _this = possibleConstructorReturn(this, (SpeedDialElement.__proto__ || Object.getPrototypeOf(SpeedDialElement)).call(this));
+
+    contentReady(_this, function () {
+      _this._compile();
+    });
+
+    _this._itemShown = false;
+    _this._boundOnClick = _this._onClick.bind(_this);
+    return _this;
+  }
+
+  createClass(SpeedDialElement, [{
+    key: '_compile',
+    value: function _compile() {
+      this.classList.add(defaultClassName$15);
+      autoStyle.prepare(this);
+      this._updateRipple();
+      ModifierUtil.initModifier(this, scheme$27);
+
+      if (this.hasAttribute('direction')) {
+        this._updateDirection(this.getAttribute('direction'));
+      } else {
+        this._updateDirection('up');
+      }
+
+      this._updatePosition();
+    }
+  }, {
+    key: 'attributeChangedCallback',
+    value: function attributeChangedCallback(name, last, current) {
+      var _this2 = this;
+
+      switch (name) {
+        case 'class':
+          util$1.restoreClass(this, defaultClassName$15, scheme$27);
+          break;
+        case 'modifier':
+          ModifierUtil.onModifierChanged(last, current, this, scheme$27);
+          break;
+        case 'ripple':
+          contentReady(this, function () {
+            return _this2._updateRipple();
+          });
+          break;
+        case 'direction':
+          contentReady(this, function () {
+            return _this2._updateDirection(current);
+          });
+          break;
+        case 'position':
+          contentReady(this, function () {
+            return _this2._updatePosition();
+          });
+          break;
+      }
+    }
+  }, {
+    key: 'connectedCallback',
+    value: function connectedCallback() {
+      this.addEventListener('click', this._boundOnClick, false);
+    }
+  }, {
+    key: 'disconnectedCallback',
+    value: function disconnectedCallback() {
+      this.removeEventListener('click', this._boundOnClick, false);
+    }
+  }, {
+    key: '_onClick',
+    value: function _onClick(e) {
+      if (this.onClick) {
+        this.onClick.apply(this);
+        return Promise.resolve();
+      } else if (!this.disabled && this.visible) {
+        return this.toggleItems();
+      }
+    }
+  }, {
+    key: '_show',
+    value: function _show() {
+      if (!this.inline) {
+        return this.show();
+      }
+      return Promise.resolve();
+    }
+  }, {
+    key: '_hide',
+    value: function _hide() {
+      var _this3 = this;
+
+      return new Promise(function (resolve) {
+        if (!_this3.inline) {
+          setImmediate(function () {
+            return _this3.hide().then(resolve);
+          });
+        } else {
+          resolve();
+        }
+      });
+    }
+  }, {
+    key: '_updateRipple',
+    value: function _updateRipple() {
+      if (this._fab) {
+        this.hasAttribute('ripple') ? this._fab.setAttribute('ripple', '') : this._fab.removeAttribute('ripple');
+      }
+    }
+  }, {
+    key: '_updateDirection',
+    value: function _updateDirection(direction) {
+      var children = this.items;
+      for (var i = 0; i < children.length; i++) {
+        styler(children[i], {
+          transitionDelay: 25 * i + 'ms',
+          bottom: 'auto',
+          right: 'auto',
+          top: 'auto',
+          left: 'auto'
+        });
+      }
+      switch (direction) {
+        case 'up':
+          for (var _i = 0; _i < children.length; _i++) {
+            children[_i].style.bottom = 72 + 56 * _i + 'px';
+            children[_i].style.right = '8px';
+          }
+          break;
+        case 'down':
+          for (var _i2 = 0; _i2 < children.length; _i2++) {
+            children[_i2].style.top = 72 + 56 * _i2 + 'px';
+            children[_i2].style.left = '8px';
+          }
+          break;
+        case 'left':
+          for (var _i3 = 0; _i3 < children.length; _i3++) {
+            children[_i3].style.top = '8px';
+            children[_i3].style.right = 72 + 56 * _i3 + 'px';
+          }
+          break;
+        case 'right':
+          for (var _i4 = 0; _i4 < children.length; _i4++) {
+            children[_i4].style.top = '8px';
+            children[_i4].style.left = 72 + 56 * _i4 + 'px';
+          }
+          break;
+        default:
+          util$1.throw('Argument must be one of up, down, left or right.');
+      }
+    }
+  }, {
+    key: '_updatePosition',
+    value: function _updatePosition() {
+      var position = this.getAttribute('position');
+      this.classList.remove('fab--top__left', 'fab--bottom__right', 'fab--bottom__left', 'fab--top__right', 'fab--top__center', 'fab--bottom__center');
+      switch (position) {
+        case 'top right':
+        case 'right top':
+          this.classList.add('fab--top__right');
+          break;
+        case 'top left':
+        case 'left top':
+          this.classList.add('fab--top__left');
+          break;
+        case 'bottom right':
+        case 'right bottom':
+          this.classList.add('fab--bottom__right');
+          break;
+        case 'bottom left':
+        case 'left bottom':
+          this.classList.add('fab--bottom__left');
+          break;
+        case 'center top':
+        case 'top center':
+          this.classList.add('fab--top__center');
+          break;
+        case 'center bottom':
+        case 'bottom center':
+          this.classList.add('fab--bottom__center');
+          break;
+        default:
+          break;
+      }
+    }
+  }, {
+    key: '_getTranslate',
+    value: function _getTranslate() {
+      var isBottom = (this.getAttribute('position') || '').indexOf('bottom') >= 0;
+      var translate = isBottom ? 'translate3d(0px, -' + (util$1.globals.fabOffset || 0) + 'px, 0px) ' : '';
+      return translate;
+    }
+
+    /**
+     * @method show
+     * @signature show()
+     * @description
+     *   [en]Show the speed dial.[/en]
+     *   [ja]Speed dialを表示します。[/ja]
+     */
+
+  }, {
+    key: 'show',
+    value: function show() {
+      this._fab.show();
+      styler(this, { transform: this._getTranslate });
+      return Promise.resolve();
+    }
+
+    /**
+     * @method hide
+     * @signature hide()
+     * @description
+     *   [en]Hide the speed dial.[/en]
+     *   [ja]Speed dialを非表示にします。[/ja]
+     */
+
+  }, {
+    key: 'hide',
+    value: function hide() {
+      var _this4 = this;
+
+      return this.hideItems().then(function () {
+        return _this4._fab.hide();
+      });
+    }
+
+    /**
+     * @method showItems
+     * @signature showItems()
+     * @description
+     *   [en]Show the speed dial items.[/en]
+     *   [ja]Speed dialの子要素を表示します。[/ja]
+     */
+
+  }, {
+    key: 'showItems',
+    value: function showItems() {
+      if (this.hasAttribute('direction')) {
+        this._updateDirection(this.getAttribute('direction'));
+      } else {
+        this._updateDirection('up');
+      }
+
+      var totalDelay = 0;
+      if (!this._itemShown) {
+        var children = this.items;
+        for (var i = 0; i < children.length; i++) {
+          var delay = 25 * i;
+          totalDelay += delay;
+          styler(children[i], {
+            transform: 'scale(1)',
+            transitionDelay: delay + 'ms'
+          });
+        }
+        totalDelay += 50;
+
+        this._itemShown = true;
+        util$1.triggerElementEvent(this, 'open');
+      }
+
+      var deferred = util$1.defer();
+      setTimeout(deferred.resolve, totalDelay);
+      return deferred.promise;
+    }
+
+    /**
+     * @method hideItems
+     * @signature hideItems()
+     * @description
+     *   [en]Hide the speed dial items.[/en]
+     *   [ja]Speed dialの子要素を非表示にします。[/ja]
+     */
+
+  }, {
+    key: 'hideItems',
+    value: function hideItems() {
+      var totalDelay = 0;
+      if (this._itemShown) {
+        var children = this.items;
+        for (var i = 0; i < children.length; i++) {
+          var delay = 25 * (children.length - i);
+          totalDelay += delay;
+          styler(children[i], {
+            transform: 'scale(0)',
+            transitionDelay: delay + 'ms'
+          });
+        }
+        totalDelay += 50;
+
+        this._itemShown = false;
+        util$1.triggerElementEvent(this, 'close');
+      }
+
+      var deferred = util$1.defer();
+      setTimeout(deferred.resolve, totalDelay);
+      return deferred.promise;
+    }
+
+    /**
+     * @property disabled
+     * @type {Boolean}
+     * @description
+     *   [en]Whether the element is disabled or not.[/en]
+     *   [ja]無効化されている場合に`true`。[/ja]
+     */
+
+  }, {
+    key: 'isOpen',
+
+
+    /**
+     * @method isOpen
+     * @signature isOpen()
+     * @description
+     *   [en]Returns whether the menu is open or not.[/en]
+     *   [ja][/ja]
+     */
+    value: function isOpen() {
+      return this._itemShown;
+    }
+
+    /**
+     * @method toggle
+     * @signature toggle()
+     * @description
+     *   [en]Toggle visibility.[/en]
+     *   [ja]Speed dialの表示非表示を切り替えます。[/ja]
+     */
+
+  }, {
+    key: 'toggle',
+    value: function toggle() {
+      return this.visible ? this.hide() : this.show();
+    }
+
+    /**
+     * @method toggleItems
+     * @signature toggleItems()
+     * @description
+     *   [en]Toggle item visibility.[/en]
+     *   [ja]Speed dialの子要素の表示非表示を切り替えます。[/ja]
+     */
+
+  }, {
+    key: 'toggleItems',
+    value: function toggleItems() {
+      return this.isOpen() ? this.hideItems() : this.showItems();
+    }
+  }, {
+    key: 'items',
+    get: function get$$1() {
+      return util$1.arrayFrom(this.querySelectorAll('ons-speed-dial-item'));
+    }
+  }, {
+    key: '_fab',
+    get: function get$$1() {
+      return util$1.findChild(this, 'ons-fab');
+    }
+  }, {
+    key: 'disabled',
+    set: function set$$1(value) {
+      if (value) {
+        this.hideItems();
+      }
+      util$1.arrayFrom(this.children).forEach(function (e) {
+        util$1.match(e, '.fab') && util$1.toggleAttribute(e, 'disabled', value);
+      });
+
+      return util$1.toggleAttribute(this, 'disabled', value);
+    },
+    get: function get$$1() {
+      return this.hasAttribute('disabled');
+    }
+
+    /**
+     * @property inline
+     * @readonly
+     * @type {Boolean}
+     * @description
+     *   [en]Whether the element is inline or not.[/en]
+     *   [ja]インライン要素の場合に`true`。[/ja]
+     */
+
+  }, {
+    key: 'inline',
+    get: function get$$1() {
+      return this.hasAttribute('inline');
+    }
+
+    /**
+     * @property visible
+     * @readonly
+     * @type {Boolean}
+     * @description
+     *   [en]Whether the element is visible or not.[/en]
+     *   [ja]要素が見える場合に`true`。[/ja]
+     */
+
+  }, {
+    key: 'visible',
+    get: function get$$1() {
+      return this._fab.visible && this.style.display !== 'none';
+    }
+  }], [{
+    key: 'observedAttributes',
+    get: function get$$1() {
+      return ['class', 'modifier', 'ripple', 'direction', 'position'];
+    }
+  }, {
+    key: 'events',
+    get: function get$$1() {
+      return ['open', 'close'];
+    }
+  }]);
+  return SpeedDialElement;
+}(BaseElement);
+
+onsElements.SpeedDial = SpeedDialElement;
+customElements.define('ons-speed-dial', SpeedDialElement);
+
+/*
+Copyright 2013-2015 ASIAL CORPORATION
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+   http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+*/
+
+var rewritables$1 = {
+  /**
+   * @param {Element} element
+   * @param {Function} callback
+   */
+  ready: function ready(element, callback) {
+    setImmediate(callback);
+  }
+};
+
+/**
+ * @element ons-splitter-content
+ * @category menu
+ * @description
+ *  [en]
+ *    The `<ons-splitter-content>` element is used as a child element of `<ons-splitter>`.
+ *
+ *    It contains the main content of the page while `<ons-splitter-side>` contains the list.
+ *  [/en]
+ *  [ja]ons-splitter-content要素は、ons-splitter要素の子要素として利用します。[/ja]
+ * @codepen rOQOML
+ * @tutorial vanilla/Reference/splitter
+ * @guide fundamentals.html#managing-pages
+ *  [en]Managing multiple pages.[/en]
+ *  [ja]複数のページを管理する[/ja]
+ * @seealso ons-splitter
+ *  [en]The `<ons-splitter>` component is the parent element.[/en]
+ *  [ja]ons-splitterコンポーネント[/ja]
+ * @seealso ons-splitter-side
+ *  [en]The `<ons-splitter-side>` component contains the menu.[/en]
+ *  [ja]ons-splitter-sideコンポーネント[/ja]
+ * @example
+ * <ons-splitter>
+ *   <ons-splitter-content>
+ *     ...
+ *   </ons-splitter-content>
+ *
+ *   <ons-splitter-side side="left" width="80%" collapse>
+ *     ...
+ *   </ons-splitter-side>
+ * </ons-splitter>
+ */
+
+var SplitterContentElement = function (_BaseElement) {
+  inherits(SplitterContentElement, _BaseElement);
+
+  /**
+   * @attribute page
+   * @type {String}
+   * @description
+   *   [en]
+   *     The url of the content page. If this attribute is used the content will be loaded from a `<template>` tag or a remote file.
+   *
+   *     It is also possible to put `<ons-page>` element as a child of the element.
+   *   [/en]
+   *   [ja]ons-splitter-content要素に表示するページのURLを指定します。[/ja]
+   */
+
+  function SplitterContentElement() {
+    classCallCheck(this, SplitterContentElement);
+
+    var _this = possibleConstructorReturn(this, (SplitterContentElement.__proto__ || Object.getPrototypeOf(SplitterContentElement)).call(this));
+
+    _this._page = null;
+    _this._pageLoader = defaultPageLoader;
+
+    contentReady(_this, function () {
+      rewritables$1.ready(_this, function () {
+        var page = _this._getPageTarget();
+
+        if (page) {
+          _this.load(page);
+        }
+      });
+    });
+    return _this;
+  }
+
+  createClass(SplitterContentElement, [{
+    key: 'connectedCallback',
+    value: function connectedCallback() {
+      if (!util$1.match(this.parentNode, 'ons-splitter')) {
+        util$1.throw('"ons-splitter-content" must have "ons-splitter" as parent');
+      }
+    }
+  }, {
+    key: '_getPageTarget',
+    value: function _getPageTarget() {
+      return this._page || this.getAttribute('page');
+    }
+  }, {
+    key: 'disconnectedCallback',
+    value: function disconnectedCallback() {}
+  }, {
+    key: 'attributeChangedCallback',
+    value: function attributeChangedCallback(name, last, current) {}
+
+    /**
+     * @property page
+     * @type {HTMLElement}
+     * @description
+     *   [en]The page to load in the splitter content.[/en]
+     *   [ja]この要素内に表示するページを指定します。[/ja]
+     */
+
+  }, {
+    key: 'load',
+
+
+    /**
+     * @method load
+     * @signature load(page, [options])
+     * @param {String} page, [options]
+     *   [en]Page URL. Can be either an HTML document or an `<template>` id.[/en]
+     *   [ja]pageのURLか、`<template>`で宣言したテンプレートのid属性の値を指定します。[/ja]
+     * @param {Object} [options]
+     * @param {Function} [options.callback]
+     * @description
+     *   [en]Show the page specified in `page` in the content.[/en]
+     *   [ja]指定したURLをメインページを読み込みます。[/ja]
+     * @return {Promise}
+     *   [en]Resolves to the new `<ons-page>` element[/en]
+     *   [ja]`<ons-page>`要素を解決するPromiseオブジェクトを返します。[/ja]
+     */
+    value: function load(page) {
+      var _this2 = this;
+
+      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
+
+      this._page = page;
+      var callback = options.callback || function () {};
+
+      return new Promise(function (resolve) {
+        var oldContent = _this2._content || null;
+
+        _this2._pageLoader.load({ page: page, parent: _this2 }, function (pageElement) {
+          if (oldContent) {
+            _this2._pageLoader.unload(oldContent);
+            oldContent = null;
+          }
+
+          setImmediate(function () {
+            return _this2._show();
+          });
+
+          callback(pageElement);
+          resolve(pageElement);
+        });
+      });
+    }
+  }, {
+    key: '_show',
+    value: function _show() {
+      if (this._content) {
+        this._content._show();
+      }
+    }
+  }, {
+    key: '_hide',
+    value: function _hide() {
+      if (this._content) {
+        this._content._hide();
+      }
+    }
+  }, {
+    key: '_destroy',
+    value: function _destroy() {
+      if (this._content) {
+        this._pageLoader.unload(this._content);
+      }
+      this.remove();
+    }
+  }, {
+    key: 'page',
+    get: function get$$1() {
+      return this._page;
+    }
+
+    /**
+     * @param {*} page
+     */
+    ,
+    set: function set$$1(page) {
+      this._page = page;
+    }
+  }, {
+    key: '_content',
+    get: function get$$1() {
+      return this.children[0];
+    }
+
+    /**
+     * @property pageLoader
+     * @type {Function}
+     * @description
+     *   [en]Page element loaded in the splitter content.[/en]
+     *   [ja]この要素内に表示するページを指定します。[/ja]
+     */
+
+  }, {
+    key: 'pageLoader',
+    get: function get$$1() {
+      return this._pageLoader;
+    },
+    set: function set$$1(loader) {
+      if (!(loader instanceof PageLoader)) {
+        util$1.throwPageLoader();
+      }
+      this._pageLoader = loader;
+    }
+  }], [{
+    key: 'observedAttributes',
+    get: function get$$1() {
+      return [];
+    }
+  }, {
+    key: 'rewritables',
+    get: function get$$1() {
+      return rewritables$1;
+    }
+  }]);
+  return SplitterContentElement;
+}(BaseElement);
+
+onsElements.SplitterContent = SplitterContentElement;
+customElements.define('ons-splitter-content', SplitterContentElement);
+
+/*
+Copyright 2013-2015 ASIAL CORPORATION
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+   http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+*/
+
+var SplitterMaskElement = function (_BaseElement) {
+  inherits(SplitterMaskElement, _BaseElement);
+
+  function SplitterMaskElement() {
+    classCallCheck(this, SplitterMaskElement);
+
+    var _this = possibleConstructorReturn(this, (SplitterMaskElement.__proto__ || Object.getPrototypeOf(SplitterMaskElement)).call(this));
+
+    _this._boundOnClick = _this._onClick.bind(_this);
+    contentReady(_this, function () {
+      if (_this.parentNode._sides.every(function (side) {
+        return side.mode === 'split';
+      })) {
+        _this.setAttribute('style', 'display: none !important');
+      }
+    });
+    return _this;
+  }
+
+  createClass(SplitterMaskElement, [{
+    key: '_onClick',
+    value: function _onClick(event) {
+      if (this.onClick instanceof Function) {
+        this.onClick();
+      } else if (util$1.match(this.parentNode, 'ons-splitter')) {
+        this.parentNode._sides.forEach(function (side) {
+          return side.close('left').catch(function () {});
+        });
+      }
+      event.stopPropagation();
+    }
+  }, {
+    key: 'attributeChangedCallback',
+    value: function attributeChangedCallback(name, last, current) {}
+  }, {
+    key: 'connectedCallback',
+    value: function connectedCallback() {
+      this.addEventListener('click', this._boundOnClick);
+      util$1.iosMaskScrollFix(this, true);
+    }
+  }, {
+    key: 'disconnectedCallback',
+    value: function disconnectedCallback() {
+      this.removeEventListener('click', this._boundOnClick);
+      util$1.iosMaskScrollFix(this, false);
+    }
+  }], [{
+    key: 'observedAttributes',
+    get: function get$$1() {
+      return [];
+    }
+  }]);
+  return SplitterMaskElement;
+}(BaseElement);
+
+onsElements.SplitterMask = SplitterMaskElement;
+customElements.define('ons-splitter-mask', SplitterMaskElement);
+
+/*
+Copyright 2013-2015 ASIAL CORPORATION
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+   http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+*/
+
+var SplitterAnimator$1 = function (_BaseAnimator) {
+  inherits(SplitterAnimator, _BaseAnimator);
+
+  function SplitterAnimator() {
+    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
+        _ref$timing = _ref.timing,
+        timing = _ref$timing === undefined ? 'cubic-bezier(.1, .7, .1, 1)' : _ref$timing,
+        _ref$duration = _ref.duration,
+        duration = _ref$duration === undefined ? 0.3 : _ref$duration,
+        _ref$delay = _ref.delay,
+        delay = _ref$delay === undefined ? 0 : _ref$delay;
+
+    classCallCheck(this, SplitterAnimator);
+    return possibleConstructorReturn(this, (SplitterAnimator.__proto__ || Object.getPrototypeOf(SplitterAnimator)).call(this, { timing: timing, duration: duration, delay: delay }));
+  }
+
+  createClass(SplitterAnimator, [{
+    key: 'updateOptions',
+    value: function updateOptions() {
+      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
+
+      util$1.extend(this, {
+        timing: this.timing, duration: this.duration, delay: this.delay
+      }, options);
+    }
+
+    /**
+     * @param {Element} sideElement
+     */
+
+  }, {
+    key: 'activate',
+    value: function activate(sideElement) {
+      var _this2 = this;
+
+      var splitter = sideElement.parentNode;
+
+      contentReady(splitter, function () {
+        _this2._side = sideElement;
+        _this2._oppositeSide = splitter.right !== sideElement && splitter.right || splitter.left !== sideElement && splitter.left;
+        _this2._content = splitter.content;
+        _this2._mask = splitter.mask;
+      });
+    }
+  }, {
+    key: 'deactivate',
+    value: function deactivate() {
+      this.clearTransition();
+      this._mask && this.clearMask();
+      this._content = this._side = this._oppositeSide = this._mask = null;
+    }
+  }, {
+    key: 'clearTransition',
+    value: function clearTransition() {
+      var _this3 = this;
+
+      'side mask content'.split(/\s+/).forEach(function (e) {
+        return _this3['_' + e] && styler.clear(_this3['_' + e], 'transform transition');
+      });
+    }
+  }, {
+    key: 'clearMask',
+    value: function clearMask() {
+      // Check if the other side needs the mask before clearing
+      if (!this._oppositeSide || this._oppositeSide.mode === 'split' || !this._oppositeSide.isOpen) {
+        this._mask.style.opacity = '';
+        this._mask.style.display = 'none';
+      }
+    }
+
+    /**
+     * @param {Number} distance
+     */
+
+  }, {
+    key: 'translate',
+    value: function translate(distance) {}
+
+    /**
+     * @param {Function} done
+     */
+
+  }, {
+    key: 'open',
+    value: function open(done) {
+      done();
+    }
+
+    /**
+     * @param {Function} done
+     */
+
+  }, {
+    key: 'close',
+    value: function close(done) {
+      done();
+    }
+  }, {
+    key: 'minus',
+    get: function get$$1() {
+      return this._side.side === 'right' ? '-' : '';
+    }
+  }]);
+  return SplitterAnimator;
+}(BaseAnimator);
+
+/*
+Copyright 2013-2015 ASIAL CORPORATION
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+   http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+*/
+
+var OverlaySplitterAnimator = function (_SplitterAnimator) {
+  inherits(OverlaySplitterAnimator, _SplitterAnimator);
+
+  function OverlaySplitterAnimator() {
+    classCallCheck(this, OverlaySplitterAnimator);
+    return possibleConstructorReturn(this, (OverlaySplitterAnimator.__proto__ || Object.getPrototypeOf(OverlaySplitterAnimator)).apply(this, arguments));
+  }
+
+  createClass(OverlaySplitterAnimator, [{
+    key: 'translate',
+    value: function translate(distance) {
+      this._mask.style.display = 'block'; // Avoid content clicks
+
+      Animit(this._side).queue({
+        transform: 'translate3d(' + (this.minus + distance) + 'px, 0, 0)'
+      }).play();
+    }
+
+    /**
+     * @param {Function} done
+     */
+
+  }, {
+    key: 'open',
+    value: function open(done) {
+      Animit.runAll(Animit(this._side).wait(this.delay).queue({
+        transform: 'translate3d(' + this.minus + '100%, 0, 0)'
+      }, this.def).queue(function (callback) {
+        callback();
+        done && done();
+      }), Animit(this._mask).wait(this.delay).queue({
+        display: 'block'
+      }).queue({
+        opacity: '1'
+      }, {
+        duration: this.duration,
+        timing: 'linear'
+      }));
+    }
+
+    /**
+     * @param {Function} done
+     */
+
+  }, {
+    key: 'close',
+    value: function close(done) {
+
+      Animit.runAll(Animit(this._side).wait(this.delay).queue({
+        transform: 'translate3d(0, 0, 0)'
+      }, this.def).queue(function (callback) {
+        done && done();
+        callback();
+      }), Animit(this._mask).wait(this.delay).queue({
+        opacity: '0'
+      }, {
+        duration: this.duration,
+        timing: 'linear'
+      }).queue({
+        display: 'none'
+      }));
+    }
+  }]);
+  return OverlaySplitterAnimator;
+}(SplitterAnimator$1);
+
+/*
+Copyright 2013-2015 ASIAL CORPORATION
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+   http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+*/
+
+var PushSplitterAnimator = function (_SplitterAnimator) {
+  inherits(PushSplitterAnimator, _SplitterAnimator);
+
+  function PushSplitterAnimator() {
+    classCallCheck(this, PushSplitterAnimator);
+    return possibleConstructorReturn(this, (PushSplitterAnimator.__proto__ || Object.getPrototypeOf(PushSplitterAnimator)).apply(this, arguments));
+  }
+
+  createClass(PushSplitterAnimator, [{
+    key: '_getSlidingElements',
+    value: function _getSlidingElements() {
+      var slidingElements = [this._side, this._content];
+      if (this._oppositeSide && this._oppositeSide.mode === 'split') {
+        slidingElements.push(this._oppositeSide);
+      }
+
+      return slidingElements;
+    }
+  }, {
+    key: 'translate',
+    value: function translate(distance) {
+      if (!this._slidingElements) {
+        this._slidingElements = this._getSlidingElements();
+      }
+
+      this._mask.style.display = 'block'; // Avoid content clicks
+
+      Animit(this._slidingElements).queue({
+        transform: 'translate3d(' + (this.minus + distance) + 'px, 0, 0)'
+      }).play();
+    }
+
+    /**
+     * @param {Function} done
+     */
+
+  }, {
+    key: 'open',
+    value: function open(done) {
+      var _this2 = this;
+
+      var max = this._side.offsetWidth;
+      this._slidingElements = this._getSlidingElements();
+
+      Animit.runAll(Animit(this._slidingElements).wait(this.delay).queue({
+        transform: 'translate3d(' + (this.minus + max) + 'px, 0, 0)'
+      }, this.def).queue(function (callback) {
+        _this2._slidingElements = null;
+        callback();
+        done && done();
+      }), Animit(this._mask).wait(this.delay).queue({
+        display: 'block'
+      }));
+    }
+
+    /**
+     * @param {Function} done
+     */
+
+  }, {
+    key: 'close',
+    value: function close(done) {
+      var _this3 = this;
+
+      this._slidingElements = this._getSlidingElements();
+
+      Animit.runAll(Animit(this._slidingElements).wait(this.delay).queue({
+        transform: 'translate3d(0, 0, 0)'
+      }, this.def).queue(function (callback) {
+        _this3._slidingElements = null;
+        get(PushSplitterAnimator.prototype.__proto__ || Object.getPrototypeOf(PushSplitterAnimator.prototype), 'clearTransition', _this3).call(_this3);
+        done && done();
+        callback();
+      }), Animit(this._mask).wait(this.delay).queue({
+        display: 'none'
+      }));
+    }
+  }]);
+  return PushSplitterAnimator;
+}(SplitterAnimator$1);
+
+/*
+Copyright 2013-2015 ASIAL CORPORATION
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+   http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+*/
+
+var RevealSplitterAnimator = function (_SplitterAnimator) {
+  inherits(RevealSplitterAnimator, _SplitterAnimator);
+
+  function RevealSplitterAnimator() {
+    classCallCheck(this, RevealSplitterAnimator);
+    return possibleConstructorReturn(this, (RevealSplitterAnimator.__proto__ || Object.getPrototypeOf(RevealSplitterAnimator)).apply(this, arguments));
+  }
+
+  createClass(RevealSplitterAnimator, [{
+    key: '_getSlidingElements',
+    value: function _getSlidingElements() {
+      var slidingElements = [this._content, this._mask];
+      if (this._oppositeSide && this._oppositeSide.mode === 'split') {
+        slidingElements.push(this._oppositeSide);
+      }
+
+      return slidingElements;
+    }
+  }, {
+    key: 'activate',
+    value: function activate(sideElement) {
+      get(RevealSplitterAnimator.prototype.__proto__ || Object.getPrototypeOf(RevealSplitterAnimator.prototype), 'activate', this).call(this, sideElement);
+      if (sideElement.mode === 'collapse') {
+        this._setStyles(sideElement);
+      }
+    }
+  }, {
+    key: 'deactivate',
+    value: function deactivate() {
+      this._side && this._unsetStyles(this._side);
+      get(RevealSplitterAnimator.prototype.__proto__ || Object.getPrototypeOf(RevealSplitterAnimator.prototype), 'deactivate', this).call(this);
+    }
+  }, {
+    key: '_setStyles',
+    value: function _setStyles(sideElement) {
+      styler(sideElement, {
+        left: sideElement.side === 'right' ? 'auto' : 0,
+        right: sideElement.side === 'right' ? 0 : 'auto',
+        zIndex: 0,
+        backgroundColor: 'black',
+        transform: this._generateBehindPageStyle(0).container.transform,
+        display: 'none'
+      });
+
+      var splitter = sideElement.parentElement;
+      contentReady(splitter, function () {
+        return splitter.content && styler(splitter.content, { boxShadow: '0 0 12px 0 rgba(0, 0, 0, 0.2)' });
+      });
+    }
+  }, {
+    key: '_unsetStyles',
+    value: function _unsetStyles(sideElement) {
+      styler.clear(sideElement, 'left right zIndex backgroundColor display');
+      if (sideElement._content) {
+        sideElement._content.style.opacity = '';
+      }
+
+      // Check if the other side needs the common styles
+      if (!this._oppositeSide || this._oppositeSide.mode === 'split') {
+        sideElement.parentElement.content && styler.clear(sideElement.parentElement.content, 'boxShadow');
+      }
+    }
+  }, {
+    key: '_generateBehindPageStyle',
+    value: function _generateBehindPageStyle(distance) {
+      var max = this.maxWidth;
+
+      var behindDistance = (distance - max) / max * 10;
+      behindDistance = isNaN(behindDistance) ? 0 : Math.max(Math.min(behindDistance, 0), -10);
+
+      var behindTransform = 'translate3d(' + (this.minus ? -1 : 1) * behindDistance + '%, 0, 0)';
+      var opacity = 1 + behindDistance / 100;
+
+      return {
+        content: {
+          opacity: opacity
+        },
+        container: {
+          transform: behindTransform
+        }
+      };
+    }
+  }, {
+    key: 'translate',
+    value: function translate(distance) {
+      this._side.style.display = '';
+      this._side.style.zIndex = 1;
+      this.maxWidth = this.maxWidth || this._getMaxWidth();
+      var menuStyle = this._generateBehindPageStyle(Math.min(distance, this.maxWidth));
+
+      if (!this._slidingElements) {
+        this._slidingElements = this._getSlidingElements();
+      }
+
+      this._mask.style.display = 'block'; // Avoid content clicks
+
+      Animit.runAll(Animit(this._slidingElements).queue({
+        transform: 'translate3d(' + (this.minus + distance) + 'px, 0, 0)'
+      }), Animit(this._side._content).queue(menuStyle.content), Animit(this._side).queue(menuStyle.container));
+    }
+
+    /**
+     * @param {Function} done
+     */
+
+  }, {
+    key: 'open',
+    value: function open(done) {
+      var _this2 = this;
+
+      this._side.style.display = '';
+      this._side.style.zIndex = 1;
+      this.maxWidth = this.maxWidth || this._getMaxWidth();
+      var menuStyle = this._generateBehindPageStyle(this.maxWidth);
+      this._slidingElements = this._getSlidingElements();
+
+      setTimeout(function () {
+        // Fix: Time to update previous translate3d after changing style.display
+        Animit.runAll(Animit(_this2._slidingElements).wait(_this2.delay).queue({
+          transform: 'translate3d(' + (_this2.minus + _this2.maxWidth) + 'px, 0, 0)'
+        }, _this2.def), Animit(_this2._mask).wait(_this2.delay).queue({
+          display: 'block'
+        }), Animit(_this2._side._content).wait(_this2.delay).queue(menuStyle.content, _this2.def), Animit(_this2._side).wait(_this2.delay).queue(menuStyle.container, _this2.def).queue(function (callback) {
+          _this2._slidingElements = null;
+          callback();
+          done && done();
+        }));
+      }, 1000 / 60);
+    }
+
+    /**
+     * @param {Function} done
+     */
+
+  }, {
+    key: 'close',
+    value: function close(done) {
+      var _this3 = this;
+
+      var menuStyle = this._generateBehindPageStyle(0);
+      this._slidingElements = this._getSlidingElements();
+
+      Animit.runAll(Animit(this._slidingElements).wait(this.delay).queue({
+        transform: 'translate3d(0, 0, 0)'
+      }, this.def), Animit(this._mask).wait(this.delay).queue({
+        display: 'none'
+      }), Animit(this._side._content).wait(this.delay).queue(menuStyle.content, this.def), Animit(this._side).wait(this.delay).queue(menuStyle.container, this.def).queue(function (callback) {
+        _this3._slidingElements = null;
+        _this3._side.style.zIndex = 0;
+        _this3._side.style.display = 'none';
+        _this3._side._content.style.opacity = '';
+        done && done();
+        callback();
+      }));
+    }
+  }, {
+    key: '_getMaxWidth',
+    value: function _getMaxWidth() {
+      return this._side.offsetWidth;
+    }
+  }]);
+  return RevealSplitterAnimator;
+}(SplitterAnimator$1);
+
+/*
+Copyright 2013-2015 ASIAL CORPORATION
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+   http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+*/
+
+var _animatorDict$7 = {
+  default: OverlaySplitterAnimator,
+  overlay: OverlaySplitterAnimator,
+  push: PushSplitterAnimator,
+  reveal: RevealSplitterAnimator
+};
+
+/**
+ * @element ons-splitter
+ * @category menu
+ * @description
+ *  [en]
+ *    A component that enables responsive layout by implementing both a two-column layout and a sliding menu layout.
+ *
+ *    It can be configured to automatically expand into a column layout on large screens and collapse the menu on smaller screens. When the menu is collapsed the user can open it by swiping.
+ *  [/en]
+ *  [ja][/ja]
+ * @codepen rOQOML
+ * @tutorial vanilla/Reference/splitter
+ * @guide fundamentals.html#managing-pages
+ *  [en]Managing multiple pages.[/en]
+ *  [ja]複数のページを管理する[/ja]
+ * @seealso ons-splitter-content
+ *  [en]The `<ons-splitter-content>` component contains the main content of the page.[/en]
+ *  [ja]ons-splitter-contentコンポーネント[/ja]
+ * @seealso ons-splitter-side
+ *  [en]The `<ons-splitter-side>` component contains the menu.[/en]
+ *  [ja]ons-splitter-sideコンポーネント[/ja]
+ * @example
+ * <ons-splitter id="splitter">
+ *   <ons-splitter-content>
+ *     ...
+ *   </ons-splitter-content>
+ *
+ *   <ons-splitter-side side="left" width="80%" collapse swipeable>
+ *     ...
+ *   </ons-splitter-side>
+ * </ons-splitter>
+ *
+ * <script>
+ *   var splitter = document.getElementById('splitter');
+ *   splitter.left.open();
+ * </script>
+ */
+
+var SplitterElement = function (_BaseElement) {
+  inherits(SplitterElement, _BaseElement);
+  createClass(SplitterElement, [{
+    key: '_getSide',
+    value: function _getSide(side) {
+      var element = util$1.findChild(this, function (e) {
+        return util$1.match(e, 'ons-splitter-side') && e.getAttribute('side') === side;
+      });
+      return element;
+    }
+
+    /**
+     * @property left
+     * @readonly
+     * @type {HTMLElement}
+     * @description
+     *   [en]Left `<ons-splitter-side>` element.[/en]
+     *   [ja][/ja]
+     */
+
+  }, {
+    key: '_onDeviceBackButton',
+    value: function _onDeviceBackButton(event) {
+      this._sides.some(function (s) {
+        return s.isOpen ? s.close() : false;
+      }) || event.callParentHandler();
+    }
+  }, {
+    key: '_onModeChange',
+    value: function _onModeChange(e) {
+      var _this2 = this;
+
+      if (e.target.parentNode) {
+        contentReady(this, function () {
+          _this2._layout();
+        });
+      }
+    }
+  }, {
+    key: '_layout',
+    value: function _layout() {
+      var _this3 = this;
+
+      this._sides.forEach(function (side) {
+        if (_this3.content) {
+          _this3.content.style[side.side] = side.mode === 'split' ? side.style.width : 0;
+        }
+      });
+    }
+  }, {
+    key: 'left',
+    get: function get$$1() {
+      return this._getSide('left');
+    }
+    /**
+     * @property right
+     * @readonly
+     * @type {HTMLElement}
+     * @description
+     *   [en]Right `<ons-splitter-side>` element.[/en]
+     *   [ja][/ja]
+     */
+
+  }, {
+    key: 'right',
+    get: function get$$1() {
+      return this._getSide('right');
+    }
+
+    /**
+     * @property side
+     * @readonly
+     * @type {HTMLElement}
+     * @description
+     *   [en]First `<ons-splitter-side>` element regardless the actual side.[/en]
+     *   [ja][/ja]
+     */
+
+  }, {
+    key: 'side',
+    get: function get$$1() {
+      return util$1.findChild(this, 'ons-splitter-side');
+    }
+  }, {
+    key: '_sides',
+    get: function get$$1() {
+      return [this.left, this.right].filter(function (e) {
+        return e;
+      });
+    }
+    /**
+     * @property content
+     * @readonly
+     * @type {HTMLElement}
+     * @description
+     *   [en]The `<ons-splitter-content>` element.[/en]
+     *   [ja][/ja]
+     */
+
+  }, {
+    key: 'content',
+    get: function get$$1() {
+      return util$1.findChild(this, 'ons-splitter-content');
+    }
+  }, {
+    key: 'topPage',
+    get: function get$$1() {
+      return this.content._content;
+    }
+  }, {
+    key: 'mask',
+    get: function get$$1() {
+      return util$1.findChild(this, 'ons-splitter-mask');
+    }
+
+    /**
+     * @property onDeviceBackButton
+     * @type {Object}
+     * @description
+     *   [en]Back-button handler.[/en]
+     *   [ja]バックボタンハンドラ。[/ja]
+     */
+
+  }, {
+    key: 'onDeviceBackButton',
+    get: function get$$1() {
+      return this._backButtonHandler;
+    },
+    set: function set$$1(callback) {
+      if (this._backButtonHandler) {
+        this._backButtonHandler.destroy();
+      }
+
+      this._backButtonHandler = deviceBackButtonDispatcher.createHandler(this, callback);
+    }
+  }]);
+
+  function SplitterElement() {
+    classCallCheck(this, SplitterElement);
+
+    var _this = possibleConstructorReturn(this, (SplitterElement.__proto__ || Object.getPrototypeOf(SplitterElement)).call(this));
+
+    _this._onModeChange = _this._onModeChange.bind(_this);
+
+    contentReady(_this, function () {
+      !_this.mask && _this.appendChild(document.createElement('ons-splitter-mask'));
+      _this._layout();
+    });
+    return _this;
+  }
+
+  createClass(SplitterElement, [{
+    key: 'connectedCallback',
+    value: function connectedCallback() {
+      this.onDeviceBackButton = this._onDeviceBackButton.bind(this);
+      this.addEventListener('modechange', this._onModeChange, false);
+    }
+  }, {
+    key: 'disconnectedCallback',
+    value: function disconnectedCallback() {
+      this._backButtonHandler.destroy();
+      this._backButtonHandler = null;
+      this.removeEventListener('modechange', this._onModeChange, false);
+    }
+  }, {
+    key: 'attributeChangedCallback',
+    value: function attributeChangedCallback(name, last, current) {}
+  }, {
+    key: '_show',
+    value: function _show() {
+      util$1.propagateAction(this, '_show');
+    }
+  }, {
+    key: '_hide',
+    value: function _hide() {
+      util$1.propagateAction(this, '_hide');
+    }
+  }, {
+    key: '_destroy',
+    value: function _destroy() {
+      util$1.propagateAction(this, '_destroy');
+      this.remove();
+    }
+  }], [{
+    key: 'registerAnimator',
+    value: function registerAnimator(name, Animator) {
+      if (!(Animator instanceof SplitterAnimator)) {
+        util$1.throwAnimator('Splitter');
+      }
+      _animatorDict$7[name] = Animator;
+    }
+  }, {
+    key: 'SplitterAnimator',
+    get: function get$$1() {
+      return SplitterAnimator;
+    }
+  }, {
+    key: 'animators',
+    get: function get$$1() {
+      return _animatorDict$7;
+    }
+  }]);
+  return SplitterElement;
+}(BaseElement);
+
+onsElements.Splitter = SplitterElement;
+customElements.define('ons-splitter', SplitterElement);
+
+/*
+Copyright 2013-2015 ASIAL CORPORATION
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+   http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+*/
+
+var SPLIT_MODE = 'split';
+var COLLAPSE_MODE = 'collapse';
+var CLOSED_STATE = 'closed';
+var OPEN_STATE = 'open';
+var CHANGING_STATE = 'changing';
+
+var rewritables$2 = {
+  /**
+   * @param {Element} splitterSideElement
+   * @param {Function} callback
+   */
+  ready: function ready(splitterSideElement, callback) {
+    setImmediate(callback);
+  }
+};
+
+var CollapseDetection = function () {
+  function CollapseDetection(element, target) {
+    classCallCheck(this, CollapseDetection);
+
+    this._element = element;
+    this._onChange = this._onChange.bind(this);
+    target && this.changeTarget(target);
+  }
+
+  createClass(CollapseDetection, [{
+    key: 'changeTarget',
+    value: function changeTarget(target) {
+      this.disable();
+      this._target = target;
+      if (target) {
+        this._orientation = ['portrait', 'landscape'].indexOf(target) !== -1;
+        this.activate();
+      }
+    }
+  }, {
+    key: '_match',
+    value: function _match(value) {
+      if (this._orientation) {
+        return this._target === (value.isPortrait ? 'portrait' : 'landscape');
+      }
+      return value.matches;
+    }
+  }, {
+    key: '_onChange',
+    value: function _onChange(value) {
+      this._element._updateMode(this._match(value) ? COLLAPSE_MODE : SPLIT_MODE);
+    }
+  }, {
+    key: 'activate',
+    value: function activate() {
+      if (this._orientation) {
+        orientation.on('change', this._onChange);
+        this._onChange({ isPortrait: orientation.isPortrait() });
+      } else {
+        this._queryResult = window.matchMedia(this._target);
+        this._queryResult.addListener(this._onChange);
+        this._onChange(this._queryResult);
+      }
+    }
+  }, {
+    key: 'disable',
+    value: function disable() {
+      if (this._orientation) {
+        orientation.off('change', this._onChange);
+      } else if (this._queryResult) {
+        this._queryResult.removeListener(this._onChange);
+        this._queryResult = null;
+      }
+    }
+  }]);
+  return CollapseDetection;
+}();
+
+/**
+ * @element ons-splitter-side
+ * @category menu
+ * @description
+ *  [en]
+ *    The `<ons-splitter-side>` element is used as a child element of `<ons-splitter>`.
+ *
+ *    It will be displayed on either the left or right side of the `<ons-splitter-content>` element.
+ *
+ *    It supports two modes: collapsed and split. When it's in collapsed mode it will be hidden from view and can be displayed when the user swipes the screen or taps a button. In split mode the element is always shown. It can be configured to automatically switch between the two modes depending on the screen size.
+ *  [/en]
+ *  [ja]ons-splitter-side要素は、ons-splitter要素の子要素として利用します。[/ja]
+ * @codepen rOQOML
+ * @tutorial vanilla/Reference/splitter
+ * @guide fundamentals.html#managing-pages
+ *  [en]Managing multiple pages.[/en]
+ *  [ja]複数のページを管理する[/ja]
+ * @seealso ons-splitter
+ *  [en]The `<ons-splitter>` is the parent component.[/en]
+ *  [ja]ons-splitterコンポーネント[/ja]
+ * @seealso ons-splitter-content
+ *  [en]The `<ons-splitter-content>` component contains the main content of the page.[/en]
+ *  [ja]ons-splitter-contentコンポーネント[/ja]
+ * @example
+ * <ons-splitter>
+ *   <ons-splitter-content>
+ *     ...
+ *   </ons-splitter-content>
+ *
+ *   <ons-splitter-side side="left" width="80%" collapse>
+ *     ...
+ *   </ons-splitter-side>
+ * </ons-splitter>
+ */
+
+var SplitterSideElement = function (_BaseElement) {
+  inherits(SplitterSideElement, _BaseElement);
+
+  /**
+   * @event modechange
+   * @description
+   *   [en]Fired just after the component's mode changes.[/en]
+   *   [ja]この要素のモードが変化した際に発火します。[/ja]
+   * @param {Object} event
+   *   [en]Event object.[/en]
+   *   [ja]イベントオブジェクトです。[/ja]
+   * @param {Object} event.side
+   *   [en]Component object.[/en]
+   *   [ja]コンポーネントのオブジェクト。[/ja]
+   * @param {String} event.mode
+   *   [en]Returns the current mode. Can be either `"collapse"` or `"split"`.[/en]
+   *   [ja]現在のモードを返します。[/ja]
+   */
+
+  /**
+   * @event preopen
+   * @description
+   *   [en]Fired just before the sliding menu is opened.[/en]
+   *   [ja]スライディングメニューが開く前に発火します。[/ja]
+   * @param {Object} event
+   *   [en]Event object.[/en]
+   *   [ja]イベントオブジェクトです。[/ja]
+   * @param {Function} event.cancel
+   *   [en]Call to cancel opening sliding menu.[/en]
+   *   [ja]スライディングメニューが開くのをキャンセルします。[/ja]
+   * @param {Object} event.side
+   *   [en]Component object.[/en]
+   *   [ja]コンポーネントのオブジェクト。[/ja]
+   */
+
+  /**
+   * @event postopen
+   * @description
+   *   [en]Fired just after the sliding menu is opened.[/en]
+   *   [ja]スライディングメニューが開いた後に発火します。[/ja]
+   * @param {Object} event
+   *   [en]Event object.[/en]
+   *   [ja]イベントオブジェクトです。[/ja]
+   * @param {Object} event.side
+   *   [en]Component object.[/en]
+   *   [ja]コンポーネントのオブジェクト。[/ja]
+   */
+
+  /**
+   * @event preclose
+   * @description
+   *   [en]Fired just before the sliding menu is closed.[/en]
+   *   [ja]スライディングメニューが閉じる前に発火します。[/ja]
+   * @param {Object} event
+   *   [en]Event object.[/en]
+   *   [ja]イベントオブジェクトです。[/ja]
+   * @param {Object} event.side
+   *   [en]Component object.[/en]
+   *   [ja]コンポーネントのオブジェクト。[/ja]
+   * @param {Function} event.cancel
+   *   [en]Call to cancel opening sliding-menu.[/en]
+   *   [ja]スライディングメニューが閉じるのをキャンセルします。[/ja]
+   */
+
+  /**
+   * @event postclose
+   * @description
+   *   [en]Fired just after the sliding menu is closed.[/en]
+   *   [ja]スライディングメニューが閉じた後に発火します。[/ja]
+   * @param {Object} event
+   *   [en]Event object.[/en]
+   *   [ja]イベントオブジェクトです。[/ja]
+   * @param {Object} event.side
+   *   [en]Component object.[/en]
+   *   [ja]コンポーネントのオブジェクト。[/ja]
+   */
+
+  /**
+   * @attribute animation
+   * @type {String}
+   * @default  default
+   * @description
+   *  [en]Specify the animation. Use one of `overlay`, `push`, `reveal` or  `default`.[/en]
+   *  [ja]アニメーションを指定します。"overlay", "push", "reveal", "default"のいずれかを指定できます。[/ja]
+   */
+
+  /**
+   * @attribute animation-options
+   * @type {Expression}
+   * @description
+   *  [en]Specify the animation's duration, timing and delay with an object literal. E.g. `{duration: 0.2, delay: 1, timing: 'ease-in'}`.[/en]
+   *  [ja]アニメーション時のduration, timing, delayをオブジェクトリテラルで指定します。e.g. {duration: 0.2, delay: 1, timing: 'ease-in'}[/ja]
+   */
+
+  /**
+   * @attribute open-threshold
+   * @type {Number}
+   * @default  0.3
+   * @description
+   *  [en]Specify how much the menu needs to be swiped before opening. A value between `0` and `1`.[/en]
+   *  [ja]どのくらいスワイプすればスライディングメニューを開くかどうかの割合を指定します。0から1の間の数値を指定します。スワイプの距離がここで指定した数値掛けるこの要素の幅よりも大きければ、スワイプが終わった時にこの要素を開きます。デフォルトは0.3です。[/ja]
+   */
+
+  /**
+   * @attribute collapse
+   * @type {String}
+   * @description
+   *   [en]
+   *     Specify the collapse behavior. Valid values are `"portrait"`, `"landscape"` or a media query.
+   *     The strings `"portrait"` and `"landscape"` means the view will collapse when device is in landscape or portrait orientation.
+   *     If the value is a media query, the view will collapse when the media query resolves to `true`.
+   *     If the value is not defined, the view always be in `"collapse"` mode.
+   *   [/en]
+   *   [ja]
+   *     左側のページを非表示にする条件を指定します。portrait, landscape、width #pxもしくはメディアクエリの指定が可能です。
+   *     portraitもしくはlandscapeを指定すると、デバイスの画面が縦向きもしくは横向きになった時に適用されます。
+   *     メディアクエリを指定すると、指定したクエリに適合している場合に適用されます。
+   *     値に何も指定しない場合には、常にcollapseモードになります。
+   *   [/ja]
+   */
+
+  /**
+   * @attribute swipe-target-width
+   * @type {String}
+   * @description
+   *   [en]The width of swipeable area calculated from the edge (in pixels). Use this to enable swipe only when the finger touch on the screen edge.[/en]
+   *   [ja]スワイプの判定領域をピクセル単位で指定します。画面の端から指定した距離に達するとページが表示されます。[/ja]
+   */
+
+  /**
+   * @attribute width
+   * @type {String}
+   * @description
+   *   [en]Can be specified in either pixels or as a percentage, e.g. `90%` or `200px`.[/en]
+   *   [ja]この要素の横幅を指定します。pxと%での指定が可能です。eg. 90%, 200px[/ja]
+   */
+
+  /**
+   * @attribute side
+   * @type {String}
+   * @default left
+   * @description
+   *   [en]Specify which side of the screen the `<ons-splitter-side>` element is located. Possible values are `"left"` and `"right"`.[/en]
+   *   [ja]この要素が左か右かを指定します。指定できる値は"left"か"right"のみです。[/ja]
+   */
+
+  /**
+   * @attribute mode
+   * @type {String}
+   * @description
+   *   [en]Current mode. Possible values are `"collapse"` or `"split"`. This attribute is read only.[/en]
+   *   [ja]現在のモードが設定されます。"collapse"もしくは"split"が指定されます。この属性は読み込み専用です。[/ja]
+   */
+
+  /**
+   * @attribute page
+   * @initonly
+   * @type {String}
+   * @description
+   *   [en]The URL of the menu page.[/en]
+   *   [ja]ons-splitter-side要素に表示するページのURLを指定します。[/ja]
+   */
+
+  /**
+   * @attribute swipeable
+   * @type {Boolean}
+   * @description
+   *   [en]Whether to enable swipe interaction on collapse mode.[/en]
+   *   [ja]collapseモード時にスワイプ操作を有効にする場合に指定します。[/ja]
+   */
+
+  function SplitterSideElement() {
+    classCallCheck(this, SplitterSideElement);
+
+    var _this = possibleConstructorReturn(this, (SplitterSideElement.__proto__ || Object.getPrototypeOf(SplitterSideElement)).call(this));
+
+    _this._page = null;
+    _this._state = CLOSED_STATE;
+    _this._lock = new DoorLock();
+    _this._pageLoader = defaultPageLoader;
+    _this._collapseDetection = new CollapseDetection(_this);
+
+    _this._animatorFactory = new AnimatorFactory({
+      animators: SplitterElement.animators,
+      baseClass: SplitterAnimator$1,
+      baseClassName: 'SplitterAnimator',
+      defaultAnimation: _this.getAttribute('animation')
+    });
+
+    contentReady(_this, function () {
+      // These attributes are used early by the parent element
+      _this.attributeChangedCallback('width');
+      if (!_this.hasAttribute('side')) {
+        _this.setAttribute('side', 'left');
+      }
+
+      rewritables$2.ready(_this, function () {
+        var page = _this._page || _this.getAttribute('page');
+        page && _this.load(page);
+      });
+    });
+    return _this;
+  }
+
+  createClass(SplitterSideElement, [{
+    key: 'connectedCallback',
+    value: function connectedCallback() {
+      var _this2 = this;
+
+      if (!util$1.match(this.parentNode, 'ons-splitter')) {
+        util$1.throw('Parent must be an ons-splitter element');
+      }
+
+      this._swipe = new SwipeReveal({
+        element: this,
+        elementHandler: this.parentElement,
+        swipeMax: function swipeMax() {
+          _this2._onSwipe && _this2._onSwipe(1, _this2._animationOpt);
+          _this2.open();
+        },
+        swipeMid: function swipeMid(distance, width) {
+          _this2._onSwipe && _this2._onSwipe(distance / width);
+          _this2._animator.translate(distance);
+        },
+        swipeMin: function swipeMin() {
+          _this2._onSwipe && _this2._onSwipe(0, _this2._animationOpt);
+          _this2.close();
+        },
+        getThreshold: function getThreshold() {
+          return Math.max(0, Math.min(1, parseFloat(_this2.getAttribute('open-threshold')) || 0.3));
+        },
+        getSide: function getSide() {
+          return _this2.side;
+        },
+        isInitialState: function isInitialState() {
+          var closed = _this2._state === CLOSED_STATE;
+          _this2._state = CHANGING_STATE;
+          return closed;
+        },
+        ignoreSwipe: function ignoreSwipe(event, distance) {
+          var isOpen = _this2.isOpen;
+          var validDrag = function validDrag(d) {
+            return _this2.side === 'left' ? d === 'left' && isOpen || d === 'right' && !isOpen : d === 'left' && !isOpen || d === 'right' && isOpen;
+          };
+
+          var area = Math.max(0, parseInt(_this2.getAttribute('swipe-target-width'), 10) || 0);
+
+          return _this2._mode === SPLIT_MODE || _this2._lock.isLocked() || _this2._isOtherSideOpen() || !validDrag(event.gesture.direction) || !isOpen && area !== 0 && distance > area;
+        }
+      });
+
+      this.attributeChangedCallback('swipeable');
+
+      contentReady(this, function () {
+        _this2.constructor.observedAttributes.forEach(function (attr) {
+          return _this2.attributeChangedCallback(attr, null, _this2.getAttribute(attr));
+        });
+      });
+    }
+  }, {
+    key: 'disconnectedCallback',
+    value: function disconnectedCallback() {
+      this._swipe && this._swipe.dispose();
+      this._animator = this._animationOpt = this._swipe = null;
+    }
+  }, {
+    key: 'attributeChangedCallback',
+    value: function attributeChangedCallback(name, last, current) {
+      switch (name) {
+        case 'swipeable':
+          this._swipe && this._swipe.update();
+          break;
+        case 'width':
+          current = this.getAttribute('width'); // Sometimes undefined. CE bug?
+          this.style.width = /^\d+(px|%)$/.test(current) ? current : '80%';
+          break;
+        default:
+          this[util$1.camelize('_update-' + name)](current);
+      }
+    }
+  }, {
+    key: '_emitEvent',
+    value: function _emitEvent(name) {
+      if (name.slice(0, 3) !== 'pre') {
+        return util$1.triggerElementEvent(this, name, { side: this });
+      }
+      var isCanceled = false;
+
+      util$1.triggerElementEvent(this, name, {
+        side: this,
+        cancel: function cancel() {
+          return isCanceled = true;
+        }
+      });
+
+      return isCanceled;
+    }
+  }, {
+    key: '_isOtherSideOpen',
+    value: function _isOtherSideOpen() {
+      var _this3 = this;
+
+      return !!util$1.findChild(this.parentElement, function (el) {
+        return el instanceof _this3.constructor && el !== _this3 && el._mode === COLLAPSE_MODE && el.isOpen;
+      });
+    }
+  }, {
+    key: '_updateCollapse',
+    value: function _updateCollapse() {
+      var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.getAttribute('collapse');
+
+      if (value === null || value === 'split') {
+        this._collapseDetection.disable();
+        return this._updateMode(SPLIT_MODE);
+      }
+      if (value === '' || value === 'collapse') {
+        this._collapseDetection.disable();
+        return this._updateMode(COLLAPSE_MODE);
+      }
+
+      this._collapseDetection.changeTarget(value);
+    }
+  }, {
+    key: '_updateMode',
+    value: function _updateMode(mode) {
+      if (mode !== this._mode) {
+        this._mode = mode;
+        this.setAttribute('mode', mode); // readonly attribute for the users
+
+        if (mode === SPLIT_MODE) {
+          this._animator && this._animator.deactivate();
+          this._state = CLOSED_STATE;
+        } else {
+          this._animator && this._animator.activate(this);
+          this._state === OPEN_STATE && this._animator.open();
+        }
+
+        util$1.triggerElementEvent(this, 'modechange', { side: this, mode: mode });
+      }
+    }
+  }, {
+    key: '_updateAnimation',
+    value: function _updateAnimation() {
+      var animation = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.getAttribute('animation');
+
+      if (this.parentNode) {
+        this._animator && this._animator.deactivate();
+        this._animator = this._animatorFactory.newAnimator({ animation: animation });
+        this._animator.activate(this);
+        this._animationOpt = {
+          timing: this._animator.duration,
+          duration: this._animator.duration
+        };
+      }
+    }
+  }, {
+    key: '_updateAnimationOptions',
+    value: function _updateAnimationOptions() {
+      var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.getAttribute('animation-options');
+
+      this._animator.updateOptions(AnimatorFactory.parseAnimationOptionsString(value));
+    }
+
+    /**
+     * @property page
+     * @type {*}
+     * @description
+     *   [en]Page location to load in the splitter side.[/en]
+     *   [ja]この要素内に表示するページを指定します。[/ja]
+     */
+
+  }, {
+    key: 'open',
+
+
+    /**
+     * @method open
+     * @signature open([options])
+     * @param {Object} [options]
+     *   [en]Parameter object.[/en]
+     *   [ja]オプションを指定するオブジェクト。[/ja]
+     * @param {Function} [options.callback]
+     *   [en]This function will be called after the menu has been opened.[/en]
+     *   [ja]メニューが開いた後に呼び出される関数オブジェクトを指定します。[/ja]
+     * @description
+     *   [en]Open menu in collapse mode.[/en]
+     *   [ja]collapseモードになっているons-splitter-side要素を開きます。[/ja]
+     * @return {Promise}
+     *   [en]Resolves to the splitter side element or false if not in collapse mode[/en]
+     *   [ja][/ja]
+     */
+    value: function open(options) {
+      return this.toggle(options, true);
+    }
+
+    /**
+     * @method close
+     * @signature close([options])
+     * @param {Object} [options]
+     *   [en]Parameter object.[/en]
+     *   [ja]オプションを指定するオブジェクト。[/ja]
+     * @param {Function} [options.callback]
+     *   [en]This function will be called after the menu has been closed.[/en]
+     *   [ja]メニューが閉じた後に呼び出される関数オブジェクトを指定します。[/ja]
+     * @description
+     *   [en]Close menu in collapse mode.[/en]
+     *   [ja]collapseモードになっているons-splitter-side要素を閉じます。[/ja]
+     * @return {Promise}
+     *   [en]Resolves to the splitter side element or false if not in collapse mode[/en]
+     *   [ja][/ja]
+     */
+
+  }, {
+    key: 'close',
+    value: function close(options) {
+      return this.toggle(options, false);
+    }
+
+    /**
+     * @method toggle
+     * @signature toggle([options])
+     * @param {Object} [options]
+     * @description
+     *   [en]Opens if it's closed. Closes if it's open.[/en]
+     *   [ja]開けている場合は要素を閉じますそして開けている場合は要素を開きます。[/ja]
+     * @return {Promise}
+     *   [en]Resolves to the splitter side element or false if not in collapse mode[/en]
+     *   [ja][/ja]
+     */
+
+  }, {
+    key: 'toggle',
+    value: function toggle() {
+      var _this4 = this;
+
+      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
+      var force = arguments[1];
+
+      var shouldOpen = typeof force === 'boolean' ? force : !this.isOpen;
+      var action = shouldOpen ? 'open' : 'close';
+      var FINAL_STATE = shouldOpen ? OPEN_STATE : CLOSED_STATE;
+
+      if (this._mode === SPLIT_MODE) {
+        return Promise.resolve(false);
+      }
+      if (this._state === FINAL_STATE) {
+        return Promise.resolve(this);
+      }
+      if (this._lock.isLocked()) {
+        return Promise.reject('Another splitter-side action is already running.');
+      }
+      if (shouldOpen && this._isOtherSideOpen()) {
+        return Promise.reject('Another menu is already open.');
+      }
+      if (this._emitEvent('pre' + action)) {
+        return Promise.reject('Canceled in pre' + action + ' event.');
+      }
+
+      var unlock = this._lock.lock();
+      this._state = CHANGING_STATE;
+
+      if (options.animation) {
+        this._updateAnimation(options.animation);
+      }
+
+      return new Promise(function (resolve) {
+        _this4._animator[action](function () {
+          util$1.iosPageScrollFix(shouldOpen);
+          _this4._state = FINAL_STATE;
+          unlock();
+          _this4._emitEvent('post' + action);
+          options.callback instanceof Function && options.callback(_this4);
+          resolve(_this4);
+        });
+      });
+    }
+
+    /**
+     * @method load
+     * @signature load(page, [options])
+     * @param {String} page
+     *   [en]Page URL. Can be either an HTML document or a `<template>`.[/en]
+     *   [ja]pageのURLか、`<template>`で宣言したテンプレートのid属性の値を指定します。[/ja]
+     * @param {Object} [options]
+     * @param {Function} [options.callback]
+     * @description
+     *   [en]Show the page specified in pageUrl in the right section[/en]
+     *   [ja]指定したURLをメインページを読み込みます。[/ja]
+     * @return {Promise}
+     *   [en]Resolves to the new page element[/en]
+     *   [ja][/ja]
+     */
+
+  }, {
+    key: 'load',
+    value: function load(page) {
+      var _this5 = this;
+
+      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
+
+      this._page = page;
+      var callback = options.callback || function () {};
+
+      return new Promise(function (resolve) {
+        var oldContent = _this5._content || null;
+
+        _this5._pageLoader.load({ page: page, parent: _this5 }, function (pageElement) {
+          if (oldContent) {
+            _this5._pageLoader.unload(oldContent);
+            oldContent = null;
+          }
+
+          setImmediate(function () {
+            return _this5._show();
+          });
+
+          callback(pageElement);
+          resolve(pageElement);
+        });
+      });
+    }
+  }, {
+    key: '_show',
+    value: function _show() {
+      if (this._content) {
+        this._content._show();
+      }
+    }
+  }, {
+    key: '_hide',
+    value: function _hide() {
+      if (this._content) {
+        this._content._hide();
+      }
+    }
+  }, {
+    key: '_destroy',
+    value: function _destroy() {
+      if (this._content) {
+        this._pageLoader.unload(this._content);
+      }
+      this.remove();
+    }
+  }, {
+    key: 'side',
+    get: function get$$1() {
+      return this.getAttribute('side') === 'right' ? 'right' : 'left';
+    }
+  }, {
+    key: 'page',
+    get: function get$$1() {
+      return this._page;
+    }
+
+    /**
+     * @param {*} page
+     */
+    ,
+    set: function set$$1(page) {
+      this._page = page;
+    }
+  }, {
+    key: '_content',
+    get: function get$$1() {
+      return this.children[0];
+    }
+
+    /**
+     * @property pageLoader
+     * @description
+     *   [en][/en]
+     *   [ja][/ja]
+     */
+
+  }, {
+    key: 'pageLoader',
+    get: function get$$1() {
+      return this._pageLoader;
+    },
+    set: function set$$1(loader) {
+      if (!(loader instanceof PageLoader)) {
+        util$1.throwPageLoader();
+      }
+      this._pageLoader = loader;
+    }
+
+    /**
+     * @property mode
+     * @readonly
+     * @type {String}
+     * @description
+     *   [en]Current mode. Possible values are "split", "collapse", "closed", "open" or "changing".[/en]
+     *   [ja][/ja]
+     */
+
+  }, {
+    key: 'mode',
+    get: function get$$1() {
+      return this._mode;
+    }
+
+    /**
+     * @property onSwipe
+     * @type {Function}
+     * @description
+     *   [en]Hook called whenever the user slides the splitter. It gets a decimal ratio (0-1) and an animationOptions object as arguments.[/en]
+     *   [ja][/ja]
+     */
+
+  }, {
+    key: 'onSwipe',
+    get: function get$$1() {
+      return this._onSwipe;
+    },
+    set: function set$$1(value) {
+      if (value && !(value instanceof Function)) {
+        util$1.throw('"onSwipe" must be a function');
+      }
+      this._onSwipe = value;
+    }
+
+    /**
+     * @property isOpen
+     * @type {Boolean}
+     * @readonly
+     * @description
+     *   [en]This value is `true` when the menu is open.[/en]
+     *   [ja][/ja]
+     */
+
+  }, {
+    key: 'isOpen',
+    get: function get$$1() {
+      return this._mode === COLLAPSE_MODE && this._state !== CLOSED_STATE;
+    }
+  }], [{
+    key: 'observedAttributes',
+    get: function get$$1() {
+      return ['animation', 'width', 'collapse', 'swipeable', 'animation-options'];
+    }
+  }, {
+    key: 'events',
+    get: function get$$1() {
+      return ['preopen', 'postopen', 'preclose', 'postclose', 'modechange'];
+    }
+  }, {
+    key: 'rewritables',
+    get: function get$$1() {
+      return rewritables$2;
+    }
+  }]);
+  return SplitterSideElement;
+}(BaseElement);
+
+onsElements.SplitterSide = SplitterSideElement;
+customElements.define('ons-splitter-side', SplitterSideElement);
+
+/*
+Copyright 2013-2015 ASIAL CORPORATION
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+   http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+*/
+
+var scheme$28 = {
+  '': 'switch--*',
+  '.switch__input': 'switch--*__input',
+  '.switch__handle': 'switch--*__handle',
+  '.switch__toggle': 'switch--*__toggle'
+};
+
+var locations = {
+  ios: [1, 21],
+  material: [0, 16]
+};
+
+/**
+ * @element ons-switch
+ * @category form
+ * @description
+ *   [en]
+ *     Switch component. The switch can be toggled both by dragging and tapping.
+ *
+ *     Will automatically displays a Material Design switch on Android devices.
+ *   [/en]
+ *   [ja]スイッチを表示するコンポーネントです。[/ja]
+ * @modifier material
+ *   [en]Material Design switch[/en]
+ *   [ja][/ja]
+ * @codepen LpXZQQ
+ * @tutorial vanilla/Reference/switch
+ * @guide theming.html#modifiers [en]More details about the `modifier` attribute[/en][ja]modifier属性の使い方[/ja]
+ * @example
+ * <ons-switch checked></ons-switch>
+ * <ons-switch disabled></ons-switch>
+ * <ons-switch modifier="material"></ons-switch>
+ */
+
+var SwitchElement = function (_BaseCheckboxElement) {
+  inherits(SwitchElement, _BaseCheckboxElement);
+
+  function SwitchElement() {
+    classCallCheck(this, SwitchElement);
+
+    var _this = possibleConstructorReturn(this, (SwitchElement.__proto__ || Object.getPrototypeOf(SwitchElement)).call(this));
+
+    contentReady(_this, function () {
+      _this.attributeChangedCallback('modifier', null, _this.getAttribute('modifier'));
+    });
+
+    _this._onChange = _this._onChange.bind(_this);
+    _this._onRelease = _this._onRelease.bind(_this);
+    _this._lastTimeStamp = 0;
+    return _this;
+  }
+
+  createClass(SwitchElement, [{
+    key: '_getPosition',
+
+
+    /* Own props */
+
+    value: function _getPosition(e) {
+      var l = this._locations;
+      return Math.min(l[1], Math.max(l[0], this._startX + e.gesture.deltaX));
+    }
+  }, {
+    key: '_emitChangeEvent',
+    value: function _emitChangeEvent() {
+      util$1.triggerElementEvent(this, 'change', {
+        value: this.checked,
+        switch: this,
+        isInteractive: true
+      });
+    }
+  }, {
+    key: '_onChange',
+    value: function _onChange(event) {
+      if (event && event.stopPropagation) {
+        event.stopPropagation();
+      }
+
+      this._emitChangeEvent();
+    }
+  }, {
+    key: '_onClick',
+    value: function _onClick(ev) {
+      if (ev.target.classList.contains(this.defaultElementClass + '__touch') || ev.timeStamp - this._lastTimeStamp < 50 // Prevent second click triggered by <label>
+      ) {
+          ev.preventDefault();
+        }
+      this._lastTimeStamp = ev.timeStamp;
+    }
+  }, {
+    key: '_onHold',
+    value: function _onHold(e) {
+      if (!this.disabled) {
+        ModifierUtil.addModifier(this, 'active');
+        document.addEventListener('release', this._onRelease);
+      }
+    }
+  }, {
+    key: '_onDragStart',
+    value: function _onDragStart(e) {
+      if (this.disabled || ['left', 'right'].indexOf(e.gesture.direction) === -1) {
+        ModifierUtil.removeModifier(this, 'active');
+        return;
+      }
+
+      e.consumed = true;
+
+      ModifierUtil.addModifier(this, 'active');
+      this._startX = this._locations[this.checked ? 1 : 0]; // - e.gesture.deltaX;
+
+      this.addEventListener('drag', this._onDrag);
+      document.addEventListener('release', this._onRelease);
+    }
+  }, {
+    key: '_onDrag',
+    value: function _onDrag(e) {
+      e.stopPropagation();
+      this._handle.style.left = this._getPosition(e) + 'px';
+    }
+  }, {
+    key: '_onRelease',
+    value: function _onRelease(e) {
+      var l = this._locations;
+      var position = this._getPosition(e);
+      var previousValue = this.checked;
+
+      this.checked = position >= (l[0] + l[1]) / 2;
+
+      if (this.checked !== previousValue) {
+        this._emitChangeEvent();
+      }
+
+      this.removeEventListener('drag', this._onDrag);
+      document.removeEventListener('release', this._onRelease);
+
+      this._handle.style.left = '';
+      ModifierUtil.removeModifier(this, 'active');
+    }
+  }, {
+    key: 'click',
+    value: function click() {
+      var ev = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
+
+      if (!this.disabled) {
+        this.checked = !this.checked;
+        this._emitChangeEvent();
+        this._lastTimeStamp = ev.timeStamp || 0;
+      }
+    }
+  }, {
+    key: 'connectedCallback',
+    value: function connectedCallback() {
+      var _this2 = this;
+
+      contentReady(this, function () {
+        _this2._input.addEventListener('change', _this2._onChange);
+      });
+
+      this.addEventListener('dragstart', this._onDragStart);
+      this.addEventListener('hold', this._onHold);
+      this.addEventListener('tap', this.click);
+      this.addEventListener('click', this._onClick);
+      this._gestureDetector = new GestureDetector(this, { dragMinDistance: 1, holdTimeout: 251, passive: true });
+    }
+  }, {
+    key: 'disconnectedCallback',
+    value: function disconnectedCallback() {
+      var _this3 = this;
+
+      contentReady(this, function () {
+        _this3._input.removeEventListener('change', _this3._onChange);
+      });
+
+      this.removeEventListener('dragstart', this._onDragStart);
+      this.removeEventListener('hold', this._onHold);
+      this.removeEventListener('tap', this.click);
+      this.removeEventListener('click', this._onClick);
+      if (this._gestureDetector) {
+        this._gestureDetector.dispose();
+      }
+    }
+  }, {
+    key: 'attributeChangedCallback',
+    value: function attributeChangedCallback(name, last, current) {
+      if (name === 'modifier') {
+        var md = (current || '').indexOf('material') !== -1;
+        this._locations = locations[md ? 'material' : 'ios'];
+      }
+
+      get(SwitchElement.prototype.__proto__ || Object.getPrototypeOf(SwitchElement.prototype), 'attributeChangedCallback', this).call(this, name, last, current);
+    }
+
+    /**
+     * @event change
+     * @description
+     *   [en]Fired when the switch is toggled.[/en]
+     *   [ja]ON/OFFが変わった時に発火します。[/ja]
+     * @param {Object} event
+     *   [en]Event object.[/en]
+     *   [ja]イベントオブジェクト。[/ja]
+     * @param {Object} event.switch
+     *   [en]Switch object.[/en]
+     *   [ja]イベントが発火したSwitchオブジェクトを返します。[/ja]
+     * @param {Boolean} event.value
+     *   [en]Current value.[/en]
+     *   [ja]現在の値を返します。[/ja]
+     * @param {Boolean} event.isInteractive
+     *   [en]True if the change was triggered by the user clicking on the switch.[/en]
+     *   [ja]タップやクリックなどのユーザの操作によって変わった場合にはtrueを返します。[/ja]
+     */
+
+    /**
+     * @attribute modifier
+     * @type {String}
+     * @description
+     *  [en]The appearance of the switch.[/en]
+     *  [ja]スイッチの表現を指定します。[/ja]
+     */
+
+    /**
+     * @attribute disabled
+     * @description
+     *   [en]Whether the switch is be disabled.[/en]
+     *   [ja]スイッチを無効の状態にする場合に指定します。[/ja]
+     */
+
+    /**
+     * @attribute checked
+     * @description
+     *   [en]Whether the switch is checked.[/en]
+     *   [ja]スイッチがONの状態にするときに指定します。[/ja]
+     */
+
+    /**
+     * @attribute input-id
+     * @type {String}
+     * @description
+     *   [en]Specify the `id` attribute of the inner `<input>` element. This is useful when using `<label for="...">` elements.[/en]
+     *   [ja][/ja]
+     */
+
+    /**
+     * @property checked
+     * @type {Boolean}
+     * @description
+     *   [en]This value is `true` if the switch is checked.[/en]
+     *   [ja]スイッチがONの場合に`true`。[/ja]
+     */
+
+    /**
+     * @property value
+     * @type {String}
+     * @description
+     *   [en]The current value of the input.[/en]
+     *   [ja][/ja]
+     */
+
+    /**
+     * @property disabled
+     * @type {Boolean}
+     * @description
+     *   [en]Whether the element is disabled or not.[/en]
+     *   [ja]無効化されている場合に`true`。[/ja]
+     */
+
+    /**
+     * @property checkbox
+     * @readonly
+     * @type {HTMLElement}
+     * @description
+     *   [en]The underlying checkbox element.[/en]
+     *   [ja]コンポーネント内部のcheckbox要素になります。[/ja]
+     */
+
+  }, {
+    key: '_scheme',
+    get: function get$$1() {
+      return scheme$28;
+    }
+  }, {
+    key: '_defaultClassName',
+    get: function get$$1() {
+      return 'switch';
+    }
+  }, {
+    key: '_template',
+    get: function get$$1() {
+      return '\n      <input type="' + this.type + '" class="' + this._defaultClassName + '__input">\n      <div class="' + this._defaultClassName + '__toggle">\n        <div class="' + this._defaultClassName + '__handle">\n          <div class="' + this._defaultClassName + '__touch"></div>\n        </div>\n      </div>\n    ';
+    }
+  }, {
+    key: 'type',
+    get: function get$$1() {
+      return 'checkbox';
+    }
+  }, {
+    key: '_handle',
+    get: function get$$1() {
+      return this.querySelector('.' + this._defaultClassName + '__handle');
+    }
+  }, {
+    key: 'checkbox',
+    get: function get$$1() {
+      return this._input;
+    }
+  }], [{
+    key: 'observedAttributes',
+    get: function get$$1() {
+      return [].concat(toConsumableArray(get(SwitchElement.__proto__ || Object.getPrototypeOf(SwitchElement), 'observedAttributes', this)), ['modifier']);
+    }
+  }]);
+  return SwitchElement;
+}(BaseCheckboxElement);
+
+onsElements.Switch = SwitchElement;
+customElements.define('ons-switch', SwitchElement);
+
+/*
+Copyright 2013-2015 ASIAL CORPORATION
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+   http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+*/
+
+var scheme$30 = {
+  '.tabbar__content': 'tabbar--*__content',
+  '.tabbar__border': 'tabbar--*__border',
+  '.tabbar': 'tabbar--*'
+};
+
+var rewritables$3 = {
+  /**
+   * @param {Element} tabbarElement
+   * @param {Function} callback
+   */
+  ready: function ready(tabbarElement, callback) {
+    callback();
+  }
+};
+
+var lerp = function lerp(x0, x1, t) {
+  return (1 - t) * x0 + t * x1;
+};
+
+/**
+ * @element ons-tabbar
+ * @category tabbar
+ * @description
+ *   [en]A component to display a tab bar on the bottom of a page. Used with `<ons-tab>` to manage pages using tabs.[/en]
+ *   [ja]タブバーをページ下部に表示するためのコンポーネントです。ons-tabと組み合わせて使うことで、ページを管理できます。[/ja]
+ * @codepen pGuDL
+ * @tutorial vanilla/Reference/tabbar
+ * @modifier material
+ *   [en]A tabbar in Material Design.[/en]
+ *   [ja][/ja]
+ * @modifier autogrow
+ *   [en]Tabs automatically grow depending on their content instead of having a fixed width.[/en]
+ *   [ja][/ja]
+ * @modifier top-border
+ *   [en]Shows a static border-bottom in tabs for iOS top tabbars.[/en]
+ *   [ja][/ja]
+ * @guide fundamentals.html#managing-pages
+ *  [en]Managing multiple pages.[/en]
+ *  [ja]複数のページを管理する[/ja]
+ * @seealso ons-tab
+ *   [en]The `<ons-tab>` component.[/en]
+ *   [ja]ons-tabコンポーネント[/ja]
+ * @seealso ons-page
+ *   [en]The `<ons-page>` component.[/en]
+ *   [ja]ons-pageコンポーネント[/ja]
+ * @example
+ * <ons-tabbar>
+ *   <ons-tab
+ *     page="home.html"
+ *     label="Home"
+ *     active>
+ *   </ons-tab>
+ *   <ons-tab
+ *     page="settings.html"
+ *     label="Settings"
+ *     active>
+ *   </ons-tab>
+ * </ons-tabbar>
+ *
+ * <template id="home.html">
+ *   ...
+ * </template>
+ *
+ * <template id="settings.html">
+ *   ...
+ * </template>
+ */
+
+var TabbarElement = function (_BaseElement) {
+  inherits(TabbarElement, _BaseElement);
+
+  /**
+   * @event prechange
+   * @description
+   *   [en]Fires just before the tab is changed.[/en]
+   *   [ja]アクティブなタブが変わる前に発火します。[/ja]
+   * @param {Object} event
+   *   [en]Event object.[/en]
+   *   [ja]イベントオブジェクト。[/ja]
+   * @param {Number} event.index
+   *   [en]Current index.[/en]
+   *   [ja]現在アクティブになっているons-tabのインデックスを返します。[/ja]
+   * @param {Object} event.tabItem
+   *   [en]Tab item object.[/en]
+   *   [ja]tabItemオブジェクト。[/ja]
+   * @param {Function} event.cancel
+   *   [en]Call this function to cancel the change event.[/en]
+   *   [ja]この関数を呼び出すと、アクティブなタブの変更がキャンセルされます。[/ja]
+   */
+
+  /**
+   * @event postchange
+   * @description
+   *   [en]Fires just after the tab is changed.[/en]
+   *   [ja]アクティブなタブが変わった後に発火します。[/ja]
+   * @param {Object} event
+   *   [en]Event object.[/en]
+   *   [ja]イベントオブジェクト。[/ja]
+   * @param {Number} event.index
+   *   [en]Current index.[/en]
+   *   [ja]現在アクティブになっているons-tabのインデックスを返します。[/ja]
+   * @param {Object} event.tabItem
+   *   [en]Tab item object.[/en]
+   *   [ja]tabItemオブジェクト。[/ja]
+   */
+
+  /**
+   * @event reactive
+   * @description
+   *   [en]Fires if the already open tab is tapped again.[/en]
+   *   [ja]すでにアクティブになっているタブがもう一度タップやクリックされた場合に発火します。[/ja]
+   * @param {Object} event
+   *   [en]Event object.[/en]
+   *   [ja]イベントオブジェクト。[/ja]
+   * @param {Number} event.index
+   *   [en]Current index.[/en]
+   *   [ja]現在アクティブになっているons-tabのインデックスを返します。[/ja]
+   * @param {Object} event.tabItem
+   *   [en]Tab item object.[/en]
+   *   [ja]tabItemオブジェクト。[/ja]
+   */
+
+  /**
+   * @attribute animation
+   * @type {String}
+   * @default none
+   * @description
+   *   [en]If this attribute is set to `"none"` the transitions will not be animated.[/en]
+   *   [ja][/ja]
+   */
+
+  /**
+   * @attribute animation-options
+   * @type {Expression}
+   * @description
+   *  [en]Specify the animation's duration, timing and delay with an object literal. E.g. `{duration: 0.2, delay: 1, timing: 'ease-in'}`.[/en]
+   *  [ja]アニメーション時のduration, timing, delayをオブジェクトリテラルで指定します。e.g. {duration: 0.2, delay: 1, timing: 'ease-in'}[/ja]
+   */
+
+  /**
+   * @attribute position
+   * @initonly
+   * @type {String}
+   * @default bottom
+   * @description
+   *   [en]Tabbar's position. Available values are `"bottom"` and `"top"`. Use `"auto"` to choose position depending on platform (bottom for iOS flat design, top for Material Design).[/en]
+   *   [ja]タブバーの位置を指定します。"bottom"もしくは"top"を選択できます。デフォルトは"bottom"です。[/ja]
+   */
+
+  /**
+   * @attribute swipeable
+   * @description
+   *   [en]If this attribute is set the tab bar can be scrolled by drag or swipe.[/en]
+   *   [ja]この属性がある時、タブバーをスワイプやドラッグで移動できるようになります。[/ja]
+   */
+
+  /**
+   * @attribute ignore-edge-width
+   * @type {Number}
+   * @default 20
+   * @description
+   *   [en]Distance in pixels from both edges. Swiping on these areas will prioritize parent components such as `ons-splitter` or `ons-navigator`.[/en]
+   *   [ja][/ja]
+   */
+
+  /**
+   * @attribute hide-tabs
+   * @description
+   *   [en]Whether to hide the tabs.[/en]
+   *   [ja]タブを非表示にする場合に指定します。[/ja]
+   */
+
+  /**
+   * @attribute tab-border
+   * @description
+   *   [en]If this attribute is set the tabs show a dynamic bottom border. Only works for iOS flat design since the border is always visible in Material Design.[/en]
+   *   [ja][/ja]
+   */
+
+  /**
+   * @attribute modifier
+   * @type {String}
+   * @description
+   *   [en]The appearance of the tabbar.[/en]
+   *   [ja]タブバーの表現を指定します。[/ja]
+   */
+
+  function TabbarElement() {
+    classCallCheck(this, TabbarElement);
+
+    var _this = possibleConstructorReturn(this, (TabbarElement.__proto__ || Object.getPrototypeOf(TabbarElement)).call(this));
+
+    _this._loadInactive = util$1.defer(); // Improves #2324
+    contentReady(_this, function () {
+      return _this._compile();
+    });
+    return _this;
+  }
+
+  createClass(TabbarElement, [{
+    key: 'connectedCallback',
+    value: function connectedCallback() {
+      var _this2 = this;
+
+      if (!this._swiper) {
+        this._swiper = new Swiper({
+          getElement: function getElement() {
+            return _this2._contentElement;
+          },
+          getInitialIndex: function getInitialIndex() {
+            return _this2.getAttribute('activeIndex') || _this2.getAttribute('active-index');
+          },
+          getAutoScrollRatio: this._getAutoScrollRatio.bind(this),
+          getBubbleWidth: function getBubbleWidth() {
+            return parseInt(_this2.getAttribute('ignore-edge-width') || 25, 10);
+          },
+          isAutoScrollable: function isAutoScrollable() {
+            return true;
+          },
+          preChangeHook: this._onPreChange.bind(this),
+          postChangeHook: this._onPostChange.bind(this),
+          refreshHook: this._onRefresh.bind(this),
+          scrollHook: this._onScroll.bind(this)
+        });
+
+        contentReady(this, function () {
+          _this2._tabbarBorder = util$1.findChild(_this2._tabbarElement, '.tabbar__border');
+          _this2._swiper.init({ swipeable: _this2.hasAttribute('swipeable') });
+        });
+      }
+
+      contentReady(this, function () {
+        _this2._updatePosition();
+
+        if (!util$1.findParent(_this2, 'ons-page', function (p) {
+          return p === document.body;
+        })) {
+          _this2._show(); // This tabbar is the top component
+        }
+      });
+    }
+  }, {
+    key: 'disconnectedCallback',
+    value: function disconnectedCallback() {
+      if (this._swiper && this._swiper.initialized) {
+        this._swiper.dispose();
+        this._swiper = null;
+        this._tabbarBorder = null;
+        this._tabsRect = null;
+      }
+    }
+  }, {
+    key: '_normalizeEvent',
+    value: function _normalizeEvent(event) {
+      return _extends({}, event, { index: event.activeIndex, tabItem: this.tabs[event.activeIndex] });
+    }
+  }, {
+    key: '_onPostChange',
+    value: function _onPostChange(event) {
+      event = this._normalizeEvent(event);
+      util$1.triggerElementEvent(this, 'postchange', event);
+      var page = event.tabItem.pageElement;
+      page && page._show();
+    }
+  }, {
+    key: '_onPreChange',
+    value: function _onPreChange(event) {
+      event = this._normalizeEvent(event);
+      event.cancel = function () {
+        return event.canceled = true;
+      };
+
+      util$1.triggerElementEvent(this, 'prechange', event);
+
+      if (!event.canceled) {
+        var _event = event,
+            activeIndex = _event.activeIndex,
+            lastActiveIndex = _event.lastActiveIndex;
+
+        var tabs = this.tabs;
+
+        tabs[activeIndex].setActive(true);
+        if (lastActiveIndex >= 0) {
+          var prevTab = tabs[lastActiveIndex];
+          prevTab.setActive(false);
+          prevTab.pageElement && prevTab.pageElement._hide();
+        }
+      }
+
+      return event.canceled;
+    }
+  }, {
+    key: '_onScroll',
+    value: function _onScroll(index) {
+      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
+
+      if (this._tabbarBorder) {
+        this._tabbarBorder.style.transition = 'all ' + (options.duration || 0) + 's ' + (options.timing || '');
+
+        if (this._autogrow && this._tabsRect.length > 0) {
+          var a = Math.floor(index),
+              b = Math.ceil(index),
+              r = index % 1;
+          this._tabbarBorder.style.width = lerp(this._tabsRect[a].width, this._tabsRect[b].width, r) + 'px';
+          this._tabbarBorder.style.transform = 'translate3d(' + lerp(this._tabsRect[a].left, this._tabsRect[b].left, r) + 'px, 0, 0)';
+        } else {
+          this._tabbarBorder.style.transform = 'translate3d(' + index * 100 + '%, 0, 0)';
+        }
+      }
+
+      this._onSwipe && this._onSwipe(index, options);
+    }
+  }, {
+    key: '_onRefresh',
+    value: function _onRefresh() {
+      this._autogrow = util$1.hasModifier(this, 'autogrow');
+      this._tabsRect = this.tabs.map(function (tab) {
+        return tab.getBoundingClientRect();
+      });
+      if (this._tabbarBorder) {
+        this._tabbarBorder.style.display = this.hasAttribute('tab-border') || util$1.hasModifier(this, 'material') ? 'block' : 'none';
+        var index = this.getActiveTabIndex();
+        if (this._tabsRect.length > 0 && index >= 0) {
+          this._tabbarBorder.style.width = this._tabsRect[index].width + 'px';
+        }
+      }
+    }
+  }, {
+    key: '_getAutoScrollRatio',
+    value: function _getAutoScrollRatio(matches, velocity, size) {
+      var ratio = .6; // Base ratio
+      var modifier = size / 300 * (matches ? -1 : 1); // Based on screen size
+      return Math.min(1, Math.max(0, ratio + velocity * modifier));
+    }
+  }, {
+    key: '_compile',
+    value: function _compile() {
+      autoStyle.prepare(this);
+
+      var content = this._contentElement || util$1.create('.tabbar__content');
+      content.classList.add('ons-tabbar__content');
+      var tabbar = this._tabbarElement || util$1.create('.tabbar');
+      tabbar.classList.add('ons-tabbar__footer');
+
+      if (!tabbar.parentNode) {
+        while (this.firstChild) {
+          tabbar.appendChild(this.firstChild);
+        }
+      }
+
+      var activeIndex = Number(this.getAttribute('activeIndex')); // 0 by default
+      if (tabbar.children.length > activeIndex && !util$1.findChild(tabbar, '[active]')) {
+        tabbar.children[activeIndex].setAttribute('active', '');
+      }
+
+      this._tabbarBorder = util$1.findChild(tabbar, '.tabbar__border') || util$1.create('.tabbar__border');
+      tabbar.appendChild(this._tabbarBorder);
+      tabbar.classList.add('ons-swiper-tabbar'); // Hides material border
+
+      !content.children[0] && content.appendChild(document.createElement('div'));
+      !content.children[1] && content.appendChild(document.createElement('div'));
+      content.appendChild = content.appendChild.bind(content.children[0]);
+      content.insertBefore = content.insertBefore.bind(content.children[0]);
+
+      this.appendChild(content);
+      this.appendChild(tabbar); // Triggers ons-tab connectedCallback
+
+      ModifierUtil.initModifier(this, scheme$30);
+    }
+  }, {
+    key: '_updatePosition',
+    value: function _updatePosition() {
+      var _this3 = this;
+
+      var position = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.getAttribute('position');
+
+      var top = this._top = position === 'top' || position === 'auto' && util$1.hasModifier(this, 'material');
+      var action = top ? util$1.addModifier : util$1.removeModifier;
+
+      action(this, 'top');
+
+      var page = util$1.findParent(this, 'ons-page');
+      if (page) {
+        contentReady(page, function () {
+          var p = 0;
+          if (page.children[0] && util$1.match(page.children[0], 'ons-toolbar')) {
+            action(page.children[0], 'noshadow');
+            p = 1; // Visual fix for some devices
+          }
+
+          var content = page._getContentElement();
+          var cs = window.getComputedStyle(page._getContentElement(), null);
+
+          _this3.style.top = top ? parseInt(cs.getPropertyValue('padding-top'), 10) - p + 'px' : '';
+
+          // Refresh content top - Fix for iOS 8
+          content.style.top = cs.top;
+          content.style.top = '';
+        });
+      }
+
+      internal$1.autoStatusBarFill(function () {
+        var filled = util$1.findParent(_this3, function (e) {
+          return e.hasAttribute('status-bar-fill');
+        });
+        util$1.toggleAttribute(_this3, 'status-bar-fill', top && !filled);
+      });
+    }
+  }, {
+    key: 'setActiveTab',
+
+
+    /**
+     * @method setActiveTab
+     * @signature setActiveTab(index, [options])
+     * @param {Number} index
+     *   [en]Tab index.[/en]
+     *   [ja]タブのインデックスを指定します。[/ja]
+     * @param {Object} [options]
+     *   [en]Parameter object.[/en]
+     *   [ja]オプションを指定するオブジェクト。[/ja]
+     * @param {Function} [options.callback]
+     *   [en]Function that runs when the new page has loaded.[/en]
+     *   [ja][/ja]
+     * @param {String} [options.animation]
+     *   [en]If this option is "none", the transition won't slide.[/en]
+     *   [ja][/ja]
+     * @param {String} [options.animationOptions]
+     *   [en]Specify the animation's duration, delay and timing. E.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}`.[/en]
+     *   [ja]アニメーション時のduration, delay, timingを指定します。e.g. {duration: 0.2, delay: 0.4, timing: 'ease-in'}[/ja]
+     * @description
+     *   [en]Show specified tab page. Animations and their options can be specified by the second parameter.[/en]
+     *   [ja]指定したインデックスのタブを表示します。アニメーションなどのオプションを指定できます。[/ja]
+     * @return {Promise}
+     *   [en]A promise that resolves to the new page element.[/en]
+     *   [ja][/ja]
+     */
+    value: function setActiveTab(nextIndex) {
+      var _this4 = this;
+
+      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
+
+      var prevIndex = this.getActiveTabIndex();
+      var prevTab = this.tabs[prevIndex],
+          nextTab = this.tabs[nextIndex];
+
+      if (!nextTab) {
+        return Promise.reject('Specified index does not match any tab.');
+      }
+
+      if (nextIndex === prevIndex) {
+        util$1.triggerElementEvent(this, 'reactive', { index: nextIndex, activeIndex: nextIndex, tabItem: nextTab });
+        return Promise.resolve(nextTab.pageElement);
+      }
+
+      // FIXME: nextTab.loaded is broken in Zone.js promises (Angular2)
+      var nextPage = nextTab.pageElement;
+      return (nextPage ? Promise.resolve(nextPage) : nextTab.loaded).then(function (nextPage) {
+        return _this4._swiper.setActiveIndex(nextIndex, _extends({
+          reject: true
+        }, options, {
+          animation: prevTab && nextPage ? options.animation || _this4.getAttribute('animation') : 'none',
+          animationOptions: util$1.extend({ duration: .3, timing: 'cubic-bezier(.4, .7, .5, 1)' }, _this4.hasAttribute('animation-options') ? util$1.animationOptionsParse(_this4.getAttribute('animation-options')) : {}, options.animationOptions || {})
+        })).then(function () {
+          options.callback instanceof Function && options.callback(nextPage);
+          return nextPage;
+        });
+      });
+    }
+
+    /**
+     * @method setTabbarVisibility
+     * @signature setTabbarVisibility(visible)
+     * @param {Boolean} visible
+     * @description
+     *   [en]Used to hide or show the tab bar.[/en]
+     *   [ja][/ja]
+     */
+
+  }, {
+    key: 'setTabbarVisibility',
+    value: function setTabbarVisibility(visible) {
+      var _this5 = this;
+
+      contentReady(this, function () {
+        _this5._contentElement.style[_this5._top ? 'top' : 'bottom'] = visible ? '' : '0px';
+        _this5._tabbarElement.style.display = visible ? '' : 'none';
+        visible && _this5._onRefresh();
+      });
+    }
+  }, {
+    key: 'show',
+    value: function show() {
+      this.setTabbarVisibility(true);
+    }
+  }, {
+    key: 'hide',
+    value: function hide() {
+      this.setTabbarVisibility(false);
+    }
+
+    /**
+     * @property visible
+     * @readonly
+     * @type {Boolean}
+     * @description
+     *   [en]Whether the tabbar is visible or not.[/en]
+     *   [ja]タブバーが見える場合に`true`。[/ja]
+     */
+
+  }, {
+    key: 'getActiveTabIndex',
+
+
+    /**
+     * @method getActiveTabIndex
+     * @signature getActiveTabIndex()
+     * @return {Number}
+     *   [en]The index of the currently active tab.[/en]
+     *   [ja]現在アクティブになっているタブのインデックスを返します。[/ja]
+     * @description
+     *   [en]Returns tab index on current active tab. If active tab is not found, returns -1.[/en]
+     *   [ja]現在アクティブになっているタブのインデックスを返します。現在アクティブなタブがない場合には-1を返します。[/ja]
+     */
+    value: function getActiveTabIndex() {
+      var tabs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.tabs;
+
+      for (var i = 0; i < tabs.length; i++) {
+        if (tabs[i] && tabs[i].tagName === 'ONS-TAB' && tabs[i].isActive()) {
+          return i;
+        }
+      }
+      return -1;
+    }
+  }, {
+    key: '_show',
+    value: function _show() {
+      var _this6 = this;
+
+      this._swiper.show();
+
+      setImmediate(function () {
+        var tabs = _this6.tabs;
+        var activeIndex = _this6.getActiveTabIndex(tabs);
+        _this6._loadInactive.resolve();
+        if (tabs.length > 0 && activeIndex >= 0) {
+          tabs[activeIndex].loaded.then(function (el) {
+            return el && setImmediate(function () {
+              return el._show();
+            });
+          });
+        }
+      });
+    }
+  }, {
+    key: '_hide',
+    value: function _hide() {
+      this._swiper.hide();
+      var topPage = this.topPage;
+      topPage && topPage._hide();
+    }
+  }, {
+    key: '_destroy',
+    value: function _destroy() {
+      this.tabs.forEach(function (tab) {
+        return tab.remove();
+      });
+      this.remove();
+    }
+  }, {
+    key: 'attributeChangedCallback',
+    value: function attributeChangedCallback(name, last, current) {
+      if (name === 'modifier') {
+        ModifierUtil.onModifierChanged(last, current, this, scheme$30);
+        var isTop = function isTop(m) {
+          return (/(^|\s+)top($|\s+)/i.test(m)
+          );
+        };
+        isTop(last) !== isTop(current) && this._updatePosition();
+      } else if (name === 'position') {
+        util$1.isAttached(this) && this._updatePosition();
+      } else if (name === 'swipeable') {
+        this._swiper && this._swiper.updateSwipeable(this.hasAttribute('swipeable'));
+      } else if (name === 'hide-tabs') {
+        this.setTabbarVisibility(!this.hasAttribute('hide-tabs') || current === 'false');
+      }
+    }
+  }, {
+    key: '_tabbarElement',
+    get: function get$$1() {
+      return util$1.findChild(this, '.tabbar');
+    }
+  }, {
+    key: '_contentElement',
+    get: function get$$1() {
+      return util$1.findChild(this, '.tabbar__content');
+    }
+  }, {
+    key: '_targetElement',
+    get: function get$$1() {
+      var content = this._contentElement;
+      return content && content.children[0] || null;
+    }
+  }, {
+    key: 'topPage',
+    get: function get$$1() {
+      var tabs = this.tabs,
+          index = this.getActiveTabIndex();
+      return tabs[index] ? tabs[index].pageElement || this.pages[0] || null : null;
+    }
+  }, {
+    key: 'pages',
+    get: function get$$1() {
+      return util$1.arrayFrom(this._targetElement.children);
+    }
+  }, {
+    key: 'tabs',
+    get: function get$$1() {
+      return Array.prototype.filter.call(this._tabbarElement.children, function (e) {
+        return e.tagName === 'ONS-TAB';
+      });
+    }
+  }, {
+    key: 'visible',
+    get: function get$$1() {
+      return this._tabbarElement.style.display !== 'none';
+    }
+
+    /**
+     * @property swipeable
+     * @type {Boolean}
+     * @description
+     *   [en]Enable swipe interaction.[/en]
+     *   [ja]swipeableであればtrueを返します。[/ja]
+     */
+
+  }, {
+    key: 'swipeable',
+    get: function get$$1() {
+      return this.hasAttribute('swipeable');
+    },
+    set: function set$$1(value) {
+      return util$1.toggleAttribute(this, 'swipeable', value);
+    }
+
+    /**
+     * @property onSwipe
+     * @type {Function}
+     * @description
+     *   [en]Hook called whenever the user slides the tabbar. It gets a decimal index and an animationOptions object as arguments.[/en]
+     *   [ja][/ja]
+     */
+
+  }, {
+    key: 'onSwipe',
+    get: function get$$1() {
+      return this._onSwipe;
+    },
+    set: function set$$1(value) {
+      if (value && !(value instanceof Function)) {
+        util$1.throw('"onSwipe" must be a function');
+      }
+      this._onSwipe = value;
+    }
+  }], [{
+    key: 'observedAttributes',
+    get: function get$$1() {
+      return ['modifier', 'position', 'swipeable', 'tab-border', 'hide-tabs'];
+    }
+  }, {
+    key: 'rewritables',
+    get: function get$$1() {
+      return rewritables$3;
+    }
+  }, {
+    key: 'events',
+    get: function get$$1() {
+      return ['prechange', 'postchange', 'reactive'];
+    }
+  }]);
+  return TabbarElement;
+}(BaseElement);
+
+onsElements.Tabbar = TabbarElement;
+customElements.define('ons-tabbar', TabbarElement);
+
+/*
+Copyright 2013-2015 ASIAL CORPORATION
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+   http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+*/
+
+var defaultClassName$16 = 'tabbar__item';
+
+var scheme$29 = {
+  '': 'tabbar--*__item',
+  '.tabbar__button': 'tabbar--*__button'
+};
+
+/**
+ * @element ons-tab
+ * @category tabbar
+ * @description
+ *   [en]Represents a tab inside tab bar. Each `<ons-tab>` represents a page.[/en]
+ *   [ja]
+ *     タブバーに配置される各アイテムのコンポーネントです。それぞれのons-tabはページを表します。
+ *     ons-tab要素の中には、タブに表示されるコンテンツを直接記述することが出来ます。
+ *   [/ja]
+ * @codepen pGuDL
+ * @tutorial vanilla/Reference/tabbar
+ * @guide fundamentals.html#managing-pages
+ *   [en]Managing multiple pages.[/en]
+ *   [ja]複数のページを管理する[/ja]]
+ * @guide appsize.html#removing-icon-packs [en]Removing icon packs.[/en][ja][/ja]
+ * @guide faq.html#how-can-i-use-custom-icon-packs [en]Adding custom icon packs.[/en][ja][/ja]
+ * @seealso ons-tabbar
+ *   [en]ons-tabbar component[/en]
+ *   [ja]ons-tabbarコンポーネント[/ja]
+ * @seealso ons-page
+ *   [en]ons-page component[/en]
+ *   [ja]ons-pageコンポーネント[/ja]
+ * @seealso ons-icon
+ *   [en]ons-icon component[/en]
+ *   [ja]ons-iconコンポーネント[/ja]
+ * @example
+ * <ons-tabbar>
+ *   <ons-tab
+ *     page="home.html"
+ *     label="Home"
+ *     active>
+ *   </ons-tab>
+ *   <ons-tab
+ *     page="settings.html"
+ *     label="Settings"
+ *     active>
+ *   </ons-tab>
+ * </ons-tabbar>
+ *
+ * <template id="home.html">
+ *   ...
+ * </template>
+ *
+ * <template id="settings.html">
+ *   ...
+ * </template>
+
+ */
+
+var TabElement = function (_BaseElement) {
+  inherits(TabElement, _BaseElement);
+
+  /**
+   * @attribute page
+   * @initonly
+   * @type {String}
+   * @description
+   *   [en]The page that is displayed when the tab is tapped.[/en]
+   *   [ja]ons-tabが参照するページへのURLを指定します。[/ja]
+   */
+
+  /**
+   * @attribute icon
+   * @type {String}
+   * @description
+   *   [en]
+   *     The icon name for the tab. Can specify the same icon name as `<ons-icon>`. Check [See also](#seealso) section for more information.
+   *   [/en]
+   *   [ja]
+   *     アイコン名を指定します。ons-iconと同じアイコン名を指定できます。
+   *     個別にアイコンをカスタマイズする場合は、background-imageなどのCSSスタイルを用いて指定できます。
+   *   [/ja]
+   */
+
+  /**
+   * @attribute active-icon
+   * @type {String}
+   * @description
+   *   [en]The name of the icon when the tab is active.[/en]
+   *   [ja]アクティブの際のアイコン名を指定します。[/ja]
+   */
+
+  /**
+   * @attribute label
+   * @type {String}
+   * @description
+   *   [en]The label of the tab item.[/en]
+   *   [ja]アイコン下に表示されるラベルを指定します。[/ja]
+   */
+
+  /**
+   * @attribute badge
+   * @type {String}
+   * @description
+   *   [en]Display a notification badge on top of the tab.[/en]
+   *   [ja]バッジに表示する内容を指定します。[/ja]
+   */
+
+  /**
+   * @attribute active
+   * @description
+   *   [en]This attribute should be set to the tab that is active by default.[/en]
+   *   [ja][/ja]
+   */
+
+  function TabElement() {
+    classCallCheck(this, TabElement);
+
+    var _this = possibleConstructorReturn(this, (TabElement.__proto__ || Object.getPrototypeOf(TabElement)).call(this));
+
+    if (['label', 'icon', 'badge'].some(_this.hasAttribute.bind(_this))) {
+      _this._compile();
+    } else {
+      contentReady(_this, function () {
+        return _this._compile();
+      });
+    }
+
+    _this._pageLoader = defaultPageLoader;
+    _this._onClick = _this._onClick.bind(_this);
+    return _this;
+  }
+
+  createClass(TabElement, [{
+    key: '_compile',
+    value: function _compile() {
+      autoStyle.prepare(this);
+      this.classList.add(defaultClassName$16);
+
+      if (this._button) {
+        return;
+      }
+
+      var button = util$1.create('button.tabbar__button');
+      while (this.childNodes[0]) {
+        button.appendChild(this.childNodes[0]);
+      }
+
+      var input = util$1.create('input', { display: 'none' });
+      input.type = 'radio';
+
+      this.appendChild(input);
+      this.appendChild(button);
+
+      this._updateButtonContent();
+      ModifierUtil.initModifier(this, scheme$29);
+      this._updateRipple();
+    }
+  }, {
+    key: '_updateRipple',
+    value: function _updateRipple() {
+      this._button && util$1.updateRipple(this._button, this.hasAttribute('ripple'));
+    }
+  }, {
+    key: '_updateButtonContent',
+    value: function _updateButtonContent() {
+      var _this2 = this;
+
+      var button = this._button;
+
+      var iconWrapper = this._icon;
+      if (this.hasAttribute('icon')) {
+        iconWrapper = iconWrapper || util$1.createElement('<div class="tabbar__icon"><ons-icon></ons-icon></div>');
+        var icon = iconWrapper.children[0];
+        var fix = function (last) {
+          return function () {
+            return icon.attributeChangedCallback('icon', last, _this2.getAttribute('icon'));
+          };
+        }(icon.getAttribute('icon'));
+        icon.setAttribute('icon', this.getAttribute('icon'));
+        iconWrapper.parentElement !== button && button.insertBefore(iconWrapper, button.firstChild);
+
+        // dirty fix for https://github.com/OnsenUI/OnsenUI/issues/1654
+        icon.attributeChangedCallback instanceof Function ? fix() : setImmediate(function () {
+          return icon.attributeChangedCallback instanceof Function && fix();
+        });
+      } else {
+        iconWrapper && iconWrapper.remove();
+      }
+
+      ['label', 'badge'].forEach(function (attr, index) {
+        var prop = _this2.querySelector('.tabbar__' + attr);
+        if (_this2.hasAttribute(attr)) {
+          prop = prop || util$1.create('.tabbar__' + attr + (attr === 'badge' ? ' notification' : ''));
+          prop.textContent = _this2.getAttribute(attr);
+          prop.parentElement !== button && button.appendChild(prop);
+        } else {
+          prop && prop.remove();
+        }
+      });
+    }
+  }, {
+    key: '_onClick',
+    value: function _onClick() {
+      if (this.onClick instanceof Function) {
+        this.onClick();
+      } else {
+        this._tabbar.setActiveTab(this.index, { reject: false });
+      }
+    }
+  }, {
+    key: 'setActive',
+    value: function setActive() {
+      var active = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
+
+      this._input.checked = active;
+      this.classList.toggle('active', active);
+      util$1.toggleAttribute(this, 'active', active);
+
+      if (this.hasAttribute('icon') && this.hasAttribute('active-icon')) {
+        this._icon.children[0].setAttribute('icon', this.getAttribute(active ? 'active-icon' : 'icon'));
+      }
+    }
+  }, {
+    key: '_loadPageElement',
+    value: function _loadPageElement(parent, page) {
+      var _this3 = this;
+
+      this._hasLoaded = true;
+
+      return new Promise(function (resolve) {
+        _this3._pageLoader.load({ parent: parent, page: page }, function (pageElement) {
+          parent.replaceChild(pageElement, parent.children[_this3.index]); // Ensure position
+          _this3._loadedPage = pageElement;
+          resolve(pageElement);
+        });
+      });
+    }
+  }, {
+    key: 'isActive',
+
+
+    /**
+     * @return {Boolean}
+     */
+    value: function isActive() {
+      return this.classList.contains('active');
+    }
+  }, {
+    key: 'disconnectedCallback',
+    value: function disconnectedCallback() {
+      this.removeEventListener('click', this._onClick, false);
+      if (this._loadedPage) {
+        this._hasLoaded = false;
+        this.loaded = null;
+      }
+    }
+  }, {
+    key: 'connectedCallback',
+    value: function connectedCallback() {
+      var _this4 = this;
+
+      this.addEventListener('click', this._onClick, false);
+
+      if (!util$1.isAttached(this) || this.loaded) {
+        return; // ons-tabbar compilation may trigger this
+      }
+
+      var deferred = util$1.defer();
+      this.loaded = deferred.promise;
+
+      contentReady(this, function () {
+        var index = _this4.index;
+        var tabbar = _this4._tabbar;
+        if (!tabbar) {
+          util$1.throw('Tab elements must be children of Tabbar');
+        }
+
+        if (tabbar.hasAttribute('modifier')) {
+          util$1.addModifier(_this4, tabbar.getAttribute('modifier'));
+        }
+
+        if (!_this4._hasLoaded) {
+          if (_this4.hasAttribute('active')) {
+            _this4.setActive(true);
+            tabbar.setAttribute('activeIndex', index);
+          }
+
+          if (index === tabbar.tabs.length - 1) {
+            tabbar._onRefresh();
+            setImmediate(function () {
+              return tabbar._onRefresh();
+            });
+          }
+
+          TabbarElement.rewritables.ready(tabbar, function () {
+            var pageTarget = _this4.page || _this4.getAttribute('page');
+            if (!_this4.pageElement && pageTarget) {
+              var parentTarget = tabbar._targetElement;
+              var dummyPage = util$1.create('div', { height: '100%', width: '100%', visibility: 'hidden' });
+              parentTarget.insertBefore(dummyPage, parentTarget.children[index]); // Ensure position
+
+              var load = function load() {
+                return _this4._loadPageElement(parentTarget, pageTarget).then(deferred.resolve);
+              };
+              return _this4.isActive() ? load() : tabbar._loadInactive.promise.then(load);
+            }
+
+            return deferred.resolve(_this4.pageElement);
+          });
+        }
+      });
+    }
+  }, {
+    key: 'attributeChangedCallback',
+    value: function attributeChangedCallback(name, last, current) {
+      var _this5 = this;
+
+      switch (name) {
+        case 'class':
+          util$1.restoreClass(this, defaultClassName$16, scheme$29);
+          break;
+        case 'modifier':
+          contentReady(this, function () {
+            return ModifierUtil.onModifierChanged(last, current, _this5, scheme$29);
+          });
+          break;
+        case 'ripple':
+          contentReady(this, function () {
+            return _this5._updateRipple();
+          });
+          break;
+        case 'icon':
+        case 'label':
+        case 'badge':
+          contentReady(this, function () {
+            return _this5._updateButtonContent();
+          });
+          break;
+        case 'page':
+          this.page = current || '';
+          break;
+      }
+    }
+  }, {
+    key: 'pageLoader',
+    set: function set$$1(loader) {
+      if (!(loader instanceof PageLoader)) {
+        util$1.throwPageLoader();
+      }
+      this._pageLoader = loader;
+    },
+    get: function get$$1() {
+      return this._pageLoader;
+    }
+  }, {
+    key: '_input',
+    get: function get$$1() {
+      return util$1.findChild(this, 'input');
+    }
+  }, {
+    key: '_button',
+    get: function get$$1() {
+      return util$1.findChild(this, '.tabbar__button');
+    }
+  }, {
+    key: '_icon',
+    get: function get$$1() {
+      return this.querySelector('.tabbar__icon');
+    }
+  }, {
+    key: '_tabbar',
+    get: function get$$1() {
+      return util$1.findParent(this, 'ons-tabbar');
+    }
+  }, {
+    key: 'index',
+    get: function get$$1() {
+      return Array.prototype.indexOf.call(this.parentElement.children, this);
+    }
+  }, {
+    key: 'pageElement',
+    get: function get$$1() {
+      // It has been loaded by ons-tab
+      if (this._loadedPage) {
+        return this._loadedPage;
+      }
+      // Manually attached to DOM, 1 per tab
+      var tabbar = this._tabbar;
+      if (tabbar.pages.length === tabbar.tabs.length) {
+        return tabbar.pages[this.index];
+      }
+      // Loaded in another way
+      return null;
+    }
+  }], [{
+    key: 'observedAttributes',
+    get: function get$$1() {
+      return ['modifier', 'ripple', 'icon', 'label', 'page', 'badge', 'class'];
+    }
+  }]);
+  return TabElement;
+}(BaseElement);
+
+onsElements.Tab = TabElement;
+customElements.define('ons-tab', TabElement);
+
+/*
+Copyright 2013-2015 ASIAL CORPORATION
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+   http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+*/
+
+var ToastAnimator = function (_BaseAnimator) {
+  inherits(ToastAnimator, _BaseAnimator);
+
+  /**
+   * @param {Object} options
+   * @param {String} options.timing
+   * @param {Number} options.duration
+   * @param {Number} options.delay
+   */
+  function ToastAnimator() {
+    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
+        _ref$timing = _ref.timing,
+        timing = _ref$timing === undefined ? 'linear' : _ref$timing,
+        _ref$delay = _ref.delay,
+        delay = _ref$delay === undefined ? 0 : _ref$delay,
+        _ref$duration = _ref.duration,
+        duration = _ref$duration === undefined ? 0.2 : _ref$duration;
+
+    classCallCheck(this, ToastAnimator);
+    return possibleConstructorReturn(this, (ToastAnimator.__proto__ || Object.getPrototypeOf(ToastAnimator)).call(this, { timing: timing, delay: delay, duration: duration }));
+  }
+
+  /**
+   * @param {HTMLElement} modal
+   * @param {Function} callback
+   */
+
+
+  createClass(ToastAnimator, [{
+    key: 'show',
+    value: function show(modal, callback) {
+      callback();
+    }
+
+    /**
+     * @param {HTMLElement} modal
+     * @param {Function} callback
+     */
+
+  }, {
+    key: 'hide',
+    value: function hide(modal, callback) {
+      callback();
+    }
+  }]);
+  return ToastAnimator;
+}(BaseAnimator);
+
+/*
+Copyright 2013-2015 ASIAL CORPORATION
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+   http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+*/
+
+/**
+ * iOS style animator for dialog.
+ */
+
+var FadeToastAnimator = function (_ToastAnimator) {
+  inherits(FadeToastAnimator, _ToastAnimator);
+
+  function FadeToastAnimator() {
+    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
+        _ref$timing = _ref.timing,
+        timing = _ref$timing === undefined ? 'linear' : _ref$timing,
+        _ref$delay = _ref.delay,
+        delay = _ref$delay === undefined ? 0 : _ref$delay,
+        _ref$duration = _ref.duration,
+        duration = _ref$duration === undefined ? 0.3 : _ref$duration;
+
+    classCallCheck(this, FadeToastAnimator);
+    return possibleConstructorReturn(this, (FadeToastAnimator.__proto__ || Object.getPrototypeOf(FadeToastAnimator)).call(this, { timing: timing, delay: delay, duration: duration }));
+  }
+
+  /**
+   * @param {HTMLElement} toast
+   * @param {Function} callback
+   */
+
+
+  createClass(FadeToastAnimator, [{
+    key: 'show',
+    value: function show(toast, callback) {
+      callback = callback ? callback : function () {};
+
+      Animit(toast, this.def).default({ opacity: 0 }, { opacity: 1 }).queue(function (done) {
+        callback();
+        done();
+      }).play();
+    }
+
+    /**
+     * @param {HTMLElement} toast
+     * @param {Function} callback
+     */
+
+  }, {
+    key: 'hide',
+    value: function hide(toast, callback) {
+      callback = callback ? callback : function () {};
+
+      Animit(toast, this.def).default({ opacity: 1 }, { opacity: 0 }).queue(function (done) {
+        callback();
+        done();
+      }).play();
+    }
+  }]);
+  return FadeToastAnimator;
+}(ToastAnimator);
+
+/*
+Copyright 2013-2015 ASIAL CORPORATION
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+   http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+*/
+
+/**
+ * Ascend Toast Animator.
+ */
+
+var AscendToastAnimator = function (_ToastAnimator) {
+  inherits(AscendToastAnimator, _ToastAnimator);
+
+  function AscendToastAnimator() {
+    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
+        _ref$timing = _ref.timing,
+        timing = _ref$timing === undefined ? 'ease' : _ref$timing,
+        _ref$delay = _ref.delay,
+        delay = _ref$delay === undefined ? 0 : _ref$delay,
+        _ref$duration = _ref.duration,
+        duration = _ref$duration === undefined ? 0.25 : _ref$duration;
+
+    classCallCheck(this, AscendToastAnimator);
+
+    var _this = possibleConstructorReturn(this, (AscendToastAnimator.__proto__ || Object.getPrototypeOf(AscendToastAnimator)).call(this, { timing: timing, delay: delay, duration: duration }));
+
+    _this.messageDelay = _this.duration * 0.4 + _this.delay; // Delay message opacity change
+    if (platform.isAndroid()) {
+      _this.ascension = 48; // Toasts are always 1 line
+    } else {
+      if (iPhoneXPatch.isIPhoneXPortraitPatchActive()) {
+        _this.ascension = 98; // 64 + 34
+      } else if (iPhoneXPatch.isIPhoneXLandscapePatchActive()) {
+        _this.ascension = 85; // 64 + 21
+      } else {
+        _this.ascension = 64;
+      }
+    }
+    return _this;
+  }
+
+  /**
+   * @param {HTMLElement} toast
+   * @param {Function} callback
+   */
+
+
+  createClass(AscendToastAnimator, [{
+    key: 'show',
+    value: function show(toast, callback) {
+      toast = toast._toast;
+      util$1.globals.fabOffset = this.ascension;
+
+      Animit.runAll(Animit(toast, this.def).default({ transform: 'translate3d(0, ' + this.ascension + 'px, 0)' }, { transform: 'translate3d(0, 0, 0)' }).queue(function (done) {
+        callback && callback();
+        done();
+      }), Animit(this._getFabs()).wait(this.delay).queue({ transform: 'translate3d(0, -' + this.ascension + 'px, 0) scale(1)' }, this.def), Animit(util$1.arrayFrom(toast.children), this.def).default({ opacity: 0 }, { opacity: 1 }));
+    }
+
+    /**
+     * @param {HTMLElement} toast
+     * @param {Function} callback
+     */
+
+  }, {
+    key: 'hide',
+    value: function hide(toast, callback) {
+      toast = toast._toast;
+      util$1.globals.fabOffset = 0;
+
+      Animit.runAll(Animit(toast, this.def).default({ transform: 'translate3d(0, 0, 0)' }, { transform: 'translate3d(0, ' + this.ascension + 'px, 0)' }).queue(function (done) {
+        callback && callback();
+        done();
+      }), Animit(this._getFabs(), this.def).wait(this.delay).queue({ transform: 'translate3d(0, 0, 0) scale(1)' }, this.def), Animit(util$1.arrayFrom(toast.children), this.def).default({ opacity: 1 }, { opacity: 0 }));
+    }
+  }, {
+    key: '_getFabs',
+    value: function _getFabs() {
+      return util$1.arrayFrom(document.querySelectorAll('ons-fab[position~=bottom], ons-speed-dial[position~=bottom]')).filter(function (fab) {
+        return fab.visible;
+      });
+    }
+  }]);
+  return AscendToastAnimator;
+}(ToastAnimator);
+
+/*
+Copyright 2013-2015 ASIAL CORPORATION
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+   http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+*/
+
+/**
+ * Lift-fade Toast Animator
+ */
+
+var LiftToastAnimator = function (_ToastAnimator) {
+  inherits(LiftToastAnimator, _ToastAnimator);
+
+  function LiftToastAnimator() {
+    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
+        _ref$timing = _ref.timing,
+        timing = _ref$timing === undefined ? 'ease' : _ref$timing,
+        _ref$delay = _ref.delay,
+        delay = _ref$delay === undefined ? 0 : _ref$delay,
+        _ref$duration = _ref.duration,
+        duration = _ref$duration === undefined ? 0.35 : _ref$duration;
+
+    classCallCheck(this, LiftToastAnimator);
+
+    var _this = possibleConstructorReturn(this, (LiftToastAnimator.__proto__ || Object.getPrototypeOf(LiftToastAnimator)).call(this, { timing: timing, delay: delay, duration: duration }));
+
+    _this.bodyHeight = document.body.clientHeight; // avoid Forced Synchronous Layout
+    if (iPhoneXPatch.isIPhoneXPortraitPatchActive()) {
+      _this.liftAmount = 'calc(100% + 34px)';
+    } else if (iPhoneXPatch.isIPhoneXLandscapePatchActive()) {
+      _this.liftAmount = 'calc(100% + 21px)';
+    } else {
+      _this.liftAmount = '100%';
+    }
+    return _this;
+  }
+
+  /**
+   * @param {HTMLElement} toast
+   * @param {Function} callback
+   */
+
+
+  createClass(LiftToastAnimator, [{
+    key: 'show',
+    value: function show(toast, callback) {
+      toast = toast._toast;
+
+      Animit.runAll(Animit(toast, this.def).default({ transform: 'translate3d(0, ' + this.liftAmount + ', 0)', opacity: 0 }, { transform: 'translate3d(0, 0, 0)', opacity: 1 }).queue(function (done) {
+        callback && callback();
+        done();
+      }));
+    }
+
+    /**
+     * @param {HTMLElement} toast
+     * @param {Function} callback
+     */
+
+  }, {
+    key: 'hide',
+    value: function hide(toast, callback) {
+      toast = toast._toast;
+
+      Animit.runAll(Animit(toast, this.def).default({ transform: 'translate3d(0, 0, 0)', opacity: 1 }, { transform: 'translate3d(0, ' + this.liftAmount + ', 0)', opacity: 0 }).queue(function (done) {
+        callback && callback();
+        done();
+      }));
+    }
+  }, {
+    key: '_updatePosition',
+    value: function _updatePosition(toast) {
+      if (parseInt(toast.style.top, 10) === 0) {
+        toast.style.top = toast.style.bottom = '';
+      }
+    }
+  }]);
+  return LiftToastAnimator;
+}(ToastAnimator);
+
+/*
+Copyright 2013-2015 ASIAL CORPORATION
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+   http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+*/
+
+/**
+ * Fall-fade Toast Animator
+ */
+
+var FallToastAnimator = function (_ToastAnimator) {
+  inherits(FallToastAnimator, _ToastAnimator);
+
+  function FallToastAnimator() {
+    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
+        _ref$timing = _ref.timing,
+        timing = _ref$timing === undefined ? 'ease' : _ref$timing,
+        _ref$delay = _ref.delay,
+        delay = _ref$delay === undefined ? 0 : _ref$delay,
+        _ref$duration = _ref.duration,
+        duration = _ref$duration === undefined ? 0.35 : _ref$duration;
+
+    classCallCheck(this, FallToastAnimator);
+
+    var _this = possibleConstructorReturn(this, (FallToastAnimator.__proto__ || Object.getPrototypeOf(FallToastAnimator)).call(this, { timing: timing, delay: delay, duration: duration }));
+
+    if (iPhoneXPatch.isIPhoneXPortraitPatchActive()) {
+      _this.fallAmount = 'calc(-100% - 44px)';
+    } else {
+      _this.fallAmount = '-100%';
+    }
+    return _this;
+  }
+
+  /**
+   * @param {HTMLElement} toast
+   * @param {Function} callback
+   */
+
+
+  createClass(FallToastAnimator, [{
+    key: 'show',
+    value: function show(toast, callback) {
+      toast = toast._toast;
+      this._updatePosition(toast);
+
+      Animit.runAll(Animit(toast, this.def).default({ transform: 'translate3d(0, ' + this.fallAmount + ', 0)', opacity: 0 }, { transform: 'translate3d(0, 0, 0)', opacity: 1 }).queue(function (done) {
+        callback && callback();
+        done();
+      }));
+    }
+
+    /**
+     * @param {HTMLElement} toast
+     * @param {Function} callback
+     */
+
+  }, {
+    key: 'hide',
+    value: function hide(toast, callback) {
+      var _this2 = this;
+
+      toast = toast._toast;
+      this._updatePosition(toast);
+
+      Animit.runAll(Animit(toast, this.def).default({ transform: 'translate3d(0, 0, 0)', opacity: 1 }, { transform: 'translate3d(0, ' + this.fallAmount + ', 0)', opacity: 0 }).queue(function (done) {
+        _this2._updatePosition(toast, true);
+        callback && callback();
+        done();
+      }));
+    }
+  }, {
+    key: '_updatePosition',
+    value: function _updatePosition(toast, cleanUp) {
+      var correctTop = void 0;
+      if (iPhoneXPatch.isIPhoneXPortraitPatchActive()) {
+        correctTop = '44px';
+      } else {
+        correctTop = '0';
+      }
+
+      if (toast.style.top !== correctTop) {
+        toast.style.top = correctTop;
+        toast.style.bottom = 'initial';
+      }
+    }
+  }]);
+  return FallToastAnimator;
+}(ToastAnimator);
+
+/*
+Copyright 2013-2015 ASIAL CORPORATION
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+   http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+*/
+
+var scheme$31 = {
+  '.toast': 'toast--*',
+  '.toast__message': 'toast--*__message',
+  '.toast__button': 'toast--*__button'
+};
+
+var defaultClassName$17 = 'toast';
+
+var _animatorDict$8 = {
+  'default': platform.isAndroid() ? AscendToastAnimator : LiftToastAnimator,
+  'fade': FadeToastAnimator,
+  'ascend': AscendToastAnimator,
+  'lift': LiftToastAnimator,
+  'fall': FallToastAnimator,
+  'none': ToastAnimator
+};
+
+/**
+ * @element ons-toast
+ * @category dialog
+ * @description
+ *   [en]
+ *     The Toast or Snackbar component is useful for displaying dismissable information or simple actions at (normally) the bottom of the page.
+ *
+ *     This component does not block user input, allowing the app to continue its flow. For simple toasts, consider `ons.notification.toast` instead.
+ *   [/en]
+ *   [ja][/ja]
+ * @tutorial vanilla/Reference/toast
+ * @seealso ons-alert-dialog
+ *   [en]The `<ons-alert-dialog>` component is preferred for displaying undismissable information.[/en]
+ *   [ja][/ja]
+ */
+
+var ToastElement = function (_BaseDialogElement) {
+  inherits(ToastElement, _BaseDialogElement);
+
+  /**
+   * @attribute animation
+   * @type {String}
+   * @default default
+   * @description
+   *  [en]The animation used when showing and hiding the toast. Can be either `"default"`, `"ascend"` (Android), `"lift"` (iOS), `"fall"`, `"fade"` or `"none"`.[/en]
+   *  [ja][/ja]
+   */
+
+  /**
+   * @attribute animation-options
+   * @type {Expression}
+   * @description
+   *  [en]Specify the animation's duration, timing and delay with an object literal. E.g. `{duration: 0.2, delay: 1, timing: 'ease-in'}`.[/en]
+   *  [ja]アニメーション時のduration, timing, delayをオブジェクトリテラルで指定します。e.g. <code>{duration: 0.2, delay: 1, timing: 'ease-in'}</code>[/ja]
+   */
+
+  function ToastElement() {
+    classCallCheck(this, ToastElement);
+
+    var _this = possibleConstructorReturn(this, (ToastElement.__proto__ || Object.getPrototypeOf(ToastElement)).call(this));
+
+    _this._defaultDBB = null;
+    contentReady(_this, function () {
+      return _this._compile();
+    });
+    return _this;
+  }
+
+  createClass(ToastElement, [{
+    key: '_updateAnimatorFactory',
+    value: function _updateAnimatorFactory() {
+      // Reset position style
+      this._toast && (this._toast.style.top = this._toast.style.bottom = '');
+
+      return new AnimatorFactory({
+        animators: _animatorDict$8,
+        baseClass: ToastAnimator,
+        baseClassName: 'ToastAnimator',
+        defaultAnimation: this.getAttribute('animation')
+      });
+    }
+
+    /**
+     * @property onDeviceBackButton
+     * @type {Object}
+     * @description
+     *   [en]Back-button handler.[/en]
+     *   [ja]バックボタンハンドラ。[/ja]
+     */
+
+  }, {
+    key: '_compile',
+    value: function _compile() {
+      autoStyle.prepare(this);
+
+      this.style.display = 'none';
+      this.style.zIndex = 10000; // Lower than dialogs
+
+      var messageClassName = 'toast__message';
+      var buttonClassName = 'toast__button';
+
+      var toast = util$1.findChild(this, '.' + defaultClassName$17);
+      if (!toast) {
+        toast = document.createElement('div');
+        toast.classList.add(defaultClassName$17);
+        while (this.childNodes[0]) {
+          toast.appendChild(this.childNodes[0]);
+        }
+      }
+
+      var button = util$1.findChild(toast, '.' + buttonClassName);
+      if (!button) {
+        button = util$1.findChild(toast, function (e) {
+          return util$1.match(e, '.button') || util$1.match(e, 'button');
+        });
+        if (button) {
+          button.classList.remove('button');
+          button.classList.add(buttonClassName);
+          toast.appendChild(button);
+        }
+      }
+
+      if (!util$1.findChild(toast, '.' + messageClassName)) {
+        var message = util$1.findChild(toast, '.message');
+        if (!message) {
+          message = document.createElement('div');
+          for (var i = toast.childNodes.length - 1; i >= 0; i--) {
+            if (toast.childNodes[i] !== button) {
+              message.insertBefore(toast.childNodes[i], message.firstChild);
+            }
+          }
+        }
+        message.classList.add(messageClassName);
+
+        toast.insertBefore(message, toast.firstChild);
+      }
+
+      if (toast.parentNode !== this) {
+        this.appendChild(toast);
+      }
+
+      ModifierUtil.initModifier(this, this._scheme);
+    }
+
+    /**
+     * @property visible
+     * @readonly
+     * @type {Boolean}
+     * @description
+     *   [en]Whether the element is visible or not.[/en]
+     *   [ja]要素が見える場合に`true`。[/ja]
+     */
+
+    /**
+     * @method show
+     * @signature show([options])
+     * @param {Object} [options]
+     *   [en]Parameter object.[/en]
+     *   [ja]オプションを指定するオブジェクト。[/ja]
+     * @param {String} [options.animation]
+     *   [en]Animation name. Available animations are `"default"`, `"ascend"` (Android), `"lift"` (iOS), `"fall"`, `"fade"` or `"none"`.[/en]
+     *   [ja][/ja]
+     * @param {String} [options.animationOptions]
+     *   [en]Specify the animation's duration, delay and timing. E.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}`.[/en]
+     *   [ja]アニメーション時のduration, delay, timingを指定します。e.g. {duration: 0.2, delay: 0.4, timing: 'ease-in'}[/ja]
+     * @description
+     *   [en]Show the element.[/en]
+     *   [ja][/ja]
+     * @return {Promise}
+     *   [en]Resolves to the displayed element[/en]
+     *   [ja][/ja]
+     */
+
+    /**
+     * @method toggle
+     * @signature toggle([options])
+     * @param {Object} [options]
+     *   [en]Parameter object.[/en]
+     *   [ja]オプションを指定するオブジェクト。[/ja]
+     * @param {String} [options.animation]
+     *   [en]Animation name. Available animations are `"default"`, `"ascend"` (Android), `"lift"` (iOS), `"fall"`, `"fade"` or `"none"`.[/en]
+     *   [ja][/ja]
+     * @param {String} [options.animationOptions]
+     *   [en]Specify the animation's duration, delay and timing. E.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}`.[/en]
+     *   [ja]アニメーション時のduration, delay, timingを指定します。e.g. {duration: 0.2, delay: 0.4, timing: 'ease-in'}[/ja]
+     * @description
+     *   [en]Toggle toast visibility.[/en]
+     *   [ja][/ja]
+     */
+
+    /**
+     * @method hide
+     * @signature hide([options])
+     * @param {Object} [options]
+     *   [en]Parameter object.[/en]
+     *   [ja]オプションを指定するオブジェクト。[/ja]
+     * @param {String} [options.animation]
+     *   [en]Animation name. Available animations are `"default"`, `"ascend"` (Android), `"lift"` (iOS), `"fall"`, `"fade"` or `"none"`.[/en]
+     *   [ja][/ja]
+     * @param {String} [options.animationOptions]
+     *   [en]Specify the animation's duration, delay and timing. E.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}`.[/en]
+     *   [ja]アニメーション時のduration, delay, timingを指定します。e.g. {duration: 0.2, delay: 0.4, timing: 'ease-in'}[/ja]
+     * @description
+     *   [en]Hide toast.[/en]
+     *   [ja][/ja]
+     * @return {Promise}
+     *   [en]Resolves to the hidden element[/en]
+     *   [ja][/ja]
+     */
+
+    /**
+     * @param {String} name
+     * @param {Function} Animator
+     */
+
+  }, {
+    key: '_scheme',
+    get: function get$$1() {
+      return scheme$31;
+    }
+  }, {
+    key: '_toast',
+    get: function get$$1() {
+      return util$1.findChild(this, '.' + defaultClassName$17);
+    }
+  }], [{
+    key: 'registerAnimator',
+    value: function registerAnimator(name, Animator) {
+      if (!(Animator.prototype instanceof ToastAnimator)) {
+        util$1.throw('"Animator" param must inherit OnsToastElement.ToastAnimator');
+      }
+      _animatorDict$8[name] = Animator;
+    }
+  }, {
+    key: 'animators',
+    get: function get$$1() {
+      return _animatorDict$8;
+    }
+  }, {
+    key: 'ToastAnimator',
+    get: function get$$1() {
+      return ToastAnimator;
+    }
+  }]);
+  return ToastElement;
+}(BaseDialogElement);
+
+onsElements.Toast = ToastElement;
+customElements.define('ons-toast', ToastElement);
+
+/*
+Copyright 2013-2015 ASIAL CORPORATION
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+   http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+*/
+
+/**
+ * @element ons-toolbar-button
+ * @category page
+ * @modifier material
+ *   [en]Material Design toolbar button.[/en]
+ *   [ja][/ja]
+ * @modifier outline
+ *   [en]A button with an outline.[/en]
+ *   [ja]アウトラインをもったボタンを表示します。[/ja]
+ * @description
+ *   [en]Button component for ons-toolbar and ons-bottom-toolbar.[/en]
+ *   [ja]ons-toolbarあるいはons-bottom-toolbarに設置できるボタン用コンポーネントです。[/ja]
+ * @codepen aHmGL
+ * @tutorial vanilla/Reference/page
+ * @guide compilation.html#toolbar-compilation
+ *   [en]Adding a toolbar[/en]
+ *   [ja]ツールバーの追加[/ja]
+ * @seealso ons-toolbar
+ *   [en]The `<ons-toolbar>` component displays a navigation bar at the top of a page.[/en]
+ *   [ja]ons-toolbarコンポーネント[/ja]
+ * @seealso ons-back-button
+ *   [en]The `<ons-back-button>` displays a back button in the navigation bar.[/en]
+ *   [ja]ons-back-buttonコンポーネント[/ja]
+ * @example
+ * <ons-toolbar>
+ *   <div class="left">
+ *     <ons-toolbar-button>
+ *       Button
+ *     </ons-toolbar-button>
+ *   </div>
+ *   <div class="center">
+ *     Title
+ *   </div>
+ *   <div class="right">
+ *     <ons-toolbar-button>
+ *       <ons-icon icon="ion-navicon" size="28px"></ons-icon>
+ *     </ons-toolbar-button>
+ *   </div>
+ * </ons-toolbar>
+ */
+
+var ToolbarButtonElement = function (_BaseButtonElement) {
+  inherits(ToolbarButtonElement, _BaseButtonElement);
+
+  function ToolbarButtonElement() {
+    classCallCheck(this, ToolbarButtonElement);
+    return possibleConstructorReturn(this, (ToolbarButtonElement.__proto__ || Object.getPrototypeOf(ToolbarButtonElement)).apply(this, arguments));
+  }
+
+  createClass(ToolbarButtonElement, [{
+    key: '_scheme',
+
+
+    /**
+     * @attribute modifier
+     * @type {String}
+     * @description
+     *   [en]The appearance of the button.[/en]
+     *   [ja]ボタンの表現を指定します。[/ja]
+     */
+
+    /**
+     * @attribute icon
+     * @type {String}
+     * @description
+     *  [en]Creates an `ons-icon` component with this string.[/en]
+     *  [ja]`ons-icon`コンポーネントを悪性します。[/ja]
+     */
+
+    /**
+     * @attribute disabled
+     * @description
+     *   [en]Specify if button should be disabled.[/en]
+     *   [ja]ボタンを無効化する場合は指定してください。[/ja]
+     */
+
+    /**
+     * @property disabled
+     * @type {Boolean}
+     * @description
+     *   [en]Whether the element is disabled or not.[/en]
+     *   [ja]無効化されている場合に`true`。[/ja]
+     */
+
+    get: function get$$1() {
+      return { '': 'toolbar-button--*' };
+    }
+  }, {
+    key: '_defaultClassName',
+    get: function get$$1() {
+      return 'toolbar-button';
+    }
+  }, {
+    key: '_rippleOpt',
+    get: function get$$1() {
+      return [this, undefined, { center: '', 'size': 'contain', 'background': 'transparent' }];
+    }
+  }]);
+  return ToolbarButtonElement;
+}(BaseButtonElement);
+
+onsElements.ToolbarButton = ToolbarButtonElement;
+customElements.define('ons-toolbar-button', ToolbarButtonElement);
+
+// Add and register Custom Elements
+setup$1(ons$1); // Setup initial listeners
+window._superSecretOns = ons$1;
+
+return ons$1;
+
+})));
+//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoib25zZW51aS5qcyIsInNvdXJjZXMiOlsiLi4vLi4vY29yZS9zcmMvb25zL2VsZW1lbnRzLmpzIiwiLi4vLi4vY29yZS9zcmMvb25zL3N0eWxlci5qcyIsIi4uLy4uL2NvcmUvc3JjL29ucy9wbGF0Zm9ybS5qcyIsIi4uLy4uL2NvcmUvc3JjL29ucy9wYWdlLWF0dHJpYnV0ZS1leHByZXNzaW9uLmpzIiwiLi4vLi4vY29yZS9zcmMvb25zL2ludGVybmFsL2ludGVybmFsLmpzIiwiLi4vLi4vY29yZS9zcmMvb25zL2ludGVybmFsL2FuaW1hdG9yLWZhY3RvcnkuanMiLCIuLi8uLi9jb3JlL3NyYy9vbnMvYXV0b3N0eWxlLmpzIiwiLi4vLi4vY29yZS9zcmMvb25zL2ludGVybmFsL21vZGlmaWVyLXV0aWwuanMiLCIuLi8uLi9jb3JlL3NyYy9vbnMvaW50ZXJuYWwvZGV2aWNlLWJhY2stYnV0dG9uLWRpc3BhdGNoZXIuanMiLCIuLi8uLi9jb3JlL3NyYy9vbnMvaW50ZXJuYWwvaW5kZXguanMiLCIuLi8uLi9jb3JlL3NyYy9vbnMvYW5pbWF0aW9uLW9wdGlvbnMtcGFyc2VyLmpzIiwiLi4vLi4vY29yZS9zcmMvb25zL3V0aWwuanMiLCIuLi8uLi9jb3JlL3NyYy9vbnMvYW5pbWl0LmpzIiwiLi4vLi4vY29yZS9zcmMvb25zL2dlc3R1cmUtZGV0ZWN0b3IuanMiLCIuLi8uLi9jb3JlL3NyYy9vbnMvY29udGVudC1yZWFkeS5qcyIsIi4uLy4uL2NvcmUvc3JjL29ucy9pbnRlcm5hbC90b2FzdC1xdWV1ZS5qcyIsIi4uLy4uL2NvcmUvc3JjL29ucy9ub3RpZmljYXRpb24uanMiLCIuLi8uLi9jb3JlL3NyYy9vbnMvYWN0aW9uLXNoZWV0LmpzIiwiLi4vLi4vY29yZS9zcmMvb25zL21pY3JvZXZlbnQuanMiLCIuLi8uLi9jb3JlL3NyYy9vbnMvb3JpZW50YXRpb24uanMiLCIuLi8uLi9jb3JlL3NyYy9vbnMvbW9kaWZpZXIuanMiLCIuLi8uLi9jb3JlL3NyYy9vbnMvc29mdHdhcmUta2V5Ym9hcmQuanMiLCIuLi8uLi9jb3JlL3NyYy9vbnMvZG9vcmxvY2suanMiLCIuLi8uLi9jb3JlL3NyYy9vbnMvcGFnZS1sb2FkZXIuanMiLCIuLi8uLi9jb3JlL3NyYy9vbnMvaW5kZXguanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvQG9uc2VudWkvZmFzdGNsaWNrL2xpYi9mYXN0Y2xpY2suanMiLCIuLi8uLi9jb3JlL3NyYy9wb2x5ZmlsbHMvcG9seWZpbGwtc3dpdGNoZXMuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19nbG9iYWwuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19jb3JlLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faXMtb2JqZWN0LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fYW4tb2JqZWN0LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZmFpbHMuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19kZXNjcmlwdG9ycy5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2RvbS1jcmVhdGUuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pZTgtZG9tLWRlZmluZS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3RvLXByaW1pdGl2ZS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1kcC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3Byb3BlcnR5LWRlc2MuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19oaWRlLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faGFzLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fdWlkLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fbGlicmFyeS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3NoYXJlZC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2Z1bmN0aW9uLXRvLXN0cmluZy5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3JlZGVmaW5lLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fYS1mdW5jdGlvbi5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2N0eC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2V4cG9ydC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1waWUuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19jb2YuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pb2JqZWN0LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZGVmaW5lZC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3RvLWlvYmplY3QuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3QtZ29wZC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3NldC1wcm90by5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5zZXQtcHJvdG90eXBlLW9mLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvZm4vb2JqZWN0L3NldC1wcm90b3R5cGUtb2YuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL193a3MuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19jbGFzc29mLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LnRvLXN0cmluZy5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3RvLWludGVnZXIuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19zdHJpbmctYXQuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pdGVyYXRvcnMuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL190by1sZW5ndGguanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL190by1hYnNvbHV0ZS1pbmRleC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2FycmF5LWluY2x1ZGVzLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fc2hhcmVkLWtleS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1rZXlzLWludGVybmFsLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZW51bS1idWcta2V5cy5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1rZXlzLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWRwcy5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2h0bWwuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3QtY3JlYXRlLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fc2V0LXRvLXN0cmluZy10YWcuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pdGVyLWNyZWF0ZS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3RvLW9iamVjdC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1ncG8uanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pdGVyLWRlZmluZS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5pdGVyYXRvci5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2FkZC10by11bnNjb3BhYmxlcy5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2l0ZXItc3RlcC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5Lml0ZXJhdG9yLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy93ZWIuZG9tLml0ZXJhYmxlLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fcmVkZWZpbmUtYWxsLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fYW4taW5zdGFuY2UuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pdGVyLWNhbGwuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pcy1hcnJheS1pdGVyLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9jb3JlLmdldC1pdGVyYXRvci1tZXRob2QuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19mb3Itb2YuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19zZXQtc3BlY2llcy5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX21ldGEuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL192YWxpZGF0ZS1jb2xsZWN0aW9uLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fY29sbGVjdGlvbi1zdHJvbmcuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pdGVyLWRldGVjdC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2luaGVyaXQtaWYtcmVxdWlyZWQuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19jb2xsZWN0aW9uLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuc2V0LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fYXJyYXktZnJvbS1pdGVyYWJsZS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2NvbGxlY3Rpb24tdG8tanNvbi5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LnNldC50by1qc29uLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fc2V0LWNvbGxlY3Rpb24tb2YuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5zZXQub2YuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19zZXQtY29sbGVjdGlvbi1mcm9tLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcuc2V0LmZyb20uanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9mbi9zZXQuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5tYXAuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5tYXAudG8tanNvbi5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3Lm1hcC5vZi5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3Lm1hcC5mcm9tLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvZm4vbWFwLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faXMtYXJyYXkuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19hcnJheS1zcGVjaWVzLWNvbnN0cnVjdG9yLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fYXJyYXktc3BlY2llcy1jcmVhdGUuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19hcnJheS1tZXRob2RzLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWdvcHMuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3QtYXNzaWduLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fY29sbGVjdGlvbi13ZWFrLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYud2Vhay1tYXAuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy53ZWFrLW1hcC5vZi5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LndlYWstbWFwLmZyb20uanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9mbi93ZWFrLW1hcC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2NyZWF0ZS1wcm9wZXJ0eS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LmZyb20uanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9mbi9hcnJheS9mcm9tLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL0BvbnNlbnVpL2N1c3RvbS1lbGVtZW50cy9zcmMvVXRpbGl0aWVzLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL0BvbnNlbnVpL2N1c3RvbS1lbGVtZW50cy9zcmMvQ3VzdG9tRWxlbWVudFN0YXRlLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL0BvbnNlbnVpL2N1c3RvbS1lbGVtZW50cy9zcmMvQ3VzdG9tRWxlbWVudEludGVybmFscy5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9Ab25zZW51aS9jdXN0b20tZWxlbWVudHMvc3JjL0RvY3VtZW50Q29uc3RydWN0aW9uT2JzZXJ2ZXIuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvQG9uc2VudWkvY3VzdG9tLWVsZW1lbnRzL3NyYy9EZWZlcnJlZC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9Ab25zZW51aS9jdXN0b20tZWxlbWVudHMvc3JjL0N1c3RvbUVsZW1lbnRSZWdpc3RyeS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9Ab25zZW51aS9jdXN0b20tZWxlbWVudHMvc3JjL1BhdGNoL05hdGl2ZS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9Ab25zZW51aS9jdXN0b20tZWxlbWVudHMvc3JjL0FscmVhZHlDb25zdHJ1Y3RlZE1hcmtlci5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9Ab25zZW51aS9jdXN0b20tZWxlbWVudHMvc3JjL1BhdGNoL0hUTUxFbGVtZW50LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL0BvbnNlbnVpL2N1c3RvbS1lbGVtZW50cy9zcmMvUGF0Y2gvSW50ZXJmYWNlL1BhcmVudE5vZGUuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvQG9uc2VudWkvY3VzdG9tLWVsZW1lbnRzL3NyYy9QYXRjaC9Eb2N1bWVudC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9Ab25zZW51aS9jdXN0b20tZWxlbWVudHMvc3JjL1BhdGNoL05vZGUuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvQG9uc2VudWkvY3VzdG9tLWVsZW1lbnRzL3NyYy9QYXRjaC9JbnRlcmZhY2UvQ2hpbGROb2RlLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL0BvbnNlbnVpL2N1c3RvbS1lbGVtZW50cy9zcmMvUGF0Y2gvRWxlbWVudC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9Ab25zZW51aS9jdXN0b20tZWxlbWVudHMvc3JjL2N1c3RvbS1lbGVtZW50cy5qcyIsIi4uLy4uL2NvcmUvc3JjL3BvbHlmaWxscy9NdXRhdGlvbk9ic2VydmVyQDAuNy4yMi9NdXRhdGlvbk9ic2VydmVyLmpzIiwiLi4vLi4vY29yZS9zcmMvcG9seWZpbGxzL3NldEltbWVkaWF0ZUAxLjAuMittb2Qvc2V0SW1tZWRpYXRlLmpzIiwiLi4vLi4vY29yZS9zcmMvcG9seWZpbGxzL2luZGV4LmpzIiwiLi4vLi4vY29yZS9zcmMvdmVuZG9yL3ZpZXdwb3J0LmpzIiwiLi4vLi4vY29yZS9zcmMvc2V0dXAuanMiLCIuLi8uLi9jb3JlL3NyYy9lbGVtZW50cy9iYXNlL2Jhc2UtZWxlbWVudC5qcyIsIi4uLy4uL2NvcmUvc3JjL2VsZW1lbnRzL29ucy10ZW1wbGF0ZS5qcyIsIi4uLy4uL2NvcmUvc3JjL2VsZW1lbnRzL29ucy1pZi5qcyIsIi4uLy4uL2NvcmUvc3JjL29ucy9iYXNlLWFuaW1hdG9yLmpzIiwiLi4vLi4vY29yZS9zcmMvb25zL2lwaG9uZXgtcGF0Y2guanMiLCIuLi8uLi9jb3JlL3NyYy9lbGVtZW50cy9vbnMtYWN0aW9uLXNoZWV0L2FuaW1hdG9yLmpzIiwiLi4vLi4vY29yZS9zcmMvZWxlbWVudHMvYmFzZS9iYXNlLWRpYWxvZy5qcyIsIi4uLy4uL2NvcmUvc3JjL2VsZW1lbnRzL29ucy1hY3Rpb24tc2hlZXQvaW5kZXguanMiLCIuLi8uLi9jb3JlL3NyYy9lbGVtZW50cy9iYXNlL2Jhc2UtYnV0dG9uLmpzIiwiLi4vLi4vY29yZS9zcmMvZWxlbWVudHMvb25zLWFjdGlvbi1zaGVldC1idXR0b24uanMiLCIuLi8uLi9jb3JlL3NyYy9lbGVtZW50cy9vbnMtYWxlcnQtZGlhbG9nL2FuaW1hdG9yLmpzIiwiLi4vLi4vY29yZS9zcmMvZWxlbWVudHMvb25zLWFsZXJ0LWRpYWxvZy9pbmRleC5qcyIsIi4uLy4uL2NvcmUvc3JjL2VsZW1lbnRzL29ucy1hbGVydC1kaWFsb2ctYnV0dG9uLmpzIiwiLi4vLi4vY29yZS9zcmMvZWxlbWVudHMvb25zLWJhY2stYnV0dG9uLmpzIiwiLi4vLi4vY29yZS9zcmMvZWxlbWVudHMvb25zLWJvdHRvbS10b29sYmFyLmpzIiwiLi4vLi4vY29yZS9zcmMvZWxlbWVudHMvb25zLWJ1dHRvbi5qcyIsIi4uLy4uL2NvcmUvc3JjL2VsZW1lbnRzL29ucy1jYXJkLmpzIiwiLi4vLi4vY29yZS9zcmMvZWxlbWVudHMvb25zLWNhcm91c2VsLWl0ZW0uanMiLCIuLi8uLi9jb3JlL3NyYy9vbnMvaW50ZXJuYWwvc3dpcGVyLmpzIiwiLi4vLi4vY29yZS9zcmMvZWxlbWVudHMvb25zLWNhcm91c2VsLmpzIiwiLi4vLi4vY29yZS9zcmMvZWxlbWVudHMvb25zLWNvbC5qcyIsIi4uLy4uL2NvcmUvc3JjL2VsZW1lbnRzL29ucy1kaWFsb2cvYW5pbWF0b3IuanMiLCIuLi8uLi9jb3JlL3NyYy9lbGVtZW50cy9vbnMtZGlhbG9nL2luZGV4LmpzIiwiLi4vLi4vY29yZS9zcmMvZWxlbWVudHMvb25zLWZhYi5qcyIsIi4uLy4uL2NvcmUvc3JjL2VsZW1lbnRzL29ucy1nZXN0dXJlLWRldGVjdG9yLmpzIiwiLi4vLi4vY29yZS9zcmMvZWxlbWVudHMvb25zLWljb24uanMiLCIuLi8uLi9jb3JlL3NyYy9vbnMvaW50ZXJuYWwvbGF6eS1yZXBlYXQuanMiLCIuLi8uLi9jb3JlL3NyYy9lbGVtZW50cy9vbnMtbGF6eS1yZXBlYXQuanMiLCIuLi8uLi9jb3JlL3NyYy9lbGVtZW50cy9vbnMtbGlzdC1oZWFkZXIuanMiLCIuLi8uLi9jb3JlL3NyYy9lbGVtZW50cy9vbnMtbGlzdC10aXRsZS5qcyIsIi4uLy4uL2NvcmUvc3JjL2VsZW1lbnRzL29ucy1saXN0LWl0ZW0vYW5pbWF0b3IuanMiLCIuLi8uLi9jb3JlL3NyYy9lbGVtZW50cy9vbnMtbGlzdC1pdGVtL2luZGV4LmpzIiwiLi4vLi4vY29yZS9zcmMvZWxlbWVudHMvb25zLWxpc3QuanMiLCIuLi8uLi9jb3JlL3NyYy9lbGVtZW50cy9iYXNlL2Jhc2UtaW5wdXQuanMiLCIuLi8uLi9jb3JlL3NyYy9lbGVtZW50cy9vbnMtaW5wdXQuanMiLCIuLi8uLi9jb3JlL3NyYy9lbGVtZW50cy9iYXNlL2Jhc2UtY2hlY2tib3guanMiLCIuLi8uLi9jb3JlL3NyYy9lbGVtZW50cy9vbnMtY2hlY2tib3guanMiLCIuLi8uLi9jb3JlL3NyYy9lbGVtZW50cy9vbnMtcmFkaW8uanMiLCIuLi8uLi9jb3JlL3NyYy9lbGVtZW50cy9vbnMtc2VhcmNoLWlucHV0LmpzIiwiLi4vLi4vY29yZS9zcmMvZWxlbWVudHMvb25zLW1vZGFsL2FuaW1hdG9yLmpzIiwiLi4vLi4vY29yZS9zcmMvZWxlbWVudHMvb25zLW1vZGFsL2ZhZGUtYW5pbWF0b3IuanMiLCIuLi8uLi9jb3JlL3NyYy9lbGVtZW50cy9vbnMtbW9kYWwvbGlmdC1hbmltYXRvci5qcyIsIi4uLy4uL2NvcmUvc3JjL2VsZW1lbnRzL29ucy1tb2RhbC9pbmRleC5qcyIsIi4uLy4uL2NvcmUvc3JjL29ucy9pbnRlcm5hbC9zd2lwZS1yZXZlYWwuanMiLCIuLi8uLi9jb3JlL3NyYy9lbGVtZW50cy9vbnMtbmF2aWdhdG9yL2FuaW1hdG9yLmpzIiwiLi4vLi4vY29yZS9zcmMvZWxlbWVudHMvb25zLW5hdmlnYXRvci9pb3Mtc3dpcGUtYW5pbWF0b3IuanMiLCIuLi8uLi9jb3JlL3NyYy9lbGVtZW50cy9vbnMtbmF2aWdhdG9yL2lvcy1zbGlkZS1hbmltYXRvci5qcyIsIi4uLy4uL2NvcmUvc3JjL2VsZW1lbnRzL29ucy1uYXZpZ2F0b3IvaW9zLWxpZnQtYW5pbWF0b3IuanMiLCIuLi8uLi9jb3JlL3NyYy9lbGVtZW50cy9vbnMtbmF2aWdhdG9yL2lvcy1mYWRlLWFuaW1hdG9yLmpzIiwiLi4vLi4vY29yZS9zcmMvZWxlbWVudHMvb25zLW5hdmlnYXRvci9tZC1zbGlkZS1hbmltYXRvci5qcyIsIi4uLy4uL2NvcmUvc3JjL2VsZW1lbnRzL29ucy1uYXZpZ2F0b3IvbWQtbGlmdC1hbmltYXRvci5qcyIsIi4uLy4uL2NvcmUvc3JjL2VsZW1lbnRzL29ucy1uYXZpZ2F0b3IvbWQtZmFkZS1hbmltYXRvci5qcyIsIi4uLy4uL2NvcmUvc3JjL2VsZW1lbnRzL29ucy1uYXZpZ2F0b3Ivbm9uZS1hbmltYXRvci5qcyIsIi4uLy4uL2NvcmUvc3JjL2VsZW1lbnRzL29ucy1uYXZpZ2F0b3IvaW5kZXguanMiLCIuLi8uLi9jb3JlL3NyYy9lbGVtZW50cy9vbnMtdG9vbGJhci5qcyIsIi4uLy4uL2NvcmUvc3JjL2VsZW1lbnRzL29ucy1wYWdlLmpzIiwiLi4vLi4vY29yZS9zcmMvZWxlbWVudHMvb25zLXBvcG92ZXIvYW5pbWF0b3IuanMiLCIuLi8uLi9jb3JlL3NyYy9lbGVtZW50cy9vbnMtcG9wb3Zlci9pbmRleC5qcyIsIi4uLy4uL2NvcmUvc3JjL2VsZW1lbnRzL29ucy1wcm9ncmVzcy1iYXIuanMiLCIuLi8uLi9jb3JlL3NyYy9lbGVtZW50cy9vbnMtcHJvZ3Jlc3MtY2lyY3VsYXIuanMiLCIuLi8uLi9jb3JlL3NyYy9lbGVtZW50cy9vbnMtcHVsbC1ob29rLmpzIiwiLi4vLi4vY29yZS9zcmMvZWxlbWVudHMvb25zLXJhbmdlLmpzIiwiLi4vLi4vY29yZS9zcmMvZWxlbWVudHMvb25zLXJpcHBsZS9hbmltYXRvci1jc3MuanMiLCIuLi8uLi9jb3JlL3NyYy9lbGVtZW50cy9vbnMtcmlwcGxlL2luZGV4LmpzIiwiLi4vLi4vY29yZS9zcmMvZWxlbWVudHMvb25zLXJvdy5qcyIsIi4uLy4uL2NvcmUvc3JjL2VsZW1lbnRzL29ucy1zZWdtZW50LmpzIiwiLi4vLi4vY29yZS9zcmMvZWxlbWVudHMvb25zLXNlbGVjdC5qcyIsIi4uLy4uL2NvcmUvc3JjL2VsZW1lbnRzL29ucy1zcGVlZC1kaWFsLWl0ZW0uanMiLCIuLi8uLi9jb3JlL3NyYy9lbGVtZW50cy9vbnMtc3BlZWQtZGlhbC5qcyIsIi4uLy4uL2NvcmUvc3JjL2VsZW1lbnRzL29ucy1zcGxpdHRlci1jb250ZW50LmpzIiwiLi4vLi4vY29yZS9zcmMvZWxlbWVudHMvb25zLXNwbGl0dGVyLW1hc2suanMiLCIuLi8uLi9jb3JlL3NyYy9lbGVtZW50cy9vbnMtc3BsaXR0ZXIvYW5pbWF0b3IuanMiLCIuLi8uLi9jb3JlL3NyYy9lbGVtZW50cy9vbnMtc3BsaXR0ZXIvb3ZlcmxheS1hbmltYXRvci5qcyIsIi4uLy4uL2NvcmUvc3JjL2VsZW1lbnRzL29ucy1zcGxpdHRlci9wdXNoLWFuaW1hdG9yLmpzIiwiLi4vLi4vY29yZS9zcmMvZWxlbWVudHMvb25zLXNwbGl0dGVyL3JldmVhbC1hbmltYXRvci5qcyIsIi4uLy4uL2NvcmUvc3JjL2VsZW1lbnRzL29ucy1zcGxpdHRlci9pbmRleC5qcyIsIi4uLy4uL2NvcmUvc3JjL2VsZW1lbnRzL29ucy1zcGxpdHRlci1zaWRlLmpzIiwiLi4vLi4vY29yZS9zcmMvZWxlbWVudHMvb25zLXN3aXRjaC5qcyIsIi4uLy4uL2NvcmUvc3JjL2VsZW1lbnRzL29ucy10YWJiYXIvaW5kZXguanMiLCIuLi8uLi9jb3JlL3NyYy9lbGVtZW50cy9vbnMtdGFiLmpzIiwiLi4vLi4vY29yZS9zcmMvZWxlbWVudHMvb25zLXRvYXN0L2FuaW1hdG9yLmpzIiwiLi4vLi4vY29yZS9zcmMvZWxlbWVudHMvb25zLXRvYXN0L2ZhZGUtYW5pbWF0b3IuanMiLCIuLi8uLi9jb3JlL3NyYy9lbGVtZW50cy9vbnMtdG9hc3QvYXNjZW5kLWFuaW1hdG9yLmpzIiwiLi4vLi4vY29yZS9zcmMvZWxlbWVudHMvb25zLXRvYXN0L2xpZnQtYW5pbWF0b3IuanMiLCIuLi8uLi9jb3JlL3NyYy9lbGVtZW50cy9vbnMtdG9hc3QvZmFsbC1hbmltYXRvci5qcyIsIi4uLy4uL2NvcmUvc3JjL2VsZW1lbnRzL29ucy10b2FzdC9pbmRleC5qcyIsIi4uLy4uL2NvcmUvc3JjL2VsZW1lbnRzL29ucy10b29sYmFyLWJ1dHRvbi5qcyIsIi4uLy4uL2NvcmUvc3JjL2luZGV4LnVtZC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCB7IH07XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgdXRpbCBmcm9tICcuLi9vbnMvdXRpbCc7XG5cbi8qKlxuICogQWRkIHZlbmRvciBwcmVmaXguXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xuY29uc3QgcHJlZml4ID0gKGZ1bmN0aW9uKCkge1xuICBjb25zdCBzdHlsZXMgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsICcnKTtcbiAgY29uc3QgcHJlZml4ID0gKEFycmF5LnByb3RvdHlwZS5zbGljZVxuICAgIC5jYWxsKHN0eWxlcylcbiAgICAuam9pbignJylcbiAgICAubWF0Y2goLy0obW96fHdlYmtpdHxtcyktLykgfHwgKHN0eWxlcy5PTGluayA9PT0gJycgJiYgWycnLCAnbyddKVxuICApWzFdO1xuXG4gIHJldHVybiBmdW5jdGlvbihuYW1lKSB7XG4gICAgcmV0dXJuICctJyArIHByZWZpeCArICctJyArIHV0aWwuaHlwaGVuYXRlKG5hbWUpO1xuICB9O1xufSkoKTtcblxuXG4vKipcbiAqIE1pbmltYWwgdXRpbGl0eSBsaWJyYXJ5IGZvciBtYW5pcHVsYXRpbmcgZWxlbWVudCdzIHN0eWxlLlxuICogU2V0IGVsZW1lbnQncyBzdHlsZS5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnRcbiAqIEBwYXJhbSB7T2JqZWN0fSBzdHlsZXNcbiAqIEByZXR1cm4ge0VsZW1lbnR9XG4gKi9cbmNvbnN0IHN0eWxlciA9IGZ1bmN0aW9uKGVsZW1lbnQsIHN0eWxlKSB7XG4gIE9iamVjdC5rZXlzKHN0eWxlKS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgIGlmIChrZXkgaW4gZWxlbWVudC5zdHlsZSkge1xuICAgICAgZWxlbWVudC5zdHlsZVtrZXldID0gc3R5bGVba2V5XTtcbiAgICB9IGVsc2UgaWYgKHByZWZpeChrZXkpIGluIGVsZW1lbnQuc3R5bGUpIHtcbiAgICAgIGVsZW1lbnQuc3R5bGVbcHJlZml4KGtleSldID0gc3R5bGVba2V5XTtcbiAgICB9IGVsc2Uge1xuICAgICAgdXRpbC53YXJuKCdObyBzdWNoIHN0eWxlIHByb3BlcnR5OiAnICsga2V5KTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gZWxlbWVudDtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XG4gKiBAcGFyYW0ge1N0cmluZ30gc3R5bGVzIFNwYWNlLXNlcGFyYXRlZCBDU1MgcHJvcGVydGllcyB0byByZW1vdmVcbiAqL1xuc3R5bGVyLmNsZWFyID0gZnVuY3Rpb24oZWxlbWVudCwgc3R5bGVzID0gJycpIHtcbiAgY29uc3QgY2xlYXJsaXN0ID0gc3R5bGVzLnNwbGl0KC9cXHMrLykucmVkdWNlKChyLCBzKSA9PiByLmNvbmNhdChbdXRpbC5oeXBoZW5hdGUocyksIHByZWZpeChzKV0pLCBbXSksXG4gICAga2V5cyA9IFtdO1xuXG4gIGZvciAobGV0IGkgPSBlbGVtZW50LnN0eWxlLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgY29uc3Qga2V5ID0gZWxlbWVudC5zdHlsZVtpXTtcbiAgICBpZiAoY2xlYXJsaXN0Lmxlbmd0aCA9PT0gMCB8fCBjbGVhcmxpc3Quc29tZShzID0+IGtleS5pbmRleE9mKHMpID09PSAwKSkge1xuICAgICAga2V5cy5wdXNoKGtleSk7IC8vIFN0b3JlIHRoZSBrZXkgdG8gZml4IFNhZmFyaSBzdHlsZSBpbmRleGVzXG4gICAgfVxuICB9XG5cbiAga2V5cy5mb3JFYWNoKGtleSA9PiBlbGVtZW50LnN0eWxlW2tleV0gPSAnJyk7XG4gIGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdzdHlsZScpID09PSAnJyAmJiBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZSgnc3R5bGUnKTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IHN0eWxlcjtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbi8vIFNhdmUgSFRNTEVsZW1lbnQgb2JqZWN0IGJlZm9yZSBDdXN0b20gRWxlbWVudHMgcG9seWZpbGwgcGF0Y2ggZ2xvYmFsIEhUTUxFbGVtZW50LlxuY29uc3QgTmF0aXZlSFRNTEVsZW1lbnQgPSB3aW5kb3cuSFRNTEVsZW1lbnQ7XG5cbi8qKlxuICogQG9iamVjdCBvbnMucGxhdGZvcm1cbiAqIEBjYXRlZ29yeSB1dGlsXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXVV0aWxpdHkgbWV0aG9kcyB0byBkZXRlY3QgY3VycmVudCBwbGF0Zm9ybS5bL2VuXVxuICogICBbamFd54++5Zyo5a6f6KGM44GV44KM44Gm44GE44KL44OX44Op44OD44OI44OV44Kp44O844Og44KS5qSc55+l44GZ44KL44Gf44KB44Gu44Om44O844OG44Kj44Oq44OG44Kj44Oh44K944OD44OJ44KS5Y+O44KB44Gf44Kq44OW44K444Kn44Kv44OI44Gn44GZ44CCWy9qYV1cbiAqL1xuY2xhc3MgUGxhdGZvcm0ge1xuXG4gIC8qKlxuICAgKiBBbGwgZWxlbWVudHMgd2lsbCBiZSByZW5kZXJlZCBhcyBpZiB0aGUgYXBwIHdhcyBydW5uaW5nIG9uIHRoaXMgcGxhdGZvcm0uXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqL1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLl9zZWxlY3RlZFBsYXRmb3JtID0gbnVsbDtcbiAgICB0aGlzLl9pZ25vcmVQbGF0Zm9ybVNlbGVjdCA9IGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2Qgc2VsZWN0XG4gICAqIEBzaWduYXR1cmUgc2VsZWN0KHBsYXRmb3JtKVxuICAgKiBAcGFyYW0gIHtzdHJpbmd9IHBsYXRmb3JtIE5hbWUgb2YgdGhlIHBsYXRmb3JtLlxuICAgKiAgIFtlbl1Qb3NzaWJsZSB2YWx1ZXMgYXJlOiBcIm9wZXJhXCIsIFwiZmlyZWZveFwiLCBcInNhZmFyaVwiLCBcImNocm9tZVwiLCBcImllXCIsIFwiYW5kcm9pZFwiLCBcImJsYWNrYmVycnlcIiwgXCJpb3NcIiBvciBcIndwXCIuWy9lbl1cbiAgICogICBbamFdXCJvcGVyYVwiLCBcImZpcmVmb3hcIiwgXCJzYWZhcmlcIiwgXCJjaHJvbWVcIiwgXCJpZVwiLCBcImFuZHJvaWRcIiwgXCJibGFja2JlcnJ5XCIsIFwiaW9zXCIsIFwid3BcIuOBruOBhOOBmuOCjOOBi+OCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1TZXRzIHRoZSBwbGF0Zm9ybSB1c2VkIHRvIHJlbmRlciB0aGUgZWxlbWVudHMuIFVzZWZ1bCBmb3IgdGVzdGluZy5bL2VuXVxuICAgKiAgIFtqYV3opoHntKDjgpLmj4/nlLvjgZnjgovjgZ/jgoHjgavliKnnlKjjgZnjgovjg5fjg6njg4Pjg4jjg5Xjgqnjg7zjg6DlkI3jgpLoqK3lrprjgZfjgb7jgZnjgILjg4bjgrnjg4jjgavkvr/liKnjgafjgZnjgIJbL2phXVxuICAgKi9cbiAgc2VsZWN0KHBsYXRmb3JtKSB7XG4gICAgaWYgKHR5cGVvZiBwbGF0Zm9ybSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRoaXMuX3NlbGVjdGVkUGxhdGZvcm0gPSBwbGF0Zm9ybS50cmltKCkudG9Mb3dlckNhc2UoKTtcbiAgICB9XG4gIH1cblxuICBfZ2V0U2VsZWN0ZWRQbGF0Zm9ybSgpIHtcbiAgICByZXR1cm4gdGhpcy5faWdub3JlUGxhdGZvcm1TZWxlY3QgPyBudWxsIDogdGhpcy5fc2VsZWN0ZWRQbGF0Zm9ybTtcbiAgfVxuXG4gIF9ydW5PbkFjdHVhbFBsYXRmb3JtKGZuKSB7XG4gICAgdGhpcy5faWdub3JlUGxhdGZvcm1TZWxlY3QgPSB0cnVlO1xuICAgIGNvbnN0IHJlc3VsdCA9IGZuKCk7XG4gICAgdGhpcy5faWdub3JlUGxhdGZvcm1TZWxlY3QgPSBmYWxzZTtcblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvLy0tLS0tLS0tLS0tLS0tLS1cbiAgLy8gR2VuZXJhbFxuICAvLy0tLS0tLS0tLS0tLS0tLS1cbiAgLyoqXG4gICAqIEBtZXRob2QgaXNXZWJWaWV3XG4gICAqIEBzaWduYXR1cmUgaXNXZWJWaWV3KClcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVJldHVybnMgd2hldGhlciBhcHAgaXMgcnVubmluZyBpbiBDb3Jkb3ZhLlsvZW5dXG4gICAqICAgW2phXUNvcmRvdmHlhoXjgaflrp/ooYzjgZXjgozjgabjgYTjgovjgYvjganjgYbjgYvjgpLov5TjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cbiAgaXNXZWJWaWV3KCkge1xuICAgIGlmIChkb2N1bWVudC5yZWFkeVN0YXRlID09PSAnbG9hZGluZycgfHwgZG9jdW1lbnQucmVhZHlTdGF0ZSA9PSAndW5pbml0aWFsaXplZCcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaXNXZWJWaWV3KCkgbWV0aG9kIGlzIGF2YWlsYWJsZSBhZnRlciBkb20gY29udGVudHMgbG9hZGVkLicpO1xuICAgIH1cblxuICAgIHJldHVybiAhISh3aW5kb3cuY29yZG92YSB8fCB3aW5kb3cucGhvbmVnYXAgfHwgd2luZG93LlBob25lR2FwKTtcbiAgfVxuXG4gIC8vLS0tLS0tLS0tLS0tLS0tLVxuICAvLyBpT1MgZGV2aWNlc1xuICAvLy0tLS0tLS0tLS0tLS0tLS1cbiAgLyoqXG4gICAqIEBtZXRob2QgaXNJUGhvbmVcbiAgICogQHNpZ25hdHVyZSBpc0lQaG9uZSgpXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1SZXR1cm5zIHdoZXRoZXIgdGhlIGRldmljZSBpcyBpUGhvbmUuWy9lbl1cbiAgICogICBbamFdaVBob25l5LiK44Gn5a6f6KGM44GV44KM44Gm44GE44KL44GL44Gp44GG44GL44KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG4gIGlzSVBob25lKCkge1xuICAgIHJldHVybiAvaVBob25lL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIGlzSVBob25lWFxuICAgKiBAc2lnbmF0dXJlIGlzSVBob25lWCgpXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1SZXR1cm5zIHdoZXRoZXIgdGhlIGRldmljZSBpcyBpUGhvbmUgWCwgWFMsIFhTIE1heCwgb3IgWFIuWy9lbl1cbiAgICogICBbamFdaVBob25lIFgg44KEIFhT44CBWFMgTWF444CB44G+44Gf44GvIFhSIOS4iuOBp+Wun+ihjOOBleOCjOOBpuOBhOOCi+OBi+OBqeOBhuOBi+OCkui/lOOBl+OBvuOBmeOAglsvamFdXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuICBpc0lQaG9uZVgoKSB7XG4gICAgLy8gaU9TIFdlYlZpZXdzIG9uIHRoZSBzYW1lIGlPUyB2ZXJzaW9uIGhhdmUgdGhlIHNhbWUgdXNlciBhZ2VudC5cbiAgICAvLyBXZSBjYW5ub3QgYXZvaWQgdXNpbmcgd2luZG93LnNjcmVlbi5cbiAgICAvLyBXZSBhbHNvIGNhbm5vdCB1c2UgY29yZG92YS1wbHVnaW4tZGV2aWNlIHNpbmNlIGl0cyBiZWhhdmlvciBpcyBkaWZmZXJlbnQgYmV0d2VlbiBzaW11bGF0b3JzIGFuZCByZWFsIGRldmljZXMuXG4gICAgLy8gVGhpcyB3b3JrcyB3ZWxsIGJvdGggaW4gaU9TIFNhZmFyaSBhbmQgKFVJfFdLKVdlYlZpZXcgb2YgaVBob25lIFguXG4gICAgcmV0dXJuIHRoaXMuaXNJUGhvbmUoKSAmJlxuICAgICAgKHdpbmRvdy5zY3JlZW4ud2lkdGggPT09IDM3NSAmJiB3aW5kb3cuc2NyZWVuLmhlaWdodCA9PT0gODEyIHx8IC8vIFgsIFhTIHBvcnRyYWl0XG4gICAgICAgd2luZG93LnNjcmVlbi53aWR0aCA9PT0gODEyICYmIHdpbmRvdy5zY3JlZW4uaGVpZ2h0ID09PSAzNzUgfHwgLy8gWCwgWFMgbGFuZHNjYXBlXG4gICAgICAgd2luZG93LnNjcmVlbi53aWR0aCA9PT0gNDE0ICYmIHdpbmRvdy5zY3JlZW4uaGVpZ2h0ID09PSA4OTYgfHwgLy8gWFMgTWF4LCBYUiBwb3J0cmFpdFxuICAgICAgIHdpbmRvdy5zY3JlZW4ud2lkdGggPT09IDg5NiAmJiB3aW5kb3cuc2NyZWVuLmhlaWdodCA9PT0gNDE0KTsgLy8gWFMgTWF4LCBYUiBsYW5kc2NhcGVcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIGlzSVBhZFxuICAgKiBAc2lnbmF0dXJlIGlzSVBhZCgpXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1SZXR1cm5zIHdoZXRoZXIgdGhlIGRldmljZSBpcyBpUGFkLlsvZW5dXG4gICAqICAgW2phXWlQYWTkuIrjgaflrp/ooYzjgZXjgozjgabjgYTjgovjgYvjganjgYbjgYvjgpLov5TjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cbiAgaXNJUGFkKCkge1xuICAgIHJldHVybiAvaVBhZC9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG4gIGlzSVBvZCgpIHtcbiAgICByZXR1cm4gL2lQb2QvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuICB9XG5cbiAgLy8tLS0tLS0tLS0tLS0tLS0tXG4gIC8vIGlPUyB2ZXJzaW9uc1xuICAvLy0tLS0tLS0tLS0tLS0tLS1cbiAgLyoqXG4gICAqIEBtZXRob2QgaXNJT1NcbiAgICogQHNpZ25hdHVyZSBpc0lPUyhbZm9yY2VBY3R1YWxQbGF0Zm9ybV0pXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gZm9yY2VBY3R1YWxQbGF0Zm9ybVxuICAgKiAgIFtlbl1JZiB0cnVlLCBzZWxlY3RlZCBwbGF0Zm9ybSBpcyBpZ25vcmVkIGFuZCB0aGUgYWN0dWFsIHBsYXRmb3JtIGlzIHJldHVybmVkLlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1SZXR1cm5zIHdoZXRoZXIgdGhlIE9TIGlzIGlPUy4gQnkgZGVmYXVsdCB3aWxsIHJldHVybiBtYW51YWxseSBzZWxlY3RlZCBwbGF0Zm9ybSBpZiBpdCBpcyBzZXQuWy9lbl1cbiAgICogICBbamFdaU9T5LiK44Gn5a6f6KGM44GV44KM44Gm44GE44KL44GL44Gp44GG44GL44KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG4gIGlzSU9TKGZvcmNlQWN0dWFsUGxhdGZvcm0pIHtcbiAgICBpZiAoIWZvcmNlQWN0dWFsUGxhdGZvcm0gJiYgdGhpcy5fZ2V0U2VsZWN0ZWRQbGF0Zm9ybSgpKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZ2V0U2VsZWN0ZWRQbGF0Zm9ybSgpID09PSAnaW9zJztcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGRldmljZSA9PT0gJ29iamVjdCcgJiYgIS9icm93c2VyL2kudGVzdChkZXZpY2UucGxhdGZvcm0pKSB7XG4gICAgICByZXR1cm4gL2lPUy9pLnRlc3QoZGV2aWNlLnBsYXRmb3JtKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIC9pUGhvbmV8aVBhZHxpUG9kL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBpc0lPUzdhYm92ZVxuICAgKiBAc2lnbmF0dXJlIGlzSU9TN2Fib3ZlKClcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVJldHVybnMgd2hldGhlciB0aGUgaU9TIHZlcnNpb24gaXMgNyBvciBhYm92ZS5bL2VuXVxuICAgKiAgIFtqYV1pT1M35Lul5LiK44Gn5a6f6KGM44GV44KM44Gm44GE44KL44GL44Gp44GG44GL44KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG4gIGlzSU9TN2Fib3ZlKCkge1xuICAgIGlmICh0eXBlb2YgZGV2aWNlID09PSAnb2JqZWN0JyAmJiAhL2Jyb3dzZXIvaS50ZXN0KGRldmljZS5wbGF0Zm9ybSkpIHtcbiAgICAgIHJldHVybiAoL2lPUy9pLnRlc3QoZGV2aWNlLnBsYXRmb3JtKSAmJiAocGFyc2VJbnQoZGV2aWNlLnZlcnNpb24uc3BsaXQoJy4nKVswXSkgPj0gNykpO1xuICAgIH0gZWxzZSBpZiAoL2lQaG9uZXxpUGFkfGlQb2QvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpKSB7XG4gICAgICBjb25zdCB2ZXIgPSAobmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaCgvXFxiWzAtOV0rX1swLTldKyg/Ol9bMC05XSspP1xcYi8pIHx8IFsnJ10pWzBdLnJlcGxhY2UoL18vZywgJy4nKTtcbiAgICAgIHJldHVybiAocGFyc2VJbnQodmVyLnNwbGl0KCcuJylbMF0pID49IDcpO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLy0tLS0tLS0tLS0tLS0tLS1cbiAgLy8gaU9TIGJyb3dzZXJzXG4gIC8vLS0tLS0tLS0tLS0tLS0tLVxuICAvKipcbiAgICogQG1ldGhvZCBpc0lPU1NhZmFyaVxuICAgKiBAc2lnbmF0dXJlIGlzSU9TU2FmYXJpKClcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVJldHVybnMgd2hldGhlciBhcHAgaXMgcnVubmluZyBpbiBpT1MgU2FmYXJpLlsvZW5dXG4gICAqICAgW2phXWlPUyBTYWZhcmnjgaflrp/ooYzjgZXjgozjgabjgYTjgovjgYvjganjgYbjgYvjgpLov5TjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cbiAgaXNJT1NTYWZhcmkoKSB7XG4gICAgY29uc3QgbmF2aWdhdG9yID0gd2luZG93Lm5hdmlnYXRvcjtcbiAgICBjb25zdCB1YSA9IG5hdmlnYXRvci51c2VyQWdlbnQ7XG5cbiAgICByZXR1cm4gISEodGhpcy5pc0lPUygpICYmIHVhLmluZGV4T2YoJ1NhZmFyaScpICE9PSAtMSAmJiB1YS5pbmRleE9mKCdWZXJzaW9uJykgIT09IC0xICYmICFuYXZpZ2F0b3Iuc3RhbmRhbG9uZSk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBpc1dLV2ViVmlld1xuICAgKiBAc2lnbmF0dXJlIGlzV0tXZWJWaWV3KClcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVJldHVybnMgd2hldGhlciBhcHAgaXMgcnVubmluZyBpbiBXS1dlYlZpZXcuWy9lbl1cbiAgICogICBbamFdV0tXZWJWaWV344Gn5a6f6KGM44GV44KM44Gm44GE44KL44GL44Gp44GG44GL44KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG4gIGlzV0tXZWJWaWV3KCkge1xuICAgIGNvbnN0IGx0ZTkgPSAvY29uc3RydWN0b3IvaS50ZXN0KE5hdGl2ZUhUTUxFbGVtZW50KTtcbiAgICByZXR1cm4gISEodGhpcy5pc0lPUygpICYmIHdpbmRvdy53ZWJraXQgJiYgd2luZG93LndlYmtpdC5tZXNzYWdlSGFuZGxlcnMgJiYgd2luZG93LmluZGV4ZWREQiAmJiAhbHRlOSk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBpc1VJV2ViVmlld1xuICAgKiBAc2lnbmF0dXJlIGlzVUlXZWJWaWV3KClcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVJldHVybnMgd2hldGhlciBhcHAgaXMgcnVubmluZyBpbiBVSVdlYlZpZXcuWy9lbl1cbiAgICogICBbamFdVUlXZWJWaWV344Gn5a6f6KGM44GV44KM44Gm44GE44KL44GL44Gp44GG44GL44KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG4gIGlzVUlXZWJWaWV3KCkge1xuICAgIHJldHVybiAhISh0aGlzLmlzSU9TKCkgJiYgIXRoaXMuaXNJT1NTYWZhcmkoKSAmJiAhdGhpcy5pc1dLV2ViVmlldygpKTtcbiAgfVxuXG4gIC8vLS0tLS0tLS0tLS0tLS0tLVxuICAvLyBBbmRyb2lkIGRldmljZXNcbiAgLy8tLS0tLS0tLS0tLS0tLS0tXG4gIC8qKlxuICAgKiBAbWV0aG9kIGlzQW5kcm9pZFBob25lXG4gICAqIEBzaWduYXR1cmUgaXNBbmRyb2lkUGhvbmUoKVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dUmV0dXJucyB3aGV0aGVyIHRoZSBkZXZpY2UgaXMgQW5kcm9pZCBwaG9uZS5bL2VuXVxuICAgKiAgIFtqYV1BbmRyb2lk5pC65biv5LiK44Gn5a6f6KGM44GV44KM44Gm44GE44KL44GL44Gp44GG44GL44KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG4gIGlzQW5kcm9pZFBob25lKCkge1xuICAgIHJldHVybiAvQW5kcm9pZC9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkgJiYgL01vYmlsZS9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBpc0FuZHJvaWRUYWJsZXRcbiAgICogQHNpZ25hdHVyZSBpc0FuZHJvaWRUYWJsZXQoKVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dUmV0dXJucyB3aGV0aGVyIHRoZSBkZXZpY2UgaXMgQW5kcm9pZCB0YWJsZXQuWy9lbl1cbiAgICogICBbamFdQW5kcm9pZOOCv+ODluODrOODg+ODiOS4iuOBp+Wun+ihjOOBleOCjOOBpuOBhOOCi+OBi+OBqeOBhuOBi+OCkui/lOOBl+OBvuOBmeOAglsvamFdXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuICBpc0FuZHJvaWRUYWJsZXQoKSB7XG4gICAgcmV0dXJuIC9BbmRyb2lkL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSAmJiAhL01vYmlsZS9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gIH1cblxuICAvLy0tLS0tLS0tLS0tLS0tLS1cbiAgLy8gQW5kcm9pZCB2ZXJzaW9uc1xuICAvLy0tLS0tLS0tLS0tLS0tLS1cbiAgLyoqXG4gICAqIEBtZXRob2QgaXNBbmRyb2lkXG4gICAqIEBzaWduYXR1cmUgaXNBbmRyb2lkKFtmb3JjZUFjdHVhbFBsYXRmb3JtXSlcbiAgICogQHBhcmFtIHtCb29sZWFufSBmb3JjZUFjdHVhbFBsYXRmb3JtXG4gICAqICAgW2VuXUlmIHRydWUsIHNlbGVjdGVkIHBsYXRmb3JtIGlzIGlnbm9yZWQgYW5kIHRoZSBhY3R1YWwgcGxhdGZvcm0gaXMgcmV0dXJuZWQuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVJldHVybnMgd2hldGhlciB0aGUgT1MgaXMgQW5kcm9pZC4gQnkgZGVmYXVsdCB3aWxsIHJldHVybiBtYW51YWxseSBzZWxlY3RlZCBwbGF0Zm9ybSBpZiBpdCBpcyBzZXQuWy9lbl1cbiAgICogICBbamFdQW5kcm9pZOS4iuOBp+Wun+ihjOOBleOCjOOBpuOBhOOCi+OBi+OBqeOBhuOBi+OCkui/lOOBl+OBvuOBmeOAglsvamFdXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuICBpc0FuZHJvaWQoZm9yY2VBY3R1YWxQbGF0Zm9ybSkge1xuICAgIGlmICghZm9yY2VBY3R1YWxQbGF0Zm9ybSAmJiB0aGlzLl9nZXRTZWxlY3RlZFBsYXRmb3JtKCkpIHtcbiAgICAgIHJldHVybiB0aGlzLl9nZXRTZWxlY3RlZFBsYXRmb3JtKCkgPT09ICdhbmRyb2lkJztcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGRldmljZSA9PT0gJ29iamVjdCcgJiYgIS9icm93c2VyL2kudGVzdChkZXZpY2UucGxhdGZvcm0pKSB7XG4gICAgICByZXR1cm4gL0FuZHJvaWQvaS50ZXN0KGRldmljZS5wbGF0Zm9ybSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAvQW5kcm9pZC9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gICAgfVxuICB9XG5cbiAgLy8tLS0tLS0tLS0tLS0tLS0tXG4gIC8vIE90aGVyIGRldmljZXNcbiAgLy8tLS0tLS0tLS0tLS0tLS0tXG4gIC8qKlxuICAgKiBAbWV0aG9kIGlzV1BcbiAgICogQHNpZ25hdHVyZSBpc1dQKFtmb3JjZUFjdHVhbFBsYXRmb3JtXSlcbiAgICogQHBhcmFtIHtCb29sZWFufSBmb3JjZUFjdHVhbFBsYXRmb3JtXG4gICAqICAgW2VuXUlmIHRydWUsIHNlbGVjdGVkIHBsYXRmb3JtIGlzIGlnbm9yZWQgYW5kIHRoZSBhY3R1YWwgcGxhdGZvcm0gaXMgcmV0dXJuZWQuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVJldHVybnMgd2hldGhlciB0aGUgT1MgaXMgV2luZG93cyBwaG9uZS4gQnkgZGVmYXVsdCB3aWxsIHJldHVybiBtYW51YWxseSBzZWxlY3RlZCBwbGF0Zm9ybSBpZiBpdCBpcyBzZXQuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG4gIGlzV1AoZm9yY2VBY3R1YWxQbGF0Zm9ybSkge1xuICAgIGlmICghZm9yY2VBY3R1YWxQbGF0Zm9ybSAmJiB0aGlzLl9nZXRTZWxlY3RlZFBsYXRmb3JtKCkpIHtcbiAgICAgIHJldHVybiB0aGlzLl9nZXRTZWxlY3RlZFBsYXRmb3JtKCkgPT09ICd3cCc7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBkZXZpY2UgPT09ICdvYmplY3QnICYmICEvYnJvd3Nlci9pLnRlc3QoZGV2aWNlLnBsYXRmb3JtKSkge1xuICAgICAgcmV0dXJuIC9XaW4zMk5UfFdpbkNFL2kudGVzdChkZXZpY2UucGxhdGZvcm0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gL1dpbmRvd3MgUGhvbmV8SUVNb2JpbGV8V1BEZXNrdG9wL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBpc0JsYWNrQmVycnlcbiAgICogQHNpZ25hdHVyZSBpc0JsYWNrQmVycnkoW2ZvcmNlQWN0dWFsUGxhdGZvcm1dKVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGZvcmNlQWN0dWFsUGxhdGZvcm1cbiAgICogICBbZW5dSWYgdHJ1ZSwgc2VsZWN0ZWQgcGxhdGZvcm0gaXMgaWdub3JlZCBhbmQgdGhlIGFjdHVhbCBwbGF0Zm9ybSBpcyByZXR1cm5lZC5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dUmV0dXJucyB3aGV0aGVyIHRoZSBkZXZpY2UgaXMgQmxhY2tCZXJyeS4gQnkgZGVmYXVsdCB3aWxsIHJldHVybiBtYW51YWxseSBzZWxlY3RlZCBwbGF0Zm9ybSBpZiBpdCBpcyBzZXQuWy9lbl1cbiAgICogICBbamFdQmxhY2tCZXJyeeS4iuOBp+Wun+ihjOOBleOCjOOBpuOBhOOCi+OBi+OBqeOBhuOBi+OCkui/lOOBl+OBvuOBmeOAglsvamFdXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuICBpc0JsYWNrQmVycnkoZm9yY2VBY3R1YWxQbGF0Zm9ybSkge1xuICAgIGlmICghZm9yY2VBY3R1YWxQbGF0Zm9ybSAmJiB0aGlzLl9nZXRTZWxlY3RlZFBsYXRmb3JtKCkpIHtcbiAgICAgIHJldHVybiB0aGlzLl9nZXRTZWxlY3RlZFBsYXRmb3JtKCkgPT09ICdibGFja2JlcnJ5JztcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGRldmljZSA9PT0gJ29iamVjdCcgJiYgIS9icm93c2VyL2kudGVzdChkZXZpY2UucGxhdGZvcm0pKSB7XG4gICAgICByZXR1cm4gL0JsYWNrQmVycnkvaS50ZXN0KGRldmljZS5wbGF0Zm9ybSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAvQmxhY2tCZXJyeXxSSU0gVGFibGV0IE9TfEJCMTAvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuICAgIH1cbiAgfVxuXG4gIC8vLS0tLS0tLS0tLS0tLS0tLVxuICAvLyBPdGhlciBicm93c2Vyc1xuICAvLy0tLS0tLS0tLS0tLS0tLS1cbiAgLyoqXG4gICAqIEBtZXRob2QgaXNPcGVyYVxuICAgKiBAc2lnbmF0dXJlIGlzT3BlcmEoW2ZvcmNlQWN0dWFsUGxhdGZvcm1dKVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGZvcmNlQWN0dWFsUGxhdGZvcm1cbiAgICogICBbZW5dSWYgdHJ1ZSwgc2VsZWN0ZWQgcGxhdGZvcm0gaXMgaWdub3JlZCBhbmQgdGhlIGFjdHVhbCBwbGF0Zm9ybSBpcyByZXR1cm5lZC5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dUmV0dXJucyB3aGV0aGVyIHRoZSBicm93c2VyIGlzIE9wZXJhLiBCeSBkZWZhdWx0IHdpbGwgcmV0dXJuIG1hbnVhbGx5IHNlbGVjdGVkIHBsYXRmb3JtIGlmIGl0IGlzIHNldC5bL2VuXVxuICAgKiAgIFtqYV1PcGVyYeS4iuOBp+Wun+ihjOOBleOCjOOBpuOBhOOCi+OBi+OBqeOBhuOBi+OCkui/lOOBl+OBvuOBmeOAglsvamFdXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuICBpc09wZXJhKGZvcmNlQWN0dWFsUGxhdGZvcm0pIHtcbiAgICBpZiAoIWZvcmNlQWN0dWFsUGxhdGZvcm0gJiYgdGhpcy5fZ2V0U2VsZWN0ZWRQbGF0Zm9ybSgpKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZ2V0U2VsZWN0ZWRQbGF0Zm9ybSgpID09PSAnb3BlcmEnO1xuICAgIH1cblxuICAgIHJldHVybiAoISF3aW5kb3cub3BlcmEgfHwgbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCcgT1BSLycpID49IDApO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgaXNGaXJlZm94XG4gICAqIEBzaWduYXR1cmUgaXNGaXJlZm94KFtmb3JjZUFjdHVhbFBsYXRmb3JtXSlcbiAgICogQHBhcmFtIHtCb29sZWFufSBmb3JjZUFjdHVhbFBsYXRmb3JtXG4gICAqICAgW2VuXUlmIHRydWUsIHNlbGVjdGVkIHBsYXRmb3JtIGlzIGlnbm9yZWQgYW5kIHRoZSBhY3R1YWwgcGxhdGZvcm0gaXMgcmV0dXJuZWQuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVJldHVybnMgd2hldGhlciB0aGUgYnJvd3NlciBpcyBGaXJlZm94LiBCeSBkZWZhdWx0IHdpbGwgcmV0dXJuIG1hbnVhbGx5IHNlbGVjdGVkIHBsYXRmb3JtIGlmIGl0IGlzIHNldC5bL2VuXVxuICAgKiAgIFtqYV1GaXJlZm945LiK44Gn5a6f6KGM44GV44KM44Gm44GE44KL44GL44Gp44GG44GL44KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG4gIGlzRmlyZWZveChmb3JjZUFjdHVhbFBsYXRmb3JtKSB7XG4gICAgaWYgKCFmb3JjZUFjdHVhbFBsYXRmb3JtICYmIHRoaXMuX2dldFNlbGVjdGVkUGxhdGZvcm0oKSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2dldFNlbGVjdGVkUGxhdGZvcm0oKSA9PT0gJ2ZpcmVmb3gnO1xuICAgIH1cblxuICAgIHJldHVybiAodHlwZW9mIEluc3RhbGxUcmlnZ2VyICE9PSAndW5kZWZpbmVkJyk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBpc1NhZmFyaVxuICAgKiBAc2lnbmF0dXJlIGlzU2FmYXJpKFtmb3JjZUFjdHVhbFBsYXRmb3JtXSlcbiAgICogQHBhcmFtIHtCb29sZWFufSBmb3JjZUFjdHVhbFBsYXRmb3JtXG4gICAqICAgW2VuXUlmIHRydWUsIHNlbGVjdGVkIHBsYXRmb3JtIGlzIGlnbm9yZWQgYW5kIHRoZSBhY3R1YWwgcGxhdGZvcm0gaXMgcmV0dXJuZWQuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVJldHVybnMgd2hldGhlciB0aGUgYnJvd3NlciBpcyBTYWZhcmkuIEJ5IGRlZmF1bHQgd2lsbCByZXR1cm4gbWFudWFsbHkgc2VsZWN0ZWQgcGxhdGZvcm0gaWYgaXQgaXMgc2V0LlsvZW5dXG4gICAqICAgW2phXVNhZmFyaeS4iuOBp+Wun+ihjOOBleOCjOOBpuOBhOOCi+OBi+OBqeOBhuOBi+OCkui/lOOBl+OBvuOBmeOAglsvamFdXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuICBpc1NhZmFyaShmb3JjZUFjdHVhbFBsYXRmb3JtKSB7XG4gICAgaWYgKCFmb3JjZUFjdHVhbFBsYXRmb3JtICYmIHRoaXMuX2dldFNlbGVjdGVkUGxhdGZvcm0oKSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2dldFNlbGVjdGVkUGxhdGZvcm0oKSA9PT0gJ3NhZmFyaSc7XG4gICAgfVxuXG4gICAgcmV0dXJuIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwod2luZG93LkhUTUxFbGVtZW50KS5pbmRleE9mKCdDb25zdHJ1Y3RvcicpID4gMCkgfHwgKGZ1bmN0aW9uIChwKSB7IHJldHVybiBwLnRvU3RyaW5nKCkgPT09ICdbb2JqZWN0IFNhZmFyaVJlbW90ZU5vdGlmaWNhdGlvbl0nIH0pKCF3aW5kb3dbJ3NhZmFyaSddIHx8IHNhZmFyaS5wdXNoTm90aWZpY2F0aW9uKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIGlzQ2hyb21lXG4gICAqIEBzaWduYXR1cmUgaXNDaHJvbWUoW2ZvcmNlQWN0dWFsUGxhdGZvcm1dKVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGZvcmNlQWN0dWFsUGxhdGZvcm1cbiAgICogICBbZW5dSWYgdHJ1ZSwgc2VsZWN0ZWQgcGxhdGZvcm0gaXMgaWdub3JlZCBhbmQgdGhlIGFjdHVhbCBwbGF0Zm9ybSBpcyByZXR1cm5lZC5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dUmV0dXJucyB3aGV0aGVyIHRoZSBicm93c2VyIGlzIENocm9tZS4gQnkgZGVmYXVsdCB3aWxsIHJldHVybiBtYW51YWxseSBzZWxlY3RlZCBwbGF0Zm9ybSBpZiBpdCBpcyBzZXQuWy9lbl1cbiAgICogICBbamFdQ2hyb21l5LiK44Gn5a6f6KGM44GV44KM44Gm44GE44KL44GL44Gp44GG44GL44KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG4gIGlzQ2hyb21lKGZvcmNlQWN0dWFsUGxhdGZvcm0pIHtcbiAgICBpZiAoIWZvcmNlQWN0dWFsUGxhdGZvcm0gJiYgdGhpcy5fZ2V0U2VsZWN0ZWRQbGF0Zm9ybSgpKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZ2V0U2VsZWN0ZWRQbGF0Zm9ybSgpID09PSAnY2hyb21lJztcbiAgICB9XG5cbiAgICByZXR1cm4gKCEhd2luZG93LmNocm9tZSAmJiAhKCEhd2luZG93Lm9wZXJhIHx8IG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignIE9QUi8nKSA+PSAwKSAmJiAhKG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignIEVkZ2UvJykgPj0gMCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgaXNJRVxuICAgKiBAc2lnbmF0dXJlIGlzSUUoW2ZvcmNlQWN0dWFsUGxhdGZvcm1dKVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGZvcmNlQWN0dWFsUGxhdGZvcm1cbiAgICogICBbZW5dSWYgdHJ1ZSwgc2VsZWN0ZWQgcGxhdGZvcm0gaXMgaWdub3JlZCBhbmQgdGhlIGFjdHVhbCBwbGF0Zm9ybSBpcyByZXR1cm5lZC5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dUmV0dXJucyB3aGV0aGVyIHRoZSBicm93c2VyIGlzIEludGVybmV0IEV4cGxvcmVyLiBCeSBkZWZhdWx0IHdpbGwgcmV0dXJuIG1hbnVhbGx5IHNlbGVjdGVkIHBsYXRmb3JtIGlmIGl0IGlzIHNldC5bL2VuXVxuICAgKiAgIFtqYV1JbnRlcm5ldCBFeHBsb3JlcuS4iuOBp+Wun+ihjOOBleOCjOOBpuOBhOOCi+OBi+OBqeOBhuOBi+OCkui/lOOBl+OBvuOBmeOAglsvamFdXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuICBpc0lFKGZvcmNlQWN0dWFsUGxhdGZvcm0pIHtcbiAgICBpZiAoIWZvcmNlQWN0dWFsUGxhdGZvcm0gJiYgdGhpcy5fZ2V0U2VsZWN0ZWRQbGF0Zm9ybSgpKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZ2V0U2VsZWN0ZWRQbGF0Zm9ybSgpID09PSAnaWUnO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZSB8fCAhIWRvY3VtZW50LmRvY3VtZW50TW9kZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIGlzRWRnZVxuICAgKiBAc2lnbmF0dXJlIGlzRWRnZShbZm9yY2VBY3R1YWxQbGF0Zm9ybV0pXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gZm9yY2VBY3R1YWxQbGF0Zm9ybVxuICAgKiAgIFtlbl1JZiB0cnVlLCBzZWxlY3RlZCBwbGF0Zm9ybSBpcyBpZ25vcmVkIGFuZCB0aGUgYWN0dWFsIHBsYXRmb3JtIGlzIHJldHVybmVkLlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1SZXR1cm5zIHdoZXRoZXIgdGhlIGJyb3dzZXIgaXMgRWRnZS4gQnkgZGVmYXVsdCB3aWxsIHJldHVybiBtYW51YWxseSBzZWxlY3RlZCBwbGF0Zm9ybSBpZiBpdCBpcyBzZXQuWy9lbl1cbiAgICogICBbamFdRWRnZeS4iuOBp+Wun+ihjOOBleOCjOOBpuOBhOOCi+OBi+OBqeOBhuOBi+OCkui/lOOBl+OBvuOBmeOAglsvamFdXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuICBpc0VkZ2UoZm9yY2VBY3R1YWxQbGF0Zm9ybSkge1xuICAgIGlmICghZm9yY2VBY3R1YWxQbGF0Zm9ybSAmJiB0aGlzLl9nZXRTZWxlY3RlZFBsYXRmb3JtKCkpIHtcbiAgICAgIHJldHVybiB0aGlzLl9nZXRTZWxlY3RlZFBsYXRmb3JtKCkgPT09ICdlZGdlJztcbiAgICB9XG5cbiAgICByZXR1cm4gbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCcgRWRnZS8nKSA+PSAwO1xuICB9XG5cbiAgLy8tLS0tLS0tLS0tLS0tLS0tXG4gIC8vIFV0aWxpdHkgZnVuY3Rpb25zXG4gIC8vLS0tLS0tLS0tLS0tLS0tLVxuICAvKipcbiAgICogQHJldHVybiB7U3RyaW5nfVxuICAgKi9cbiAgZ2V0TW9iaWxlT1MoKSB7XG4gICAgaWYgKHRoaXMuaXNBbmRyb2lkKCkpIHtcbiAgICAgIHJldHVybiAnYW5kcm9pZCc7XG4gICAgfVxuICAgIGVsc2UgaWYgKHRoaXMuaXNJT1MoKSkge1xuICAgICAgcmV0dXJuICdpb3MnO1xuICAgIH1cbiAgICBlbHNlIGlmICh0aGlzLmlzV1AoKSkge1xuICAgICAgcmV0dXJuICd3cCc7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcmV0dXJuICdvdGhlcic7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICovXG4gIGdldElPU0RldmljZSgpIHtcbiAgICBpZiAodGhpcy5pc0lQaG9uZSgpKSB7XG4gICAgICByZXR1cm4gJ2lwaG9uZSc7XG4gICAgfVxuICAgIGVsc2UgaWYgKHRoaXMuaXNJUGFkKCkpIHtcbiAgICAgIHJldHVybiAnaXBhZCc7XG4gICAgfVxuICAgIGVsc2UgaWYgKHRoaXMuaXNJUG9kKCkpIHtcbiAgICAgIHJldHVybiAnaXBvZCc7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcmV0dXJuICduYSc7XG4gICAgfVxuICB9XG59XG5cblxuZXhwb3J0IGRlZmF1bHQgbmV3IFBsYXRmb3JtKCk7XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgcGxhdGZvcm0gZnJvbSAnLi9wbGF0Zm9ybSc7XG5pbXBvcnQgdXRpbCBmcm9tICcuL3V0aWwnO1xuXG5jb25zdCBlcnJvciA9IG1lc3NhZ2UgPT4gdXRpbC50aHJvdyhgSW4gUGFnZUF0dHJpYnV0ZUV4cHJlc3Npb246ICR7bWVzc2FnZX1gKTtcblxuY29uc3QgcGFnZUF0dHJpYnV0ZUV4cHJlc3Npb24gPSB7XG4gIF92YXJpYWJsZXM6IHt9LFxuXG4gIC8qKlxuICAgKiBEZWZpbmUgYSB2YXJpYWJsZS5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgTmFtZSBvZiB0aGUgdmFyaWFibGVcbiAgICogQHBhcmFtIHtTdHJpbmd8RnVuY3Rpb259IHZhbHVlIFZhbHVlIG9mIHRoZSB2YXJpYWJsZS4gQ2FuIGJlIGEgc3RyaW5nIG9yIGEgZnVuY3Rpb24uIFRoZSBmdW5jdGlvbiBtdXN0IHJldHVybiBhIHN0cmluZy5cbiAgICogQHBhcmFtIHtCb29sZWFufSBvdmVyd3JpdGUgSWYgdGhpcyB2YWx1ZSBpcyBmYWxzZSwgYW4gZXJyb3Igd2lsbCBiZSB0aHJvd24gd2hlbiB0cnlpbmcgdG8gZGVmaW5lIGEgdmFyaWFibGUgdGhhdCBoYXMgYWxyZWFkeSBiZWVuIGRlZmluZWQuXG4gICAqL1xuICBkZWZpbmVWYXJpYWJsZTogZnVuY3Rpb24obmFtZSwgdmFsdWUsIG92ZXJ3cml0ZT1mYWxzZSkge1xuICAgIGlmICh0eXBlb2YgbmFtZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIGVycm9yKCdWYXJpYWJsZSBuYW1lIG11c3QgYmUgYSBzdHJpbmcnKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJyAmJiB0eXBlb2YgdmFsdWUgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGVycm9yKCdWYXJpYWJsZSB2YWx1ZSBtdXN0IGJlIGEgc3RyaW5nIG9yIGEgZnVuY3Rpb24nKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodGhpcy5fdmFyaWFibGVzLmhhc093blByb3BlcnR5KG5hbWUpICYmICFvdmVyd3JpdGUpIHtcbiAgICAgIGVycm9yKGBcIiR7bmFtZX1cIiBpcyBhbHJlYWR5IGRlZmluZWRgKTtcbiAgICB9XG4gICAgdGhpcy5fdmFyaWFibGVzW25hbWVdID0gdmFsdWU7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldCBhIHZhcmlhYmxlLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBOYW1lIG9mIHRoZSB2YXJpYWJsZS5cbiAgICogQHJldHVybiB7U3RyaW5nfEZ1bmN0aW9ufG51bGx9XG4gICAqL1xuICBnZXRWYXJpYWJsZTogZnVuY3Rpb24obmFtZSkge1xuICAgIGlmICghdGhpcy5fdmFyaWFibGVzLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fdmFyaWFibGVzW25hbWVdO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZW1vdmUgYSB2YXJpYWJsZS5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgTmFtZSBvZiB0aGUgdmFyYWlibGUuXG4gICAqL1xuICByZW1vdmVWYXJpYWJsZTogZnVuY3Rpb24obmFtZSkge1xuICAgIGRlbGV0ZSB0aGlzLl92YXJpYWJsZXNbbmFtZV07XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldCBhbGwgdmFyaWFibGVzLlxuICAgKlxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqL1xuICBnZXRBbGxWYXJpYWJsZXM6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl92YXJpYWJsZXM7XG4gIH0sXG4gIF9wYXJzZVBhcnQ6IGZ1bmN0aW9uKHBhcnQpIHtcbiAgICBsZXQgYyxcbiAgICAgIGluSW50ZXJwb2xhdGlvbiA9IGZhbHNlLFxuICAgICAgY3VycmVudEluZGV4ID0gMDtcblxuICAgIGNvbnN0IHRva2VucyA9IFtdO1xuXG4gICAgaWYgKHBhcnQubGVuZ3RoID09PSAwKSB7XG4gICAgICBlcnJvcignVW5hYmxlIHRvIHBhcnNlIGVtcHR5IHN0cmluZycpO1xuICAgIH1cblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFydC5sZW5ndGg7IGkrKykge1xuICAgICAgYyA9IHBhcnQuY2hhckF0KGkpO1xuXG4gICAgICBpZiAoYyA9PT0gJyQnICYmIHBhcnQuY2hhckF0KGkgKyAxKSA9PT0gJ3snKSB7XG4gICAgICAgIGlmIChpbkludGVycG9sYXRpb24pIHtcbiAgICAgICAgICBlcnJvcignTmVzdGVkIGludGVycG9sYXRpb24gbm90IHN1cHBvcnRlZCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgdG9rZW4gPSBwYXJ0LnN1YnN0cmluZyhjdXJyZW50SW5kZXgsIGkpO1xuICAgICAgICBpZiAodG9rZW4ubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHRva2Vucy5wdXNoKHBhcnQuc3Vic3RyaW5nKGN1cnJlbnRJbmRleCwgaSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgY3VycmVudEluZGV4ID0gaTtcbiAgICAgICAgaW5JbnRlcnBvbGF0aW9uID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGMgPT09ICd9Jykge1xuICAgICAgICBpZiAoIWluSW50ZXJwb2xhdGlvbikge1xuICAgICAgICAgIGVycm9yKCd9IG11c3QgYmUgcHJlY2VlZGVkIGJ5ICR7Jyk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB0b2tlbiA9IHBhcnQuc3Vic3RyaW5nKGN1cnJlbnRJbmRleCwgaSArIDEpO1xuICAgICAgICBpZiAodG9rZW4ubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHRva2Vucy5wdXNoKHBhcnQuc3Vic3RyaW5nKGN1cnJlbnRJbmRleCwgaSArIDEpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGN1cnJlbnRJbmRleCA9IGkgKyAxO1xuICAgICAgICBpbkludGVycG9sYXRpb24gPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaW5JbnRlcnBvbGF0aW9uKSB7XG4gICAgICBlcnJvcignVW50ZXJtaW5hdGVkIGludGVycG9sYXRpb24nKTtcbiAgICB9XG5cbiAgICB0b2tlbnMucHVzaChwYXJ0LnN1YnN0cmluZyhjdXJyZW50SW5kZXgsIHBhcnQubGVuZ3RoKSk7XG5cbiAgICByZXR1cm4gdG9rZW5zO1xuICB9LFxuICBfcmVwbGFjZVRva2VuOiBmdW5jdGlvbih0b2tlbikge1xuICAgIGNvbnN0IHJlID0gL15cXCR7KC4qPyl9JC8sXG4gICAgICBtYXRjaCA9IHRva2VuLm1hdGNoKHJlKTtcblxuICAgIGlmIChtYXRjaCkge1xuICAgICAgY29uc3QgbmFtZSA9IG1hdGNoWzFdLnRyaW0oKTtcbiAgICAgIGNvbnN0IHZhcmlhYmxlID0gdGhpcy5nZXRWYXJpYWJsZShuYW1lKTtcblxuICAgICAgaWYgKHZhcmlhYmxlID09PSBudWxsKSB7XG4gICAgICAgIGVycm9yKGBWYXJpYWJsZSBcIiR7bmFtZX1cIiBkb2VzIG5vdCBleGlzdGApO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAodHlwZW9mIHZhcmlhYmxlID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gdmFyaWFibGU7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgcnYgPSB2YXJpYWJsZSgpO1xuXG4gICAgICAgIGlmICh0eXBlb2YgcnYgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgZXJyb3IoJ011c3QgcmV0dXJuIGEgc3RyaW5nJyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcnY7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcmV0dXJuIHRva2VuO1xuICAgIH1cbiAgfSxcbiAgX3JlcGxhY2VUb2tlbnM6IGZ1bmN0aW9uKHRva2Vucykge1xuICAgIHJldHVybiB0b2tlbnMubWFwKHRoaXMuX3JlcGxhY2VUb2tlbi5iaW5kKHRoaXMpKTtcbiAgfSxcbiAgX3BhcnNlRXhwcmVzc2lvbjogZnVuY3Rpb24oZXhwcmVzc2lvbikge1xuICAgIHJldHVybiBleHByZXNzaW9uLnNwbGl0KCcsJylcbiAgICAgIC5tYXAoXG4gICAgICAgIGZ1bmN0aW9uKHBhcnQpIHtcbiAgICAgICAgICByZXR1cm4gcGFydC50cmltKCk7XG4gICAgICAgIH1cbiAgICAgIClcbiAgICAgIC5tYXAodGhpcy5fcGFyc2VQYXJ0LmJpbmQodGhpcykpXG4gICAgICAubWFwKHRoaXMuX3JlcGxhY2VUb2tlbnMuYmluZCh0aGlzKSlcbiAgICAgIC5tYXAoKHBhcnQpID0+IHBhcnQuam9pbignJykpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBFdmFsdWF0ZSBhbiBleHByZXNzaW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gZXhwcmVzc2lvbiBBbiBwYWdlIGF0dHJpYnV0ZSBleHByZXNzaW9uLlxuICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICovXG4gIGV2YWx1YXRlOiBmdW5jdGlvbihleHByZXNzaW9uKSB7XG4gICAgaWYgKCFleHByZXNzaW9uKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3BhcnNlRXhwcmVzc2lvbihleHByZXNzaW9uKTtcbiAgfVxufTtcblxuLy8gRGVmaW5lIGRlZmF1bHQgdmFyaWFibGVzLlxucGFnZUF0dHJpYnV0ZUV4cHJlc3Npb24uZGVmaW5lVmFyaWFibGUoJ21vYmlsZU9TJywgcGxhdGZvcm0uZ2V0TW9iaWxlT1MoKSk7XG5wYWdlQXR0cmlidXRlRXhwcmVzc2lvbi5kZWZpbmVWYXJpYWJsZSgnaU9TRGV2aWNlJywgcGxhdGZvcm0uZ2V0SU9TRGV2aWNlKCkpO1xucGFnZUF0dHJpYnV0ZUV4cHJlc3Npb24uZGVmaW5lVmFyaWFibGUoJ3J1bnRpbWUnLCAoKSA9PiB7XG4gIHJldHVybiBwbGF0Zm9ybS5pc1dlYlZpZXcoKSA/ICdjb3Jkb3ZhJyA6ICdicm93c2VyJztcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBwYWdlQXR0cmlidXRlRXhwcmVzc2lvbjtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCB1dGlsIGZyb20gJy4uL3V0aWwnO1xuaW1wb3J0IHBsYXRmb3JtIGZyb20gJy4uL3BsYXRmb3JtJztcbmltcG9ydCBwYWdlQXR0cmlidXRlRXhwcmVzc2lvbiBmcm9tICcuLi9wYWdlLWF0dHJpYnV0ZS1leHByZXNzaW9uJztcblxuY29uc3QgaW50ZXJuYWwgPSB7fTtcblxuaW50ZXJuYWwuY29uZmlnID0ge1xuICBhdXRvU3RhdHVzQmFyRmlsbDogdHJ1ZSxcbiAgYW5pbWF0aW9uc0Rpc2FibGVkOiBmYWxzZSxcbiAgd2FybmluZ3NEaXNhYmxlZDogZmFsc2Vcbn07XG5cbmludGVybmFsLm51bGxFbGVtZW50ID0gd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXG4vKipcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbmludGVybmFsLmlzRW5hYmxlZEF1dG9TdGF0dXNCYXJGaWxsID0gKCkgPT4ge1xuICByZXR1cm4gISFpbnRlcm5hbC5jb25maWcuYXV0b1N0YXR1c0JhckZpbGw7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nfSBodG1sXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cbmludGVybmFsLm5vcm1hbGl6ZVBhZ2VIVE1MID0gaHRtbCA9PiAoJycgKyBodG1sKS50cmltKCk7XG5cbmludGVybmFsLndhaXRET01Db250ZW50TG9hZGVkID0gY2FsbGJhY2sgPT4ge1xuICBpZiAod2luZG93LmRvY3VtZW50LnJlYWR5U3RhdGUgPT09ICdsb2FkaW5nJyB8fCB3aW5kb3cuZG9jdW1lbnQucmVhZHlTdGF0ZSA9PSAndW5pbml0aWFsaXplZCcpIHtcbiAgICBjb25zdCB3cmFwcGVkQ2FsbGJhY2sgPSAoKSA9PiB7XG4gICAgICBjYWxsYmFjaygpO1xuICAgICAgd2luZG93LmRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ0RPTUNvbnRlbnRMb2FkZWQnLCB3cmFwcGVkQ2FsbGJhY2spO1xuICAgIH07XG4gICAgd2luZG93LmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ0RPTUNvbnRlbnRMb2FkZWQnLCB3cmFwcGVkQ2FsbGJhY2spO1xuICB9IGVsc2Uge1xuICAgIHNldEltbWVkaWF0ZShjYWxsYmFjayk7XG4gIH1cbn07XG5cbmludGVybmFsLmF1dG9TdGF0dXNCYXJGaWxsID0gYWN0aW9uID0+IHtcbiAgY29uc3Qgb25SZWFkeSA9ICgpID0+IHtcbiAgICBpZiAoaW50ZXJuYWwuc2hvdWxkRmlsbFN0YXR1c0JhcigpKSB7XG4gICAgICBhY3Rpb24oKTtcbiAgICB9XG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignZGV2aWNlcmVhZHknLCBvblJlYWR5KTtcbiAgfTtcblxuICBpZiAodHlwZW9mIGRldmljZSA9PT0gJ29iamVjdCcpIHtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdkZXZpY2VyZWFkeScsIG9uUmVhZHkpO1xuICB9IGVsc2UgaWYgKFsnY29tcGxldGUnLCAnaW50ZXJhY3RpdmUnXS5pbmRleE9mKGRvY3VtZW50LnJlYWR5U3RhdGUpID09PSAtMSkge1xuICAgIGludGVybmFsLndhaXRET01Db250ZW50TG9hZGVkKG9uUmVhZHkpO1xuICB9IGVsc2Uge1xuICAgIG9uUmVhZHkoKTtcbiAgfVxufTtcblxuaW50ZXJuYWwuc2hvdWxkRmlsbFN0YXR1c0JhciA9ICgpID0+IGludGVybmFsLmlzRW5hYmxlZEF1dG9TdGF0dXNCYXJGaWxsKCkgJiZcbiAgKHBsYXRmb3JtLmlzV2ViVmlldygpICYmIHBsYXRmb3JtLmlzSU9TN2Fib3ZlKCkgJiYgIXBsYXRmb3JtLmlzSVBob25lWCgpIHx8IGRvY3VtZW50LmJvZHkucXVlcnlTZWxlY3RvcignLm9ucy1zdGF0dXMtYmFyLW1vY2suaW9zJykpO1xuXG5pbnRlcm5hbC50ZW1wbGF0ZVN0b3JlID0ge1xuICBfc3RvcmFnZToge30sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAgICogQHJldHVybiB7U3RyaW5nL251bGx9IHRlbXBsYXRlXG4gICAqL1xuICBnZXQoa2V5KSB7XG4gICAgcmV0dXJuIGludGVybmFsLnRlbXBsYXRlU3RvcmUuX3N0b3JhZ2Vba2V5XSB8fCBudWxsO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0ZW1wbGF0ZVxuICAgKi9cbiAgc2V0KGtleSwgdGVtcGxhdGUpIHtcbiAgICBpbnRlcm5hbC50ZW1wbGF0ZVN0b3JlLl9zdG9yYWdlW2tleV0gPSB0ZW1wbGF0ZTtcbiAgfVxufTtcblxud2luZG93LmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ190ZW1wbGF0ZWxvYWRlZCcsIGZ1bmN0aW9uKGUpIHtcbiAgaWYgKGUudGFyZ2V0Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdvbnMtdGVtcGxhdGUnKSB7XG4gICAgaW50ZXJuYWwudGVtcGxhdGVTdG9yZS5zZXQoZS50ZW1wbGF0ZUlkLCBlLnRlbXBsYXRlKTtcbiAgfVxufSwgZmFsc2UpO1xuXG5pbnRlcm5hbC53YWl0RE9NQ29udGVudExvYWRlZChmdW5jdGlvbigpIHtcbiAgcmVnaXN0ZXIoJ3NjcmlwdFt0eXBlPVwidGV4dC9vbnMtdGVtcGxhdGVcIl0nKTtcbiAgcmVnaXN0ZXIoJ3NjcmlwdFt0eXBlPVwidGV4dC90ZW1wbGF0ZVwiXScpO1xuICByZWdpc3Rlcignc2NyaXB0W3R5cGU9XCJ0ZXh0L25nLXRlbXBsYXRlXCJdJyk7XG4gIHJlZ2lzdGVyKCd0ZW1wbGF0ZScpO1xuXG4gIGZ1bmN0aW9uIHJlZ2lzdGVyKHF1ZXJ5KSB7XG4gICAgY29uc3QgdGVtcGxhdGVzID0gd2luZG93LmRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwocXVlcnkpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGVtcGxhdGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpbnRlcm5hbC50ZW1wbGF0ZVN0b3JlLnNldCh0ZW1wbGF0ZXNbaV0uZ2V0QXR0cmlidXRlKCdpZCcpLCB0ZW1wbGF0ZXNbaV0udGV4dENvbnRlbnQgfHwgdGVtcGxhdGVzW2ldLmNvbnRlbnQpO1xuICAgIH1cbiAgfVxufSk7XG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IHBhZ2VcbiAqIEByZXR1cm4ge1Byb21pc2V9XG4gKi9cbmludGVybmFsLmdldFRlbXBsYXRlSFRNTEFzeW5jID0gZnVuY3Rpb24ocGFnZSkge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGludGVybmFsLndhaXRET01Db250ZW50TG9hZGVkKCgpID0+IHtcbiAgICAgIGNvbnN0IGNhY2hlID0gaW50ZXJuYWwudGVtcGxhdGVTdG9yZS5nZXQocGFnZSk7XG4gICAgICBpZiAoY2FjaGUpIHtcbiAgICAgICAgaWYgKGNhY2hlIGluc3RhbmNlb2YgRG9jdW1lbnRGcmFnbWVudCkge1xuICAgICAgICAgIHJldHVybiByZXNvbHZlKGNhY2hlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGh0bWwgPSB0eXBlb2YgY2FjaGUgPT09ICdzdHJpbmcnID8gY2FjaGUgOiBjYWNoZVsxXTtcbiAgICAgICAgcmV0dXJuIHJlc29sdmUoaW50ZXJuYWwubm9ybWFsaXplUGFnZUhUTUwoaHRtbCkpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBsb2NhbCA9IHdpbmRvdy5kb2N1bWVudC5nZXRFbGVtZW50QnlJZChwYWdlKTtcbiAgICAgIGlmIChsb2NhbCkge1xuICAgICAgICBjb25zdCBodG1sID0gbG9jYWwudGV4dENvbnRlbnQgfHwgbG9jYWwuY29udGVudDtcbiAgICAgICAgcmV0dXJuIHJlc29sdmUoaHRtbCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgeGhyLm9wZW4oJ0dFVCcsIHBhZ2UsIHRydWUpO1xuICAgICAgeGhyLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBjb25zdCBodG1sID0geGhyLnJlc3BvbnNlVGV4dDtcbiAgICAgICAgaWYgKHhoci5zdGF0dXMgPj0gNDAwICYmIHhoci5zdGF0dXMgPCA2MDApIHtcbiAgICAgICAgICByZWplY3QoaHRtbCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gUmVmcmVzaCBzY3JpcHQgdGFnc1xuICAgICAgICAgIGNvbnN0IGZyYWdtZW50ID0gdXRpbC5jcmVhdGVGcmFnbWVudChodG1sKTtcbiAgICAgICAgICB1dGlsLmFycmF5RnJvbShmcmFnbWVudC5xdWVyeVNlbGVjdG9yQWxsKCdzY3JpcHQnKSkuZm9yRWFjaChlbCA9PiB7XG4gICAgICAgICAgICBjb25zdCBzY3JpcHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtcbiAgICAgICAgICAgIHNjcmlwdC50eXBlID0gZWwudHlwZSB8fCAndGV4dC9qYXZhc2NyaXB0JztcbiAgICAgICAgICAgIHNjcmlwdC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShlbC50ZXh0IHx8IGVsLnRleHRDb250ZW50IHx8IGVsLmlubmVySFRNTCkpO1xuICAgICAgICAgICAgZWwucGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQoc2NyaXB0LCBlbCk7XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBpbnRlcm5hbC50ZW1wbGF0ZVN0b3JlLnNldChwYWdlLCBmcmFnbWVudCk7XG4gICAgICAgICAgcmVzb2x2ZShmcmFnbWVudCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICB4aHIub25lcnJvciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB1dGlsLnRocm93KGBQYWdlIHRlbXBsYXRlIG5vdCBmb3VuZDogJHtwYWdlfWApO1xuICAgICAgfTtcbiAgICAgIHhoci5zZW5kKG51bGwpO1xuICAgIH0pO1xuICB9KTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IHBhZ2VcbiAqIEByZXR1cm4ge1Byb21pc2V9XG4gKi9cbmludGVybmFsLmdldFBhZ2VIVE1MQXN5bmMgPSBmdW5jdGlvbihwYWdlKSB7XG4gIGNvbnN0IHBhZ2VzID0gcGFnZUF0dHJpYnV0ZUV4cHJlc3Npb24uZXZhbHVhdGUocGFnZSk7XG5cbiAgY29uc3QgZ2V0UGFnZSA9IChwYWdlKSA9PiB7XG4gICAgaWYgKHR5cGVvZiBwYWdlICE9PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KCdNdXN0IHNwZWNpZnkgYSBwYWdlLicpO1xuICAgIH1cblxuICAgIHJldHVybiBpbnRlcm5hbC5nZXRUZW1wbGF0ZUhUTUxBc3luYyhwYWdlKVxuICAgICAgLmNhdGNoKGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgIGlmIChwYWdlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyb3IpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGdldFBhZ2UocGFnZXMuc2hpZnQoKSk7XG4gICAgICB9KTtcbiAgfTtcblxuICByZXR1cm4gZ2V0UGFnZShwYWdlcy5zaGlmdCgpKTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGludGVybmFsO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IHV0aWwgZnJvbSAnLi4vdXRpbCc7XG5pbXBvcnQgaW50ZXJuYWwgZnJvbSAnLi4vaW50ZXJuYWwnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBbmltYXRvckZhY3Rvcnkge1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cy5hbmltYXRvcnMgVGhlIGRpY3Rpb25hcnkgZm9yIGFuaW1hdG9yIGNsYXNzZXNcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gb3B0cy5iYXNlQ2xhc3MgVGhlIGJhc2UgY2xhc3Mgb2YgYW5pbWF0b3JzXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0cy5iYXNlQ2xhc3NOYW1lXSBUaGUgbmFtZSBvZiB0aGUgYmFzZSBjbGFzcyBvZiBhbmltYXRvcnNcbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRzLmRlZmF1bHRBbmltYXRpb25dIFRoZSBkZWZhdWx0IGFuaW1hdGlvbiBuYW1lXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0cy5kZWZhdWx0QW5pbWF0aW9uT3B0aW9uc10gVGhlIGRlZmF1bHQgYW5pbWF0aW9uIG9wdGlvbnNcbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdHMpIHtcbiAgICB0aGlzLl9hbmltYXRvcnMgPSBvcHRzLmFuaW1hdG9ycztcbiAgICB0aGlzLl9iYXNlQ2xhc3MgPSBvcHRzLmJhc2VDbGFzcztcbiAgICB0aGlzLl9iYXNlQ2xhc3NOYW1lID0gb3B0cy5iYXNlQ2xhc3NOYW1lIHx8IG9wdHMuYmFzZUNsYXNzLm5hbWU7XG4gICAgdGhpcy5fYW5pbWF0aW9uID0gb3B0cy5kZWZhdWx0QW5pbWF0aW9uIHx8ICdkZWZhdWx0JztcbiAgICB0aGlzLl9hbmltYXRpb25PcHRpb25zID0gb3B0cy5kZWZhdWx0QW5pbWF0aW9uT3B0aW9ucyB8fCB7fTtcblxuICAgIGlmICghdGhpcy5fYW5pbWF0b3JzW3RoaXMuX2FuaW1hdGlvbl0pIHtcbiAgICAgIHV0aWwudGhyb3coJ05vIHN1Y2ggYW5pbWF0aW9uOiAnICsgdGhpcy5fYW5pbWF0aW9uKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtTdHJpbmd9IGpzb25TdHJpbmdcbiAgICogQHJldHVybiB7T2JqZWN0L251bGx9XG4gICAqL1xuICBzdGF0aWMgcGFyc2VBbmltYXRpb25PcHRpb25zU3RyaW5nKGpzb25TdHJpbmcpIHtcbiAgICB0cnkge1xuICAgICAgaWYgKHR5cGVvZiBqc29uU3RyaW5nID09PSAnc3RyaW5nJykge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB1dGlsLmFuaW1hdGlvbk9wdGlvbnNQYXJzZShqc29uU3RyaW5nKTtcbiAgICAgICAgaWYgKHR5cGVvZiByZXN1bHQgPT09ICdvYmplY3QnICYmIHJlc3VsdCAhPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcignXCJhbmltYXRpb24tb3B0aW9uc1wiIGF0dHJpYnV0ZSBtdXN0IGJlIGEgSlNPTiBvYmplY3Qgc3RyaW5nOiAnICsganNvblN0cmluZyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB7fTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdcImFuaW1hdGlvbi1vcHRpb25zXCIgYXR0cmlidXRlIG11c3QgYmUgYSBKU09OIG9iamVjdCBzdHJpbmc6ICcgKyBqc29uU3RyaW5nKTtcbiAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICovXG4gIHNldEFuaW1hdGlvbk9wdGlvbnMob3B0aW9ucykge1xuICAgIHRoaXMuX2FuaW1hdGlvbk9wdGlvbnMgPSBvcHRpb25zO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5hbmltYXRpb25dIFRoZSBhbmltYXRpb24gbmFtZVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuYW5pbWF0aW9uT3B0aW9uc10gVGhlIGFuaW1hdGlvbiBvcHRpb25zXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkZWZhdWx0QW5pbWF0b3IgVGhlIGRlZmF1bHQgYW5pbWF0b3IgaW5zdGFuY2VcbiAgICogQHJldHVybiB7T2JqZWN0fSBBbiBhbmltYXRvciBpbnN0YW5jZVxuICAgKi9cbiAgbmV3QW5pbWF0b3Iob3B0aW9ucyA9IHt9LCBkZWZhdWx0QW5pbWF0b3IpIHtcblxuICAgIGxldCBhbmltYXRvciA9IG51bGw7XG5cbiAgICBpZiAob3B0aW9ucy5hbmltYXRpb24gaW5zdGFuY2VvZiB0aGlzLl9iYXNlQ2xhc3MpIHtcbiAgICAgIHJldHVybiBvcHRpb25zLmFuaW1hdGlvbjtcbiAgICB9XG5cbiAgICBsZXQgQW5pbWF0b3IgPSBudWxsO1xuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmFuaW1hdGlvbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgIEFuaW1hdG9yID0gdGhpcy5fYW5pbWF0b3JzW29wdGlvbnMuYW5pbWF0aW9uXTtcbiAgICB9XG5cbiAgICBpZiAoIUFuaW1hdG9yICYmIGRlZmF1bHRBbmltYXRvcikge1xuICAgICAgYW5pbWF0b3IgPSBkZWZhdWx0QW5pbWF0b3I7XG4gICAgfSBlbHNlIHtcbiAgICAgIEFuaW1hdG9yID0gQW5pbWF0b3IgfHwgdGhpcy5fYW5pbWF0b3JzW3RoaXMuX2FuaW1hdGlvbl07XG5cbiAgICAgIGNvbnN0IGFuaW1hdGlvbk9wdHMgPSB1dGlsLmV4dGVuZChcbiAgICAgICAge30sXG4gICAgICAgIHRoaXMuX2FuaW1hdGlvbk9wdGlvbnMsXG4gICAgICAgIG9wdGlvbnMuYW5pbWF0aW9uT3B0aW9ucyB8fCB7fSxcbiAgICAgICAgaW50ZXJuYWwuY29uZmlnLmFuaW1hdGlvbnNEaXNhYmxlZCA/IHtkdXJhdGlvbjogMCwgZGVsYXk6IDB9IDoge31cbiAgICAgICk7XG5cbiAgICAgIGFuaW1hdG9yID0gbmV3IEFuaW1hdG9yKGFuaW1hdGlvbk9wdHMpO1xuXG4gICAgICBpZiAodHlwZW9mIGFuaW1hdG9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGFuaW1hdG9yID0gbmV3IGFuaW1hdG9yKGFuaW1hdGlvbk9wdHMpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5ldy1jYXBcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIShhbmltYXRvciBpbnN0YW5jZW9mIHRoaXMuX2Jhc2VDbGFzcykpIHtcbiAgICAgIHV0aWwudGhyb3coYFwiYW5pbWF0b3JcIiBpcyBub3QgYW4gaW5zdGFuY2Ugb2YgJHt0aGlzLl9iYXNlQ2xhc3NOYW1lfWApO1xuICAgIH1cblxuICAgIHJldHVybiBhbmltYXRvcjtcbiAgfVxufVxuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IG9uc1BsYXRmb3JtIGZyb20gJy4vcGxhdGZvcm0nO1xuaW1wb3J0IHV0aWwgZnJvbSAnLi91dGlsJztcblxubGV0IGF1dG9TdHlsZUVuYWJsZWQgPSB0cnVlO1xuXG4vLyBNb2RpZmllcnNcbmNvbnN0IG1vZGlmaWVyc01hcCA9IHtcbiAgJ3F1aWV0JzogJ21hdGVyaWFsLS1mbGF0JyxcbiAgJ2xpZ2h0JzogJ21hdGVyaWFsLS1mbGF0JyxcbiAgJ291dGxpbmUnOiAnbWF0ZXJpYWwtLWZsYXQnLFxuICAnY3RhJzogJycsXG4gICdsYXJnZS0tcXVpZXQnOiAnbWF0ZXJpYWwtLWZsYXQgbGFyZ2UnLFxuICAnbGFyZ2UtLWN0YSc6ICdsYXJnZScsXG4gICdub2JvcmRlcic6ICcnLFxuICAndGFwcGFibGUnOiAnJ1xufTtcblxuY29uc3QgcGxhdGZvcm1zID0ge307XG5cbnBsYXRmb3Jtcy5hbmRyb2lkID0gZWxlbWVudCA9PiB7XG5cbiAgY29uc3QgZWxlbWVudE5hbWUgPSBlbGVtZW50LnRhZ05hbWUudG9Mb3dlckNhc2UoKTtcblxuICBpZiAoIXV0aWwuaGFzTW9kaWZpZXIoZWxlbWVudCwgJ21hdGVyaWFsJykpIHtcbiAgICBjb25zdCBvbGRNb2RpZmllciA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdtb2RpZmllcicpIHx8ICcnO1xuXG4gICAgY29uc3QgbmV3TW9kaWZpZXIgPSBvbGRNb2RpZmllci50cmltKCkuc3BsaXQoL1xccysvKS5tYXAoZSA9PiBtb2RpZmllcnNNYXAuaGFzT3duUHJvcGVydHkoZSkgPyBtb2RpZmllcnNNYXBbZV0gOiBlKTtcbiAgICBuZXdNb2RpZmllci51bnNoaWZ0KCdtYXRlcmlhbCcpO1xuXG4gICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ21vZGlmaWVyJywgbmV3TW9kaWZpZXIuam9pbignICcpLnRyaW0oKSk7XG4gIH1cblxuICBjb25zdCBlbGVtZW50cyA9IFtcbiAgICAnb25zLWFsZXJ0LWRpYWxvZy1idXR0b24nLFxuICAgICdvbnMtdG9vbGJhci1idXR0b24nLFxuICAgICdvbnMtYmFjay1idXR0b24nLFxuICAgICdvbnMtYnV0dG9uJyxcbiAgICAnb25zLWxpc3QtaXRlbScsXG4gICAgJ29ucy1mYWInLFxuICAgICdvbnMtc3BlZWQtZGlhbCcsXG4gICAgJ29ucy1zcGVlZC1kaWFsLWl0ZW0nLFxuICAgICdvbnMtdGFiJ1xuICBdO1xuXG5cbiAgLy8gRWZmZWN0c1xuICBpZiAoZWxlbWVudHMuaW5kZXhPZihlbGVtZW50TmFtZSkgIT09IC0xXG4gICAgJiYgIWVsZW1lbnQuaGFzQXR0cmlidXRlKCdyaXBwbGUnKVxuICAgICYmICFlbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJ29ucy1yaXBwbGUnKSkge1xuXG4gICAgaWYgKGVsZW1lbnROYW1lID09PSAnb25zLWxpc3QtaXRlbScpIHtcbiAgICAgIGlmIChlbGVtZW50Lmhhc0F0dHJpYnV0ZSgndGFwcGFibGUnKSkge1xuICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgncmlwcGxlJywgJycpO1xuICAgICAgICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZSgndGFwcGFibGUnKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3JpcHBsZScsICcnKTtcbiAgICB9XG4gIH1cbn07XG5cbnBsYXRmb3Jtcy5pb3MgPSBlbGVtZW50ID0+IHtcblxuIC8vIE1vZGlmaWVyc1xuIGlmICh1dGlsLnJlbW92ZU1vZGlmaWVyKGVsZW1lbnQsICdtYXRlcmlhbCcpKSB7XG4gICBpZiAodXRpbC5yZW1vdmVNb2RpZmllcihlbGVtZW50LCAnbWF0ZXJpYWwtLWZsYXQnKSkge1xuICAgICB1dGlsLmFkZE1vZGlmaWVyKGVsZW1lbnQsICh1dGlsLnJlbW92ZU1vZGlmaWVyKGVsZW1lbnQsICdsYXJnZScpKSA/ICdsYXJnZS0tcXVpZXQnIDogJ3F1aWV0Jyk7XG4gICB9XG5cbiAgIGlmICghZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ21vZGlmaWVyJykpIHtcbiAgICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ21vZGlmaWVyJyk7XG4gICB9XG4gfVxuXG4gLy8gRWZmZWN0c1xuIGlmIChlbGVtZW50Lmhhc0F0dHJpYnV0ZSgncmlwcGxlJykpIHtcbiAgIGlmIChlbGVtZW50LnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ29ucy1saXN0LWl0ZW0nKSB7XG4gICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCd0YXBwYWJsZScsICcnKTtcbiAgIH1cblxuICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ3JpcHBsZScpO1xuIH1cbn07XG5cbmNvbnN0IHVubG9ja2VkID0ge1xuICBhbmRyb2lkOiB0cnVlXG59O1xuXG5jb25zdCBnZXRQbGF0Zm9ybSA9IChlbGVtZW50LCBmb3JjZSkgPT4ge1xuICBpZiAoYXV0b1N0eWxlRW5hYmxlZCAmJiAhZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ2Rpc2FibGUtYXV0by1zdHlsaW5nJykpIHtcbiAgICBjb25zdCBtb2JpbGVPUyA9IG9uc1BsYXRmb3JtLmdldE1vYmlsZU9TKCk7XG4gICAgaWYgKHBsYXRmb3Jtcy5oYXNPd25Qcm9wZXJ0eShtb2JpbGVPUykgJiYgKHVubG9ja2VkLmhhc093blByb3BlcnR5KG1vYmlsZU9TKSB8fCBmb3JjZSkpIHtcbiAgICAgIHJldHVybiBtb2JpbGVPUztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59O1xuXG5jb25zdCBwcmVwYXJlID0gKGVsZW1lbnQsIGZvcmNlKSA9PiB7XG4gIGNvbnN0IHAgPSBnZXRQbGF0Zm9ybShlbGVtZW50LCBmb3JjZSk7XG4gIHAgJiYgcGxhdGZvcm1zW3BdKGVsZW1lbnQpO1xufTtcblxuY29uc3QgbWFwTW9kaWZpZXIgPSAobW9kaWZpZXIsIGVsZW1lbnQsIGZvcmNlKSA9PiB7XG4gIGlmIChnZXRQbGF0Zm9ybShlbGVtZW50LCBmb3JjZSkpIHtcbiAgICByZXR1cm4gbW9kaWZpZXIuc3BsaXQoL1xccysvKS5tYXAobSA9PiBtb2RpZmllcnNNYXAuaGFzT3duUHJvcGVydHkobSkgPyBtb2RpZmllcnNNYXBbbV0gOiBtKS5qb2luKCcgJyk7XG4gIH1cbiAgcmV0dXJuIG1vZGlmaWVyO1xufTtcblxuY29uc3QgcmVzdG9yZU1vZGlmaWVyID0gZWxlbWVudCA9PiB7XG4gIGlmIChnZXRQbGF0Zm9ybShlbGVtZW50KSA9PT0gJ2FuZHJvaWQnKSB7XG4gICAgY29uc3QgbW9kaWZpZXIgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgnbW9kaWZpZXInKSB8fCAnJztcbiAgICBsZXQgbmV3TW9kaWZpZXIgPSBtYXBNb2RpZmllcihtb2RpZmllciwgZWxlbWVudCk7XG5cbiAgICBpZiAoIS8oXnxcXHMrKW1hdGVyaWFsKCR8XFxzKykvaS50ZXN0KG1vZGlmaWVyKSkge1xuICAgICAgbmV3TW9kaWZpZXIgPSAnbWF0ZXJpYWwgJyArIG5ld01vZGlmaWVyO1xuICAgIH1cblxuICAgIGlmIChuZXdNb2RpZmllciAhPT0gbW9kaWZpZXIpIHtcbiAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCdtb2RpZmllcicsIG5ld01vZGlmaWVyLnRyaW0oKSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuZXhwb3J0IGRlZmF1bHQge1xuICBpc0VuYWJsZWQ6ICgpID0+IGF1dG9TdHlsZUVuYWJsZWQsXG4gIGVuYWJsZTogKCkgPT4gYXV0b1N0eWxlRW5hYmxlZCA9IHRydWUsXG4gIGRpc2FibGU6ICgpID0+IGF1dG9TdHlsZUVuYWJsZWQgPSBmYWxzZSxcbiAgcHJlcGFyZSxcbiAgbWFwTW9kaWZpZXIsXG4gIGdldFBsYXRmb3JtLFxuICByZXN0b3JlTW9kaWZpZXJcbn07XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgdXRpbCBmcm9tICcuLi91dGlsLmpzJztcbmltcG9ydCBhdXRvU3R5bGUgZnJvbSAnLi4vYXV0b3N0eWxlLmpzJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTW9kaWZpZXJVdGlsIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBsYXN0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBjdXJyZW50XG4gICAqL1xuICBzdGF0aWMgZGlmZihsYXN0LCBjdXJyZW50KSB7XG4gICAgbGFzdCA9IG1ha2VEaWN0KCgnJyArIGxhc3QpLnRyaW0oKSk7XG4gICAgY3VycmVudCA9IG1ha2VEaWN0KCgnJyArIGN1cnJlbnQpLnRyaW0oKSk7XG5cbiAgICBjb25zdCByZW1vdmVkID0gT2JqZWN0LmtleXMobGFzdCkucmVkdWNlKChyZXN1bHQsIHRva2VuKSA9PiB7XG4gICAgICBpZiAoIWN1cnJlbnRbdG9rZW5dKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKHRva2VuKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSwgW10pO1xuXG4gICAgY29uc3QgYWRkZWQgPSBPYmplY3Qua2V5cyhjdXJyZW50KS5yZWR1Y2UoKHJlc3VsdCwgdG9rZW4pID0+IHtcbiAgICAgIGlmICghbGFzdFt0b2tlbl0pIHtcbiAgICAgICAgcmVzdWx0LnB1c2godG9rZW4pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LCBbXSk7XG5cbiAgICByZXR1cm4ge2FkZGVkLCByZW1vdmVkfTtcblxuICAgIGZ1bmN0aW9uIG1ha2VEaWN0KG1vZGlmaWVyKSB7XG4gICAgICBjb25zdCBkaWN0ID0ge307XG4gICAgICBNb2RpZmllclV0aWwuc3BsaXQobW9kaWZpZXIpLmZvckVhY2godG9rZW4gPT4gZGljdFt0b2tlbl0gPSB0b2tlbik7XG4gICAgICByZXR1cm4gZGljdDtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IGRpZmZcbiAgICogQHBhcmFtIHtBcnJheX0gZGlmZi5yZW1vdmVkXG4gICAqIEBwYXJhbSB7QXJyYXl9IGRpZmYuYWRkZWRcbiAgICogQHBhcmFtIHtPYmplY3R9IGNsYXNzTGlzdFxuICAgKiBAcGFyYW0ge1N0cmluZ30gdGVtcGxhdGVcbiAgICovXG4gIHN0YXRpYyBhcHBseURpZmZUb0NsYXNzTGlzdChkaWZmLCBjbGFzc0xpc3QsIHRlbXBsYXRlKSB7XG4gICAgZGlmZi5hZGRlZFxuICAgICAgLm1hcChtb2RpZmllciA9PiB0ZW1wbGF0ZS5yZXBsYWNlKC9cXCovZywgbW9kaWZpZXIpKVxuICAgICAgLmZvckVhY2goa2xhc3MgPT4ga2xhc3Muc3BsaXQoL1xccysvKS5mb3JFYWNoKGsgPT4gY2xhc3NMaXN0LmFkZChrKSkpO1xuXG4gICAgZGlmZi5yZW1vdmVkXG4gICAgICAubWFwKG1vZGlmaWVyID0+IHRlbXBsYXRlLnJlcGxhY2UoL1xcKi9nLCBtb2RpZmllcikpXG4gICAgICAuZm9yRWFjaChrbGFzcyA9PiBrbGFzcy5zcGxpdCgvXFxzKy8pLmZvckVhY2goayA9PiBjbGFzc0xpc3QucmVtb3ZlKGspKSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IGRpZmZcbiAgICogQHBhcmFtIHtBcnJheX0gZGlmZi5yZW1vdmVkXG4gICAqIEBwYXJhbSB7QXJyYXl9IGRpZmYuYWRkZWRcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICAgKiBAcGFyYW0ge09iamVjdH0gc2NoZW1lXG4gICAqL1xuICBzdGF0aWMgYXBwbHlEaWZmVG9FbGVtZW50KGRpZmYsIGVsZW1lbnQsIHNjaGVtZSkge1xuICAgIE9iamVjdC5rZXlzKHNjaGVtZSkuZm9yRWFjaChzZWxlY3RvciA9PiB7XG4gICAgICBjb25zdCB0YXJnZXRFbGVtZW50cyA9ICFzZWxlY3RvciB8fCB1dGlsLm1hdGNoKGVsZW1lbnQsIHNlbGVjdG9yKVxuICAgICAgICA/IFtlbGVtZW50XVxuICAgICAgICA6IEFycmF5LnByb3RvdHlwZS5maWx0ZXIuY2FsbChcbiAgICAgICAgICAgIGVsZW1lbnQucXVlcnlTZWxlY3RvckFsbChzZWxlY3RvciksXG4gICAgICAgICAgICB0YXJnZXRFbGVtZW50ID0+ICF1dGlsLmZpbmRQYXJlbnQodGFyZ2V0RWxlbWVudCwgZWxlbWVudC50YWdOYW1lLCBwYXJlbnQgPT4gcGFyZW50ID09PSBlbGVtZW50KVxuICAgICAgICAgICk7XG5cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGFyZ2V0RWxlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgTW9kaWZpZXJVdGlsLmFwcGx5RGlmZlRvQ2xhc3NMaXN0KGRpZmYsIHRhcmdldEVsZW1lbnRzW2ldLmNsYXNzTGlzdCwgc2NoZW1lW3NlbGVjdG9yXSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtTdHJpbmd9IGxhc3RcbiAgICogQHBhcmFtIHtTdHJpbmd9IGN1cnJlbnRcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICAgKiBAcGFyYW0ge09iamVjdH0gc2NoZW1lXG4gICAqL1xuICBzdGF0aWMgb25Nb2RpZmllckNoYW5nZWQobGFzdCwgY3VycmVudCwgZWxlbWVudCwgc2NoZW1lKSB7XG4gICAgTW9kaWZpZXJVdGlsLmFwcGx5RGlmZlRvRWxlbWVudChNb2RpZmllclV0aWwuZGlmZihsYXN0LCBjdXJyZW50KSwgZWxlbWVudCwgc2NoZW1lKTtcbiAgICBhdXRvU3R5bGUucmVzdG9yZU1vZGlmaWVyKGVsZW1lbnQpO1xuICB9XG5cbiAgc3RhdGljIHJlZnJlc2goZWxlbWVudCwgc2NoZW1lKSB7XG4gICAgTW9kaWZpZXJVdGlsLmFwcGx5RGlmZlRvRWxlbWVudChNb2RpZmllclV0aWwuZGlmZignJywgZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ21vZGlmaWVyJykgfHwgJycpLCBlbGVtZW50LCBzY2hlbWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAgICogQHBhcmFtIHtPYmplY3R9IHNjaGVtZVxuICAgKi9cbiAgc3RhdGljIGluaXRNb2RpZmllcihlbGVtZW50LCBzY2hlbWUpIHtcbiAgICBjb25zdCBtb2RpZmllciA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdtb2RpZmllcicpO1xuICAgIGlmICh0eXBlb2YgbW9kaWZpZXIgIT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgTW9kaWZpZXJVdGlsLmFwcGx5RGlmZlRvRWxlbWVudCh7XG4gICAgICByZW1vdmVkOiBbXSxcbiAgICAgIGFkZGVkOiBNb2RpZmllclV0aWwuc3BsaXQobW9kaWZpZXIpXG4gICAgfSwgZWxlbWVudCwgc2NoZW1lKTtcbiAgfVxuXG4gIHN0YXRpYyBzcGxpdChtb2RpZmllcikge1xuICAgIGlmICh0eXBlb2YgbW9kaWZpZXIgIT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgcmV0dXJuIG1vZGlmaWVyLnRyaW0oKS5zcGxpdCgvICsvKS5maWx0ZXIodG9rZW4gPT4gdG9rZW4gIT09ICcnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgbW9kaWZpZXIgdG9rZW4gdG8gYW4gZWxlbWVudC5cbiAgICovXG4gIHN0YXRpYyBhZGRNb2RpZmllcihlbGVtZW50LCBtb2RpZmllclRva2VuKSB7XG4gICAgaWYgKCFlbGVtZW50Lmhhc0F0dHJpYnV0ZSgnbW9kaWZpZXInKSkge1xuICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ21vZGlmaWVyJywgbW9kaWZpZXJUb2tlbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHRva2VucyA9IE1vZGlmaWVyVXRpbC5zcGxpdChlbGVtZW50LmdldEF0dHJpYnV0ZSgnbW9kaWZpZXInKSk7XG4gICAgICBpZiAodG9rZW5zLmluZGV4T2YobW9kaWZpZXJUb2tlbikgPT0gLTEpIHtcbiAgICAgICAgdG9rZW5zLnB1c2gobW9kaWZpZXJUb2tlbik7XG4gICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCdtb2RpZmllcicsIHRva2Vucy5qb2luKCcgJykpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgbW9kaWZpZXIgdG9rZW4gZnJvbSBhbiBlbGVtZW50LlxuICAgKi9cbiAgc3RhdGljIHJlbW92ZU1vZGlmaWVyKGVsZW1lbnQsIG1vZGlmaWVyVG9rZW4pIHtcbiAgICBpZiAoZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ21vZGlmaWVyJykpIHtcbiAgICAgIGNvbnN0IHRva2VucyA9IE1vZGlmaWVyVXRpbC5zcGxpdChlbGVtZW50LmdldEF0dHJpYnV0ZSgnbW9kaWZpZXInKSk7XG4gICAgICBjb25zdCBpbmRleCA9IHRva2Vucy5pbmRleE9mKG1vZGlmaWVyVG9rZW4pO1xuICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICB0b2tlbnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ21vZGlmaWVyJywgdG9rZW5zLmpvaW4oJyAnKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgcGxhdGZvcm0gZnJvbSAnLi4vcGxhdGZvcm0nO1xuXG5jb25zdCB1dGlsID0ge1xuICBfcmVhZHk6IGZhbHNlLFxuXG4gIF9kb21Db250ZW50TG9hZGVkOiBmYWxzZSxcblxuICBfb25ET01Db250ZW50TG9hZGVkOiAoKSA9PiB7XG4gICAgdXRpbC5fZG9tQ29udGVudExvYWRlZCA9IHRydWU7XG5cbiAgICBpZiAocGxhdGZvcm0uaXNXZWJWaWV3KCkpIHtcbiAgICAgIHdpbmRvdy5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdkZXZpY2VyZWFkeScsICgpID0+IHtcbiAgICAgICAgdXRpbC5fcmVhZHkgPSB0cnVlO1xuICAgICAgfSwgZmFsc2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICB1dGlsLl9yZWFkeSA9IHRydWU7XG4gICAgfVxuICB9LFxuXG4gIGFkZEJhY2tCdXR0b25MaXN0ZW5lcjogZnVuY3Rpb24oZm4pIHtcbiAgICBpZiAoIXRoaXMuX2RvbUNvbnRlbnRMb2FkZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVGhpcyBtZXRob2QgaXMgYXZhaWxhYmxlIGFmdGVyIERPTUNvbnRlbnRMb2FkZWQnKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fcmVhZHkpIHtcbiAgICAgIHdpbmRvdy5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdiYWNrYnV0dG9uJywgZm4sIGZhbHNlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgd2luZG93LmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2RldmljZXJlYWR5JywgZnVuY3Rpb24oKSB7XG4gICAgICAgIHdpbmRvdy5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdiYWNrYnV0dG9uJywgZm4sIGZhbHNlKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSxcblxuICByZW1vdmVCYWNrQnV0dG9uTGlzdGVuZXI6IGZ1bmN0aW9uKGZuKSB7XG4gICAgaWYgKCF0aGlzLl9kb21Db250ZW50TG9hZGVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgbWV0aG9kIGlzIGF2YWlsYWJsZSBhZnRlciBET01Db250ZW50TG9hZGVkJyk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX3JlYWR5KSB7XG4gICAgICB3aW5kb3cuZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignYmFja2J1dHRvbicsIGZuLCBmYWxzZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdpbmRvdy5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdkZXZpY2VyZWFkeScsIGZ1bmN0aW9uKCkge1xuICAgICAgICB3aW5kb3cuZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignYmFja2J1dHRvbicsIGZuLCBmYWxzZSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbn07XG53aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignRE9NQ29udGVudExvYWRlZCcsICgpID0+IHV0aWwuX29uRE9NQ29udGVudExvYWRlZCgpLCBmYWxzZSk7XG5cbmNvbnN0IEhhbmRsZXJSZXBvc2l0b3J5ID0ge1xuICBfc3RvcmU6IHt9LFxuXG4gIF9nZW5JZDogKCgpID0+IHtcbiAgICBsZXQgaSA9IDA7XG4gICAgcmV0dXJuICgpID0+IGkrKztcbiAgfSkoKSxcblxuICBzZXQ6IGZ1bmN0aW9uKGVsZW1lbnQsIGhhbmRsZXIpIHtcbiAgICBpZiAoZWxlbWVudC5kYXRhc2V0LmRldmljZUJhY2tCdXR0b25IYW5kbGVySWQpIHtcbiAgICAgIHRoaXMucmVtb3ZlKGVsZW1lbnQpO1xuICAgIH1cbiAgICBjb25zdCBpZCA9IGVsZW1lbnQuZGF0YXNldC5kZXZpY2VCYWNrQnV0dG9uSGFuZGxlcklkID0gSGFuZGxlclJlcG9zaXRvcnkuX2dlbklkKCk7XG4gICAgdGhpcy5fc3RvcmVbaWRdID0gaGFuZGxlcjtcbiAgfSxcblxuICByZW1vdmU6IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICBpZiAoZWxlbWVudC5kYXRhc2V0LmRldmljZUJhY2tCdXR0b25IYW5kbGVySWQpIHtcbiAgICAgIGRlbGV0ZSB0aGlzLl9zdG9yZVtlbGVtZW50LmRhdGFzZXQuZGV2aWNlQmFja0J1dHRvbkhhbmRsZXJJZF07XG4gICAgICBkZWxldGUgZWxlbWVudC5kYXRhc2V0LmRldmljZUJhY2tCdXR0b25IYW5kbGVySWQ7XG4gICAgfVxuICB9LFxuXG4gIGdldDogZnVuY3Rpb24oZWxlbWVudCkge1xuICAgIGlmICghZWxlbWVudC5kYXRhc2V0LmRldmljZUJhY2tCdXR0b25IYW5kbGVySWQpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgY29uc3QgaWQgPSBlbGVtZW50LmRhdGFzZXQuZGV2aWNlQmFja0J1dHRvbkhhbmRsZXJJZDtcblxuICAgIGlmICghdGhpcy5fc3RvcmVbaWRdKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fc3RvcmVbaWRdO1xuICB9LFxuXG4gIGhhczogZnVuY3Rpb24oZWxlbWVudCkge1xuICAgIGlmICghZWxlbWVudC5kYXRhc2V0KSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgY29uc3QgaWQgPSBlbGVtZW50LmRhdGFzZXQuZGV2aWNlQmFja0J1dHRvbkhhbmRsZXJJZDtcblxuICAgIHJldHVybiAhIXRoaXMuX3N0b3JlW2lkXTtcbiAgfVxufTtcblxuY2xhc3MgRGV2aWNlQmFja0J1dHRvbkRpc3BhdGNoZXIge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLl9pc0VuYWJsZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9ib3VuZENhbGxiYWNrID0gdGhpcy5fY2FsbGJhY2suYmluZCh0aGlzKTtcbiAgfVxuXG5cbiAgLyoqXG4gICAqIEVuYWJsZSB0byBoYW5kbGUgJ2JhY2tidXR0b24nIGV2ZW50cy5cbiAgICovXG4gIGVuYWJsZSgpIHtcbiAgICBpZiAoIXRoaXMuX2lzRW5hYmxlZCkge1xuICAgICAgdXRpbC5hZGRCYWNrQnV0dG9uTGlzdGVuZXIodGhpcy5fYm91bmRDYWxsYmFjayk7XG4gICAgICB0aGlzLl9pc0VuYWJsZWQgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBEaXNhYmxlIHRvIGhhbmRsZSAnYmFja2J1dHRvbicgZXZlbnRzLlxuICAgKi9cbiAgZGlzYWJsZSgpIHtcbiAgICBpZiAodGhpcy5faXNFbmFibGVkKSB7XG4gICAgICB1dGlsLnJlbW92ZUJhY2tCdXR0b25MaXN0ZW5lcih0aGlzLl9ib3VuZENhbGxiYWNrKTtcbiAgICAgIHRoaXMuX2lzRW5hYmxlZCA9IGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBGaXJlIGEgJ2JhY2tidXR0b24nIGV2ZW50IG1hbnVhbGx5LlxuICAgKi9cbiAgZmlyZURldmljZUJhY2tCdXR0b25FdmVudCgpIHtcbiAgICBjb25zdCBldmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdFdmVudCcpO1xuICAgIGV2ZW50LmluaXRFdmVudCgnYmFja2J1dHRvbicsIHRydWUsIHRydWUpO1xuICAgIGRvY3VtZW50LmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICB9XG5cbiAgX2NhbGxiYWNrKCkge1xuICAgIHRoaXMuX2Rpc3BhdGNoRGV2aWNlQmFja0J1dHRvbkV2ZW50KCk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKi9cbiAgY3JlYXRlSGFuZGxlcihlbGVtZW50LCBjYWxsYmFjaykge1xuICAgIGlmICghKGVsZW1lbnQgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignZWxlbWVudCBtdXN0IGJlIGFuIGluc3RhbmNlIG9mIEhUTUxFbGVtZW50Jyk7XG4gICAgfVxuXG4gICAgaWYgKCEoY2FsbGJhY2sgaW5zdGFuY2VvZiBGdW5jdGlvbikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignY2FsbGJhY2sgbXVzdCBiZSBhbiBpbnN0YW5jZSBvZiBGdW5jdGlvbicpO1xuICAgIH1cblxuICAgIGNvbnN0IGhhbmRsZXIgPSB7XG4gICAgICBfY2FsbGJhY2s6IGNhbGxiYWNrLFxuICAgICAgX2VsZW1lbnQ6IGVsZW1lbnQsXG5cbiAgICAgIGRpc2FibGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICBIYW5kbGVyUmVwb3NpdG9yeS5yZW1vdmUoZWxlbWVudCk7XG4gICAgICB9LFxuXG4gICAgICBzZXRMaXN0ZW5lcjogZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5fY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICAgIH0sXG5cbiAgICAgIGVuYWJsZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIEhhbmRsZXJSZXBvc2l0b3J5LnNldChlbGVtZW50LCB0aGlzKTtcbiAgICAgIH0sXG5cbiAgICAgIGlzRW5hYmxlZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBIYW5kbGVyUmVwb3NpdG9yeS5nZXQoZWxlbWVudCkgPT09IHRoaXM7XG4gICAgICB9LFxuXG4gICAgICBkZXN0cm95OiBmdW5jdGlvbigpIHtcbiAgICAgICAgSGFuZGxlclJlcG9zaXRvcnkucmVtb3ZlKGVsZW1lbnQpO1xuICAgICAgICB0aGlzLl9jYWxsYmFjayA9IHRoaXMuX2VsZW1lbnQgPSBudWxsO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBoYW5kbGVyLmVuYWJsZSgpO1xuXG4gICAgcmV0dXJuIGhhbmRsZXI7XG4gIH1cblxuICBfZGlzcGF0Y2hEZXZpY2VCYWNrQnV0dG9uRXZlbnQoKSB7XG4gICAgY29uc3QgdHJlZSA9IHRoaXMuX2NhcHR1cmVUcmVlKCk7XG5cbiAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5fZmluZEhhbmRsZXJMZWFmRWxlbWVudCh0cmVlKTtcblxuICAgIGxldCBoYW5kbGVyID0gSGFuZGxlclJlcG9zaXRvcnkuZ2V0KGVsZW1lbnQpO1xuICAgIGhhbmRsZXIuX2NhbGxiYWNrKGNyZWF0ZUV2ZW50KGVsZW1lbnQpKTtcblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUV2ZW50KGVsZW1lbnQpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIF9lbGVtZW50OiBlbGVtZW50LFxuICAgICAgICBjYWxsUGFyZW50SGFuZGxlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgbGV0IHBhcmVudCA9IHRoaXMuX2VsZW1lbnQucGFyZW50Tm9kZTtcblxuICAgICAgICAgIHdoaWxlIChwYXJlbnQpIHtcbiAgICAgICAgICAgIGhhbmRsZXIgPSBIYW5kbGVyUmVwb3NpdG9yeS5nZXQocGFyZW50KTtcbiAgICAgICAgICAgIGlmIChoYW5kbGVyKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGVyLl9jYWxsYmFjayhjcmVhdGVFdmVudChwYXJlbnQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnROb2RlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKi9cbiAgX2NhcHR1cmVUcmVlKCkge1xuICAgIHJldHVybiBjcmVhdGVUcmVlKGRvY3VtZW50LmJvZHkpO1xuXG4gICAgZnVuY3Rpb24gY3JlYXRlVHJlZShlbGVtZW50KSB7XG4gICAgICBjb25zdCB0cmVlID0ge1xuICAgICAgICBlbGVtZW50OiBlbGVtZW50LFxuICAgICAgICBjaGlsZHJlbjogQXJyYXkucHJvdG90eXBlLmNvbmNhdC5hcHBseShbXSwgYXJyYXlPZihlbGVtZW50LmNoaWxkcmVuKS5tYXAoZnVuY3Rpb24oY2hpbGRFbGVtZW50KSB7XG5cbiAgICAgICAgICBpZiAoY2hpbGRFbGVtZW50LnN0eWxlLmRpc3BsYXkgPT09ICdub25lJyB8fCBjaGlsZEVsZW1lbnQuX2lzU2hvd24gPT09IGZhbHNlKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGNoaWxkRWxlbWVudC5jaGlsZHJlbi5sZW5ndGggPT09IDAgJiYgIUhhbmRsZXJSZXBvc2l0b3J5LmhhcyhjaGlsZEVsZW1lbnQpKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgcmVzdWx0ID0gY3JlYXRlVHJlZShjaGlsZEVsZW1lbnQpO1xuXG4gICAgICAgICAgaWYgKHJlc3VsdC5jaGlsZHJlbi5sZW5ndGggPT09IDAgJiYgIUhhbmRsZXJSZXBvc2l0b3J5LmhhcyhyZXN1bHQuZWxlbWVudCkpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gW3Jlc3VsdF07XG4gICAgICAgIH0pKVxuICAgICAgfTtcblxuICAgICAgaWYgKCFIYW5kbGVyUmVwb3NpdG9yeS5oYXModHJlZS5lbGVtZW50KSkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRyZWUuY2hpbGRyZW4ubGVuZ3RoOyBpKyspe1xuICAgICAgICAgIGNvbnN0IHN1YlRyZWUgPSB0cmVlLmNoaWxkcmVuW2ldO1xuICAgICAgICAgIGlmIChIYW5kbGVyUmVwb3NpdG9yeS5oYXMoc3ViVHJlZS5lbGVtZW50KSkge1xuICAgICAgICAgICAgcmV0dXJuIHN1YlRyZWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cmVlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFycmF5T2YodGFyZ2V0KSB7XG4gICAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGFyZ2V0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKHRhcmdldFtpXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gdHJlZVxuICAgKiBAcmV0dXJuIHtIVE1MRWxlbWVudH1cbiAgICovXG4gIF9maW5kSGFuZGxlckxlYWZFbGVtZW50KHRyZWUpIHtcbiAgICByZXR1cm4gZmluZCh0cmVlKTtcblxuICAgIGZ1bmN0aW9uIGZpbmQobm9kZSkge1xuICAgICAgaWYgKG5vZGUuY2hpbGRyZW4ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBub2RlLmVsZW1lbnQ7XG4gICAgICB9XG5cbiAgICAgIGlmIChub2RlLmNoaWxkcmVuLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICByZXR1cm4gZmluZChub2RlLmNoaWxkcmVuWzBdKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5vZGUuY2hpbGRyZW4ubWFwKGZ1bmN0aW9uKGNoaWxkTm9kZSkge1xuICAgICAgICByZXR1cm4gY2hpbGROb2RlLmVsZW1lbnQ7XG4gICAgICB9KS5yZWR1Y2UoZnVuY3Rpb24obGVmdCwgcmlnaHQpIHtcbiAgICAgICAgaWYgKCFsZWZ0KSB7XG4gICAgICAgICAgcmV0dXJuIHJpZ2h0O1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgbGVmdFogPSBwYXJzZUludCh3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShsZWZ0LCAnJykuekluZGV4LCAxMCk7XG4gICAgICAgIGNvbnN0IHJpZ2h0WiA9IHBhcnNlSW50KHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHJpZ2h0LCAnJykuekluZGV4LCAxMCk7XG5cbiAgICAgICAgaWYgKCFpc05hTihsZWZ0WikgJiYgIWlzTmFOKHJpZ2h0WikpIHtcbiAgICAgICAgICByZXR1cm4gbGVmdFogPiByaWdodFogPyBsZWZ0IDogcmlnaHQ7XG4gICAgICAgIH1cblxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhcHR1cmluZyBiYWNrYnV0dG9uLWhhbmRsZXIgaXMgZmFpbHVyZS4nKTtcbiAgICAgIH0sIG51bGwpO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBuZXcgRGV2aWNlQmFja0J1dHRvbkRpc3BhdGNoZXIoKTtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5pbXBvcnQgaW50ZXJuYWwgZnJvbSAnLi9pbnRlcm5hbCc7XG5pbXBvcnQgQW5pbWF0b3JGYWN0b3J5IGZyb20gJy4vYW5pbWF0b3ItZmFjdG9yeSc7XG5pbXBvcnQgTW9kaWZpZXJVdGlsIGZyb20gJy4vbW9kaWZpZXItdXRpbCc7XG5pbXBvcnQgZGV2aWNlQmFja0J1dHRvbkRpc3BhdGNoZXIgZnJvbSAnLi9kZXZpY2UtYmFjay1idXR0b24tZGlzcGF0Y2hlcic7XG5cbmludGVybmFsLkFuaW1hdG9yRmFjdG9yeSA9IEFuaW1hdG9yRmFjdG9yeTtcbmludGVybmFsLk1vZGlmaWVyVXRpbCA9IE1vZGlmaWVyVXRpbDtcbmludGVybmFsLmRiYkRpc3BhdGNoZXIgPSBkZXZpY2VCYWNrQnV0dG9uRGlzcGF0Y2hlcjtcblxuZXhwb3J0IGRlZmF1bHQgaW50ZXJuYWw7XG5cbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbid1c2Ugc3RyaWN0JztcblxuY29uc3Qgc3RhcnRzV2l0aCA9IChzLCBjKSA9PiBzLnN1YnN0cigwLCBjLmxlbmd0aCkgPT09IGM7XG5jb25zdCBlbmRzV2l0aCA9IChzLCBjKSA9PiBzLnN1YnN0cihzLmxlbmd0aCAtIGMubGVuZ3RoLCBjLmxlbmd0aCkgPT09IGM7XG5jb25zdCB1bndyYXAgPSBzID0+IHMuc2xpY2UoMSwgLTEpO1xuY29uc3QgaXNPYmplY3RTdHJpbmcgPSBzID0+IHN0YXJ0c1dpdGgocywgJ3snKSAmJiBlbmRzV2l0aChzLCAnfScpO1xuY29uc3QgaXNBcnJheVN0cmluZyA9IHMgPT4gc3RhcnRzV2l0aChzLCAnWycpICYmIGVuZHNXaXRoKHMsICddJyk7XG5jb25zdCBpc1F1b3RlZFN0cmluZyA9IHMgPT4gKHN0YXJ0c1dpdGgocywgJ1xcJycpICYmIGVuZHNXaXRoKHMsICdcXCcnKSkgfHwgKHN0YXJ0c1dpdGgocywgJ1wiJykgJiYgZW5kc1dpdGgocywgJ1wiJykpO1xuXG5jb25zdCBlcnJvciA9ICh0b2tlbiwgc3RyaW5nLCBvcmlnaW5hbFN0cmluZykgPT4ge1xuICB0aHJvdyBuZXcgRXJyb3IoJ1VuZXhwZWN0ZWQgdG9rZW4gXFwnJyArIHRva2VuICsgJ1xcJyBhdCBwb3NpdGlvbiAnICsgKG9yaWdpbmFsU3RyaW5nLmxlbmd0aCAtIHN0cmluZy5sZW5ndGggLSAxKSArICcgaW4gc3RyaW5nOiBcXCcnICsgb3JpZ2luYWxTdHJpbmcgKyAnXFwnJyk7XG59O1xuXG5jb25zdCBwcm9jZXNzVG9rZW4gPSAodG9rZW4sIHN0cmluZywgb3JpZ2luYWxTdHJpbmcpID0+IHtcbiAgaWYgKHRva2VuID09PSAndHJ1ZScgfHwgdG9rZW4gPT09ICdmYWxzZScpIHtcbiAgICByZXR1cm4gdG9rZW4gPT09ICd0cnVlJztcbiAgfSBlbHNlIGlmIChpc1F1b3RlZFN0cmluZyh0b2tlbikpIHtcbiAgICByZXR1cm4gdW53cmFwKHRva2VuKTtcbiAgfSBlbHNlIGlmICghaXNOYU4odG9rZW4pKSB7XG4gICAgcmV0dXJuICsodG9rZW4pO1xuICB9IGVsc2UgaWYgKGlzT2JqZWN0U3RyaW5nKHRva2VuKSkge1xuICAgIHJldHVybiBwYXJzZU9iamVjdCh1bndyYXAodG9rZW4pKTtcbiAgfSBlbHNlIGlmIChpc0FycmF5U3RyaW5nKHRva2VuKSkge1xuICAgIHJldHVybiBwYXJzZUFycmF5KHVud3JhcCh0b2tlbikpO1xuICB9IGVsc2Uge1xuICAgIGVycm9yKHRva2VuLCBzdHJpbmcsIG9yaWdpbmFsU3RyaW5nKTtcbiAgfVxufTtcblxuY29uc3QgbmV4dFRva2VuID0gKHN0cmluZykgPT4ge1xuICBzdHJpbmcgPSBzdHJpbmcudHJpbSgpO1xuICBsZXQgbGltaXQgPSBzdHJpbmcubGVuZ3RoO1xuXG4gIGlmIChzdHJpbmdbMF0gPT09ICc6JyB8fCBzdHJpbmdbMF0gPT09ICcsJykge1xuXG4gICAgbGltaXQgPSAxO1xuXG4gIH0gZWxzZSBpZiAoc3RyaW5nWzBdID09PSAneycgfHwgc3RyaW5nWzBdID09PSAnWycpIHtcblxuICAgIGNvbnN0IGMgPSBzdHJpbmcuY2hhckNvZGVBdCgwKTtcbiAgICBsZXQgbmVzdGVkT2JqZWN0ID0gMTtcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IHN0cmluZy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHN0cmluZy5jaGFyQ29kZUF0KGkpID09PSBjKSB7XG4gICAgICAgIG5lc3RlZE9iamVjdCsrO1xuICAgICAgfSBlbHNlIGlmIChzdHJpbmcuY2hhckNvZGVBdChpKSA9PT0gYyArIDIpIHtcbiAgICAgICAgbmVzdGVkT2JqZWN0LS07XG4gICAgICAgIGlmIChuZXN0ZWRPYmplY3QgPT09IDApIHtcbiAgICAgICAgICBsaW1pdCA9IGkgKyAxO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gIH0gZWxzZSBpZiAoc3RyaW5nWzBdID09PSAnXFwnJyB8fCBzdHJpbmdbMF0gPT09ICdcIicpIHtcblxuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgc3RyaW5nLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoc3RyaW5nW2ldID09PSBzdHJpbmdbMF0pIHtcbiAgICAgICAgbGltaXQgPSBpICsgMTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gIH0gZWxzZSB7XG5cbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IHN0cmluZy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKFsnICcsICcsJywgJzonXS5pbmRleE9mKHN0cmluZ1tpXSkgIT09IC0xKSB7XG4gICAgICAgIGxpbWl0ID0gaTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gIH1cblxuICByZXR1cm4gc3RyaW5nLnNsaWNlKDAsIGxpbWl0KTtcbn07XG5cbmNvbnN0IHBhcnNlT2JqZWN0ID0gKHN0cmluZykgPT4ge1xuICBjb25zdCBpc1ZhbGlkS2V5ID0ga2V5ID0+IC9eW0EtWl8kXVtBLVowLTlfJF0qJC9pLnRlc3Qoa2V5KTtcblxuICBzdHJpbmcgPSBzdHJpbmcudHJpbSgpO1xuICBjb25zdCBvcmlnaW5hbFN0cmluZyA9IHN0cmluZztcbiAgY29uc3Qgb2JqZWN0ID0ge307XG4gIGxldCByZWFkaW5nS2V5ID0gdHJ1ZSwga2V5LCBwcmV2aW91c1Rva2VuLCB0b2tlbjtcblxuICB3aGlsZSAoc3RyaW5nLmxlbmd0aCA+IDApIHtcbiAgICBwcmV2aW91c1Rva2VuID0gdG9rZW47XG4gICAgdG9rZW4gPSBuZXh0VG9rZW4oc3RyaW5nKTtcbiAgICBzdHJpbmcgPSBzdHJpbmcuc2xpY2UodG9rZW4ubGVuZ3RoLCBzdHJpbmcubGVuZ3RoKS50cmltKCk7XG5cbiAgICBpZiAoKHRva2VuID09PSAnOicgJiYgKCFyZWFkaW5nS2V5IHx8ICFwcmV2aW91c1Rva2VuIHx8IHByZXZpb3VzVG9rZW4gPT09ICcsJykpXG4gICAgICAgfHwgKHRva2VuID09PSAnLCcgJiYgcmVhZGluZ0tleSlcbiAgICAgICB8fCAodG9rZW4gIT09ICc6JyAmJiB0b2tlbiAhPT0gJywnICYmIChwcmV2aW91c1Rva2VuICYmIHByZXZpb3VzVG9rZW4gIT09ICcsJyAmJiBwcmV2aW91c1Rva2VuICE9PSAnOicpKSkge1xuICAgICAgZXJyb3IodG9rZW4sIHN0cmluZywgb3JpZ2luYWxTdHJpbmcpO1xuICAgIH0gZWxzZSBpZiAodG9rZW4gPT09ICc6JyAmJiByZWFkaW5nS2V5ICYmIHByZXZpb3VzVG9rZW4pIHtcbiAgICAgIHByZXZpb3VzVG9rZW4gPSBpc1F1b3RlZFN0cmluZyhwcmV2aW91c1Rva2VuKSA/IHVud3JhcChwcmV2aW91c1Rva2VuKSA6IHByZXZpb3VzVG9rZW47XG4gICAgICBpZiAoaXNWYWxpZEtleShwcmV2aW91c1Rva2VuKSkge1xuICAgICAgICBrZXkgPSBwcmV2aW91c1Rva2VuO1xuICAgICAgICByZWFkaW5nS2V5ID0gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQga2V5IHRva2VuIFxcJycgKyBwcmV2aW91c1Rva2VuICsgJ1xcJyBhdCBwb3NpdGlvbiAwIGluIHN0cmluZzogXFwnJyArIG9yaWdpbmFsU3RyaW5nICsgJ1xcJycpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodG9rZW4gPT09ICcsJyAmJiAhcmVhZGluZ0tleSAmJiBwcmV2aW91c1Rva2VuKSB7XG4gICAgICBvYmplY3Rba2V5XSA9IHByb2Nlc3NUb2tlbihwcmV2aW91c1Rva2VuLCBzdHJpbmcsIG9yaWdpbmFsU3RyaW5nKTtcbiAgICAgIHJlYWRpbmdLZXkgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0b2tlbikge1xuICAgIG9iamVjdFtrZXldID0gcHJvY2Vzc1Rva2VuKHRva2VuLCBzdHJpbmcsIG9yaWdpbmFsU3RyaW5nKTtcbiAgfVxuXG4gIHJldHVybiBvYmplY3Q7XG59O1xuXG5jb25zdCBwYXJzZUFycmF5ID0gKHN0cmluZykgPT4ge1xuICBzdHJpbmcgPSBzdHJpbmcudHJpbSgpO1xuICBjb25zdCBvcmlnaW5hbFN0cmluZyA9IHN0cmluZztcbiAgY29uc3QgYXJyYXkgPSBbXTtcbiAgbGV0IHByZXZpb3VzVG9rZW4sIHRva2VuO1xuXG4gIHdoaWxlIChzdHJpbmcubGVuZ3RoID4gMCkge1xuICAgIHByZXZpb3VzVG9rZW4gPSB0b2tlbjtcbiAgICB0b2tlbiA9IG5leHRUb2tlbihzdHJpbmcpO1xuICAgIHN0cmluZyA9IHN0cmluZy5zbGljZSh0b2tlbi5sZW5ndGgsIHN0cmluZy5sZW5ndGgpLnRyaW0oKTtcblxuICAgIGlmICh0b2tlbiA9PT0gJywnICYmICghcHJldmlvdXNUb2tlbiB8fCBwcmV2aW91c1Rva2VuID09PSAnLCcpKSB7XG4gICAgICBlcnJvcih0b2tlbiwgc3RyaW5nLCBvcmlnaW5hbFN0cmluZyk7XG4gICAgfSBlbHNlIGlmICh0b2tlbiA9PT0gJywnKSB7XG4gICAgICBhcnJheS5wdXNoKHByb2Nlc3NUb2tlbihwcmV2aW91c1Rva2VuLCBzdHJpbmcsIG9yaWdpbmFsU3RyaW5nKSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHRva2VuKSB7XG4gICAgaWYgKHRva2VuICE9PSAnLCcpIHtcbiAgICAgIGFycmF5LnB1c2gocHJvY2Vzc1Rva2VuKHRva2VuLCBzdHJpbmcsIG9yaWdpbmFsU3RyaW5nKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVycm9yKHRva2VuLCBzdHJpbmcsIG9yaWdpbmFsU3RyaW5nKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYXJyYXk7XG59O1xuXG5jb25zdCBwYXJzZSA9IChzdHJpbmcpID0+IHtcbiAgc3RyaW5nID0gc3RyaW5nLnRyaW0oKTtcblxuICBpZiAoaXNPYmplY3RTdHJpbmcoc3RyaW5nKSkge1xuICAgIHJldHVybiBwYXJzZU9iamVjdCh1bndyYXAoc3RyaW5nKSk7XG4gIH0gZWxzZSBpZiAoaXNBcnJheVN0cmluZyhzdHJpbmcpKSB7XG4gICAgcmV0dXJuIHBhcnNlQXJyYXkodW53cmFwKHN0cmluZykpO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcignUHJvdmlkZWQgc3RyaW5nIG11c3QgYmUgb2JqZWN0IG9yIGFycmF5IGxpa2U6ICcgKyBzdHJpbmcpO1xuICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCBwYXJzZTtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCBvbnNFbGVtZW50cyBmcm9tICcuL2VsZW1lbnRzJztcbmltcG9ydCBzdHlsZXIgZnJvbSAnLi9zdHlsZXInO1xuaW1wb3J0IGludGVybmFsIGZyb20gJy4vaW50ZXJuYWwnO1xuaW1wb3J0IGF1dG9TdHlsZSBmcm9tICcuL2F1dG9zdHlsZSc7XG5pbXBvcnQgTW9kaWZpZXJVdGlsIGZyb20gJy4vaW50ZXJuYWwvbW9kaWZpZXItdXRpbCc7XG5pbXBvcnQgYW5pbWF0aW9uT3B0aW9uc1BhcnNlIGZyb20gJy4vYW5pbWF0aW9uLW9wdGlvbnMtcGFyc2VyJztcbmltcG9ydCBwbGF0Zm9ybSBmcm9tICcuL3BsYXRmb3JtJztcblxuY29uc3QgdXRpbCA9IHt9O1xuY29uc3QgZXJyb3JQcmVmaXggPSAnW09uc2VuIFVJXSc7XG5cbnV0aWwuZ2xvYmFscyA9IHtcbiAgZmFiT2Zmc2V0OiAwLFxuICBlcnJvclByZWZpeCxcbiAgc3VwcG9ydHNQYXNzaXZlOiBmYWxzZVxufTtcblxucGxhdGZvcm0uX3J1bk9uQWN0dWFsUGxhdGZvcm0oKCkgPT4ge1xuICB1dGlsLmdsb2JhbHMuYWN0dWFsTW9iaWxlT1MgPSBwbGF0Zm9ybS5nZXRNb2JpbGVPUygpO1xuICB1dGlsLmdsb2JhbHMuaXNVSVdlYlZpZXcgPSBwbGF0Zm9ybS5pc1VJV2ViVmlldygpO1xuICB1dGlsLmdsb2JhbHMuaXNXS1dlYlZpZXcgPSBwbGF0Zm9ybS5pc1dLV2ViVmlldygpO1xufSk7XG5cbnRyeSB7XG4gIGNvbnN0IG9wdHMgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sICdwYXNzaXZlJywge1xuICAgIGdldCgpIHsgdXRpbC5nbG9iYWxzLnN1cHBvcnRzUGFzc2l2ZSA9IHRydWU7IH1cbiAgfSk7XG4gIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd0ZXN0UGFzc2l2ZScsIG51bGwsIG9wdHMpO1xuICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigndGVzdFBhc3NpdmUnLCBudWxsLCBvcHRzKTtcbn0gY2F0Y2ggKGUpIHsgbnVsbDsgfVxuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWwgVGFyZ2V0XG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBFdmVudCBuYW1lXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyIEV2ZW50IGhhbmRsZXJcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0XSBFdmVudCBvcHRpb25zIChwYXNzaXZlLCBjYXB0dXJlLi4uKVxuICogQHBhcmFtIHtCb29sZWFufSBbaXNHRF0gSWYgY29tZXMgZnJvbSBHZXN0dXJlRGV0ZWN0b3IuIEp1c3QgZm9yIHRlc3RpbmcuXG4gKi9cbnV0aWwuYWRkRXZlbnRMaXN0ZW5lciA9IChlbCwgbmFtZSwgaGFuZGxlciwgb3B0LCBpc0dEKSA9PiB7XG4gIGVsLmFkZEV2ZW50TGlzdGVuZXIobmFtZSwgaGFuZGxlciwgdXRpbC5nbG9iYWxzLnN1cHBvcnRzUGFzc2l2ZSA/IG9wdCA6IChvcHQgfHwge30pLmNhcHR1cmUpO1xufTtcbnV0aWwucmVtb3ZlRXZlbnRMaXN0ZW5lciA9IChlbCwgbmFtZSwgaGFuZGxlciwgb3B0LCBpc0dEKSA9PiB7XG4gIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIobmFtZSwgaGFuZGxlciwgdXRpbC5nbG9iYWxzLnN1cHBvcnRzUGFzc2l2ZSA/IG9wdCA6IChvcHQgfHwge30pLmNhcHR1cmUpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge1N0cmluZy9GdW5jdGlvbn0gcXVlcnkgZG90IGNsYXNzIG5hbWUgb3Igbm9kZSBuYW1lIG9yIG1hdGNoZXIgZnVuY3Rpb24uXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqL1xudXRpbC5wcmVwYXJlUXVlcnkgPSAocXVlcnkpID0+IHtcbiAgcmV0dXJuIHF1ZXJ5IGluc3RhbmNlb2YgRnVuY3Rpb24gPyBxdWVyeSA6IChlbGVtZW50KSA9PiB1dGlsLm1hdGNoKGVsZW1lbnQsIHF1ZXJ5KTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50fSBlXG4gKiBAcGFyYW0ge1N0cmluZy9GdW5jdGlvbn0gcyBDU1MgU2VsZWN0b3IuXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG51dGlsLm1hdGNoID0gKGUsIHMpID0+IChlLm1hdGNoZXMgfHwgZS53ZWJraXRNYXRjaGVzU2VsZWN0b3IgfHwgZS5tb3pNYXRjaGVzU2VsZWN0b3IgfHwgZS5tc01hdGNoZXNTZWxlY3RvcikuY2FsbChlLCBzKTtcblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnRcbiAqIEBwYXJhbSB7U3RyaW5nL0Z1bmN0aW9ufSBxdWVyeSBkb3QgY2xhc3MgbmFtZSBvciBub2RlIG5hbWUgb3IgbWF0Y2hlciBmdW5jdGlvbi5cbiAqIEByZXR1cm4ge0hUTUxFbGVtZW50L251bGx9XG4gKi9cbnV0aWwuZmluZENoaWxkID0gKGVsZW1lbnQsIHF1ZXJ5KSA9PiB7XG4gIGNvbnN0IG1hdGNoID0gdXRpbC5wcmVwYXJlUXVlcnkocXVlcnkpO1xuXG4gIC8vIENhdXRpb246IGBlbGVtZW50LmNoaWxkcmVuYCBpcyBgdW5kZWZpbmVkYCBpbiBzb21lIGVudmlyb25tZW50cyBpZiBgZWxlbWVudGAgaXMgYHN2Z2BcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBlbGVtZW50LmNoaWxkTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBub2RlID0gZWxlbWVudC5jaGlsZE5vZGVzW2ldO1xuICAgIGlmIChub2RlLm5vZGVUeXBlICE9PSBOb2RlLkVMRU1FTlRfTk9ERSkgeyAvLyBwcm9jZXNzIG9ubHkgZWxlbWVudCBub2Rlc1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChtYXRjaChub2RlKSkge1xuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnRcbiAqIEBwYXJhbSB7U3RyaW5nL0Z1bmN0aW9ufSBxdWVyeSBkb3QgY2xhc3MgbmFtZSBvciBub2RlIG5hbWUgb3IgbWF0Y2hlciBmdW5jdGlvbi5cbiAqIEByZXR1cm4ge0hUTUxFbGVtZW50L251bGx9XG4gKi9cbnV0aWwuZmluZFBhcmVudCA9IChlbGVtZW50LCBxdWVyeSwgdW50aWwpID0+IHtcbiAgY29uc3QgbWF0Y2ggPSB1dGlsLnByZXBhcmVRdWVyeShxdWVyeSk7XG5cbiAgbGV0IHBhcmVudCA9IGVsZW1lbnQucGFyZW50Tm9kZTtcbiAgZm9yICg7Oykge1xuICAgIGlmICghcGFyZW50IHx8IHBhcmVudCA9PT0gZG9jdW1lbnQgfHwgcGFyZW50IGluc3RhbmNlb2YgRG9jdW1lbnRGcmFnbWVudCB8fCAodW50aWwgJiYgdW50aWwocGFyZW50KSkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0gZWxzZSBpZiAobWF0Y2gocGFyZW50KSkge1xuICAgICAgcmV0dXJuIHBhcmVudDtcbiAgICB9XG4gICAgcGFyZW50ID0gcGFyZW50LnBhcmVudE5vZGU7XG4gIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG51dGlsLmlzQXR0YWNoZWQgPSBlbGVtZW50ID0+IGRvY3VtZW50LmJvZHkuY29udGFpbnMoZWxlbWVudCk7XG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG51dGlsLmhhc0FueUNvbXBvbmVudEFzUGFyZW50ID0gKGVsZW1lbnQpID0+IHtcbiAgd2hpbGUgKGVsZW1lbnQgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50ICE9PSBlbGVtZW50KSB7XG4gICAgZWxlbWVudCA9IGVsZW1lbnQucGFyZW50Tm9kZTtcbiAgICBpZiAoZWxlbWVudCAmJiBlbGVtZW50Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkubWF0Y2goLyhvbnMtbmF2aWdhdG9yfG9ucy10YWJiYXJ8b25zLW1vZGFsKS8pKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge09iamVjdH0gZWxlbWVudFxuICogQHJldHVybiB7QXJyYXl9XG4gKi9cbnV0aWwuZ2V0QWxsQ2hpbGROb2RlcyA9IChlbGVtZW50KSA9PiB7XG4gIHJldHVybiBbZWxlbWVudF0uY29uY2F0KFxuICAgIC4uLkFycmF5LmZyb20oZWxlbWVudC5jaGlsZHJlbikubWFwKGNoaWxkRWwgPT4ge1xuICAgICAgcmV0dXJuIHV0aWwuZ2V0QWxsQ2hpbGROb2RlcyhjaGlsZEVsKTtcbiAgICB9KVxuICApO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xudXRpbC5pc1BhZ2VDb250cm9sID0gZWxlbWVudCA9PiBlbGVtZW50Lm5vZGVOYW1lLm1hdGNoKC9eb25zLShuYXZpZ2F0b3J8c3BsaXR0ZXJ8dGFiYmFyfHBhZ2UpJC9pKTtcblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnRcbiAqIEBwYXJhbSB7U3RyaW5nfSBhY3Rpb24gdG8gcHJvcGFnYXRlXG4gKi9cbnV0aWwucHJvcGFnYXRlQWN0aW9uID0gKGVsZW1lbnQsIGFjdGlvbikgPT4ge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGVsZW1lbnQuY2hpbGROb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGNoaWxkID0gZWxlbWVudC5jaGlsZE5vZGVzW2ldO1xuICAgIGlmIChjaGlsZFthY3Rpb25dIGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcbiAgICAgIGNoaWxkW2FjdGlvbl0oKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdXRpbC5wcm9wYWdhdGVBY3Rpb24oY2hpbGQsIGFjdGlvbik7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJpbmcgLSBzdHJpbmcgdG8gYmUgY2FtZWxpemVkXG4gKiBAcmV0dXJuIHtTdHJpbmd9IENhbWVsaXplZCBzdHJpbmdcbiAqL1xudXRpbC5jYW1lbGl6ZSA9IHN0cmluZyA9PiBzdHJpbmcudG9Mb3dlckNhc2UoKS5yZXBsYWNlKC8tKFthLXpdKS9nLCAobSwgbCkgPT4gbC50b1VwcGVyQ2FzZSgpKTtcblxuLyoqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyaW5nIC0gc3RyaW5nIHRvIGJlIGh5cGhlbmF0ZWRcbiAqIEByZXR1cm4ge1N0cmluZ30gSHlwaGVuYXRlZCBzdHJpbmdcbiAqL1xudXRpbC5oeXBoZW5hdGUgPSBzdHJpbmcgPT4gc3RyaW5nLnJlcGxhY2UoLyhbYS16QS1aXSkoW0EtWl0pL2csICckMS0kMicpLnRvTG93ZXJDYXNlKCk7XG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IHNlbGVjdG9yIC0gdGFnIGFuZCBjbGFzcyBvbmx5XG4gKiBAcGFyYW0ge09iamVjdH0gc3R5bGVcbiAqIEBwYXJhbSB7RWxlbWVudH1cbiAqL1xudXRpbC5jcmVhdGUgPSAoc2VsZWN0b3IgPSAnJywgc3R5bGUgPSB7fSkgPT4ge1xuICBjb25zdCBjbGFzc0xpc3QgPSBzZWxlY3Rvci5zcGxpdCgnLicpO1xuICBjb25zdCBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChjbGFzc0xpc3Quc2hpZnQoKSB8fCAnZGl2Jyk7XG5cbiAgaWYgKGNsYXNzTGlzdC5sZW5ndGgpIHtcbiAgICBlbGVtZW50LmNsYXNzTmFtZSA9IGNsYXNzTGlzdC5qb2luKCcgJyk7XG4gIH1cblxuICBzdHlsZXIoZWxlbWVudCwgc3R5bGUpO1xuXG4gIHJldHVybiBlbGVtZW50O1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge1N0cmluZ30gaHRtbFxuICogQHJldHVybiB7RWxlbWVudH1cbiAqL1xudXRpbC5jcmVhdGVFbGVtZW50ID0gKGh0bWwpID0+IHtcbiAgY29uc3Qgd3JhcHBlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXG4gIGlmIChodG1sIGluc3RhbmNlb2YgRG9jdW1lbnRGcmFnbWVudCkge1xuICAgIHdyYXBwZXIuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuaW1wb3J0Tm9kZShodG1sLCB0cnVlKSk7XG4gIH0gZWxzZSB7XG4gICAgd3JhcHBlci5pbm5lckhUTUwgPSBodG1sLnRyaW0oKTtcbiAgfVxuXG4gIGlmICh3cmFwcGVyLmNoaWxkcmVuLmxlbmd0aCA+IDEpIHtcbiAgICB1dGlsLnRocm93KCdIVE1MIHRlbXBsYXRlIG11c3QgY29udGFpbiBhIHNpbmdsZSByb290IGVsZW1lbnQnKVxuICB9XG5cbiAgY29uc3QgZWxlbWVudCA9IHdyYXBwZXIuY2hpbGRyZW5bMF07XG4gIHdyYXBwZXIuY2hpbGRyZW5bMF0ucmVtb3ZlKCk7XG4gIHJldHVybiBlbGVtZW50O1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge1N0cmluZ30gaHRtbFxuICogQHJldHVybiB7SFRNTEZyYWdtZW50fVxuICovXG51dGlsLmNyZWF0ZUZyYWdtZW50ID0gKGh0bWwpID0+IHtcbiAgY29uc3QgdGVtcGxhdGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZW1wbGF0ZScpO1xuICB0ZW1wbGF0ZS5pbm5lckhUTUwgPSBodG1sO1xuICByZXR1cm4gZG9jdW1lbnQuaW1wb3J0Tm9kZSh0ZW1wbGF0ZS5jb250ZW50LCB0cnVlKTtcbn07XG5cbi8qXG4gKiBAcGFyYW0ge09iamVjdH0gZHN0IERlc3RpbmF0aW9uIG9iamVjdC5cbiAqIEBwYXJhbSB7Li4uT2JqZWN0fSBzcmMgU291cmNlIG9iamVjdChzKS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJlZmVyZW5jZSB0byBgZHN0YC5cbiAqL1xudXRpbC5leHRlbmQgPSAoZHN0LCAuLi5hcmdzKSA9PiB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgIGlmIChhcmdzW2ldKSB7XG4gICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoYXJnc1tpXSk7XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGtleXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgY29uc3Qga2V5ID0ga2V5c1tqXTtcbiAgICAgICAgZHN0W2tleV0gPSBhcmdzW2ldW2tleV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGRzdDtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtPYmplY3R9IGFycmF5TGlrZVxuICogQHJldHVybiB7QXJyYXl9XG4gKi9cbnV0aWwuYXJyYXlGcm9tID0gKGFycmF5TGlrZSkgPT4ge1xuICByZXR1cm4gQXJyYXkucHJvdG90eXBlLnNsaWNlLmFwcGx5KGFycmF5TGlrZSk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nfSBqc29uU3RyaW5nXG4gKiBAcGFyYW0ge09iamVjdH0gW2ZhaWxTYWZlXVxuICogQHJldHVybiB7T2JqZWN0fVxuICovXG51dGlsLnBhcnNlSlNPTk9iamVjdFNhZmVseSA9IChqc29uU3RyaW5nLCBmYWlsU2FmZSA9IHt9KSA9PiB7XG4gIHRyeSB7XG4gICAgY29uc3QgcmVzdWx0ID0gSlNPTi5wYXJzZSgnJyArIGpzb25TdHJpbmcpO1xuICAgIGlmICh0eXBlb2YgcmVzdWx0ID09PSAnb2JqZWN0JyAmJiByZXN1bHQgIT09IG51bGwpIHtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhaWxTYWZlO1xuICB9XG4gIHJldHVybiBmYWlsU2FmZTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IHBhdGggLSBwYXRoIHN1Y2ggYXMgJ215QXBwLmNvbnRyb2xsZXJzLmRhdGEubG9hZERhdGEnXG4gKiBAcmV0dXJuIHtBbnl9IC0gd2hhdGV2ZXIgaXMgbG9jYXRlZCBhdCB0aGF0IHBhdGhcbiAqL1xudXRpbC5maW5kRnJvbVBhdGggPSAocGF0aCkgPT4ge1xuICBwYXRoID0gcGF0aC5zcGxpdCgnLicpO1xuICB2YXIgZWwgPSB3aW5kb3csIGtleTtcbiAgd2hpbGUgKGtleSA9IHBhdGguc2hpZnQoKSkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbmQtYXNzaWduXG4gICAgZWwgPSBlbFtrZXldO1xuICB9XG4gIHJldHVybiBlbDtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gY29udGFpbmVyIC0gUGFnZSBvciBwYWdlLWNvbnRhaW5lciB0aGF0IGltcGxlbWVudHMgJ3RvcFBhZ2UnXG4gKiBAcmV0dXJuIHtIVE1MRWxlbWVudHxudWxsfSAtIFZpc2libGUgcGFnZSBlbGVtZW50IG9yIG51bGwgaWYgbm90IGZvdW5kLlxuICovXG51dGlsLmdldFRvcFBhZ2UgPSBjb250YWluZXIgPT4gY29udGFpbmVyICYmIChjb250YWluZXIudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnb25zLXBhZ2UnID8gY29udGFpbmVyIDogY29udGFpbmVyLnRvcFBhZ2UpIHx8IG51bGw7XG5cbi8qKlxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gY29udGFpbmVyIC0gRWxlbWVudCB3aGVyZSB0aGUgc2VhcmNoIGJlZ2luc1xuICogQHJldHVybiB7SFRNTEVsZW1lbnR8bnVsbH0gLSBQYWdlIGVsZW1lbnQgdGhhdCBjb250YWlucyB0aGUgdmlzaWJsZSB0b29sYmFyIG9yIG51bGwuXG4gKi9cbnV0aWwuZmluZFRvb2xiYXJQYWdlID0gY29udGFpbmVyID0+IHtcbiAgY29uc3QgcGFnZSA9IHV0aWwuZ2V0VG9wUGFnZShjb250YWluZXIpO1xuXG4gIGlmIChwYWdlKSB7XG4gICAgaWYgKHBhZ2UuX2NhbkFuaW1hdGVUb29sYmFyKCkpIHtcbiAgICAgIHJldHVybiBwYWdlO1xuICAgIH1cblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFnZS5fY29udGVudEVsZW1lbnQuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IG5leHRQYWdlID0gdXRpbC5nZXRUb3BQYWdlKHBhZ2UuX2NvbnRlbnRFbGVtZW50LmNoaWxkcmVuW2ldKTtcbiAgICAgIGlmIChuZXh0UGFnZSAmJiAhL29ucy10YWJiYXIvaS50ZXN0KHBhZ2UuX2NvbnRlbnRFbGVtZW50LmNoaWxkcmVuW2ldLnRhZ05hbWUpKSB7XG4gICAgICAgIHJldHVybiB1dGlsLmZpbmRUb29sYmFyUGFnZShuZXh0UGFnZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50TmFtZVxuICogQHBhcmFtIHtPYmplY3R9IFtkZXRhaWxdXG4gKiBAcmV0dXJuIHtDdXN0b21FdmVudH1cbiAqL1xudXRpbC50cmlnZ2VyRWxlbWVudEV2ZW50ID0gKHRhcmdldCwgZXZlbnROYW1lLCBkZXRhaWwgPSB7fSkgPT4ge1xuXG4gIGNvbnN0IGV2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KGV2ZW50TmFtZSwge1xuICAgIGJ1YmJsZXM6IHRydWUsXG4gICAgY2FuY2VsYWJsZTogdHJ1ZSxcbiAgICBkZXRhaWw6IGRldGFpbFxuICB9KTtcblxuICBPYmplY3Qua2V5cyhkZXRhaWwpLmZvckVhY2goa2V5ID0+IHtcbiAgICBldmVudFtrZXldID0gZGV0YWlsW2tleV07XG4gIH0pO1xuXG4gIHRhcmdldC5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcblxuICByZXR1cm4gZXZlbnQ7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudH0gdGFyZ2V0XG4gKiBAcGFyYW0ge1N0cmluZ30gbW9kaWZpZXJOYW1lXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG51dGlsLmhhc01vZGlmaWVyID0gKHRhcmdldCwgbW9kaWZpZXJOYW1lKSA9PiB7XG4gIGlmICghdGFyZ2V0Lmhhc0F0dHJpYnV0ZSgnbW9kaWZpZXInKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBSZWdFeHAoYChefFxcXFxzKykke21vZGlmaWVyTmFtZX0oJHxcXFxccyspYCwgJ2knKS50ZXN0KHRhcmdldC5nZXRBdHRyaWJ1dGUoJ21vZGlmaWVyJykpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IHRhcmdldFxuICogQHBhcmFtIHtTdHJpbmd9IG1vZGlmaWVyTmFtZVxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMuYXV0b1N0eWxlIE1hcHMgdGhlIG1vZGlmaWVyTmFtZSB0byB0aGUgY29ycmVzcG9uZGluZyBzdHlsZWQgbW9kaWZpZXIuXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucy5mb3JjZUF1dG9TdHlsZSBJZ25vcmVzIHBsYXRmb3JtIGxpbWl0YXRpb24uXG4gKiBAcmV0dXJuIHtCb29sZWFufSBXaGV0aGVyIGl0IHdhcyBhZGRlZCBvciBub3QuXG4gKi9cbnV0aWwuYWRkTW9kaWZpZXIgPSAodGFyZ2V0LCBtb2RpZmllck5hbWUsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICBpZiAob3B0aW9ucy5hdXRvU3R5bGUpIHtcbiAgICBtb2RpZmllck5hbWUgPSBhdXRvU3R5bGUubWFwTW9kaWZpZXIobW9kaWZpZXJOYW1lLCB0YXJnZXQsIG9wdGlvbnMuZm9yY2VBdXRvU3R5bGUpO1xuICB9XG5cbiAgaWYgKHV0aWwuaGFzTW9kaWZpZXIodGFyZ2V0LCBtb2RpZmllck5hbWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdGFyZ2V0LnNldEF0dHJpYnV0ZSgnbW9kaWZpZXInLCAoKHRhcmdldC5nZXRBdHRyaWJ1dGUoJ21vZGlmaWVyJykgfHwgJycpICsgJyAnICsgbW9kaWZpZXJOYW1lKS50cmltKCkpO1xuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50fSB0YXJnZXRcbiAqIEBwYXJhbSB7U3RyaW5nfSBtb2RpZmllck5hbWVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zLmF1dG9TdHlsZSBNYXBzIHRoZSBtb2RpZmllck5hbWUgdG8gdGhlIGNvcnJlc3BvbmRpbmcgc3R5bGVkIG1vZGlmaWVyLlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMuZm9yY2VBdXRvU3R5bGUgSWdub3JlcyBwbGF0Zm9ybSBsaW1pdGF0aW9uLlxuICogQHJldHVybiB7Qm9vbGVhbn0gV2hldGhlciBpdCB3YXMgZm91bmQgb3Igbm90LlxuICovXG51dGlsLnJlbW92ZU1vZGlmaWVyID0gKHRhcmdldCwgbW9kaWZpZXJOYW1lLCBvcHRpb25zID0ge30pID0+IHtcbiAgaWYgKG9wdGlvbnMuYXV0b1N0eWxlKSB7XG4gICAgbW9kaWZpZXJOYW1lID0gYXV0b1N0eWxlLm1hcE1vZGlmaWVyKG1vZGlmaWVyTmFtZSwgdGFyZ2V0LCBvcHRpb25zLmZvcmNlQXV0b1N0eWxlKTtcbiAgfVxuXG4gIGlmICghdGFyZ2V0LmdldEF0dHJpYnV0ZSgnbW9kaWZpZXInKSB8fCAhdXRpbC5oYXNNb2RpZmllcih0YXJnZXQsIG1vZGlmaWVyTmFtZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBjb25zdCBuZXdNb2RpZmllcnMgPSB0YXJnZXQuZ2V0QXR0cmlidXRlKCdtb2RpZmllcicpLnNwbGl0KC9cXHMrLykuZmlsdGVyKG0gPT4gbSAmJiBtICE9PSBtb2RpZmllck5hbWUpO1xuICBuZXdNb2RpZmllcnMubGVuZ3RoID8gdGFyZ2V0LnNldEF0dHJpYnV0ZSgnbW9kaWZpZXInLCBuZXdNb2RpZmllcnMuam9pbignICcpKSA6IHRhcmdldC5yZW1vdmVBdHRyaWJ1dGUoJ21vZGlmaWVyJyk7XG4gIHJldHVybiB0cnVlO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IHRhcmdldFxuICogQHBhcmFtIHtTdHJpbmd9IG1vZGlmaWVyTmFtZVxuICogQHBhcmFtIHtCb29sZWFufSBvcHRpb25zLmZvcmNlIEZvcmNlcyBtb2RpZmllciB0byBiZSBhZGRlZCBvciByZW1vdmVkLlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMuYXV0b1N0eWxlIE1hcHMgdGhlIG1vZGlmaWVyTmFtZSB0byB0aGUgY29ycmVzcG9uZGluZyBzdHlsZWQgbW9kaWZpZXIuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IG9wdGlvbnMuZm9yY2VBdXRvU3R5bGUgSWdub3JlcyBwbGF0Zm9ybSBsaW1pdGF0aW9uLlxuICogQHJldHVybiB7Qm9vbGVhbn0gV2hldGhlciBpdCB3YXMgZm91bmQgb3Igbm90LlxuICovXG51dGlsLnRvZ2dsZU1vZGlmaWVyID0gKC4uLmFyZ3MpID0+IHtcbiAgY29uc3Qgb3B0aW9ucyA9IGFyZ3MubGVuZ3RoID4gMiA/IGFyZ3NbMl0gOiB7fTtcbiAgY29uc3QgZm9yY2UgPSB0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Jvb2xlYW4nID8gb3B0aW9ucyA6IG9wdGlvbnMuZm9yY2U7XG5cbiAgY29uc3QgdG9nZ2xlID0gdHlwZW9mIGZvcmNlID09PSAnYm9vbGVhbicgPyBmb3JjZSA6ICF1dGlsLmhhc01vZGlmaWVyKC4uLmFyZ3MpO1xuICB0b2dnbGUgPyB1dGlsLmFkZE1vZGlmaWVyKC4uLmFyZ3MpIDogdXRpbC5yZW1vdmVNb2RpZmllciguLi5hcmdzKVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKiBAcGFyYW0ge1N0cmluZ30gZGVmYXVsdENsYXNzXG4gKiBAcGFyYW0ge09iamVjdH0gc2NoZW1lXG4gKi9cbnV0aWwucmVzdG9yZUNsYXNzID0gKGVsLCBkZWZhdWx0Q2xhc3MsIHNjaGVtZSkgPT4ge1xuICBkZWZhdWx0Q2xhc3Muc3BsaXQoL1xccysvKS5mb3JFYWNoKGMgPT4gYyAhPT0gJycgJiYgIWVsLmNsYXNzTGlzdC5jb250YWlucyhjKSAmJiBlbC5jbGFzc0xpc3QuYWRkKGMpKTtcbiAgZWwuaGFzQXR0cmlidXRlKCdtb2RpZmllcicpICYmIE1vZGlmaWVyVXRpbC5yZWZyZXNoKGVsLCBzY2hlbWUpO1xufVxuXG4vLyBUT0RPOiBGSVhcbnV0aWwudXBkYXRlUGFyZW50UG9zaXRpb24gPSAoZWwpID0+IHtcbiAgaWYgKCFlbC5fcGFyZW50VXBkYXRlZCAmJiBlbC5wYXJlbnRFbGVtZW50KSB7XG4gICAgaWYgKHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsLnBhcmVudEVsZW1lbnQpLmdldFByb3BlcnR5VmFsdWUoJ3Bvc2l0aW9uJykgPT09ICdzdGF0aWMnKSB7XG4gICAgICBlbC5wYXJlbnRFbGVtZW50LnN0eWxlLnBvc2l0aW9uID0gJ3JlbGF0aXZlJztcbiAgICB9XG4gICAgZWwuX3BhcmVudFVwZGF0ZWQgPSB0cnVlO1xuICB9XG59O1xuXG51dGlsLnRvZ2dsZUF0dHJpYnV0ZSA9IChlbGVtZW50LCBuYW1lLCB2YWx1ZSkgPT4ge1xuICBpZiAodmFsdWUpIHtcbiAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShuYW1lLCB0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJyA/ICcnIDogdmFsdWUpO1xuICB9IGVsc2Uge1xuICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuICB9XG59O1xuXG51dGlsLmJpbmRMaXN0ZW5lcnMgPSAoZWxlbWVudCwgbGlzdGVuZXJOYW1lcykgPT4ge1xuICBsaXN0ZW5lck5hbWVzLmZvckVhY2gobmFtZSA9PiB7XG4gICAgY29uc3QgYm91bmROYW1lID0gbmFtZS5yZXBsYWNlKC9eX1thLXpdLywgJ19ib3VuZCcgKyBuYW1lWzFdLnRvVXBwZXJDYXNlKCkpO1xuICAgIGVsZW1lbnRbYm91bmROYW1lXSA9IGVsZW1lbnRbYm91bmROYW1lXSB8fCBlbGVtZW50W25hbWVdLmJpbmQoZWxlbWVudCk7XG4gIH0pO1xufTtcblxudXRpbC5lYWNoID0gKG9iaiwgZikgPT4gT2JqZWN0LmtleXMob2JqKS5mb3JFYWNoKGtleSA9PiBmKGtleSwgb2JqW2tleV0pKTtcblxuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudH0gdGFyZ2V0XG4gKiBAcGFyYW0ge2Jvb2xlYW59IGhhc1JpcHBsZVxuICogQHBhcmFtIHtPYmplY3R9IGF0dHJzXG4gKi9cbnV0aWwudXBkYXRlUmlwcGxlID0gKHRhcmdldCwgaGFzUmlwcGxlLCBhdHRycyA9IHt9KSA9PiB7XG4gIGlmIChoYXNSaXBwbGUgPT09IHVuZGVmaW5lZCkge1xuICAgIGhhc1JpcHBsZSA9IHRhcmdldC5oYXNBdHRyaWJ1dGUoJ3JpcHBsZScpO1xuICB9XG5cbiAgY29uc3QgcmlwcGxlRWxlbWVudCA9IHV0aWwuZmluZENoaWxkKHRhcmdldCwgJ29ucy1yaXBwbGUnKTtcblxuICBpZiAoaGFzUmlwcGxlKSB7XG4gICAgaWYgKCFyaXBwbGVFbGVtZW50KSB7XG4gICAgICBjb25zdCBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnb25zLXJpcHBsZScpO1xuICAgICAgT2JqZWN0LmtleXMoYXR0cnMpLmZvckVhY2goa2V5ID0+IGVsZW1lbnQuc2V0QXR0cmlidXRlKGtleSwgYXR0cnNba2V5XSkpO1xuICAgICAgdGFyZ2V0Lmluc2VydEJlZm9yZShlbGVtZW50LCB0YXJnZXQuZmlyc3RDaGlsZCk7XG4gICAgfVxuICB9IGVsc2UgaWYgKHJpcHBsZUVsZW1lbnQpIHtcbiAgICByaXBwbGVFbGVtZW50LnJlbW92ZSgpO1xuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nfVxuICogQHJldHVybiB7T2JqZWN0fVxuICovXG51dGlsLmFuaW1hdGlvbk9wdGlvbnNQYXJzZSA9IGFuaW1hdGlvbk9wdGlvbnNQYXJzZTtcblxuLyoqXG4gKiBAcGFyYW0geyp9IHZhbHVlXG4gKi9cbnV0aWwuaXNJbnRlZ2VyID0gKHZhbHVlKSA9PiB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmXG4gICAgaXNGaW5pdGUodmFsdWUpICYmXG4gICAgTWF0aC5mbG9vcih2YWx1ZSkgPT09IHZhbHVlO1xufTtcblxuLyoqXG4gKiBAcmV0dXJuIHtPYmplY3R9IERlZmVycmVkIHByb21pc2UuXG4gKi9cbnV0aWwuZGVmZXIgPSAoKSA9PiB7XG4gIGNvbnN0IGRlZmVycmVkID0ge307XG4gIGRlZmVycmVkLnByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgZGVmZXJyZWQucmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgZGVmZXJyZWQucmVqZWN0ID0gcmVqZWN0O1xuICB9KTtcbiAgcmV0dXJuIGRlZmVycmVkO1xufTtcblxuLyoqXG4gKiBTaG93IHdhcm5pbmdzIHdoZW4gdGhleSBhcmUgZW5hYmxlZC5cbiAqXG4gKiBAcGFyYW0geyp9IGFyZ3VtZW50cyB0byBjb25zb2xlLndhcm5cbiAqL1xudXRpbC53YXJuID0gKC4uLmFyZ3MpID0+IHtcbiAgaWYgKCFpbnRlcm5hbC5jb25maWcud2FybmluZ3NEaXNhYmxlZCkge1xuICAgIGNvbnNvbGUud2FybihlcnJvclByZWZpeCwgLi4uYXJncyk7XG4gIH1cbn07XG5cbnV0aWwudGhyb3cgPSAobWVzc2FnZSkgPT4ge1xuICB0aHJvdyBuZXcgRXJyb3IoYCR7ZXJyb3JQcmVmaXh9ICR7bWVzc2FnZX1gKTtcbn07XG5cbnV0aWwudGhyb3dBYnN0cmFjdCA9ICgpID0+IHV0aWwudGhyb3coJ0Nhbm5vdCBpbnN0YW50aWF0ZSBhYnN0cmFjdCBjbGFzcycpO1xudXRpbC50aHJvd01lbWJlciA9ICgpID0+IHV0aWwudGhyb3coJ0NsYXNzIG1lbWJlciBtdXN0IGJlIGltcGxlbWVudGVkJyk7XG51dGlsLnRocm93UGFnZUxvYWRlciA9ICgpID0+IHV0aWwudGhyb3coJ0ZpcnN0IHBhcmFtZXRlciBzaG91bGQgYmUgYW4gaW5zdGFuY2Ugb2YgUGFnZUxvYWRlcicpO1xudXRpbC50aHJvd0FuaW1hdG9yID0gKGVsKSA9PiB1dGlsLnRocm93KGBcIkFuaW1hdG9yXCIgcGFyYW0gbXVzdCBpbmhlcml0ICR7ZWx9QW5pbWF0b3JgKTtcblxuXG5jb25zdCBwcmV2ZW50ID0gZSA9PiBlLmNhbmNlbGFibGUgJiYgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4vKipcbiAqIFByZXZlbnQgc2Nyb2xsaW5nIHdoaWxlIGRyYWdpbmcgaG9yaXpvbnRhbGx5IG9uIGlPUy5cbiAqXG4gKiBAcGFyYW0ge2dkfSBHZXN0dXJlRGV0ZWN0b3IgaW5zdGFuY2VcbiAqL1xudXRpbC5pb3NQcmV2ZW50U2Nyb2xsID0gZ2QgPT4ge1xuICBpZiAodXRpbC5nbG9iYWxzLmFjdHVhbE1vYmlsZU9TID09PSAnaW9zJykge1xuICAgIGNvbnN0IGNsZWFuID0gKGUpID0+IHtcbiAgICAgIGdkLm9mZigndG91Y2htb3ZlJywgcHJldmVudCk7XG4gICAgICBnZC5vZmYoJ2RyYWdlbmQnLCBjbGVhbik7XG4gICAgfTtcblxuICAgIGdkLm9uKCd0b3VjaG1vdmUnLCBwcmV2ZW50KTtcbiAgICBnZC5vbignZHJhZ2VuZCcsIGNsZWFuKTtcbiAgfVxufTtcblxuLyoqXG4gKiBQcmV2ZW50cyBzY3JvbGwgaW4gdW5kZXJseWluZyBwYWdlcyBvbiBpT1MuIFNlZSAjMjIyMCAjMjI3NCAjMTk0OVxuICpcbiAqIEBwYXJhbSB7ZWx9IEhUTUxFbGVtZW50IHRoYXQgcHJldmVudHMgdGhlIGV2ZW50c1xuICogQHBhcmFtIHthZGR9IEJvb2xlYW4gQWRkIG9yIHJlbW92ZSBldmVudCBsaXN0ZW5lcnNcbiAqL1xudXRpbC5pb3NQYWdlU2Nyb2xsRml4ID0gKGFkZCkgPT4geyAvLyBGdWxsIGZpeCAtIE1heSBjYXVzZSBpc3N1ZXMgd2l0aCBVSVdlYlZpZXcncyBtb21lbnR1bSBzY3JvbGxcbiAgaWYgKHV0aWwuZ2xvYmFscy5hY3R1YWxNb2JpbGVPUyA9PT0gJ2lvcycpIHtcbiAgICBkb2N1bWVudC5ib2R5LmNsYXNzTGlzdC50b2dnbGUoJ29ucy1pb3Mtc2Nyb2xsJywgYWRkKTsgLy8gQWxsb3dzIGN1c3RvbSBhbmQgbG9jYWxpemVkIGZpeGVzICgjMjI3NClcbiAgICBpZiAoIXV0aWwuZ2xvYmFscy5pc1VJV2ViVmlldyB8fCBpbnRlcm5hbC5jb25maWcuZm9yY2VVSVdlYlZpZXdTY3JvbGxGaXgpIHtcbiAgICAgIGRvY3VtZW50LmJvZHkuY2xhc3NMaXN0LnRvZ2dsZSgnb25zLWlvcy1zY3JvbGwtZml4JywgYWRkKTtcbiAgICB9XG4gIH1cbn07XG51dGlsLmlvc01hc2tTY3JvbGxGaXggPSAoZWwsIGFkZCkgPT4geyAvLyBIYWxmIGZpeCAtIG9ubHkgcHJldmVudHMgc2Nyb2xsIG9uIG1hc2tzXG4gIGlmICh1dGlsLmdsb2JhbHMuaXNVSVdlYlZpZXcpIHtcbiAgICBjb25zdCBhY3Rpb24gPSAoYWRkID8gJ2FkZCcgOiAncmVtb3ZlJykgKyAnRXZlbnRMaXN0ZW5lcic7XG4gICAgZWxbYWN0aW9uXSgndG91Y2htb3ZlJywgcHJldmVudCwgZmFsc2UpO1xuICB9XG59O1xuXG4vKipcbiAqIERpc3RhbmNlIGFuZCBkZWx0YVRpbWUgZmlsdGVyIHNvbWUgd2VpcmQgZHJhZ3N0YXJ0IGV2ZW50cyB0aGF0IGFyZSBub3QgZmlyZWQgaW1tZWRpYXRlbHkuXG4gKlxuICogQHBhcmFtIHtldmVudH1cbiAqL1xudXRpbC5pc1ZhbGlkR2VzdHVyZSA9IGV2ZW50ID0+IGV2ZW50Lmdlc3R1cmUgIT09IHVuZGVmaW5lZCAmJiAoZXZlbnQuZ2VzdHVyZS5kaXN0YW5jZSA8PSAxNSB8fCBldmVudC5nZXN0dXJlLmRlbHRhVGltZSA8PSAxMDApO1xuXG51dGlsLmNoZWNrTWlzc2luZ0ltcG9ydCA9ICguLi5lbGVtZW50TmFtZXMpID0+IHtcbiAgZWxlbWVudE5hbWVzLmZvckVhY2gobmFtZSA9PiB7XG4gICAgaWYgKCFvbnNFbGVtZW50c1tuYW1lXSkge1xuICAgICAgdXRpbC50aHJvdyhgT25zJHtuYW1lfSBpcyByZXF1aXJlZCBidXQgd2FzIG5vdCBpbXBvcnRlZCAoQ3VzdG9tIEVsZW1lbnRzKWApO1xuICAgIH1cbiAgfSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHV0aWw7XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5cbi8qKlxuICogTWluaW1hbCBhbmltYXRpb24gbGlicmFyeSBmb3IgbWFuYWdpbmcgY3NzIHRyYW5zaXRpb24gb24gbW9iaWxlIGJyb3dzZXJzLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBUSU1FT1VUX1JBVElPID0gMS40O1xuXG52YXIgdXRpbCA9IHtcbn07XG5cbi8vIGNhcGl0YWxpemUgc3RyaW5nXG51dGlsLmNhcGl0YWxpemUgPSBmdW5jdGlvbihzdHIpIHtcbiAgcmV0dXJuIHN0ci5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHN0ci5zbGljZSgxKTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtPYmplY3R9IHBhcmFtc1xuICogQHBhcmFtIHtTdHJpbmd9IHBhcmFtcy5wcm9wZXJ0eVxuICogQHBhcmFtIHtGbG9hdH0gcGFyYW1zLmR1cmF0aW9uXG4gKiBAcGFyYW0ge1N0cmluZ30gcGFyYW1zLnRpbWluZ1xuICovXG51dGlsLmJ1aWxkVHJhbnNpdGlvblZhbHVlID0gZnVuY3Rpb24ocGFyYW1zKSB7XG4gIHBhcmFtcy5wcm9wZXJ0eSA9IHBhcmFtcy5wcm9wZXJ0eSB8fCAnYWxsJztcbiAgcGFyYW1zLmR1cmF0aW9uID0gcGFyYW1zLmR1cmF0aW9uIHx8IDAuNDtcbiAgcGFyYW1zLnRpbWluZyA9IHBhcmFtcy50aW1pbmcgfHwgJ2xpbmVhcic7XG5cbiAgdmFyIHByb3BzID0gcGFyYW1zLnByb3BlcnR5LnNwbGl0KC8gKy8pO1xuXG4gIHJldHVybiBwcm9wcy5tYXAoZnVuY3Rpb24ocHJvcCkge1xuICAgIHJldHVybiBwcm9wICsgJyAnICsgcGFyYW1zLmR1cmF0aW9uICsgJ3MgJyArIHBhcmFtcy50aW1pbmc7XG4gIH0pLmpvaW4oJywgJyk7XG59O1xuXG4vKipcbiAqIEFkZCBhbiBldmVudCBoYW5kbGVyIG9uIFwidHJhbnNpdGlvbmVuZFwiIGV2ZW50LlxuICovXG51dGlsLm9uY2VPblRyYW5zaXRpb25FbmQgPSBmdW5jdGlvbihlbGVtZW50LCBjYWxsYmFjaykge1xuICBpZiAoIWVsZW1lbnQpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7fTtcbiAgfVxuXG4gIHZhciBmbiA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgaWYgKGVsZW1lbnQgPT0gZXZlbnQudGFyZ2V0KSB7XG4gICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgIHJlbW92ZUxpc3RlbmVycygpO1xuXG4gICAgICBjYWxsYmFjaygpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgcmVtb3ZlTGlzdGVuZXJzID0gZnVuY3Rpb24oKSB7XG4gICAgdXRpbC5fdHJhbnNpdGlvbkVuZEV2ZW50cy5mb3JFYWNoKGZ1bmN0aW9uKGV2ZW50TmFtZSkge1xuICAgICAgZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgZm4sIGZhbHNlKTtcbiAgICB9KTtcbiAgfTtcblxuICB1dGlsLl90cmFuc2l0aW9uRW5kRXZlbnRzLmZvckVhY2goZnVuY3Rpb24oZXZlbnROYW1lKSB7XG4gICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgZm4sIGZhbHNlKTtcbiAgfSk7XG5cbiAgcmV0dXJuIHJlbW92ZUxpc3RlbmVycztcbn07XG5cbnV0aWwuX3RyYW5zaXRpb25FbmRFdmVudHMgPSAoZnVuY3Rpb24oKSB7XG5cbiAgaWYgKCdvbnRyYW5zaXRpb25lbmQnIGluIHdpbmRvdykge1xuICAgIHJldHVybiBbJ3RyYW5zaXRpb25lbmQnXTtcbiAgfVxuXG4gIGlmICgnb253ZWJraXR0cmFuc2l0aW9uZW5kJyBpbiB3aW5kb3cpIHtcbiAgICByZXR1cm4gWyd3ZWJraXRUcmFuc2l0aW9uRW5kJ107XG4gIH1cblxuICBpZiAodXRpbC52ZW5kb3JQcmVmaXggPT09ICd3ZWJraXQnIHx8IHV0aWwudmVuZG9yUHJlZml4ID09PSAnbycgfHwgdXRpbC52ZW5kb3JQcmVmaXggPT09ICdtb3onIHx8IHV0aWwudmVuZG9yUHJlZml4ID09PSAnbXMnKSB7XG4gICAgcmV0dXJuIFt1dGlsLnZlbmRvclByZWZpeCArICdUcmFuc2l0aW9uRW5kJywgJ3RyYW5zaXRpb25lbmQnXTtcbiAgfVxuXG4gIHJldHVybiBbXTtcbn0pKCk7XG5cbnV0aWwuX2Nzc1Byb3BlcnR5RGljdCA9IChmdW5jdGlvbigpIHtcbiAgdmFyIHN0eWxlcyA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCwgJycpO1xuICB2YXIgZGljdCA9IHt9O1xuICB2YXIgYSA9ICdBJy5jaGFyQ29kZUF0KDApO1xuICB2YXIgeiA9ICd6Jy5jaGFyQ29kZUF0KDApO1xuXG4gIHZhciB1cHBlciA9IGZ1bmN0aW9uKHMpIHtcbiAgICByZXR1cm4gcy5zdWJzdHIoMSkudG9VcHBlckNhc2UoKTtcbiAgfTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0eWxlcy5sZW5ndGg7IGkrKykge1xuXG4gICAgdmFyIGtleSA9IHN0eWxlc1tpXVxuICAgIC5yZXBsYWNlKC9eWy1dKy8sICcnKVxuICAgIC5yZXBsYWNlKC9bLV1bYS16XS9nLCB1cHBlcilcbiAgICAucmVwbGFjZSgvXm1vei8sICdNb3onKTtcblxuICAgIGlmIChhIDw9IGtleS5jaGFyQ29kZUF0KDApICYmIHogPj0ga2V5LmNoYXJDb2RlQXQoMCkpIHtcbiAgICAgIGlmIChrZXkgIT09ICdjc3NUZXh0JyAmJiBrZXkgIT09ICdwYXJlbnRUZXh0Jykge1xuICAgICAgICBkaWN0W2tleV0gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBkaWN0O1xufSkoKTtcblxudXRpbC5oYXNDc3NQcm9wZXJ0eSA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgcmV0dXJuIG5hbWUgaW4gdXRpbC5fY3NzUHJvcGVydHlEaWN0O1xufTtcblxuLyoqXG4gKiBWZW5kb3IgcHJlZml4IGZvciBjc3MgcHJvcGVydHkuXG4gKi9cbnV0aWwudmVuZG9yUHJlZml4ID0gKGZ1bmN0aW9uKCkge1xuICB2YXIgc3R5bGVzID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCAnJyksXG4gICAgcHJlID0gKEFycmF5LnByb3RvdHlwZS5zbGljZVxuICAgICAgLmNhbGwoc3R5bGVzKVxuICAgICAgLmpvaW4oJycpXG4gICAgICAubWF0Y2goLy0obW96fHdlYmtpdHxtcyktLykgfHwgKHN0eWxlcy5PTGluayA9PT0gJycgJiYgWycnLCAnbyddKVxuICAgIClbMV07XG4gICAgcmV0dXJuIHByZTtcbn0pKCk7XG5cbnV0aWwuZm9yY2VMYXlvdXRBdE9uY2UgPSBmdW5jdGlvbihlbGVtZW50cywgY2FsbGJhY2spIHtcbiAgdGhpcy5iYXRjaEltbWVkaWF0ZShmdW5jdGlvbigpIHtcbiAgICBlbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgIC8vIGZvcmNlIGxheW91dFxuICAgICAgZWxlbWVudC5vZmZzZXRIZWlnaHQ7XG4gICAgfSk7XG4gICAgY2FsbGJhY2soKTtcbiAgfSk7XG59O1xuXG51dGlsLmJhdGNoSW1tZWRpYXRlID0gKGZ1bmN0aW9uKCkge1xuICB2YXIgY2FsbGJhY2tzID0gW107XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgaWYgKGNhbGxiYWNrcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHNldEltbWVkaWF0ZShmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGNvbmNyZWF0ZUNhbGxiYWNrcyA9IGNhbGxiYWNrcy5zbGljZSgwKTtcbiAgICAgICAgY2FsbGJhY2tzID0gW107XG4gICAgICAgIGNvbmNyZWF0ZUNhbGxiYWNrcy5mb3JFYWNoKGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBjYWxsYmFja3MucHVzaChjYWxsYmFjayk7XG4gIH07XG59KSgpO1xuXG51dGlsLmJhdGNoQW5pbWF0aW9uRnJhbWUgPSAoZnVuY3Rpb24oKSB7XG4gIHZhciBjYWxsYmFja3MgPSBbXTtcblxuICB2YXIgcmFmID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxuICAgIHdpbmRvdy53ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcbiAgICB3aW5kb3cubW96UmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8XG4gICAgd2luZG93Lm9SZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcbiAgICB3aW5kb3cubXNSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcbiAgICBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgIHNldFRpbWVvdXQoY2FsbGJhY2ssIDEwMDAgLyA2MCk7XG4gIH07XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgaWYgKGNhbGxiYWNrcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJhZihmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGNvbmNyZWF0ZUNhbGxiYWNrcyA9IGNhbGxiYWNrcy5zbGljZSgwKTtcbiAgICAgICAgY2FsbGJhY2tzID0gW107XG4gICAgICAgIGNvbmNyZWF0ZUNhbGxiYWNrcy5mb3JFYWNoKGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBjYWxsYmFja3MucHVzaChjYWxsYmFjayk7XG4gIH07XG59KSgpO1xuXG51dGlsLnRyYW5zaXRpb25Qcm9wZXJ0eU5hbWUgPSAoZnVuY3Rpb24oKSB7XG4gIGlmICh1dGlsLmhhc0Nzc1Byb3BlcnR5KCd0cmFuc2l0aW9uRHVyYXRpb24nKSkge1xuICAgIHJldHVybiAndHJhbnNpdGlvbic7XG4gIH1cblxuICBpZiAodXRpbC5oYXNDc3NQcm9wZXJ0eSh1dGlsLnZlbmRvclByZWZpeCArICdUcmFuc2l0aW9uRHVyYXRpb24nKSkge1xuICAgIHJldHVybiB1dGlsLnZlbmRvclByZWZpeCArICdUcmFuc2l0aW9uJztcbiAgfVxuXG4gIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzdGF0ZScpO1xufSkoKTtcblxuXG4vKipcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAqL1xudmFyIEFuaW1pdCA9IGZ1bmN0aW9uKGVsZW1lbnQsIGRlZmF1bHRzKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBBbmltaXQpKSB7XG4gICAgcmV0dXJuIG5ldyBBbmltaXQoZWxlbWVudCwgZGVmYXVsdHMpO1xuICB9XG5cbiAgaWYgKGVsZW1lbnQgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkge1xuICAgIHRoaXMuZWxlbWVudHMgPSBbZWxlbWVudF07XG4gIH0gZWxzZSBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGVsZW1lbnQpID09PSAnW29iamVjdCBBcnJheV0nKSB7XG4gICAgdGhpcy5lbGVtZW50cyA9IGVsZW1lbnQ7XG5cbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYW4gYXJyYXkgb3IgYW4gaW5zdGFuY2Ugb2YgSFRNTEVsZW1lbnQuJyk7XG4gIH1cblxuICB0aGlzLmRlZmF1bHRzID0gZGVmYXVsdHM7XG4gIHRoaXMudHJhbnNpdGlvblF1ZXVlID0gW107XG4gIHRoaXMubGFzdFN0eWxlQXR0cmlidXRlRGljdCA9IFtdO1xufTtcblxuQW5pbWl0LnByb3RvdHlwZSA9IHtcblxuICAvKipcbiAgICogQHByb3BlcnR5IHtBcnJheX1cbiAgICovXG4gIHRyYW5zaXRpb25RdWV1ZTogdW5kZWZpbmVkLFxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkge0FycmF5fVxuICAgKi9cbiAgZWxlbWVudHM6IHVuZGVmaW5lZCxcblxuICAvKipcbiAgICogQHByb3BlcnR5IHtPYmplY3R9XG4gICAqL1xuICBkZWZhdWx0czogdW5kZWZpbmVkLFxuXG4gIC8qKlxuICAgKiBTdGFydCBhbmltYXRpb24gc2VxdWVuY2Ugd2l0aCBwYXNzZWQgYW5pbWF0aW9ucy5cbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICovXG4gIHBsYXk6IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpcy50cmFuc2l0aW9uUXVldWUucHVzaChmdW5jdGlvbihkb25lKSB7XG4gICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgIGRvbmUoKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHRoaXMuc3RhcnRBbmltYXRpb24oKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBNb3N0IG9mIHRoZSBhbmltYXRpb25zIGZvbGxvdyB0aGlzIGRlZmF1bHQgcHJvY2Vzcy5cbiAgICpcbiAgICogQHBhcmFtIHtmcm9tfSBjc3Mgb3Igb3B0aW9ucyBvYmplY3QgY29udGFpbmluZyBjc3NcbiAgICogQHBhcmFtIHt0b30gY3NzIG9yIG9wdGlvbnMgb2JqZWN0IGNvbnRhaW5pbmcgY3NzXG4gICAqIEBwYXJhbSB7ZGVsYXl9IGRlbGF5IHRvIHdhaXRcbiAgICovXG4gIGRlZmF1bHQ6IGZ1bmN0aW9uKGZyb20sIHRvLCBkZWxheSkge1xuICAgIGZ1bmN0aW9uIHN0ZXAocGFyYW1zLCBkdXJhdGlvbiwgdGltaW5nKSB7XG4gICAgICBpZiAocGFyYW1zLmR1cmF0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZHVyYXRpb24gPSBwYXJhbXMuZHVyYXRpb247XG4gICAgICB9XG4gICAgICBpZiAocGFyYW1zLnRpbWluZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRpbWluZyA9IHBhcmFtcy50aW1pbmc7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGNzczogcGFyYW1zLmNzcyB8fCBwYXJhbXMsXG4gICAgICAgIGR1cmF0aW9uOiBkdXJhdGlvbixcbiAgICAgICAgdGltaW5nOiB0aW1pbmdcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuc2F2ZVN0eWxlKClcbiAgICAgIC5xdWV1ZShzdGVwKGZyb20sIDAsIHRoaXMuZGVmYXVsdHMudGltaW5nKSlcbiAgICAgIC53YWl0KGRlbGF5ID09PSB1bmRlZmluZWQgPyB0aGlzLmRlZmF1bHRzLmRlbGF5IDogZGVsYXkpXG4gICAgICAucXVldWUoc3RlcCh0bywgdGhpcy5kZWZhdWx0cy5kdXJhdGlvbiwgdGhpcy5kZWZhdWx0cy50aW1pbmcpKVxuICAgICAgLnJlc3RvcmVTdHlsZSgpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBRdWV1ZSB0cmFuc2l0aW9uIGFuaW1hdGlvbnMgb3Igb3RoZXIgZnVuY3Rpb24uXG4gICAqXG4gICAqIGUuZy4gYW5pbWl0KGVsdCkucXVldWUoe2NvbG9yOiAncmVkJ30pXG4gICAqIGUuZy4gYW5pbWl0KGVsdCkucXVldWUoe2NvbG9yOiAncmVkJ30sIHtkdXJhdGlvbjogMC40fSlcbiAgICogZS5nLiBhbmltaXQoZWx0KS5xdWV1ZSh7Y3NzOiB7Y29sb3I6ICdyZWQnfSwgZHVyYXRpb246IDAuMn0pXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fEFuaW1pdC5UcmFuc2l0aW9ufEZ1bmN0aW9ufSB0cmFuc2l0aW9uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICovXG4gIHF1ZXVlOiBmdW5jdGlvbih0cmFuc2l0aW9uLCBvcHRpb25zKSB7XG4gICAgdmFyIHF1ZXVlID0gdGhpcy50cmFuc2l0aW9uUXVldWU7XG5cbiAgICBpZiAodHJhbnNpdGlvbiAmJiBvcHRpb25zKSB7XG4gICAgICBvcHRpb25zLmNzcyA9IHRyYW5zaXRpb247XG4gICAgICB0cmFuc2l0aW9uID0gbmV3IEFuaW1pdC5UcmFuc2l0aW9uKG9wdGlvbnMpO1xuICAgIH1cblxuICAgIGlmICghKHRyYW5zaXRpb24gaW5zdGFuY2VvZiBGdW5jdGlvbiB8fCB0cmFuc2l0aW9uIGluc3RhbmNlb2YgQW5pbWl0LlRyYW5zaXRpb24pKSB7XG4gICAgICBpZiAodHJhbnNpdGlvbi5jc3MpIHtcbiAgICAgICAgdHJhbnNpdGlvbiA9IG5ldyBBbmltaXQuVHJhbnNpdGlvbih0cmFuc2l0aW9uKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRyYW5zaXRpb24gPSBuZXcgQW5pbWl0LlRyYW5zaXRpb24oe1xuICAgICAgICAgIGNzczogdHJhbnNpdGlvblxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodHJhbnNpdGlvbiBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XG4gICAgICBxdWV1ZS5wdXNoKHRyYW5zaXRpb24pO1xuICAgIH0gZWxzZSBpZiAodHJhbnNpdGlvbiBpbnN0YW5jZW9mIEFuaW1pdC5UcmFuc2l0aW9uKSB7XG4gICAgICBxdWV1ZS5wdXNoKHRyYW5zaXRpb24uYnVpbGQoKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBhcmd1bWVudHMnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICogUXVldWUgdHJhbnNpdGlvbiBhbmltYXRpb25zLlxuICAgKlxuICAgKiBAcGFyYW0ge0Zsb2F0fSBzZWNvbmRzXG4gICAqL1xuICB3YWl0OiBmdW5jdGlvbihzZWNvbmRzKSB7XG4gICAgaWYgKHNlY29uZHMgPiAwKSB7XG4gICAgICB0aGlzLnRyYW5zaXRpb25RdWV1ZS5wdXNoKGZ1bmN0aW9uKGRvbmUpIHtcbiAgICAgICAgc2V0VGltZW91dChkb25lLCAxMDAwICogc2Vjb25kcyk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICBzYXZlU3R5bGU6IGZ1bmN0aW9uKCkge1xuXG4gICAgdGhpcy50cmFuc2l0aW9uUXVldWUucHVzaChmdW5jdGlvbihkb25lKSB7XG4gICAgICB0aGlzLmVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24oZWxlbWVudCwgaW5kZXgpIHtcbiAgICAgICAgdmFyIGNzcyA9IHRoaXMubGFzdFN0eWxlQXR0cmlidXRlRGljdFtpbmRleF0gPSB7fTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZW1lbnQuc3R5bGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjc3NbZWxlbWVudC5zdHlsZVtpXV0gPSBlbGVtZW50LnN0eWxlW2VsZW1lbnQuc3R5bGVbaV1dO1xuICAgICAgICB9XG4gICAgICB9LmJpbmQodGhpcykpO1xuICAgICAgZG9uZSgpO1xuICAgIH0uYmluZCh0aGlzKSk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICogUmVzdG9yZSBlbGVtZW50J3Mgc3R5bGUuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogQHBhcmFtIHtGbG9hdH0gW29wdGlvbnMuZHVyYXRpb25dXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy50aW1pbmddXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy50cmFuc2l0aW9uXVxuICAgKi9cbiAgcmVzdG9yZVN0eWxlOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgaWYgKG9wdGlvbnMudHJhbnNpdGlvbiAmJiAhb3B0aW9ucy5kdXJhdGlvbikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdcIm9wdGlvbnMuZHVyYXRpb25cIiBpcyByZXF1aXJlZCB3aGVuIFwib3B0aW9ucy50cmFuc2l0aW9uXCIgaXMgZW5hYmxlZC4nKTtcbiAgICB9XG5cbiAgICB2YXIgdHJhbnNpdGlvbk5hbWUgPSB1dGlsLnRyYW5zaXRpb25Qcm9wZXJ0eU5hbWU7XG5cbiAgICBpZiAob3B0aW9ucy50cmFuc2l0aW9uIHx8IChvcHRpb25zLmR1cmF0aW9uICYmIG9wdGlvbnMuZHVyYXRpb24gPiAwKSkge1xuICAgICAgdmFyIHRyYW5zaXRpb25WYWx1ZSA9IG9wdGlvbnMudHJhbnNpdGlvbiB8fCAoJ2FsbCAnICsgb3B0aW9ucy5kdXJhdGlvbiArICdzICcgKyAob3B0aW9ucy50aW1pbmcgfHwgJ2xpbmVhcicpKTtcblxuICAgICAgdGhpcy50cmFuc2l0aW9uUXVldWUucHVzaChmdW5jdGlvbihkb25lKSB7XG4gICAgICAgIHZhciBlbGVtZW50cyA9IHRoaXMuZWxlbWVudHM7XG4gICAgICAgIHZhciB0aW1lb3V0SWQ7XG5cbiAgICAgICAgdmFyIGNsZWFyVHJhbnNpdGlvbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgICAgICAgZWxlbWVudC5zdHlsZVt0cmFuc2l0aW9uTmFtZV0gPSAnJztcbiAgICAgICAgICB9KTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBhZGQgXCJ0cmFuc2l0aW9uZW5kXCIgZXZlbnQgaGFuZGxlclxuICAgICAgICB2YXIgcmVtb3ZlTGlzdGVuZXJzID0gdXRpbC5vbmNlT25UcmFuc2l0aW9uRW5kKGVsZW1lbnRzWzBdLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgICAgICAgICBjbGVhclRyYW5zaXRpb24oKTtcbiAgICAgICAgICBkb25lKCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIGZvciBmYWlsIHNhZmUuXG4gICAgICAgIHRpbWVvdXRJZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmVtb3ZlTGlzdGVuZXJzKCk7XG4gICAgICAgICAgY2xlYXJUcmFuc2l0aW9uKCk7XG4gICAgICAgICAgZG9uZSgpO1xuICAgICAgICB9LCBvcHRpb25zLmR1cmF0aW9uICogMTAwMCAqIFRJTUVPVVRfUkFUSU8pO1xuXG4gICAgICAgIC8vIHRyYW5zaXRpb24gYW5kIHN0eWxlIHNldHRpbmdzXG4gICAgICAgIGVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24oZWxlbWVudCwgaW5kZXgpIHtcblxuICAgICAgICAgIHZhciBjc3MgPSBzZWxmLmxhc3RTdHlsZUF0dHJpYnV0ZURpY3RbaW5kZXhdO1xuXG4gICAgICAgICAgaWYgKCFjc3MpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncmVzdG9yZVN0eWxlKCk6IFRoZSBzdHlsZSBpcyBub3Qgc2F2ZWQuIEludm9rZSBzYXZlU3R5bGUoKSBiZWZvcmUuJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc2VsZi5sYXN0U3R5bGVBdHRyaWJ1dGVEaWN0W2luZGV4XSA9IHVuZGVmaW5lZDtcblxuICAgICAgICAgIHZhciBuYW1lO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBlbGVtZW50LnN0eWxlLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBuYW1lID0gZWxlbWVudC5zdHlsZVtpXTtcbiAgICAgICAgICAgIGlmIChjc3NbbmFtZV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICBjc3NbbmFtZV0gPSAnJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBlbGVtZW50LnN0eWxlW3RyYW5zaXRpb25OYW1lXSA9IHRyYW5zaXRpb25WYWx1ZTtcblxuICAgICAgICAgIE9iamVjdC5rZXlzKGNzcykuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgIGlmIChrZXkgIT09IHRyYW5zaXRpb25OYW1lKSB7XG4gICAgICAgICAgICAgIGVsZW1lbnQuc3R5bGVba2V5XSA9IGNzc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgZWxlbWVudC5zdHlsZVt0cmFuc2l0aW9uTmFtZV0gPSB0cmFuc2l0aW9uVmFsdWU7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudHJhbnNpdGlvblF1ZXVlLnB1c2goZnVuY3Rpb24oZG9uZSkge1xuICAgICAgICByZXNldCgpO1xuICAgICAgICBkb25lKCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcblxuICAgIGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgICAgLy8gQ2xlYXIgdHJhbnNpdGlvbiBhbmltYXRpb24gc2V0dGluZ3MuXG4gICAgICBzZWxmLmVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24oZWxlbWVudCwgaW5kZXgpIHtcbiAgICAgICAgZWxlbWVudC5zdHlsZVt0cmFuc2l0aW9uTmFtZV0gPSAnbm9uZSc7XG5cbiAgICAgICAgdmFyIGNzcyA9IHNlbGYubGFzdFN0eWxlQXR0cmlidXRlRGljdFtpbmRleF07XG5cbiAgICAgICAgaWYgKCFjc3MpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Jlc3RvcmVTdHlsZSgpOiBUaGUgc3R5bGUgaXMgbm90IHNhdmVkLiBJbnZva2Ugc2F2ZVN0eWxlKCkgYmVmb3JlLicpO1xuICAgICAgICB9XG5cbiAgICAgICAgc2VsZi5sYXN0U3R5bGVBdHRyaWJ1dGVEaWN0W2luZGV4XSA9IHVuZGVmaW5lZDtcblxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbmFtZSA9ICcnOyBpIDwgZWxlbWVudC5zdHlsZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIG5hbWUgPSBlbGVtZW50LnN0eWxlW2ldO1xuICAgICAgICAgIGlmICh0eXBlb2YgY3NzW2VsZW1lbnQuc3R5bGVbaV1dID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgY3NzW2VsZW1lbnQuc3R5bGVbaV1dID0gJyc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgT2JqZWN0LmtleXMoY3NzKS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgIGVsZW1lbnQuc3R5bGVba2V5XSA9IGNzc1trZXldO1xuICAgICAgICB9KTtcblxuICAgICAgfSk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBTdGFydCBhbmltYXRpb24gc2VxdWVuY2UuXG4gICAqL1xuICBzdGFydEFuaW1hdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fZGVxdWV1ZVRyYW5zaXRpb24oKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIF9kZXF1ZXVlVHJhbnNpdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgdmFyIHRyYW5zaXRpb24gPSB0aGlzLnRyYW5zaXRpb25RdWV1ZS5zaGlmdCgpO1xuICAgIGlmICh0aGlzLl9jdXJyZW50VHJhbnNpdGlvbikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDdXJyZW50IHRyYW5zaXRpb24gZXhpc3RzLicpO1xuICAgIH1cbiAgICB0aGlzLl9jdXJyZW50VHJhbnNpdGlvbiA9IHRyYW5zaXRpb247XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBjYWxsZWQgPSBmYWxzZTtcblxuICAgIHZhciBkb25lID0gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoIWNhbGxlZCkge1xuICAgICAgICBjYWxsZWQgPSB0cnVlO1xuICAgICAgICBzZWxmLl9jdXJyZW50VHJhbnNpdGlvbiA9IHVuZGVmaW5lZDtcbiAgICAgICAgc2VsZi5fZGVxdWV1ZVRyYW5zaXRpb24oKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzdGF0ZTogVGhpcyBjYWxsYmFjayBpcyBjYWxsZWQgdHdpY2UuJyk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGlmICh0cmFuc2l0aW9uKSB7XG4gICAgICB0cmFuc2l0aW9uLmNhbGwodGhpcywgZG9uZSk7XG4gICAgfVxuICB9XG5cbn07XG5cbi8qKlxuICogQHBhcmFtIHtBbmltaXR9IGFyZ3VtZW50c1xuICovXG5BbmltaXQucnVuQWxsID0gZnVuY3Rpb24oLyogYXJndW1lbnRzLi4uICovKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgYXJndW1lbnRzW2ldLnBsYXkoKTtcbiAgfVxufTtcblxuXG4vKipcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcGFyYW0ge0Zsb2F0fSBbb3B0aW9ucy5kdXJhdGlvbl1cbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5wcm9wZXJ0eV1cbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy50aW1pbmddXG4gKi9cbkFuaW1pdC5UcmFuc2l0aW9uID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB0aGlzLm9wdGlvbnMuZHVyYXRpb24gPSB0aGlzLm9wdGlvbnMuZHVyYXRpb24gfHwgMDtcbiAgdGhpcy5vcHRpb25zLnRpbWluZyA9IHRoaXMub3B0aW9ucy50aW1pbmcgfHwgJ2xpbmVhcic7XG4gIHRoaXMub3B0aW9ucy5jc3MgPSB0aGlzLm9wdGlvbnMuY3NzIHx8IHt9O1xuICB0aGlzLm9wdGlvbnMucHJvcGVydHkgPSB0aGlzLm9wdGlvbnMucHJvcGVydHkgfHwgJ2FsbCc7XG59O1xuXG5BbmltaXQuVHJhbnNpdGlvbi5wcm90b3R5cGUgPSB7XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAgICogQHJldHVybiB7RnVuY3Rpb259XG4gICAqL1xuICBidWlsZDogZnVuY3Rpb24oKSB7XG5cbiAgICBpZiAoT2JqZWN0LmtleXModGhpcy5vcHRpb25zLmNzcykubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ29wdGlvbnMuY3NzIGlzIHJlcXVpcmVkLicpO1xuICAgIH1cblxuICAgIHZhciBjc3MgPSBjcmVhdGVBY3R1YWxDc3NQcm9wcyh0aGlzLm9wdGlvbnMuY3NzKTtcblxuICAgIGlmICh0aGlzLm9wdGlvbnMuZHVyYXRpb24gPiAwKSB7XG4gICAgICB2YXIgdHJhbnNpdGlvblZhbHVlID0gdXRpbC5idWlsZFRyYW5zaXRpb25WYWx1ZSh0aGlzLm9wdGlvbnMpO1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICByZXR1cm4gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIGVsZW1lbnRzID0gdGhpcy5lbGVtZW50cztcbiAgICAgICAgdmFyIHRpbWVvdXQgPSBzZWxmLm9wdGlvbnMuZHVyYXRpb24gKiAxMDAwICogVElNRU9VVF9SQVRJTztcbiAgICAgICAgdmFyIHRpbWVvdXRJZDtcblxuICAgICAgICB2YXIgcmVtb3ZlTGlzdGVuZXJzID0gdXRpbC5vbmNlT25UcmFuc2l0aW9uRW5kKGVsZW1lbnRzWzBdLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICB9KTtcblxuICAgICAgICB0aW1lb3V0SWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJlbW92ZUxpc3RlbmVycygpO1xuICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgIH0sIHRpbWVvdXQpO1xuXG4gICAgICAgIGVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgICAgIGVsZW1lbnQuc3R5bGVbdXRpbC50cmFuc2l0aW9uUHJvcGVydHlOYW1lXSA9IHRyYW5zaXRpb25WYWx1ZTtcblxuICAgICAgICAgIE9iamVjdC5rZXlzKGNzcykuZm9yRWFjaChmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgICAgICBlbGVtZW50LnN0eWxlW25hbWVdID0gY3NzW25hbWVdO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgfTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLmR1cmF0aW9uIDw9IDApIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgICAgICB2YXIgZWxlbWVudHMgPSB0aGlzLmVsZW1lbnRzO1xuXG4gICAgICAgIGVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgICAgIGVsZW1lbnQuc3R5bGVbdXRpbC50cmFuc2l0aW9uUHJvcGVydHlOYW1lXSA9ICcnO1xuXG4gICAgICAgICAgT2JqZWN0LmtleXMoY3NzKS5mb3JFYWNoKGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgICAgIGVsZW1lbnQuc3R5bGVbbmFtZV0gPSBjc3NbbmFtZV07XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChlbGVtZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgdXRpbC5mb3JjZUxheW91dEF0T25jZShlbGVtZW50cywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB1dGlsLmJhdGNoQW5pbWF0aW9uRnJhbWUoY2FsbGJhY2spO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHV0aWwuYmF0Y2hBbmltYXRpb25GcmFtZShjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlQWN0dWFsQ3NzUHJvcHMoY3NzKSB7XG4gICAgICB2YXIgcmVzdWx0ID0ge307XG5cbiAgICAgIE9iamVjdC5rZXlzKGNzcykuZm9yRWFjaChmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGNzc1tuYW1lXTtcblxuICAgICAgICBpZiAodXRpbC5oYXNDc3NQcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICAgIHJlc3VsdFtuYW1lXSA9IHZhbHVlO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwcmVmaXhlZCA9IHV0aWwudmVuZG9yUHJlZml4ICsgdXRpbC5jYXBpdGFsaXplKG5hbWUpO1xuICAgICAgICBpZiAodXRpbC5oYXNDc3NQcm9wZXJ0eShwcmVmaXhlZCkpIHtcbiAgICAgICAgICByZXN1bHRbcHJlZml4ZWRdID0gdmFsdWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0W3ByZWZpeGVkXSA9IHZhbHVlO1xuICAgICAgICAgIHJlc3VsdFtuYW1lXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgQW5pbWl0O1xuXG4iLCIvKlxuICogR2VzdHVyZSBkZXRlY3RvciBsaWJyYXJ5IHRoYXQgZm9ya2VkIGZyb20gZ2l0aHViLmNvbS9FaWdodE1lZGlhL2hhbW1lci5qcy5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmltcG9ydCB1dGlsIGZyb20gJy4vdXRpbCc7XG5cbnZhciBFdmVudCwgVXRpbHMsIERldGVjdGlvbiwgUG9pbnRlckV2ZW50O1xuXG4vKipcbiAqIEBvYmplY3Qgb25zLkdlc3R1cmVEZXRlY3RvclxuICogQGNhdGVnb3J5IGdlc3R1cmVcbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dVXRpbGl0eSBjbGFzcyBmb3IgZ2VzdHVyZSBkZXRlY3Rpb24uWy9lbl1cbiAqICAgW2phXeOCuOOCp+OCueODgeODo+OCkuaknOefpeOBmeOCi+OBn+OCgeOBruODpuODvOODhuOCo+ODquODhuOCo+OCr+ODqeOCueOBp+OBmeOAglsvamFdXG4gKi9cblxuLyoqXG4gKiBAbWV0aG9kIGNvbnN0cnVjdG9yXG4gKiBAc2lnbmF0dXJlIGNvbnN0cnVjdG9yKGVsZW1lbnRbLCBvcHRpb25zXSlcbiAqIEBkZXNjcmlwdGlvblxuICogIFtlbl1DcmVhdGUgYSBuZXcgR2VzdHVyZURldGVjdG9yIGluc3RhbmNlLlsvZW5dXG4gKiAgW2phXUdlc3R1cmVEZXRlY3RvcuOBruOCpOODs+OCueOCv+ODs+OCueOCkueUn+aIkOOBl+OBvuOBmeOAglsvamFdXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnRcbiAqICAgW2VuXU5hbWUgb2YgdGhlIGV2ZW50LlsvZW5dXG4gKiAgIFtqYV3jgrjjgqfjgrnjg4Hjg6PjgpLmpJznn6XjgZnjgotET03opoHntKDjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogICBbZW5dT3B0aW9ucyBvYmplY3QuWy9lbl1cbiAqICAgW2phXeOCquODl+OCt+ODp+ODs+OCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gKiBAcmV0dXJuIHtvbnMuR2VzdHVyZURldGVjdG9yLkluc3RhbmNlfVxuICovXG52YXIgR2VzdHVyZURldGVjdG9yID0gZnVuY3Rpb24gR2VzdHVyZURldGVjdG9yKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIG5ldyBHZXN0dXJlRGV0ZWN0b3IuSW5zdGFuY2UoZWxlbWVudCwgb3B0aW9ucyB8fCB7fSk7XG59O1xuXG5cbi8qKlxuICogZGVmYXVsdCBzZXR0aW5ncy5cbiAqIG1vcmUgc2V0dGluZ3MgYXJlIGRlZmluZWQgcGVyIGdlc3R1cmUgYXQgYC9nZXN0dXJlc2AuIEVhY2ggZ2VzdHVyZSBjYW4gYmUgZGlzYWJsZWQvZW5hYmxlZFxuICogYnkgc2V0dGluZyBpdCdzIG5hbWUgKGxpa2UgYHN3aXBlYCkgdG8gZmFsc2UuXG4gKiBZb3UgY2FuIHNldCB0aGUgZGVmYXVsdHMgZm9yIGFsbCBpbnN0YW5jZXMgYnkgY2hhbmdpbmcgdGhpcyBvYmplY3QgYmVmb3JlIGNyZWF0aW5nIGFuIGluc3RhbmNlLlxuICogQGV4YW1wbGVcbiAqIGBgYGBcbiAqICBHZXN0dXJlRGV0ZWN0b3IuZGVmYXVsdHMuZHJhZyA9IGZhbHNlO1xuICogIEdlc3R1cmVEZXRlY3Rvci5kZWZhdWx0cy5iZWhhdmlvci50b3VjaEFjdGlvbiA9ICdwYW4teSc7XG4gKiAgZGVsZXRlIEdlc3R1cmVEZXRlY3Rvci5kZWZhdWx0cy5iZWhhdmlvci51c2VyU2VsZWN0O1xuICogYGBgYFxuICogQHByb3BlcnR5IGRlZmF1bHRzXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG5HZXN0dXJlRGV0ZWN0b3IuZGVmYXVsdHMgPSB7XG4gIGJlaGF2aW9yOiB7XG4gICAgLy8gdXNlclNlbGVjdDogJ25vbmUnLCAvLyBBbHNvIGRpc2FibGVzIHNlbGVjdGlvbiBpbiBgaW5wdXRgIGNoaWxkcmVuXG4gICAgdG91Y2hBY3Rpb246ICdwYW4teScsXG4gICAgdG91Y2hDYWxsb3V0OiAnbm9uZScsXG4gICAgY29udGVudFpvb21pbmc6ICdub25lJyxcbiAgICB1c2VyRHJhZzogJ25vbmUnLFxuICAgIHRhcEhpZ2hsaWdodENvbG9yOiAncmdiYSgwLDAsMCwwKSdcbiAgfVxufTtcblxuLyoqXG4gKiBHZXN0dXJlRGV0ZWN0b3IgZG9jdW1lbnQgd2hlcmUgdGhlIGJhc2UgZXZlbnRzIGFyZSBhZGRlZCBhdFxuICogQHByb3BlcnR5IERPQ1VNRU5UXG4gKiBAdHlwZSB7SFRNTEVsZW1lbnR9XG4gKiBAZGVmYXVsdCB3aW5kb3cuZG9jdW1lbnRcbiAqL1xuR2VzdHVyZURldGVjdG9yLkRPQ1VNRU5UID0gZG9jdW1lbnQ7XG5cbi8qKlxuICogZGV0ZWN0IHN1cHBvcnQgZm9yIHBvaW50ZXIgZXZlbnRzXG4gKiBAcHJvcGVydHkgSEFTX1BPSU5URVJFVkVOVFNcbiAqIEB0eXBlIHtCb29sZWFufVxuICovXG5HZXN0dXJlRGV0ZWN0b3IuSEFTX1BPSU5URVJFVkVOVFMgPSBuYXZpZ2F0b3IucG9pbnRlckVuYWJsZWQgfHwgbmF2aWdhdG9yLm1zUG9pbnRlckVuYWJsZWQ7XG5cbi8qKlxuICogZGV0ZWN0IHN1cHBvcnQgZm9yIHRvdWNoIGV2ZW50c1xuICogQHByb3BlcnR5IEhBU19UT1VDSEVWRU5UU1xuICogQHR5cGUge0Jvb2xlYW59XG4gKi9cbkdlc3R1cmVEZXRlY3Rvci5IQVNfVE9VQ0hFVkVOVFMgPSAoJ29udG91Y2hzdGFydCcgaW4gd2luZG93KTtcblxuLyoqXG4gKiBkZXRlY3QgbW9iaWxlIGJyb3dzZXJzXG4gKiBAcHJvcGVydHkgSVNfTU9CSUxFXG4gKiBAdHlwZSB7Qm9vbGVhbn1cbiAqL1xuR2VzdHVyZURldGVjdG9yLklTX01PQklMRSA9IC9tb2JpbGV8dGFibGV0fGlwKGFkfGhvbmV8b2QpfGFuZHJvaWR8c2lsay9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG5cbi8qKlxuICogZGV0ZWN0IGlmIHdlIHdhbnQgdG8gc3VwcG9ydCBtb3VzZWV2ZW50cyBhdCBhbGxcbiAqIEBwcm9wZXJ0eSBOT19NT1VTRUVWRU5UU1xuICogQHR5cGUge0Jvb2xlYW59XG4gKi9cbkdlc3R1cmVEZXRlY3Rvci5OT19NT1VTRUVWRU5UUyA9IChHZXN0dXJlRGV0ZWN0b3IuSEFTX1RPVUNIRVZFTlRTICYmIEdlc3R1cmVEZXRlY3Rvci5JU19NT0JJTEUpIHx8IEdlc3R1cmVEZXRlY3Rvci5IQVNfUE9JTlRFUkVWRU5UUztcblxuLyoqXG4gKiBpbnRlcnZhbCBpbiB3aGljaCBHZXN0dXJlRGV0ZWN0b3IgcmVjYWxjdWxhdGVzIGN1cnJlbnQgdmVsb2NpdHkvZGlyZWN0aW9uL2FuZ2xlIGluIG1zXG4gKiBAcHJvcGVydHkgQ0FMQ1VMQVRFX0lOVEVSVkFMXG4gKiBAdHlwZSB7TnVtYmVyfVxuICogQGRlZmF1bHQgMjVcbiAqL1xuR2VzdHVyZURldGVjdG9yLkNBTENVTEFURV9JTlRFUlZBTCA9IDI1O1xuXG4vKipcbiAqIGV2ZW50dHlwZXMgcGVyIHRvdWNoZXZlbnQgKHN0YXJ0LCBtb3ZlLCBlbmQpIGFyZSBmaWxsZWQgYnkgYEV2ZW50LmRldGVybWluZUV2ZW50VHlwZXNgIG9uIGBzZXR1cGBcbiAqIHRoZSBvYmplY3QgY29udGFpbnMgdGhlIERPTSBldmVudCBuYW1lcyBwZXIgdHlwZSAoYEVWRU5UX1NUQVJUYCwgYEVWRU5UX01PVkVgLCBgRVZFTlRfRU5EYClcbiAqIEBwcm9wZXJ0eSBFVkVOVF9UWVBFU1xuICogQHByaXZhdGVcbiAqIEB3cml0ZU9uY2VcbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cbnZhciBFVkVOVF9UWVBFUyA9IHt9O1xuXG4vKipcbiAqIGRpcmVjdGlvbiBzdHJpbmdzLCBmb3Igc2FmZSBjb21wYXJpc29uc1xuICogQHByb3BlcnR5IERJUkVDVElPTl9ET1dOfExFRlR8VVB8UklHSFRcbiAqIEBmaW5hbFxuICogQHR5cGUge1N0cmluZ31cbiAqIEBkZWZhdWx0ICdkb3duJyAnbGVmdCcgJ3VwJyAncmlnaHQnXG4gKi9cbnZhciBESVJFQ1RJT05fRE9XTiA9IEdlc3R1cmVEZXRlY3Rvci5ESVJFQ1RJT05fRE9XTiA9ICdkb3duJztcbnZhciBESVJFQ1RJT05fTEVGVCA9IEdlc3R1cmVEZXRlY3Rvci5ESVJFQ1RJT05fTEVGVCA9ICdsZWZ0JztcbnZhciBESVJFQ1RJT05fVVAgPSBHZXN0dXJlRGV0ZWN0b3IuRElSRUNUSU9OX1VQID0gJ3VwJztcbnZhciBESVJFQ1RJT05fUklHSFQgPSBHZXN0dXJlRGV0ZWN0b3IuRElSRUNUSU9OX1JJR0hUID0gJ3JpZ2h0JztcblxuLyoqXG4gKiBwb2ludGVydHlwZSBzdHJpbmdzLCBmb3Igc2FmZSBjb21wYXJpc29uc1xuICogQHByb3BlcnR5IFBPSU5URVJfTU9VU0V8VE9VQ0h8UEVOXG4gKiBAZmluYWxcbiAqIEB0eXBlIHtTdHJpbmd9XG4gKiBAZGVmYXVsdCAnbW91c2UnICd0b3VjaCcgJ3BlbidcbiAqL1xudmFyIFBPSU5URVJfTU9VU0UgPSBHZXN0dXJlRGV0ZWN0b3IuUE9JTlRFUl9NT1VTRSA9ICdtb3VzZSc7XG52YXIgUE9JTlRFUl9UT1VDSCA9IEdlc3R1cmVEZXRlY3Rvci5QT0lOVEVSX1RPVUNIID0gJ3RvdWNoJztcbnZhciBQT0lOVEVSX1BFTiA9IEdlc3R1cmVEZXRlY3Rvci5QT0lOVEVSX1BFTiA9ICdwZW4nO1xuXG4vKipcbiAqIGV2ZW50dHlwZXNcbiAqIEBwcm9wZXJ0eSBFVkVOVF9TVEFSVHxNT1ZFfEVORHxSRUxFQVNFfFRPVUNIXG4gKiBAZmluYWxcbiAqIEB0eXBlIHtTdHJpbmd9XG4gKiBAZGVmYXVsdCAnc3RhcnQnICdjaGFuZ2UnICdtb3ZlJyAnZW5kJyAncmVsZWFzZScgJ3RvdWNoJ1xuICovXG52YXIgRVZFTlRfU1RBUlQgPSBHZXN0dXJlRGV0ZWN0b3IuRVZFTlRfU1RBUlQgPSAnc3RhcnQnO1xudmFyIEVWRU5UX01PVkUgPSBHZXN0dXJlRGV0ZWN0b3IuRVZFTlRfTU9WRSA9ICdtb3ZlJztcbnZhciBFVkVOVF9FTkQgPSBHZXN0dXJlRGV0ZWN0b3IuRVZFTlRfRU5EID0gJ2VuZCc7XG52YXIgRVZFTlRfUkVMRUFTRSA9IEdlc3R1cmVEZXRlY3Rvci5FVkVOVF9SRUxFQVNFID0gJ3JlbGVhc2UnO1xudmFyIEVWRU5UX1RPVUNIID0gR2VzdHVyZURldGVjdG9yLkVWRU5UX1RPVUNIID0gJ3RvdWNoJztcblxuLyoqXG4gKiBpZiB0aGUgd2luZG93IGV2ZW50cyBhcmUgc2V0Li4uXG4gKiBAcHJvcGVydHkgUkVBRFlcbiAqIEB3cml0ZU9uY2VcbiAqIEB0eXBlIHtCb29sZWFufVxuICogQGRlZmF1bHQgZmFsc2VcbiAqL1xuR2VzdHVyZURldGVjdG9yLlJFQURZID0gZmFsc2U7XG5cbi8qKlxuICogcGx1Z2lucyBuYW1lc3BhY2VcbiAqIEBwcm9wZXJ0eSBwbHVnaW5zXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG5HZXN0dXJlRGV0ZWN0b3IucGx1Z2lucyA9IEdlc3R1cmVEZXRlY3Rvci5wbHVnaW5zIHx8IHt9O1xuXG4vKipcbiAqIGdlc3R1cmVzIG5hbWVzcGFjZVxuICogc2VlIGAvZ2VzdHVyZXNgIGZvciB0aGUgZGVmaW5pdGlvbnNcbiAqIEBwcm9wZXJ0eSBnZXN0dXJlc1xuICogQHR5cGUge09iamVjdH1cbiAqL1xuR2VzdHVyZURldGVjdG9yLmdlc3R1cmVzID0gR2VzdHVyZURldGVjdG9yLmdlc3R1cmVzIHx8IHt9O1xuXG4vKipcbiAqIHNldHVwIGV2ZW50cyB0byBkZXRlY3QgZ2VzdHVyZXMgb24gdGhlIGRvY3VtZW50XG4gKiB0aGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCB3aGVuIGNyZWF0aW5nIGFuIG5ldyBpbnN0YW5jZVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gc2V0dXAob3B0cykge1xuICBpZiAoR2VzdHVyZURldGVjdG9yLlJFQURZKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gZmluZCB3aGF0IGV2ZW50dHlwZXMgd2UgYWRkIGxpc3RlbmVycyB0b1xuICBFdmVudC5kZXRlcm1pbmVFdmVudFR5cGVzKCk7XG5cbiAgLy8gUmVnaXN0ZXIgYWxsIGdlc3R1cmVzIGluc2lkZSBHZXN0dXJlRGV0ZWN0b3IuZ2VzdHVyZXNcbiAgVXRpbHMuZWFjaChHZXN0dXJlRGV0ZWN0b3IuZ2VzdHVyZXMsIGZ1bmN0aW9uKGdlc3R1cmUpIHtcbiAgICBEZXRlY3Rpb24ucmVnaXN0ZXIoZ2VzdHVyZSk7XG4gIH0pO1xuXG4gIC8vIEFkZCB0b3VjaCBldmVudHMgb24gdGhlIGRvY3VtZW50XG4gIEV2ZW50Lm9uVG91Y2goR2VzdHVyZURldGVjdG9yLkRPQ1VNRU5ULCBFVkVOVF9NT1ZFLCBEZXRlY3Rpb24uZGV0ZWN0LCBvcHRzKTtcbiAgRXZlbnQub25Ub3VjaChHZXN0dXJlRGV0ZWN0b3IuRE9DVU1FTlQsIEVWRU5UX0VORCwgRGV0ZWN0aW9uLmRldGVjdCwgb3B0cyk7XG5cbiAgLy8gR2VzdHVyZURldGVjdG9yIGlzIHJlYWR5Li4uIVxuICBHZXN0dXJlRGV0ZWN0b3IuUkVBRFkgPSB0cnVlO1xufVxuXG4vKipcbiAqIEBtb2R1bGUgR2VzdHVyZURldGVjdG9yXG4gKlxuICogQGNsYXNzIFV0aWxzXG4gKiBAc3RhdGljXG4gKi9cblV0aWxzID0gR2VzdHVyZURldGVjdG9yLnV0aWxzID0ge1xuICAvKipcbiAgICogZXh0ZW5kIG1ldGhvZCwgY291bGQgYWxzbyBiZSB1c2VkIGZvciBjbG9uaW5nIHdoZW4gYGRlc3RgIGlzIGFuIGVtcHR5IG9iamVjdC5cbiAgICogY2hhbmdlcyB0aGUgZGVzdCBvYmplY3RcbiAgICogQHBhcmFtIHtPYmplY3R9IGRlc3RcbiAgICogQHBhcmFtIHtPYmplY3R9IHNyY1xuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFttZXJnZT1mYWxzZV0gIGRvIGEgbWVyZ2VcbiAgICogQHJldHVybiB7T2JqZWN0fSBkZXN0XG4gICAqL1xuICBleHRlbmQ6IGZ1bmN0aW9uIGV4dGVuZChkZXN0LCBzcmMsIG1lcmdlKSB7XG4gICAgZm9yICh2YXIga2V5IGluIHNyYykge1xuICAgICAgaWYgKHNyYy5oYXNPd25Qcm9wZXJ0eShrZXkpICYmIChkZXN0W2tleV0gPT09IHVuZGVmaW5lZCB8fCAhbWVyZ2UpKSB7XG4gICAgICAgIGRlc3Rba2V5XSA9IHNyY1trZXldO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZGVzdDtcbiAgfSxcblxuICAvKipcbiAgICogc2ltcGxlIGFkZEV2ZW50TGlzdGVuZXIgd3JhcHBlclxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXJcbiAgICovXG4gIG9uOiBmdW5jdGlvbiBvbihlbGVtZW50LCB0eXBlLCBoYW5kbGVyLCBvcHQpIHtcbiAgICB1dGlsLmFkZEV2ZW50TGlzdGVuZXIoZWxlbWVudCwgdHlwZSwgaGFuZGxlciwgb3B0LCB0cnVlKTtcbiAgfSxcblxuICAvKipcbiAgICogc2ltcGxlIHJlbW92ZUV2ZW50TGlzdGVuZXIgd3JhcHBlclxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXJcbiAgICovXG4gIG9mZjogZnVuY3Rpb24gb2ZmKGVsZW1lbnQsIHR5cGUsIGhhbmRsZXIsIG9wdCkge1xuICAgIHV0aWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihlbGVtZW50LCB0eXBlLCBoYW5kbGVyLCBvcHQsIHRydWUpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBmb3JFYWNoIG92ZXIgYXJyYXlzIGFuZCBvYmplY3RzXG4gICAqIEBwYXJhbSB7T2JqZWN0fEFycmF5fSBvYmpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0b3JcbiAgICogQHBhcmFtIHthbnl9IGl0ZXJhdG9yLml0ZW1cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGl0ZXJhdG9yLmluZGV4XG4gICAqIEBwYXJhbSB7T2JqZWN0fEFycmF5fSBpdGVyYXRvci5vYmogdGhlIHNvdXJjZSBvYmplY3RcbiAgICogQHBhcmFtIHtPYmplY3R9IGNvbnRleHQgdmFsdWUgdG8gdXNlIGFzIGB0aGlzYCBpbiB0aGUgaXRlcmF0b3JcbiAgICovXG4gIGVhY2g6IGZ1bmN0aW9uIGVhY2gob2JqLCBpdGVyYXRvciwgY29udGV4dCkge1xuICAgIHZhciBpLCBsZW47XG5cbiAgICAvLyBuYXRpdmUgZm9yRWFjaCBvbiBhcnJheXNcbiAgICBpZiAoJ2ZvckVhY2gnIGluIG9iaikge1xuICAgICAgb2JqLmZvckVhY2goaXRlcmF0b3IsIGNvbnRleHQpO1xuICAgICAgLy8gYXJyYXlzXG4gICAgfSBlbHNlIGlmIChvYmoubGVuZ3RoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGZvciAoaSA9IDAsIGxlbiA9IG9iai5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBpZiAoaXRlcmF0b3IuY2FsbChjb250ZXh0LCBvYmpbaV0sIGksIG9iaikgPT09IGZhbHNlKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBvYmplY3RzXG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAoaSBpbiBvYmopIHtcbiAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShpKSAmJlxuICAgICAgICAgIGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgb2JqW2ldLCBpLCBvYmopID09PSBmYWxzZSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogZmluZCBpZiBhIHN0cmluZyBjb250YWlucyB0aGUgc3RyaW5nIHVzaW5nIGluZGV4T2ZcbiAgICogQHBhcmFtIHtTdHJpbmd9IHNyY1xuICAgKiBAcGFyYW0ge1N0cmluZ30gZmluZFxuICAgKiBAcmV0dXJuIHtCb29sZWFufSBmb3VuZFxuICAgKi9cbiAgaW5TdHI6IGZ1bmN0aW9uIGluU3RyKHNyYywgZmluZCkge1xuICAgIHJldHVybiBzcmMuaW5kZXhPZihmaW5kKSA+IC0xO1xuICB9LFxuXG4gIC8qKlxuICAgKiBmaW5kIGlmIGEgYXJyYXkgY29udGFpbnMgdGhlIG9iamVjdCB1c2luZyBpbmRleE9mIG9yIGEgc2ltcGxlIHBvbHlmaWxsXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzcmNcbiAgICogQHBhcmFtIHtTdHJpbmd9IGZpbmRcbiAgICogQHJldHVybiB7Qm9vbGVhbnxOdW1iZXJ9IGZhbHNlIHdoZW4gbm90IGZvdW5kLCBvciB0aGUgaW5kZXhcbiAgICovXG4gIGluQXJyYXk6IGZ1bmN0aW9uIGluQXJyYXkoc3JjLCBmaW5kLCBkZWVwKSB7XG4gICAgaWYgKGRlZXApIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBzcmMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHsgLy8gQXJyYXkuZmluZEluZGV4XG4gICAgICAgIGlmIChPYmplY3Qua2V5cyhmaW5kKS5ldmVyeShmdW5jdGlvbihrZXkpIHsgcmV0dXJuIHNyY1tpXVtrZXldID09PSBmaW5kW2tleV07IH0pKSB7XG4gICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG5cbiAgICBpZiAoc3JjLmluZGV4T2YpIHtcbiAgICAgIHJldHVybiBzcmMuaW5kZXhPZihmaW5kKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHNyYy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBpZiAoc3JjW2ldID09PSBmaW5kKSB7XG4gICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIGNvbnZlcnQgYW4gYXJyYXktbGlrZSBvYmplY3QgKGBhcmd1bWVudHNgLCBgdG91Y2hsaXN0YCkgdG8gYW4gYXJyYXlcbiAgICogQHBhcmFtIHtPYmplY3R9IG9ialxuICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICovXG4gIHRvQXJyYXk6IGZ1bmN0aW9uIHRvQXJyYXkob2JqKSB7XG4gICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKG9iaiwgMCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIGZpbmQgaWYgYSBub2RlIGlzIGluIHRoZSBnaXZlbiBwYXJlbnRcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gbm9kZVxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBwYXJlbnRcbiAgICogQHJldHVybiB7Qm9vbGVhbn0gZm91bmRcbiAgICovXG4gIGhhc1BhcmVudDogZnVuY3Rpb24gaGFzUGFyZW50KG5vZGUsIHBhcmVudCkge1xuICAgIHdoaWxlIChub2RlKSB7XG4gICAgICBpZiAobm9kZSA9PSBwYXJlbnQpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH0sXG5cbiAgLyoqXG4gICAqIGdldCB0aGUgY2VudGVyIG9mIGFsbCB0aGUgdG91Y2hlc1xuICAgKiBAcGFyYW0ge0FycmF5fSB0b3VjaGVzXG4gICAqIEByZXR1cm4ge09iamVjdH0gY2VudGVyIGNvbnRhaW5zIGBwYWdlWGAsIGBwYWdlWWAsIGBjbGllbnRYYCBhbmQgYGNsaWVudFlgIHByb3BlcnRpZXNcbiAgICovXG4gIGdldENlbnRlcjogZnVuY3Rpb24gZ2V0Q2VudGVyKHRvdWNoZXMpIHtcbiAgICB2YXIgcGFnZVggPSBbXSxcbiAgICAgICAgcGFnZVkgPSBbXSxcbiAgICAgICAgY2xpZW50WCA9IFtdLFxuICAgICAgICBjbGllbnRZID0gW10sXG4gICAgICAgIG1pbiA9IE1hdGgubWluLFxuICAgICAgICBtYXggPSBNYXRoLm1heDtcblxuICAgIC8vIG5vIG5lZWQgdG8gbG9vcCB3aGVuIG9ubHkgb25lIHRvdWNoXG4gICAgaWYgKHRvdWNoZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwYWdlWDogdG91Y2hlc1swXS5wYWdlWCxcbiAgICAgICAgcGFnZVk6IHRvdWNoZXNbMF0ucGFnZVksXG4gICAgICAgIGNsaWVudFg6IHRvdWNoZXNbMF0uY2xpZW50WCxcbiAgICAgICAgY2xpZW50WTogdG91Y2hlc1swXS5jbGllbnRZXG4gICAgICB9O1xuICAgIH1cblxuICAgIFV0aWxzLmVhY2godG91Y2hlcywgZnVuY3Rpb24odG91Y2gpIHtcbiAgICAgIHBhZ2VYLnB1c2godG91Y2gucGFnZVgpO1xuICAgICAgcGFnZVkucHVzaCh0b3VjaC5wYWdlWSk7XG4gICAgICBjbGllbnRYLnB1c2godG91Y2guY2xpZW50WCk7XG4gICAgICBjbGllbnRZLnB1c2godG91Y2guY2xpZW50WSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgcGFnZVg6IChtaW4uYXBwbHkoTWF0aCwgcGFnZVgpICsgbWF4LmFwcGx5KE1hdGgsIHBhZ2VYKSkgLyAyLFxuICAgICAgcGFnZVk6IChtaW4uYXBwbHkoTWF0aCwgcGFnZVkpICsgbWF4LmFwcGx5KE1hdGgsIHBhZ2VZKSkgLyAyLFxuICAgICAgY2xpZW50WDogKG1pbi5hcHBseShNYXRoLCBjbGllbnRYKSArIG1heC5hcHBseShNYXRoLCBjbGllbnRYKSkgLyAyLFxuICAgICAgY2xpZW50WTogKG1pbi5hcHBseShNYXRoLCBjbGllbnRZKSArIG1heC5hcHBseShNYXRoLCBjbGllbnRZKSkgLyAyXG4gICAgfTtcbiAgfSxcblxuICAvKipcbiAgICogY2FsY3VsYXRlIHRoZSB2ZWxvY2l0eSBiZXR3ZWVuIHR3byBwb2ludHMuIHVuaXQgaXMgaW4gcHggcGVyIG1zLlxuICAgKiBAcGFyYW0ge051bWJlcn0gZGVsdGFUaW1lXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBkZWx0YVhcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGRlbHRhWVxuICAgKiBAcmV0dXJuIHtPYmplY3R9IHZlbG9jaXR5IGB4YCBhbmQgYHlgXG4gICAqL1xuICBnZXRWZWxvY2l0eTogZnVuY3Rpb24gZ2V0VmVsb2NpdHkoZGVsdGFUaW1lLCBkZWx0YVgsIGRlbHRhWSkge1xuICAgIHJldHVybiB7XG4gICAgICB4OiBNYXRoLmFicyhkZWx0YVggLyBkZWx0YVRpbWUpIHx8IDAsXG4gICAgICB5OiBNYXRoLmFicyhkZWx0YVkgLyBkZWx0YVRpbWUpIHx8IDBcbiAgICB9O1xuICB9LFxuXG4gIC8qKlxuICAgKiBjYWxjdWxhdGUgdGhlIGFuZ2xlIGJldHdlZW4gdHdvIGNvb3JkaW5hdGVzXG4gICAqIEBwYXJhbSB7VG91Y2h9IHRvdWNoMVxuICAgKiBAcGFyYW0ge1RvdWNofSB0b3VjaDJcbiAgICogQHJldHVybiB7TnVtYmVyfSBhbmdsZVxuICAgKi9cbiAgZ2V0QW5nbGU6IGZ1bmN0aW9uIGdldEFuZ2xlKHRvdWNoMSwgdG91Y2gyKSB7XG4gICAgdmFyIHggPSB0b3VjaDIuY2xpZW50WCAtIHRvdWNoMS5jbGllbnRYLFxuICAgICAgICB5ID0gdG91Y2gyLmNsaWVudFkgLSB0b3VjaDEuY2xpZW50WTtcblxuICAgIHJldHVybiBNYXRoLmF0YW4yKHksIHgpICogMTgwIC8gTWF0aC5QSTtcbiAgfSxcblxuICAvKipcbiAgICogZG8gYSBzbWFsbCBjb21wYXJpc29uIHRvIGdldCB0aGUgZGlyZWN0aW9uIGJldHdlZW4gdHdvIHRvdWNoZXMuXG4gICAqIEBwYXJhbSB7VG91Y2h9IHRvdWNoMVxuICAgKiBAcGFyYW0ge1RvdWNofSB0b3VjaDJcbiAgICogQHJldHVybiB7U3RyaW5nfSBkaXJlY3Rpb24gbWF0Y2hlcyBgRElSRUNUSU9OX0xFRlR8UklHSFR8VVB8RE9XTmBcbiAgICovXG4gIGdldERpcmVjdGlvbjogZnVuY3Rpb24gZ2V0RGlyZWN0aW9uKHRvdWNoMSwgdG91Y2gyKSB7XG4gICAgdmFyIHggPSBNYXRoLmFicyh0b3VjaDEuY2xpZW50WCAtIHRvdWNoMi5jbGllbnRYKSxcbiAgICAgICAgeSA9IE1hdGguYWJzKHRvdWNoMS5jbGllbnRZIC0gdG91Y2gyLmNsaWVudFkpO1xuXG4gICAgaWYgKHggPj0geSkge1xuICAgICAgcmV0dXJuIHRvdWNoMS5jbGllbnRYIC0gdG91Y2gyLmNsaWVudFggPiAwID8gRElSRUNUSU9OX0xFRlQgOiBESVJFQ1RJT05fUklHSFQ7XG4gICAgfVxuICAgIHJldHVybiB0b3VjaDEuY2xpZW50WSAtIHRvdWNoMi5jbGllbnRZID4gMCA/IERJUkVDVElPTl9VUCA6IERJUkVDVElPTl9ET1dOO1xuICB9LFxuXG4gIC8qKlxuICAgKiBjYWxjdWxhdGUgdGhlIGRpc3RhbmNlIGJldHdlZW4gdHdvIHRvdWNoZXNcbiAgICogQHBhcmFtIHtUb3VjaH10b3VjaDFcbiAgICogQHBhcmFtIHtUb3VjaH0gdG91Y2gyXG4gICAqIEByZXR1cm4ge051bWJlcn0gZGlzdGFuY2VcbiAgICovXG4gIGdldERpc3RhbmNlOiBmdW5jdGlvbiBnZXREaXN0YW5jZSh0b3VjaDEsIHRvdWNoMikge1xuICAgIHZhciB4ID0gdG91Y2gyLmNsaWVudFggLSB0b3VjaDEuY2xpZW50WCxcbiAgICAgICAgeSA9IHRvdWNoMi5jbGllbnRZIC0gdG91Y2gxLmNsaWVudFk7XG5cbiAgICByZXR1cm4gTWF0aC5zcXJ0KCh4ICogeCkgKyAoeSAqIHkpKTtcbiAgfSxcblxuICAvKipcbiAgICogY2FsY3VsYXRlIHRoZSBzY2FsZSBmYWN0b3IgYmV0d2VlbiB0d28gdG91Y2hMaXN0c1xuICAgKiBubyBzY2FsZSBpcyAxLCBhbmQgZ29lcyBkb3duIHRvIDAgd2hlbiBwaW5jaGVkIHRvZ2V0aGVyLCBhbmQgYmlnZ2VyIHdoZW4gcGluY2hlZCBvdXRcbiAgICogQHBhcmFtIHtBcnJheX0gc3RhcnQgYXJyYXkgb2YgdG91Y2hlc1xuICAgKiBAcGFyYW0ge0FycmF5fSBlbmQgYXJyYXkgb2YgdG91Y2hlc1xuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IHNjYWxlXG4gICAqL1xuICBnZXRTY2FsZTogZnVuY3Rpb24gZ2V0U2NhbGUoc3RhcnQsIGVuZCkge1xuICAgIC8vIG5lZWQgdHdvIGZpbmdlcnMuLi5cbiAgICBpZiAoc3RhcnQubGVuZ3RoID49IDIgJiYgZW5kLmxlbmd0aCA+PSAyKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXREaXN0YW5jZShlbmRbMF0sIGVuZFsxXSkgLyB0aGlzLmdldERpc3RhbmNlKHN0YXJ0WzBdLCBzdGFydFsxXSk7XG4gICAgfVxuICAgIHJldHVybiAxO1xuICB9LFxuXG4gIC8qKlxuICAgKiBjYWxjdWxhdGUgdGhlIHJvdGF0aW9uIGRlZ3JlZXMgYmV0d2VlbiB0d28gdG91Y2hMaXN0c1xuICAgKiBAcGFyYW0ge0FycmF5fSBzdGFydCBhcnJheSBvZiB0b3VjaGVzXG4gICAqIEBwYXJhbSB7QXJyYXl9IGVuZCBhcnJheSBvZiB0b3VjaGVzXG4gICAqIEByZXR1cm4ge051bWJlcn0gcm90YXRpb25cbiAgICovXG4gIGdldFJvdGF0aW9uOiBmdW5jdGlvbiBnZXRSb3RhdGlvbihzdGFydCwgZW5kKSB7XG4gICAgLy8gbmVlZCB0d28gZmluZ2Vyc1xuICAgIGlmIChzdGFydC5sZW5ndGggPj0gMiAmJiBlbmQubGVuZ3RoID49IDIpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldEFuZ2xlKGVuZFsxXSwgZW5kWzBdKSAtIHRoaXMuZ2V0QW5nbGUoc3RhcnRbMV0sIHN0YXJ0WzBdKTtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH0sXG5cbiAgLyoqXG4gICAqIGZpbmQgb3V0IGlmIHRoZSBkaXJlY3Rpb24gaXMgdmVydGljYWwgICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBkaXJlY3Rpb24gbWF0Y2hlcyBgRElSRUNUSU9OX1VQfERPV05gXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IGlzX3ZlcnRpY2FsXG4gICAqL1xuICBpc1ZlcnRpY2FsOiBmdW5jdGlvbiBpc1ZlcnRpY2FsKGRpcmVjdGlvbikge1xuICAgIHJldHVybiBkaXJlY3Rpb24gPT0gRElSRUNUSU9OX1VQIHx8IGRpcmVjdGlvbiA9PSBESVJFQ1RJT05fRE9XTjtcbiAgfSxcblxuICAvKipcbiAgICogc2V0IGNzcyBwcm9wZXJ0aWVzIHdpdGggdGhlaXIgcHJlZml4ZXNcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcFxuICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAgICogQHBhcmFtIHtCb29sZWFufSBbdG9nZ2xlPXRydWVdXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuICBzZXRQcmVmaXhlZENzczogZnVuY3Rpb24gc2V0UHJlZml4ZWRDc3MoZWxlbWVudCwgcHJvcCwgdmFsdWUsIHRvZ2dsZSkge1xuICAgIHZhciBwcmVmaXhlcyA9IFsnJywgJ1dlYmtpdCcsICdNb3onLCAnTycsICdtcyddO1xuICAgIHByb3AgPSBVdGlscy50b0NhbWVsQ2FzZShwcm9wKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJlZml4ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBwID0gcHJvcDtcbiAgICAgIC8vIHByZWZpeGVzXG4gICAgICBpZiAocHJlZml4ZXNbaV0pIHtcbiAgICAgICAgcCA9IHByZWZpeGVzW2ldICsgcC5zbGljZSgwLCAxKS50b1VwcGVyQ2FzZSgpICsgcC5zbGljZSgxKTtcbiAgICAgIH1cblxuICAgICAgLy8gdGVzdCB0aGUgc3R5bGVcbiAgICAgIGlmIChwIGluIGVsZW1lbnQuc3R5bGUpIHtcbiAgICAgICAgZWxlbWVudC5zdHlsZVtwXSA9ICh0b2dnbGUgPT09IG51bGwgfHwgdG9nZ2xlKSAmJiB2YWx1ZSB8fCAnJztcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiB0b2dnbGUgYnJvd3NlciBkZWZhdWx0IGJlaGF2aW9yIGJ5IHNldHRpbmcgY3NzIHByb3BlcnRpZXMuXG4gICAqIGB1c2VyU2VsZWN0PSdub25lJ2AgYWxzbyBzZXRzIGBlbGVtZW50Lm9uc2VsZWN0c3RhcnRgIHRvIGZhbHNlXG4gICAqIGB1c2VyRHJhZz0nbm9uZSdgIGFsc28gc2V0cyBgZWxlbWVudC5vbmRyYWdzdGFydGAgdG8gZmFsc2VcbiAgICpcbiAgICogQHBhcmFtIHtIdG1sRWxlbWVudH0gZWxlbWVudFxuICAgKiBAcGFyYW0ge09iamVjdH0gcHJvcHNcbiAgICogQHBhcmFtIHtCb29sZWFufSBbdG9nZ2xlPXRydWVdXG4gICAqL1xuICB0b2dnbGVCZWhhdmlvcjogZnVuY3Rpb24gdG9nZ2xlQmVoYXZpb3IoZWxlbWVudCwgcHJvcHMsIHRvZ2dsZSkge1xuICAgIGlmICghcHJvcHMgfHwgIWVsZW1lbnQgfHwgIWVsZW1lbnQuc3R5bGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBzZXQgdGhlIGNzcyBwcm9wZXJ0aWVzXG4gICAgVXRpbHMuZWFjaChwcm9wcywgZnVuY3Rpb24odmFsdWUsIHByb3ApIHtcbiAgICAgIFV0aWxzLnNldFByZWZpeGVkQ3NzKGVsZW1lbnQsIHByb3AsIHZhbHVlLCB0b2dnbGUpO1xuICAgIH0pO1xuXG4gICAgdmFyIGZhbHNlRm4gPSB0b2dnbGUgJiYgZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcblxuICAgIC8vIGFsc28gdGhlIGRpc2FibGUgb25zZWxlY3RzdGFydFxuICAgIGlmIChwcm9wcy51c2VyU2VsZWN0ID09ICdub25lJykge1xuICAgICAgZWxlbWVudC5vbnNlbGVjdHN0YXJ0ID0gZmFsc2VGbjtcbiAgICB9XG4gICAgLy8gYW5kIGRpc2FibGUgb25kcmFnc3RhcnRcbiAgICBpZiAocHJvcHMudXNlckRyYWcgPT0gJ25vbmUnKSB7XG4gICAgICBlbGVtZW50Lm9uZHJhZ3N0YXJ0ID0gZmFsc2VGbjtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIGNvbnZlcnQgYSBzdHJpbmcgd2l0aCB1bmRlcnNjb3JlcyB0byBjYW1lbENhc2VcbiAgICogc28gcHJldmVudF9kZWZhdWx0IGJlY29tZXMgcHJldmVudERlZmF1bHRcbiAgICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICAgKiBAcmV0dXJuIHtTdHJpbmd9IGNhbWVsQ2FzZVN0clxuICAgKi9cbiAgdG9DYW1lbENhc2U6IGZ1bmN0aW9uIHRvQ2FtZWxDYXNlKHN0cikge1xuICAgIHJldHVybiBzdHIucmVwbGFjZSgvW18tXShbYS16XSkvZywgZnVuY3Rpb24ocykge1xuICAgICAgcmV0dXJuIHNbMV0udG9VcHBlckNhc2UoKTtcbiAgICB9KTtcbiAgfVxufTtcblxuXG4vKipcbiAqIEBtb2R1bGUgR2VzdHVyZURldGVjdG9yXG4gKi9cbi8qKlxuICogQGNsYXNzIEV2ZW50XG4gKiBAc3RhdGljXG4gKi9cbkV2ZW50ID0gR2VzdHVyZURldGVjdG9yLmV2ZW50ID0ge1xuICAvKipcbiAgICogd2hlbiB0b3VjaCBldmVudHMgaGF2ZSBiZWVuIGZpcmVkLCB0aGlzIGlzIHRydWVcbiAgICogdGhpcyBpcyB1c2VkIHRvIHN0b3AgbW91c2UgZXZlbnRzXG4gICAqIEBwcm9wZXJ0eSBwcmV2ZW50X21vdXNlZXZlbnRzXG4gICAqIEBwcml2YXRlXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKi9cbiAgcHJldmVudE1vdXNlRXZlbnRzOiBmYWxzZSxcblxuICAvKipcbiAgICogaWYgRVZFTlRfU1RBUlQgaGFzIGJlZW4gZmlyZWRcbiAgICogQHByb3BlcnR5IHN0YXJ0ZWRcbiAgICogQHByaXZhdGVcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqL1xuICBzdGFydGVkOiBmYWxzZSxcblxuICAvKipcbiAgICogd2hlbiB0aGUgbW91c2UgaXMgaG9sZCBkb3duLCB0aGlzIGlzIHRydWVcbiAgICogQHByb3BlcnR5IHNob3VsZF9kZXRlY3RcbiAgICogQHByaXZhdGVcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqL1xuICBzaG91bGREZXRlY3Q6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiBzaW1wbGUgZXZlbnQgYmluZGVyIHdpdGggYSBob29rIGFuZCBzdXBwb3J0IGZvciBtdWx0aXBsZSB0eXBlc1xuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXJcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRdXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtob29rXVxuICAgKiBAcGFyYW0ge09iamVjdH0gaG9vay50eXBlXG4gICAqL1xuICBvbjogZnVuY3Rpb24gb24oZWxlbWVudCwgdHlwZSwgaGFuZGxlciwgb3B0LCBob29rKSB7XG4gICAgdmFyIHR5cGVzID0gdHlwZS5zcGxpdCgnICcpO1xuICAgIFV0aWxzLmVhY2godHlwZXMsIGZ1bmN0aW9uKHR5cGUpIHtcbiAgICAgIFV0aWxzLm9uKGVsZW1lbnQsIHR5cGUsIGhhbmRsZXIsIG9wdCk7XG4gICAgICBob29rICYmIGhvb2sodHlwZSk7XG4gICAgfSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIHNpbXBsZSBldmVudCB1bmJpbmRlciB3aXRoIGEgaG9vayBhbmQgc3VwcG9ydCBmb3IgbXVsdGlwbGUgdHlwZXNcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0XVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaG9va11cbiAgICogQHBhcmFtIHtPYmplY3R9IGhvb2sudHlwZVxuICAgKi9cbiAgb2ZmOiBmdW5jdGlvbiBvZmYoZWxlbWVudCwgdHlwZSwgaGFuZGxlciwgb3B0LCBob29rKSB7XG4gICAgdmFyIHR5cGVzID0gdHlwZS5zcGxpdCgnICcpO1xuICAgIFV0aWxzLmVhY2godHlwZXMsIGZ1bmN0aW9uKHR5cGUpIHtcbiAgICAgIFV0aWxzLm9mZihlbGVtZW50LCB0eXBlLCBoYW5kbGVyLCBvcHQpO1xuICAgICAgaG9vayAmJiBob29rKHR5cGUpO1xuICAgIH0pO1xuICB9LFxuXG4gIC8qKlxuICAgKiB0aGUgY29yZSB0b3VjaCBldmVudCBoYW5kbGVyLlxuICAgKiB0aGlzIGZpbmRzIG91dCBpZiB3ZSBzaG91bGQgdG8gZGV0ZWN0IGdlc3R1cmVzXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50VHlwZSBtYXRjaGVzIGBFVkVOVF9TVEFSVHxNT1ZFfEVORGBcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlclxuICAgKiBAcmV0dXJuIG9uVG91Y2hIYW5kbGVyIHtGdW5jdGlvbn0gdGhlIGNvcmUgZXZlbnQgaGFuZGxlclxuICAgKi9cbiAgb25Ub3VjaDogZnVuY3Rpb24gb25Ub3VjaChlbGVtZW50LCBldmVudFR5cGUsIGhhbmRsZXIsIG9wdCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIHZhciBvblRvdWNoSGFuZGxlciA9IGZ1bmN0aW9uIG9uVG91Y2hIYW5kbGVyKGV2KSB7XG4gICAgICB2YXIgc3JjVHlwZSA9IGV2LnR5cGUudG9Mb3dlckNhc2UoKSxcbiAgICAgICAgICBpc1BvaW50ZXIgPSBHZXN0dXJlRGV0ZWN0b3IuSEFTX1BPSU5URVJFVkVOVFMsXG4gICAgICAgICAgaXNNb3VzZSA9IFV0aWxzLmluU3RyKHNyY1R5cGUsICdtb3VzZScpLFxuICAgICAgICAgIHRyaWdnZXJUeXBlO1xuXG4gICAgICAvLyBpZiB3ZSBhcmUgaW4gYSBtb3VzZWV2ZW50LCBidXQgdGhlcmUgaGFzIGJlZW4gYSB0b3VjaGV2ZW50IHRyaWdnZXJlZCBpbiB0aGlzIHNlc3Npb25cbiAgICAgIC8vIHdlIHdhbnQgdG8gZG8gbm90aGluZy4gc2ltcGx5IGJyZWFrIG91dCBvZiB0aGUgZXZlbnQuXG4gICAgICBpZiAoaXNNb3VzZSAmJiBzZWxmLnByZXZlbnRNb3VzZUV2ZW50cykge1xuICAgICAgICByZXR1cm47XG5cbiAgICAgICAgLy8gbW91c2VidXR0b24gbXVzdCBiZSBkb3duXG4gICAgICB9IGVsc2UgaWYgKGlzTW91c2UgJiYgZXZlbnRUeXBlID09IEVWRU5UX1NUQVJUICYmIGV2LmJ1dHRvbiA9PT0gMCkge1xuICAgICAgICBzZWxmLnByZXZlbnRNb3VzZUV2ZW50cyA9IGZhbHNlO1xuICAgICAgICBzZWxmLnNob3VsZERldGVjdCA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKGlzUG9pbnRlciAmJiBldmVudFR5cGUgPT0gRVZFTlRfU1RBUlQpIHtcbiAgICAgICAgc2VsZi5zaG91bGREZXRlY3QgPSAoZXYuYnV0dG9ucyA9PT0gMSB8fCBQb2ludGVyRXZlbnQubWF0Y2hUeXBlKFBPSU5URVJfVE9VQ0gsIGV2KSk7XG4gICAgICAgIC8vIGp1c3QgYSB2YWxpZCBzdGFydCBldmVudCwgYnV0IG5vIG1vdXNlXG4gICAgICB9IGVsc2UgaWYgKCFpc01vdXNlICYmIGV2ZW50VHlwZSA9PSBFVkVOVF9TVEFSVCkge1xuICAgICAgICBzZWxmLnByZXZlbnRNb3VzZUV2ZW50cyA9IHRydWU7XG4gICAgICAgIHNlbGYuc2hvdWxkRGV0ZWN0ID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgLy8gdXBkYXRlIHRoZSBwb2ludGVyIGV2ZW50IGJlZm9yZSBlbnRlcmluZyB0aGUgZGV0ZWN0aW9uXG4gICAgICBpZiAoaXNQb2ludGVyICYmIGV2ZW50VHlwZSAhPSBFVkVOVF9FTkQpIHtcbiAgICAgICAgUG9pbnRlckV2ZW50LnVwZGF0ZVBvaW50ZXIoZXZlbnRUeXBlLCBldik7XG4gICAgICB9XG5cbiAgICAgIC8vIHdlIGFyZSBpbiBhIHRvdWNoL2Rvd24gc3RhdGUsIHNvIGFsbG93ZWQgZGV0ZWN0aW9uIG9mIGdlc3R1cmVzXG4gICAgICBpZiAoc2VsZi5zaG91bGREZXRlY3QpIHtcbiAgICAgICAgdHJpZ2dlclR5cGUgPSBzZWxmLmRvRGV0ZWN0LmNhbGwoc2VsZiwgZXYsIGV2ZW50VHlwZSwgZWxlbWVudCwgaGFuZGxlcik7XG4gICAgICB9XG5cbiAgICAgIC8vIC4uLmFuZCB3ZSBhcmUgZG9uZSB3aXRoIHRoZSBkZXRlY3Rpb25cbiAgICAgIC8vIHNvIHJlc2V0IGV2ZXJ5dGhpbmcgdG8gc3RhcnQgZWFjaCBkZXRlY3Rpb24gdG90YWxseSBmcmVzaFxuICAgICAgaWYgKHRyaWdnZXJUeXBlID09IEVWRU5UX0VORCkge1xuICAgICAgICBzZWxmLnByZXZlbnRNb3VzZUV2ZW50cyA9IGZhbHNlO1xuICAgICAgICBzZWxmLnNob3VsZERldGVjdCA9IGZhbHNlO1xuICAgICAgICBQb2ludGVyRXZlbnQucmVzZXQoKTtcbiAgICAgICAgLy8gdXBkYXRlIHRoZSBwb2ludGVyZXZlbnQgb2JqZWN0IGFmdGVyIHRoZSBkZXRlY3Rpb25cbiAgICAgIH1cblxuICAgICAgaWYgKGlzUG9pbnRlciAmJiBldmVudFR5cGUgPT0gRVZFTlRfRU5EKSB7XG4gICAgICAgIFBvaW50ZXJFdmVudC51cGRhdGVQb2ludGVyKGV2ZW50VHlwZSwgZXYpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB0aGlzLm9uKGVsZW1lbnQsIEVWRU5UX1RZUEVTW2V2ZW50VHlwZV0sIG9uVG91Y2hIYW5kbGVyLCBvcHQpO1xuICAgIHJldHVybiBvblRvdWNoSGFuZGxlcjtcbiAgfSxcblxuICAvKipcbiAgICogdGhlIGNvcmUgZGV0ZWN0aW9uIG1ldGhvZFxuICAgKiB0aGlzIGZpbmRzIG91dCB3aGF0IEdlc3R1cmVEZXRlY3Rvci10b3VjaC1ldmVudHMgdG8gdHJpZ2dlclxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZcbiAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50VHlwZSBtYXRjaGVzIGBFVkVOVF9TVEFSVHxNT1ZFfEVORGBcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyXG4gICAqIEByZXR1cm4ge1N0cmluZ30gdHJpZ2dlclR5cGUgbWF0Y2hlcyBgRVZFTlRfU1RBUlR8TU9WRXxFTkRgXG4gICAqL1xuICBkb0RldGVjdDogZnVuY3Rpb24gZG9EZXRlY3QoZXYsIGV2ZW50VHlwZSwgZWxlbWVudCwgaGFuZGxlcikge1xuICAgIHZhciB0b3VjaExpc3QgPSB0aGlzLmdldFRvdWNoTGlzdChldiwgZXZlbnRUeXBlKTtcbiAgICB2YXIgdG91Y2hMaXN0TGVuZ3RoID0gdG91Y2hMaXN0Lmxlbmd0aDtcbiAgICB2YXIgdHJpZ2dlclR5cGUgPSBldmVudFR5cGU7XG4gICAgdmFyIHRyaWdnZXJDaGFuZ2UgPSB0b3VjaExpc3QudHJpZ2dlcjsgLy8gdXNlZCBieSBmYWtlTXVsdGl0b3VjaCBwbHVnaW5cbiAgICB2YXIgY2hhbmdlZExlbmd0aCA9IHRvdWNoTGlzdExlbmd0aDtcblxuICAgIC8vIGF0IGVhY2ggdG91Y2hzdGFydC1saWtlIGV2ZW50IHdlIHdhbnQgYWxzbyB3YW50IHRvIHRyaWdnZXIgYSBUT1VDSCBldmVudC4uLlxuICAgIGlmIChldmVudFR5cGUgPT0gRVZFTlRfU1RBUlQpIHtcbiAgICAgIHRyaWdnZXJDaGFuZ2UgPSBFVkVOVF9UT1VDSDtcbiAgICAgIC8vIC4uLnRoZSBzYW1lIGZvciBhIHRvdWNoZW5kLWxpa2UgZXZlbnRcbiAgICB9IGVsc2UgaWYgKGV2ZW50VHlwZSA9PSBFVkVOVF9FTkQpIHtcbiAgICAgIHRyaWdnZXJDaGFuZ2UgPSBFVkVOVF9SRUxFQVNFO1xuXG4gICAgICAvLyBrZWVwIHRyYWNrIG9mIGhvdyBtYW55IHRvdWNoZXMgaGF2ZSBiZWVuIHJlbW92ZWRcbiAgICAgIGNoYW5nZWRMZW5ndGggPSB0b3VjaExpc3QubGVuZ3RoIC0gKChldi5jaGFuZ2VkVG91Y2hlcykgPyBldi5jaGFuZ2VkVG91Y2hlcy5sZW5ndGggOiAxKTtcbiAgICB9XG5cbiAgICAvLyBhZnRlciB0aGVyZSBhcmUgc3RpbGwgdG91Y2hlcyBvbiB0aGUgc2NyZWVuLFxuICAgIC8vIHdlIGp1c3Qgd2FudCB0byB0cmlnZ2VyIGEgTU9WRSBldmVudC4gc28gY2hhbmdlIHRoZSBTVEFSVCBvciBFTkQgdG8gYSBNT1ZFXG4gICAgLy8gYnV0IG9ubHkgYWZ0ZXIgZGV0ZWN0aW9uIGhhcyBiZWVuIHN0YXJ0ZWQsIHRoZSBmaXJzdCB0aW1lIHdlIGFjdHVhbGx5IHdhbnQgYSBTVEFSVFxuICAgIGlmIChjaGFuZ2VkTGVuZ3RoID4gMCAmJiB0aGlzLnN0YXJ0ZWQpIHtcbiAgICAgIHRyaWdnZXJUeXBlID0gRVZFTlRfTU9WRTtcbiAgICB9XG5cbiAgICAvLyBkZXRlY3Rpb24gaGFzIGJlZW4gc3RhcnRlZCwgd2Uga2VlcCB0cmFjayBvZiB0aGlzLCBzZWUgYWJvdmVcbiAgICB0aGlzLnN0YXJ0ZWQgPSB0cnVlO1xuXG4gICAgLy8gZ2VuZXJhdGUgc29tZSBldmVudCBkYXRhLCBzb21lIGJhc2ljIGluZm9ybWF0aW9uXG4gICAgdmFyIGV2RGF0YSA9IHRoaXMuY29sbGVjdEV2ZW50RGF0YShlbGVtZW50LCB0cmlnZ2VyVHlwZSwgdG91Y2hMaXN0LCBldik7XG5cbiAgICAvLyB0cmlnZ2VyIHRoZSB0cmlnZ2VyVHlwZSBldmVudCBiZWZvcmUgdGhlIGNoYW5nZSAoVE9VQ0gsIFJFTEVBU0UpIGV2ZW50c1xuICAgIC8vIGJ1dCB0aGUgRU5EIGV2ZW50IHNob3VsZCBiZSBhdCBsYXN0XG4gICAgaWYgKGV2ZW50VHlwZSAhPSBFVkVOVF9FTkQpIHtcbiAgICAgIGhhbmRsZXIuY2FsbChEZXRlY3Rpb24sIGV2RGF0YSk7XG4gICAgfVxuXG4gICAgLy8gdHJpZ2dlciBhIGNoYW5nZSAoVE9VQ0gsIFJFTEVBU0UpIGV2ZW50LCB0aGlzIG1lYW5zIHRoZSBsZW5ndGggb2YgdGhlIHRvdWNoZXMgY2hhbmdlZFxuICAgIGlmICh0cmlnZ2VyQ2hhbmdlKSB7XG4gICAgICBldkRhdGEuY2hhbmdlZExlbmd0aCA9IGNoYW5nZWRMZW5ndGg7XG4gICAgICBldkRhdGEuZXZlbnRUeXBlID0gdHJpZ2dlckNoYW5nZTtcblxuICAgICAgaGFuZGxlci5jYWxsKERldGVjdGlvbiwgZXZEYXRhKTtcblxuICAgICAgZXZEYXRhLmV2ZW50VHlwZSA9IHRyaWdnZXJUeXBlO1xuICAgICAgZGVsZXRlIGV2RGF0YS5jaGFuZ2VkTGVuZ3RoO1xuICAgIH1cblxuICAgIC8vIHRyaWdnZXIgdGhlIEVORCBldmVudFxuICAgIGlmICh0cmlnZ2VyVHlwZSA9PSBFVkVOVF9FTkQpIHtcbiAgICAgIGhhbmRsZXIuY2FsbChEZXRlY3Rpb24sIGV2RGF0YSk7XG5cbiAgICAgIC8vIC4uLmFuZCB3ZSBhcmUgZG9uZSB3aXRoIHRoZSBkZXRlY3Rpb25cbiAgICAgIC8vIHNvIHJlc2V0IGV2ZXJ5dGhpbmcgdG8gc3RhcnQgZWFjaCBkZXRlY3Rpb24gdG90YWxseSBmcmVzaFxuICAgICAgdGhpcy5zdGFydGVkID0gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRyaWdnZXJUeXBlO1xuICB9LFxuXG4gIC8qKlxuICAgKiB3ZSBoYXZlIGRpZmZlcmVudCBldmVudHMgZm9yIGVhY2ggZGV2aWNlL2Jyb3dzZXJcbiAgICogZGV0ZXJtaW5lIHdoYXQgd2UgbmVlZCBhbmQgc2V0IHRoZW0gaW4gdGhlIEVWRU5UX1RZUEVTIGNvbnN0YW50XG4gICAqIHRoZSBgb25Ub3VjaGAgbWV0aG9kIGlzIGJpbmQgdG8gdGhlc2UgcHJvcGVydGllcy5cbiAgICogQHJldHVybiB7T2JqZWN0fSBldmVudHNcbiAgICovXG4gIGRldGVybWluZUV2ZW50VHlwZXM6IGZ1bmN0aW9uIGRldGVybWluZUV2ZW50VHlwZXMoKSB7XG4gICAgdmFyIHR5cGVzO1xuICAgIGlmIChHZXN0dXJlRGV0ZWN0b3IuSEFTX1BPSU5URVJFVkVOVFMpIHtcbiAgICAgIGlmICh3aW5kb3cuUG9pbnRlckV2ZW50KSB7XG4gICAgICAgIHR5cGVzID0gW1xuICAgICAgICAgICdwb2ludGVyZG93bicsXG4gICAgICAgICAgJ3BvaW50ZXJtb3ZlJyxcbiAgICAgICAgICAncG9pbnRlcnVwIHBvaW50ZXJjYW5jZWwgbG9zdHBvaW50ZXJjYXB0dXJlJ1xuICAgICAgICBdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHlwZXMgPSBbXG4gICAgICAgICAgJ01TUG9pbnRlckRvd24nLFxuICAgICAgICAgICdNU1BvaW50ZXJNb3ZlJyxcbiAgICAgICAgICAnTVNQb2ludGVyVXAgTVNQb2ludGVyQ2FuY2VsIE1TTG9zdFBvaW50ZXJDYXB0dXJlJ1xuICAgICAgICBdO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoR2VzdHVyZURldGVjdG9yLk5PX01PVVNFRVZFTlRTKSB7XG4gICAgICB0eXBlcyA9IFtcbiAgICAgICAgJ3RvdWNoc3RhcnQnLFxuICAgICAgICAndG91Y2htb3ZlJyxcbiAgICAgICAgJ3RvdWNoZW5kIHRvdWNoY2FuY2VsJ1xuICAgICAgXTtcbiAgICB9IGVsc2Uge1xuICAgICAgdHlwZXMgPSBbXG4gICAgICAgICd0b3VjaHN0YXJ0IG1vdXNlZG93bicsXG4gICAgICAgICd0b3VjaG1vdmUgbW91c2Vtb3ZlJyxcbiAgICAgICAgJ3RvdWNoZW5kIHRvdWNoY2FuY2VsIG1vdXNldXAnXG4gICAgICBdO1xuICAgIH1cblxuICAgIEVWRU5UX1RZUEVTW0VWRU5UX1NUQVJUXSA9IHR5cGVzWzBdO1xuICAgIEVWRU5UX1RZUEVTW0VWRU5UX01PVkVdID0gdHlwZXNbMV07XG4gICAgRVZFTlRfVFlQRVNbRVZFTlRfRU5EXSA9IHR5cGVzWzJdO1xuICAgIHJldHVybiBFVkVOVF9UWVBFUztcbiAgfSxcblxuICAvKipcbiAgICogY3JlYXRlIHRvdWNoTGlzdCBkZXBlbmRpbmcgb24gdGhlIGV2ZW50XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldlxuICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRUeXBlXG4gICAqIEByZXR1cm4ge0FycmF5fSB0b3VjaGVzXG4gICAqL1xuICBnZXRUb3VjaExpc3Q6IGZ1bmN0aW9uIGdldFRvdWNoTGlzdChldiwgZXZlbnRUeXBlKSB7XG4gICAgLy8gZ2V0IHRoZSBmYWtlIHBvaW50ZXJFdmVudCB0b3VjaGxpc3RcbiAgICBpZiAoR2VzdHVyZURldGVjdG9yLkhBU19QT0lOVEVSRVZFTlRTKSB7XG4gICAgICByZXR1cm4gUG9pbnRlckV2ZW50LmdldFRvdWNoTGlzdCgpO1xuICAgIH1cblxuICAgIC8vIGdldCB0aGUgdG91Y2hsaXN0XG4gICAgaWYgKGV2LnRvdWNoZXMpIHtcbiAgICAgIGlmIChldmVudFR5cGUgPT0gRVZFTlRfTU9WRSkge1xuICAgICAgICByZXR1cm4gZXYudG91Y2hlcztcbiAgICAgIH1cblxuICAgICAgdmFyIGlkZW50aWZpZXJzID0gW107XG4gICAgICB2YXIgY29uY2F0ID0gW10uY29uY2F0KFV0aWxzLnRvQXJyYXkoZXYudG91Y2hlcyksIFV0aWxzLnRvQXJyYXkoZXYuY2hhbmdlZFRvdWNoZXMpKTtcbiAgICAgIHZhciB0b3VjaExpc3QgPSBbXTtcblxuICAgICAgVXRpbHMuZWFjaChjb25jYXQsIGZ1bmN0aW9uKHRvdWNoKSB7XG4gICAgICAgIGlmIChVdGlscy5pbkFycmF5KGlkZW50aWZpZXJzLCB0b3VjaC5pZGVudGlmaWVyKSA9PT0gLTEpIHtcbiAgICAgICAgICB0b3VjaExpc3QucHVzaCh0b3VjaCk7XG4gICAgICAgIH1cbiAgICAgICAgaWRlbnRpZmllcnMucHVzaCh0b3VjaC5pZGVudGlmaWVyKTtcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gdG91Y2hMaXN0O1xuICAgIH1cblxuICAgIC8vIG1ha2UgZmFrZSB0b3VjaExpc3QgZnJvbSBtb3VzZSBwb3NpdGlvblxuICAgIGV2LmlkZW50aWZpZXIgPSAxO1xuICAgIHJldHVybiBbZXZdO1xuICB9LFxuXG4gIC8qKlxuICAgKiBjb2xsZWN0IGJhc2ljIGV2ZW50IGRhdGFcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRUeXBlIG1hdGNoZXMgYEVWRU5UX1NUQVJUfE1PVkV8RU5EYFxuICAgKiBAcGFyYW0ge0FycmF5fSB0b3VjaGVzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldlxuICAgKiBAcmV0dXJuIHtPYmplY3R9IGV2XG4gICAqL1xuICBjb2xsZWN0RXZlbnREYXRhOiBmdW5jdGlvbiBjb2xsZWN0RXZlbnREYXRhKGVsZW1lbnQsIGV2ZW50VHlwZSwgdG91Y2hlcywgZXYpIHtcbiAgICAvLyBmaW5kIG91dCBwb2ludGVyVHlwZVxuICAgIHZhciBwb2ludGVyVHlwZSA9IFBPSU5URVJfVE9VQ0g7XG4gICAgaWYgKFV0aWxzLmluU3RyKGV2LnR5cGUsICdtb3VzZScpIHx8IFBvaW50ZXJFdmVudC5tYXRjaFR5cGUoUE9JTlRFUl9NT1VTRSwgZXYpKSB7XG4gICAgICBwb2ludGVyVHlwZSA9IFBPSU5URVJfTU9VU0U7XG4gICAgfSBlbHNlIGlmIChQb2ludGVyRXZlbnQubWF0Y2hUeXBlKFBPSU5URVJfUEVOLCBldikpIHtcbiAgICAgIHBvaW50ZXJUeXBlID0gUE9JTlRFUl9QRU47XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGNlbnRlcjogVXRpbHMuZ2V0Q2VudGVyKHRvdWNoZXMpLFxuICAgICAgdGltZVN0YW1wOiBEYXRlLm5vdygpLFxuICAgICAgdGFyZ2V0OiBldi50YXJnZXQsXG4gICAgICB0b3VjaGVzOiB0b3VjaGVzLFxuICAgICAgZXZlbnRUeXBlOiBldmVudFR5cGUsXG4gICAgICBwb2ludGVyVHlwZTogcG9pbnRlclR5cGUsXG4gICAgICBzcmNFdmVudDogZXYsXG5cbiAgICAgIC8qKlxuICAgICAgICogcHJldmVudCB0aGUgYnJvd3NlciBkZWZhdWx0IGFjdGlvbnNcbiAgICAgICAqIG1vc3RseSB1c2VkIHRvIGRpc2FibGUgc2Nyb2xsaW5nIG9mIHRoZSBicm93c2VyXG4gICAgICAgKi9cbiAgICAgIHByZXZlbnREZWZhdWx0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHNyY0V2ZW50ID0gdGhpcy5zcmNFdmVudDtcbiAgICAgICAgc3JjRXZlbnQucHJldmVudE1hbmlwdWxhdGlvbiAmJiBzcmNFdmVudC5wcmV2ZW50TWFuaXB1bGF0aW9uKCk7XG4gICAgICAgIHNyY0V2ZW50LnByZXZlbnREZWZhdWx0ICYmIHNyY0V2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIHN0b3AgYnViYmxpbmcgdGhlIGV2ZW50IHVwIHRvIGl0cyBwYXJlbnRzXG4gICAgICAgKi9cbiAgICAgIHN0b3BQcm9wYWdhdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuc3JjRXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIGltbWVkaWF0ZWx5IHN0b3AgZ2VzdHVyZSBkZXRlY3Rpb25cbiAgICAgICAqIG1pZ2h0IGJlIHVzZWZ1bCBhZnRlciBhIHN3aXBlIHdhcyBkZXRlY3RlZFxuICAgICAgICogQHJldHVybiB7Kn1cbiAgICAgICAqL1xuICAgICAgc3RvcERldGVjdDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBEZXRlY3Rpb24uc3RvcERldGVjdCgpO1xuICAgICAgfVxuICAgIH07XG4gIH1cbn07XG5cblxuLyoqXG4gKiBAbW9kdWxlIEdlc3R1cmVEZXRlY3RvclxuICpcbiAqIEBjbGFzcyBQb2ludGVyRXZlbnRcbiAqIEBzdGF0aWNcbiAqL1xuUG9pbnRlckV2ZW50ID0gR2VzdHVyZURldGVjdG9yLlBvaW50ZXJFdmVudCA9IHtcbiAgLyoqXG4gICAqIGhvbGRzIGFsbCBwb2ludGVycywgYnkgYGlkZW50aWZpZXJgXG4gICAqIEBwcm9wZXJ0eSBwb2ludGVyc1xuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgcG9pbnRlcnM6IHt9LFxuXG4gIC8qKlxuICAgKiBnZXQgdGhlIHBvaW50ZXJzIGFzIGFuIGFycmF5XG4gICAqIEByZXR1cm4ge0FycmF5fSB0b3VjaGxpc3RcbiAgICovXG4gIGdldFRvdWNoTGlzdDogZnVuY3Rpb24gZ2V0VG91Y2hMaXN0KCkge1xuICAgIHZhciB0b3VjaGxpc3QgPSBbXTtcbiAgICAvLyB3ZSBjYW4gdXNlIGZvckVhY2ggc2luY2UgcG9pbnRlckV2ZW50cyBvbmx5IGlzIGluIElFMTBcbiAgICBVdGlscy5lYWNoKHRoaXMucG9pbnRlcnMsIGZ1bmN0aW9uKHBvaW50ZXIpIHtcbiAgICAgIHRvdWNobGlzdC5wdXNoKHBvaW50ZXIpO1xuICAgIH0pO1xuICAgIHJldHVybiB0b3VjaGxpc3Q7XG4gIH0sXG5cbiAgLyoqXG4gICAqIHVwZGF0ZSB0aGUgcG9zaXRpb24gb2YgYSBwb2ludGVyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFR5cGUgbWF0Y2hlcyBgRVZFTlRfU1RBUlR8TU9WRXxFTkRgXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwb2ludGVyRXZlbnRcbiAgICovXG4gIHVwZGF0ZVBvaW50ZXI6IGZ1bmN0aW9uIHVwZGF0ZVBvaW50ZXIoZXZlbnRUeXBlLCBwb2ludGVyRXZlbnQpIHtcbiAgICBpZiAoZXZlbnRUeXBlID09IEVWRU5UX0VORCB8fCAoZXZlbnRUeXBlICE9IEVWRU5UX0VORCAmJiBwb2ludGVyRXZlbnQuYnV0dG9ucyAhPT0gMSkpIHtcbiAgICAgIGRlbGV0ZSB0aGlzLnBvaW50ZXJzW3BvaW50ZXJFdmVudC5wb2ludGVySWRdO1xuICAgIH0gZWxzZSB7XG4gICAgICBwb2ludGVyRXZlbnQuaWRlbnRpZmllciA9IHBvaW50ZXJFdmVudC5wb2ludGVySWQ7XG4gICAgICB0aGlzLnBvaW50ZXJzW3BvaW50ZXJFdmVudC5wb2ludGVySWRdID0gcG9pbnRlckV2ZW50O1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogY2hlY2sgaWYgZXYgbWF0Y2hlcyBwb2ludGVydHlwZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gcG9pbnRlclR5cGUgbWF0Y2hlcyBgUE9JTlRFUl9NT1VTRXxUT1VDSHxQRU5gXG4gICAqIEBwYXJhbSB7UG9pbnRlckV2ZW50fSBldlxuICAgKi9cbiAgbWF0Y2hUeXBlOiBmdW5jdGlvbiBtYXRjaFR5cGUocG9pbnRlclR5cGUsIGV2KSB7XG4gICAgaWYgKCFldi5wb2ludGVyVHlwZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBwdCA9IGV2LnBvaW50ZXJUeXBlLFxuICAgICAgICB0eXBlcyA9IHt9O1xuXG4gICAgdHlwZXNbUE9JTlRFUl9NT1VTRV0gPSAocHQgPT09IChldi5NU1BPSU5URVJfVFlQRV9NT1VTRSB8fCBQT0lOVEVSX01PVVNFKSk7XG4gICAgdHlwZXNbUE9JTlRFUl9UT1VDSF0gPSAocHQgPT09IChldi5NU1BPSU5URVJfVFlQRV9UT1VDSCB8fCBQT0lOVEVSX1RPVUNIKSk7XG4gICAgdHlwZXNbUE9JTlRFUl9QRU5dID0gKHB0ID09PSAoZXYuTVNQT0lOVEVSX1RZUEVfUEVOIHx8IFBPSU5URVJfUEVOKSk7XG4gICAgcmV0dXJuIHR5cGVzW3BvaW50ZXJUeXBlXTtcbiAgfSxcblxuICAvKipcbiAgICogcmVzZXQgdGhlIHN0b3JlZCBwb2ludGVyc1xuICAgKi9cbiAgcmVzZXQ6IGZ1bmN0aW9uIHJlc2V0TGlzdCgpIHtcbiAgICB0aGlzLnBvaW50ZXJzID0ge307XG4gIH1cbn07XG5cblxuLyoqXG4gKiBAbW9kdWxlIEdlc3R1cmVEZXRlY3RvclxuICpcbiAqIEBjbGFzcyBEZXRlY3Rpb25cbiAqIEBzdGF0aWNcbiAqL1xuRGV0ZWN0aW9uID0gR2VzdHVyZURldGVjdG9yLmRldGVjdGlvbiA9IHtcbiAgLy8gY29udGFpbnMgYWxsIHJlZ2lzdGVyZWQgR2VzdHVyZURldGVjdG9yLmdlc3R1cmVzIGluIHRoZSBjb3JyZWN0IG9yZGVyXG4gIGdlc3R1cmVzOiBbXSxcblxuICAvLyBkYXRhIG9mIHRoZSBjdXJyZW50IEdlc3R1cmVEZXRlY3Rvci5nZXN0dXJlIGRldGVjdGlvbiBzZXNzaW9uXG4gIGN1cnJlbnQ6IG51bGwsXG5cbiAgLy8gdGhlIHByZXZpb3VzIEdlc3R1cmVEZXRlY3Rvci5nZXN0dXJlIHNlc3Npb24gZGF0YVxuICAvLyBpcyBhIGZ1bGwgY2xvbmUgb2YgdGhlIHByZXZpb3VzIGdlc3R1cmUuY3VycmVudCBvYmplY3RcbiAgcHJldmlvdXM6IG51bGwsXG5cbiAgLy8gd2hlbiB0aGlzIGJlY29tZXMgdHJ1ZSwgbm8gZ2VzdHVyZXMgYXJlIGZpcmVkXG4gIHN0b3BwZWQ6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiBzdGFydCBHZXN0dXJlRGV0ZWN0b3IuZ2VzdHVyZSBkZXRlY3Rpb25cbiAgICogQHBhcmFtIHtHZXN0dXJlRGV0ZWN0b3IuSW5zdGFuY2V9IGluc3RcbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50RGF0YVxuICAgKi9cbiAgc3RhcnREZXRlY3Q6IGZ1bmN0aW9uIHN0YXJ0RGV0ZWN0KGluc3QsIGV2ZW50RGF0YSkge1xuICAgIC8vIGFscmVhZHkgYnVzeSB3aXRoIGEgR2VzdHVyZURldGVjdG9yLmdlc3R1cmUgZGV0ZWN0aW9uIG9uIGFuIGVsZW1lbnRcbiAgICBpZiAodGhpcy5jdXJyZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5zdG9wcGVkID0gZmFsc2U7XG5cbiAgICAvLyBob2xkcyBjdXJyZW50IHNlc3Npb25cbiAgICB0aGlzLmN1cnJlbnQgPSB7XG4gICAgICBpbnN0OiBpbnN0LCAvLyByZWZlcmVuY2UgdG8gR2VzdHVyZURldGVjdG9ySW5zdGFuY2Ugd2UncmUgd29ya2luZyBmb3JcbiAgICAgIHN0YXJ0RXZlbnQ6IFV0aWxzLmV4dGVuZCh7fSwgZXZlbnREYXRhKSwgLy8gc3RhcnQgZXZlbnREYXRhIGZvciBkaXN0YW5jZXMsIHRpbWluZyBldGNcbiAgICAgIGxhc3RFdmVudDogZmFsc2UsIC8vIGxhc3QgZXZlbnREYXRhXG4gICAgICBsYXN0Q2FsY0V2ZW50OiBmYWxzZSwgLy8gbGFzdCBldmVudERhdGEgZm9yIGNhbGN1bGF0aW9ucy5cbiAgICAgIGZ1dHVyZUNhbGNFdmVudDogZmFsc2UsIC8vIGxhc3QgZXZlbnREYXRhIGZvciBjYWxjdWxhdGlvbnMuXG4gICAgICBsYXN0Q2FsY0RhdGE6IHt9LCAvLyBsYXN0IGxhc3RDYWxjRGF0YVxuICAgICAgbmFtZTogJycgLy8gY3VycmVudCBnZXN0dXJlIHdlJ3JlIGluL2RldGVjdGVkLCBjYW4gYmUgJ3RhcCcsICdob2xkJyBldGNcbiAgICB9O1xuXG4gICAgdGhpcy5kZXRlY3QoZXZlbnREYXRhKTtcbiAgfSxcblxuICAvKipcbiAgICogR2VzdHVyZURldGVjdG9yLmdlc3R1cmUgZGV0ZWN0aW9uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudERhdGFcbiAgICogQHJldHVybiB7YW55fVxuICAgKi9cbiAgZGV0ZWN0OiBmdW5jdGlvbiBkZXRlY3QoZXZlbnREYXRhKSB7XG4gICAgaWYgKCF0aGlzLmN1cnJlbnQgfHwgdGhpcy5zdG9wcGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gZXh0ZW5kIGV2ZW50IGRhdGEgd2l0aCBjYWxjdWxhdGlvbnMgYWJvdXQgc2NhbGUsIGRpc3RhbmNlIGV0Y1xuICAgIGV2ZW50RGF0YSA9IHRoaXMuZXh0ZW5kRXZlbnREYXRhKGV2ZW50RGF0YSk7XG5cbiAgICAvLyBHZXN0dXJlRGV0ZWN0b3IgaW5zdGFuY2UgYW5kIGluc3RhbmNlIG9wdGlvbnNcbiAgICB2YXIgaW5zdCA9IHRoaXMuY3VycmVudC5pbnN0LFxuICAgICAgICBpbnN0T3B0aW9ucyA9IGluc3Qub3B0aW9ucztcblxuICAgIC8vIGNhbGwgR2VzdHVyZURldGVjdG9yLmdlc3R1cmUgaGFuZGxlcnNcbiAgICBVdGlscy5lYWNoKHRoaXMuZ2VzdHVyZXMsIGZ1bmN0aW9uIHRyaWdnZXJHZXN0dXJlKGdlc3R1cmUpIHtcbiAgICAgIC8vIG9ubHkgd2hlbiB0aGUgaW5zdGFuY2Ugb3B0aW9ucyBoYXZlIGVuYWJsZWQgdGhpcyBnZXN0dXJlXG4gICAgICBpZiAoIXRoaXMuc3RvcHBlZCAmJiBpbnN0LmVuYWJsZWQgJiYgaW5zdE9wdGlvbnNbZ2VzdHVyZS5uYW1lXSkge1xuICAgICAgICBnZXN0dXJlLmhhbmRsZXIuY2FsbChnZXN0dXJlLCBldmVudERhdGEsIGluc3QpO1xuICAgICAgfVxuICAgIH0sIHRoaXMpO1xuXG4gICAgLy8gc3RvcmUgYXMgcHJldmlvdXMgZXZlbnQgZXZlbnRcbiAgICBpZiAodGhpcy5jdXJyZW50KSB7XG4gICAgICB0aGlzLmN1cnJlbnQubGFzdEV2ZW50ID0gZXZlbnREYXRhO1xuICAgIH1cblxuICAgIGlmIChldmVudERhdGEuZXZlbnRUeXBlID09IEVWRU5UX0VORCkge1xuICAgICAgdGhpcy5zdG9wRGV0ZWN0KCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGV2ZW50RGF0YTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBjb25zaXN0ZW50LXJldHVyblxuICB9LFxuXG4gIC8qKlxuICAgKiBjbGVhciB0aGUgR2VzdHVyZURldGVjdG9yLmdlc3R1cmUgdmFyc1xuICAgKiB0aGlzIGlzIGNhbGxlZCBvbiBlbmREZXRlY3QsIGJ1dCBjYW4gYWxzbyBiZSB1c2VkIHdoZW4gYSBmaW5hbCBHZXN0dXJlRGV0ZWN0b3IuZ2VzdHVyZSBoYXMgYmVlbiBkZXRlY3RlZFxuICAgKiB0byBzdG9wIG90aGVyIEdlc3R1cmVEZXRlY3Rvci5nZXN0dXJlcyBmcm9tIGJlaW5nIGZpcmVkXG4gICAqL1xuICBzdG9wRGV0ZWN0OiBmdW5jdGlvbiBzdG9wRGV0ZWN0KCkge1xuICAgIC8vIGNsb25lIGN1cnJlbnQgZGF0YSB0byB0aGUgc3RvcmUgYXMgdGhlIHByZXZpb3VzIGdlc3R1cmVcbiAgICAvLyB1c2VkIGZvciB0aGUgZG91YmxlIHRhcCBnZXN0dXJlLCBzaW5jZSB0aGlzIGlzIGFuIG90aGVyIGdlc3R1cmUgZGV0ZWN0IHNlc3Npb25cbiAgICB0aGlzLnByZXZpb3VzID0gVXRpbHMuZXh0ZW5kKHt9LCB0aGlzLmN1cnJlbnQpO1xuXG4gICAgLy8gcmVzZXQgdGhlIGN1cnJlbnRcbiAgICB0aGlzLmN1cnJlbnQgPSBudWxsO1xuICAgIHRoaXMuc3RvcHBlZCA9IHRydWU7XG4gIH0sXG5cbiAgLyoqXG4gICAqIGNhbGN1bGF0ZSB2ZWxvY2l0eSwgYW5nbGUgYW5kIGRpcmVjdGlvblxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZcbiAgICogQHBhcmFtIHtPYmplY3R9IGNlbnRlclxuICAgKiBAcGFyYW0ge051bWJlcn0gZGVsdGFUaW1lXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBkZWx0YVhcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGRlbHRhWVxuICAgKi9cbiAgZ2V0Q2FsY3VsYXRlZERhdGE6IGZ1bmN0aW9uIGdldENhbGN1bGF0ZWREYXRhKGV2LCBjZW50ZXIsIGRlbHRhVGltZSwgZGVsdGFYLCBkZWx0YVkpIHtcbiAgICB2YXIgY3VyID0gdGhpcy5jdXJyZW50LFxuICAgICAgICByZWNhbGMgPSBmYWxzZSxcbiAgICAgICAgY2FsY0V2ID0gY3VyLmxhc3RDYWxjRXZlbnQsXG4gICAgICAgIGNhbGNEYXRhID0gY3VyLmxhc3RDYWxjRGF0YTtcblxuICAgIGlmIChjYWxjRXYgJiYgZXYudGltZVN0YW1wIC0gY2FsY0V2LnRpbWVTdGFtcCA+IEdlc3R1cmVEZXRlY3Rvci5DQUxDVUxBVEVfSU5URVJWQUwpIHtcbiAgICAgIGNlbnRlciA9IGNhbGNFdi5jZW50ZXI7XG4gICAgICBkZWx0YVRpbWUgPSBldi50aW1lU3RhbXAgLSBjYWxjRXYudGltZVN0YW1wO1xuICAgICAgZGVsdGFYID0gZXYuY2VudGVyLmNsaWVudFggLSBjYWxjRXYuY2VudGVyLmNsaWVudFg7XG4gICAgICBkZWx0YVkgPSBldi5jZW50ZXIuY2xpZW50WSAtIGNhbGNFdi5jZW50ZXIuY2xpZW50WTtcbiAgICAgIHJlY2FsYyA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKGV2LmV2ZW50VHlwZSA9PSBFVkVOVF9UT1VDSCB8fCBldi5ldmVudFR5cGUgPT0gRVZFTlRfUkVMRUFTRSkge1xuICAgICAgY3VyLmZ1dHVyZUNhbGNFdmVudCA9IGV2O1xuICAgIH1cblxuICAgIGlmICghY3VyLmxhc3RDYWxjRXZlbnQgfHwgcmVjYWxjKSB7XG4gICAgICBjYWxjRGF0YS52ZWxvY2l0eSA9IFV0aWxzLmdldFZlbG9jaXR5KGRlbHRhVGltZSwgZGVsdGFYLCBkZWx0YVkpO1xuICAgICAgY2FsY0RhdGEuYW5nbGUgPSBVdGlscy5nZXRBbmdsZShjZW50ZXIsIGV2LmNlbnRlcik7XG4gICAgICBjYWxjRGF0YS5kaXJlY3Rpb24gPSBVdGlscy5nZXREaXJlY3Rpb24oY2VudGVyLCBldi5jZW50ZXIpO1xuXG4gICAgICBjdXIubGFzdENhbGNFdmVudCA9IGN1ci5mdXR1cmVDYWxjRXZlbnQgfHwgZXY7XG4gICAgICBjdXIuZnV0dXJlQ2FsY0V2ZW50ID0gZXY7XG4gICAgfVxuXG4gICAgZXYudmVsb2NpdHlYID0gY2FsY0RhdGEudmVsb2NpdHkueDtcbiAgICBldi52ZWxvY2l0eVkgPSBjYWxjRGF0YS52ZWxvY2l0eS55O1xuICAgIGV2LmludGVyaW1BbmdsZSA9IGNhbGNEYXRhLmFuZ2xlO1xuICAgIGV2LmludGVyaW1EaXJlY3Rpb24gPSBjYWxjRGF0YS5kaXJlY3Rpb247XG4gIH0sXG5cbiAgLyoqXG4gICAqIGV4dGVuZCBldmVudERhdGEgZm9yIEdlc3R1cmVEZXRlY3Rvci5nZXN0dXJlc1xuICAgKiBAcGFyYW0ge09iamVjdH0gZXZcbiAgICogQHJldHVybiB7T2JqZWN0fSBldlxuICAgKi9cbiAgZXh0ZW5kRXZlbnREYXRhOiBmdW5jdGlvbiBleHRlbmRFdmVudERhdGEoZXYpIHtcbiAgICB2YXIgY3VyID0gdGhpcy5jdXJyZW50LFxuICAgICAgICBzdGFydEV2ID0gY3VyLnN0YXJ0RXZlbnQsXG4gICAgICAgIGxhc3RFdiA9IGN1ci5sYXN0RXZlbnQgfHwgc3RhcnRFdjtcblxuICAgIC8vIHVwZGF0ZSB0aGUgc3RhcnQgdG91Y2hsaXN0IHRvIGNhbGN1bGF0ZSB0aGUgc2NhbGUvcm90YXRpb25cbiAgICBpZiAoZXYuZXZlbnRUeXBlID09IEVWRU5UX1RPVUNIIHx8IGV2LmV2ZW50VHlwZSA9PSBFVkVOVF9SRUxFQVNFKSB7XG4gICAgICBzdGFydEV2LnRvdWNoZXMgPSBbXTtcbiAgICAgIFV0aWxzLmVhY2goZXYudG91Y2hlcywgZnVuY3Rpb24odG91Y2gpIHtcbiAgICAgICAgc3RhcnRFdi50b3VjaGVzLnB1c2goe1xuICAgICAgICAgIGNsaWVudFg6IHRvdWNoLmNsaWVudFgsXG4gICAgICAgICAgY2xpZW50WTogdG91Y2guY2xpZW50WVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHZhciBkZWx0YVRpbWUgPSBldi50aW1lU3RhbXAgLSBzdGFydEV2LnRpbWVTdGFtcCxcbiAgICAgICAgZGVsdGFYID0gZXYuY2VudGVyLmNsaWVudFggLSBzdGFydEV2LmNlbnRlci5jbGllbnRYLFxuICAgICAgICBkZWx0YVkgPSBldi5jZW50ZXIuY2xpZW50WSAtIHN0YXJ0RXYuY2VudGVyLmNsaWVudFk7XG5cbiAgICB0aGlzLmdldENhbGN1bGF0ZWREYXRhKGV2LCBsYXN0RXYuY2VudGVyLCBkZWx0YVRpbWUsIGRlbHRhWCwgZGVsdGFZKTtcblxuICAgIFV0aWxzLmV4dGVuZChldiwge1xuICAgICAgc3RhcnRFdmVudDogc3RhcnRFdixcblxuICAgICAgZGVsdGFUaW1lOiBkZWx0YVRpbWUsXG4gICAgICBkZWx0YVg6IGRlbHRhWCxcbiAgICAgIGRlbHRhWTogZGVsdGFZLFxuXG4gICAgICBkaXN0YW5jZTogVXRpbHMuZ2V0RGlzdGFuY2Uoc3RhcnRFdi5jZW50ZXIsIGV2LmNlbnRlciksXG4gICAgICBhbmdsZTogVXRpbHMuZ2V0QW5nbGUoc3RhcnRFdi5jZW50ZXIsIGV2LmNlbnRlciksXG4gICAgICBkaXJlY3Rpb246IFV0aWxzLmdldERpcmVjdGlvbihzdGFydEV2LmNlbnRlciwgZXYuY2VudGVyKSxcbiAgICAgIHNjYWxlOiBVdGlscy5nZXRTY2FsZShzdGFydEV2LnRvdWNoZXMsIGV2LnRvdWNoZXMpLFxuICAgICAgcm90YXRpb246IFV0aWxzLmdldFJvdGF0aW9uKHN0YXJ0RXYudG91Y2hlcywgZXYudG91Y2hlcylcbiAgICB9KTtcblxuICAgIHJldHVybiBldjtcbiAgfSxcblxuICAvKipcbiAgICogcmVnaXN0ZXIgbmV3IGdlc3R1cmVcbiAgICogQHBhcmFtIHtPYmplY3R9IGdlc3R1cmUgb2JqZWN0LCBzZWUgYGdlc3R1cmVzL2AgZm9yIGRvY3VtZW50YXRpb25cbiAgICogQHJldHVybiB7QXJyYXl9IGdlc3R1cmVzXG4gICAqL1xuICByZWdpc3RlcjogZnVuY3Rpb24gcmVnaXN0ZXIoZ2VzdHVyZSkge1xuICAgIC8vIGFkZCBhbiBlbmFibGUgZ2VzdHVyZSBvcHRpb25zIGlmIHRoZXJlIGlzIG5vIGdpdmVuXG4gICAgdmFyIG9wdGlvbnMgPSBnZXN0dXJlLmRlZmF1bHRzIHx8IHt9O1xuICAgIGlmIChvcHRpb25zW2dlc3R1cmUubmFtZV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgb3B0aW9uc1tnZXN0dXJlLm5hbWVdID0gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBleHRlbmQgR2VzdHVyZURldGVjdG9yIGRlZmF1bHQgb3B0aW9ucyB3aXRoIHRoZSBHZXN0dXJlRGV0ZWN0b3IuZ2VzdHVyZSBvcHRpb25zXG4gICAgVXRpbHMuZXh0ZW5kKEdlc3R1cmVEZXRlY3Rvci5kZWZhdWx0cywgb3B0aW9ucywgdHJ1ZSk7XG5cbiAgICAvLyBzZXQgaXRzIGluZGV4XG4gICAgZ2VzdHVyZS5pbmRleCA9IGdlc3R1cmUuaW5kZXggfHwgMTAwMDtcblxuICAgIC8vIGFkZCBHZXN0dXJlRGV0ZWN0b3IuZ2VzdHVyZSB0byB0aGUgbGlzdFxuICAgIHRoaXMuZ2VzdHVyZXMucHVzaChnZXN0dXJlKTtcblxuICAgIC8vIHNvcnQgdGhlIGxpc3QgYnkgaW5kZXhcbiAgICB0aGlzLmdlc3R1cmVzLnNvcnQoZnVuY3Rpb24oYSwgYikge1xuICAgICAgaWYgKGEuaW5kZXggPCBiLmluZGV4KSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH1cbiAgICAgIGlmIChhLmluZGV4ID4gYi5pbmRleCkge1xuICAgICAgICByZXR1cm4gMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAwO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRoaXMuZ2VzdHVyZXM7XG4gIH1cbn07XG5cblxuLyoqXG4gKiBAbW9kdWxlIEdlc3R1cmVEZXRlY3RvclxuICovXG5cbi8qKlxuICogY3JlYXRlIG5ldyBHZXN0dXJlRGV0ZWN0b3IgaW5zdGFuY2VcbiAqIGFsbCBtZXRob2RzIHNob3VsZCByZXR1cm4gdGhlIGluc3RhbmNlIGl0c2VsZiwgc28gaXQgaXMgY2hhaW5hYmxlLlxuICpcbiAqIEBjbGFzcyBJbnN0YW5jZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIG9wdGlvbnMgYXJlIG1lcmdlZCB3aXRoIGBHZXN0dXJlRGV0ZWN0b3IuZGVmYXVsdHNgXG4gKiBAcmV0dXJuIHtHZXN0dXJlRGV0ZWN0b3IuSW5zdGFuY2V9XG4gKi9cbkdlc3R1cmVEZXRlY3Rvci5JbnN0YW5jZSA9IGZ1bmN0aW9uKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgbGlzdGVuZXJPcHRpb25zID0gKG9wdGlvbnMgJiYgb3B0aW9ucy5wYXNzaXZlKSA/IHsgcGFzc2l2ZTogdHJ1ZSB9IDogdW5kZWZpbmVkO1xuXG4gIC8vIHNldHVwIEdlc3R1cmVEZXRlY3RvckpTIHdpbmRvdyBldmVudHMgYW5kIHJlZ2lzdGVyIGFsbCBnZXN0dXJlc1xuICAvLyB0aGlzIGFsc28gc2V0cyB1cCB0aGUgZGVmYXVsdCBvcHRpb25zXG4gIHNldHVwKGxpc3RlbmVyT3B0aW9ucyk7XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBlbGVtZW50XG4gICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cbiAgICovXG4gIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBlbmFibGVkXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICB0aGlzLmVuYWJsZWQgPSB0cnVlO1xuXG4gIC8qKlxuICAgKiBvcHRpb25zLCBtZXJnZWQgd2l0aCB0aGUgZGVmYXVsdHNcbiAgICogb3B0aW9ucyB3aXRoIGFuIF8gYXJlIGNvbnZlcnRlZCB0byBjYW1lbENhc2VcbiAgICogQHByb3BlcnR5IG9wdGlvbnNcbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIFV0aWxzLmVhY2gob3B0aW9ucywgZnVuY3Rpb24odmFsdWUsIG5hbWUpIHtcbiAgICBkZWxldGUgb3B0aW9uc1tuYW1lXTtcbiAgICBvcHRpb25zW1V0aWxzLnRvQ2FtZWxDYXNlKG5hbWUpXSA9IHZhbHVlO1xuICB9KTtcblxuICB0aGlzLm9wdGlvbnMgPSBVdGlscy5leHRlbmQoVXRpbHMuZXh0ZW5kKHt9LCBHZXN0dXJlRGV0ZWN0b3IuZGVmYXVsdHMpLCBvcHRpb25zIHx8IHt9KTtcbiAgdGhpcy5vcHRpb25zLmxpc3RlbmVyT3B0aW9ucyA9IGxpc3RlbmVyT3B0aW9ucztcblxuICAvLyBhZGQgc29tZSBjc3MgdG8gdGhlIGVsZW1lbnQgdG8gcHJldmVudCB0aGUgYnJvd3NlciBmcm9tIGRvaW5nIGl0cyBuYXRpdmUgYmVoYXZpb3JcbiAgaWYgKHRoaXMub3B0aW9ucy5iZWhhdmlvcikge1xuICAgIFV0aWxzLnRvZ2dsZUJlaGF2aW9yKHRoaXMuZWxlbWVudCwgdGhpcy5vcHRpb25zLmJlaGF2aW9yLCB0cnVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBldmVudCBzdGFydCBoYW5kbGVyIG9uIHRoZSBlbGVtZW50IHRvIHN0YXJ0IHRoZSBkZXRlY3Rpb25cbiAgICogQHByb3BlcnR5IGV2ZW50U3RhcnRIYW5kbGVyXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICB0aGlzLmV2ZW50U3RhcnRIYW5kbGVyID0gRXZlbnQub25Ub3VjaChlbGVtZW50LCBFVkVOVF9TVEFSVCwgZnVuY3Rpb24oZXYpIHtcbiAgICBpZiAoc2VsZi5lbmFibGVkICYmIGV2LmV2ZW50VHlwZSA9PSBFVkVOVF9TVEFSVCkge1xuICAgICAgRGV0ZWN0aW9uLnN0YXJ0RGV0ZWN0KHNlbGYsIGV2KTtcbiAgICB9IGVsc2UgaWYgKGV2LmV2ZW50VHlwZSA9PSBFVkVOVF9UT1VDSCkge1xuICAgICAgRGV0ZWN0aW9uLmRldGVjdChldik7XG4gICAgfVxuICB9LCBsaXN0ZW5lck9wdGlvbnMpO1xuXG4gIC8qKlxuICAgKiBrZWVwIGEgbGlzdCBvZiB1c2VyIGV2ZW50IGhhbmRsZXJzIHdoaWNoIG5lZWRzIHRvIGJlIHJlbW92ZWQgd2hlbiBjYWxsaW5nICdkaXNwb3NlJ1xuICAgKiBAcHJvcGVydHkgZXZlbnRIYW5kbGVyc1xuICAgKiBAdHlwZSB7QXJyYXl9XG4gICAqL1xuICB0aGlzLmV2ZW50SGFuZGxlcnMgPSBbXTtcbn07XG5cbkdlc3R1cmVEZXRlY3Rvci5JbnN0YW5jZS5wcm90b3R5cGUgPSB7XG4gIC8qKlxuICAgKiBAbWV0aG9kIG9uXG4gICAqIEBzaWduYXR1cmUgb24oZ2VzdHVyZXMsIGhhbmRsZXIpXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXUFkZHMgYW4gZXZlbnQgaGFuZGxlciBmb3IgYSBnZXN0dXJlLiBBdmFpbGFibGUgZ2VzdHVyZXMgYXJlOiBkcmFnLCBkcmFnbGVmdCwgZHJhZ3JpZ2h0LCBkcmFndXAsIGRyYWdkb3duLCBob2xkLCByZWxlYXNlLCBzd2lwZSwgc3dpcGVsZWZ0LCBzd2lwZXJpZ2h0LCBzd2lwZXVwLCBzd2lwZWRvd24sIHRhcCwgZG91YmxldGFwLCB0b3VjaCwgdHJhbnNmb3JtLCBwaW5jaCwgcGluY2hpbiwgcGluY2hvdXQgYW5kIHJvdGF0ZS4gWy9lbl1cbiAgICogIFtqYV3jgrjjgqfjgrnjg4Hjg6Pjgavlr77jgZnjgovjgqTjg5njg7Pjg4jjg4/jg7Pjg4njg6njgpLov73liqDjgZfjgb7jgZnjgILmjIflrprjgafjgY3jgovjgrjjgqfjgrnjg4Hjg6PlkI3jga/jgIFkcmFnIGRyYWdsZWZ0IGRyYWdyaWdodCBkcmFndXAgZHJhZ2Rvd24gaG9sZCByZWxlYXNlIHN3aXBlIHN3aXBlbGVmdCBzd2lwZXJpZ2h0IHN3aXBldXAgc3dpcGVkb3duIHRhcCBkb3VibGV0YXAgdG91Y2ggdHJhbnNmb3JtIHBpbmNoIHBpbmNoaW4gcGluY2hvdXQgcm90YXRlIOOBp+OBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBnZXN0dXJlc1xuICAgKiAgIFtlbl1BIHNwYWNlIHNlcGFyYXRlZCBsaXN0IG9mIGdlc3R1cmVzLlsvZW5dXG4gICAqICAgW2phXeaknOefpeOBmeOCi+OCuOOCp+OCueODgeODo+WQjeOCkuaMh+WumuOBl+OBvuOBmeOAguOCueODmuODvOOCueOBp+ikh+aVsOaMh+WumuOBmeOCi+OBk+OBqOOBjOOBp+OBjeOBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXJcbiAgICogICBbZW5dQW4gZXZlbnQgaGFuZGxpbmcgZnVuY3Rpb24uWy9lbl1cbiAgICogICBbamFd44Kk44OZ44Oz44OI44OP44Oz44OJ44Op44Go44Gq44KL6Zai5pWw44Kq44OW44K444Kn44Kv44OI44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICovXG4gIG9uOiBmdW5jdGlvbiBvbkV2ZW50KGdlc3R1cmVzLCBoYW5kbGVyLCBvcHQpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICBFdmVudC5vbihzZWxmLmVsZW1lbnQsIGdlc3R1cmVzLCBoYW5kbGVyLCB1dGlsLmV4dGVuZCh7fSwgc2VsZi5vcHRpb25zLmxpc3RlbmVyT3B0aW9ucywgb3B0KSwgZnVuY3Rpb24odHlwZSkge1xuICAgICAgc2VsZi5ldmVudEhhbmRsZXJzLnB1c2goeyBnZXN0dXJlOiB0eXBlLCBoYW5kbGVyOiBoYW5kbGVyIH0pO1xuICAgIH0pO1xuICAgIHJldHVybiBzZWxmO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIG9mZlxuICAgKiBAc2lnbmF0dXJlIG9mZihnZXN0dXJlcywgaGFuZGxlcilcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dUmVtb3ZlIGFuIGV2ZW50IGxpc3RlbmVyLlsvZW5dXG4gICAqICBbamFd44Kk44OZ44Oz44OI44Oq44K544OK44O844KS5YmK6Zmk44GX44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtTdHJpbmd9IGdlc3R1cmVzXG4gICAqICAgW2VuXUEgc3BhY2Ugc2VwYXJhdGVkIGxpc3Qgb2YgZ2VzdHVyZXMuWy9lbl1cbiAgICogICBbamFd44K444Kn44K544OB44Oj5ZCN44KS5oyH5a6a44GX44G+44GZ44CC44K544Oa44O844K544Gn6KSH5pWw5oyH5a6a44GZ44KL44GT44Go44GM44Gn44GN44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlclxuICAgKiAgIFtlbl1BbiBldmVudCBoYW5kbGluZyBmdW5jdGlvbi5bL2VuXVxuICAgKiAgIFtqYV3jgqTjg5njg7Pjg4jjg4/jg7Pjg4njg6njgajjgarjgovplqLmlbDjgqrjg5bjgrjjgqfjgq/jg4jjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cbiAgb2ZmOiBmdW5jdGlvbiBvZmZFdmVudChnZXN0dXJlcywgaGFuZGxlciwgb3B0KSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgRXZlbnQub2ZmKHNlbGYuZWxlbWVudCwgZ2VzdHVyZXMsIGhhbmRsZXIsIHV0aWwuZXh0ZW5kKHt9LCBzZWxmLm9wdGlvbnMubGlzdGVuZXJPcHRpb25zLCBvcHQpLCBmdW5jdGlvbih0eXBlKSB7XG4gICAgICB2YXIgaW5kZXggPSBVdGlscy5pbkFycmF5KHNlbGYuZXZlbnRIYW5kbGVycywgeyBnZXN0dXJlOiB0eXBlLCBoYW5kbGVyOiBoYW5kbGVyIH0sIHRydWUpO1xuICAgICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgICAgc2VsZi5ldmVudEhhbmRsZXJzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHNlbGY7XG4gIH0sXG5cbiAgLyoqXG4gICAqIHRyaWdnZXIgZ2VzdHVyZSBldmVudFxuICAgKiBAbWV0aG9kIHRyaWdnZXJcbiAgICogQHNpZ25hdHVyZSB0cmlnZ2VyKGdlc3R1cmUsIGV2ZW50RGF0YSlcbiAgICogQHBhcmFtIHtTdHJpbmd9IGdlc3R1cmVcbiAgICogQHBhcmFtIHtPYmplY3R9IFtldmVudERhdGFdXG4gICAqL1xuICB0cmlnZ2VyOiBmdW5jdGlvbiB0cmlnZ2VyRXZlbnQoZ2VzdHVyZSwgZXZlbnREYXRhKSB7XG4gICAgLy8gb3B0aW9uYWxcbiAgICBpZiAoIWV2ZW50RGF0YSkge1xuICAgICAgZXZlbnREYXRhID0ge307XG4gICAgfVxuXG4gICAgLy8gY3JlYXRlIERPTSBldmVudFxuICAgIHZhciBldmVudCA9IEdlc3R1cmVEZXRlY3Rvci5ET0NVTUVOVC5jcmVhdGVFdmVudCgnRXZlbnQnKTtcbiAgICBldmVudC5pbml0RXZlbnQoZ2VzdHVyZSwgdHJ1ZSwgdHJ1ZSk7XG4gICAgZXZlbnQuZ2VzdHVyZSA9IGV2ZW50RGF0YTtcblxuICAgIC8vIHRyaWdnZXIgb24gdGhlIHRhcmdldCBpZiBpdCBpcyBpbiB0aGUgaW5zdGFuY2UgZWxlbWVudCxcbiAgICAvLyB0aGlzIGlzIGZvciBldmVudCBkZWxlZ2F0aW9uIHRyaWNrc1xuICAgIHZhciBlbGVtZW50ID0gdGhpcy5lbGVtZW50O1xuICAgIGlmIChVdGlscy5oYXNQYXJlbnQoZXZlbnREYXRhLnRhcmdldCwgZWxlbWVudCkpIHtcbiAgICAgIGVsZW1lbnQgPSBldmVudERhdGEudGFyZ2V0O1xuICAgIH1cblxuICAgIGVsZW1lbnQuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBtZXRob2QgZW5hYmxlXG4gICAqIEBzaWduYXR1cmUgZW5hYmxlKHN0YXRlKVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFtlbl1FbmFibGUgb3IgZGlzYWJsZSBnZXN0dXJlIGRldGVjdGlvbi5bL2VuXVxuICAgKiAgW2phXeOCuOOCp+OCueODgeODo+aknOefpeOCkuacieWKueWMli/nhKHlirnljJbjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IHN0YXRlXG4gICAqICAgW2VuXVNwZWNpZnkgaWYgaXQgc2hvdWxkIGJlIGVuYWJsZWQgb3Igbm90LlsvZW5dXG4gICAqICAgW2phXeacieWKueOBq+OBmeOCi+OBi+OBqeOBhuOBi+OCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuICBlbmFibGU6IGZ1bmN0aW9uIGVuYWJsZShzdGF0ZSkge1xuICAgIHRoaXMuZW5hYmxlZCA9IHN0YXRlO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIGRpc3Bvc2VcbiAgICogQHNpZ25hdHVyZSBkaXNwb3NlKClcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dUmVtb3ZlIGFuZCBkZXN0cm95IGFsbCBldmVudCBoYW5kbGVycyBmb3IgdGhpcyBpbnN0YW5jZS5bL2VuXVxuICAgKiAgW2phXeOBk+OBruOCpOODs+OCueOCv+ODs+OCueOBp+OBruOCuOOCp+OCueODgeODo+OBruaknOefpeOChOOAgeOCpOODmeODs+ODiOODj+ODs+ODieODqeOCkuWFqOOBpuino+mZpOOBl+OBpuW7g+ajhOOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuICBkaXNwb3NlOiBmdW5jdGlvbiBkaXNwb3NlKCkge1xuICAgIHZhciBpLCBlaDtcblxuICAgIC8vIHVuZG8gYWxsIGNoYW5nZXMgbWFkZSBieSBzdG9wX2Jyb3dzZXJfYmVoYXZpb3JcbiAgICBVdGlscy50b2dnbGVCZWhhdmlvcih0aGlzLmVsZW1lbnQsIHRoaXMub3B0aW9ucy5iZWhhdmlvciwgZmFsc2UpO1xuXG4gICAgLy8gdW5iaW5kIGFsbCBjdXN0b20gZXZlbnQgaGFuZGxlcnNcbiAgICBmb3IgKGkgPSAtMTsgKGVoID0gdGhpcy5ldmVudEhhbmRsZXJzWysraV0pOykgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbmQtYXNzaWduXG4gICAgICBVdGlscy5vZmYodGhpcy5lbGVtZW50LCBlaC5nZXN0dXJlLCBlaC5oYW5kbGVyKTtcbiAgICB9XG5cbiAgICB0aGlzLmV2ZW50SGFuZGxlcnMgPSBbXTtcblxuICAgIC8vIHVuYmluZCB0aGUgc3RhcnQgZXZlbnQgbGlzdGVuZXJcbiAgICBFdmVudC5vZmYodGhpcy5lbGVtZW50LCBFVkVOVF9UWVBFU1tFVkVOVF9TVEFSVF0sIHRoaXMuZXZlbnRTdGFydEhhbmRsZXIpO1xuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn07XG5cblxuLyoqXG4gKiBAbW9kdWxlIGdlc3R1cmVzXG4gKi9cbi8qKlxuICogTW92ZSB3aXRoIHggZmluZ2VycyAoZGVmYXVsdCAxKSBhcm91bmQgb24gdGhlIHBhZ2UuXG4gKiBQcmV2ZW50aW5nIHRoZSBkZWZhdWx0IGJyb3dzZXIgYmVoYXZpb3IgaXMgYSBnb29kIHdheSB0byBpbXByb3ZlIGZlZWwgYW5kIHdvcmtpbmcuXG4gKiBgYGBgXG4gKiAgR2VzdHVyZURldGVjdG9ydGltZS5vbihcImRyYWdcIiwgZnVuY3Rpb24oZXYpIHtcbiAqICAgIGNvbnNvbGUubG9nKGV2KTtcbiAqICAgIGV2Lmdlc3R1cmUucHJldmVudERlZmF1bHQoKTtcbiAqICB9KTtcbiAqIGBgYGBcbiAqXG4gKiBAY2xhc3MgRHJhZ1xuICogQHN0YXRpY1xuICovXG4vKipcbiAqIEBldmVudCBkcmFnXG4gKiBAcGFyYW0ge09iamVjdH0gZXZcbiAqL1xuLyoqXG4gKiBAZXZlbnQgZHJhZ3N0YXJ0XG4gKiBAcGFyYW0ge09iamVjdH0gZXZcbiAqL1xuLyoqXG4gKiBAZXZlbnQgZHJhZ2VuZFxuICogQHBhcmFtIHtPYmplY3R9IGV2XG4gKi9cbi8qKlxuICogQGV2ZW50IGRyYXBsZWZ0XG4gKiBAcGFyYW0ge09iamVjdH0gZXZcbiAqL1xuLyoqXG4gKiBAZXZlbnQgZHJhZ3JpZ2h0XG4gKiBAcGFyYW0ge09iamVjdH0gZXZcbiAqL1xuLyoqXG4gKiBAZXZlbnQgZHJhZ3VwXG4gKiBAcGFyYW0ge09iamVjdH0gZXZcbiAqL1xuLyoqXG4gKiBAZXZlbnQgZHJhZ2Rvd25cbiAqIEBwYXJhbSB7T2JqZWN0fSBldlxuICovXG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqL1xuKGZ1bmN0aW9uKG5hbWUpIHtcbiAgdmFyIHRyaWdnZXJlZCA9IGZhbHNlO1xuXG4gIGZ1bmN0aW9uIGRyYWdHZXN0dXJlKGV2LCBpbnN0KSB7XG4gICAgdmFyIGN1ciA9IERldGVjdGlvbi5jdXJyZW50O1xuXG4gICAgLy8gbWF4IHRvdWNoZXNcbiAgICBpZiAoaW5zdC5vcHRpb25zLmRyYWdNYXhUb3VjaGVzID4gMCAmJlxuICAgICAgZXYudG91Y2hlcy5sZW5ndGggPiBpbnN0Lm9wdGlvbnMuZHJhZ01heFRvdWNoZXMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBzd2l0Y2ggKGV2LmV2ZW50VHlwZSkge1xuICAgIGNhc2UgRVZFTlRfU1RBUlQ6XG4gICAgICB0cmlnZ2VyZWQgPSBmYWxzZTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBFVkVOVF9NT1ZFOlxuICAgICAgLy8gd2hlbiB0aGUgZGlzdGFuY2Ugd2UgbW92ZWQgaXMgdG9vIHNtYWxsIHdlIHNraXAgdGhpcyBnZXN0dXJlXG4gICAgICAvLyBvciB3ZSBjYW4gYmUgYWxyZWFkeSBpbiBkcmFnZ2luZ1xuICAgICAgaWYgKGV2LmRpc3RhbmNlIDwgaW5zdC5vcHRpb25zLmRyYWdNaW5EaXN0YW5jZSAmJlxuICAgICAgICBjdXIubmFtZSAhPSBuYW1lKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIHN0YXJ0Q2VudGVyID0gY3VyLnN0YXJ0RXZlbnQuY2VudGVyO1xuXG4gICAgICAvLyB3ZSBhcmUgZHJhZ2dpbmchXG4gICAgICBpZiAoY3VyLm5hbWUgIT0gbmFtZSkge1xuICAgICAgICBjdXIubmFtZSA9IG5hbWU7XG4gICAgICAgIGlmIChpbnN0Lm9wdGlvbnMuZHJhZ0Rpc3RhbmNlQ29ycmVjdGlvbiAmJiBldi5kaXN0YW5jZSA+IDApIHtcbiAgICAgICAgICAvLyBXaGVuIGEgZHJhZyBpcyB0cmlnZ2VyZWQsIHNldCB0aGUgZXZlbnQgY2VudGVyIHRvIGRyYWdNaW5EaXN0YW5jZSBwaXhlbHMgZnJvbSB0aGUgb3JpZ2luYWwgZXZlbnQgY2VudGVyLlxuICAgICAgICAgIC8vIFdpdGhvdXQgdGhpcyBjb3JyZWN0aW9uLCB0aGUgZHJhZ2dlZCBkaXN0YW5jZSB3b3VsZCBqdW1wc3RhcnQgYXQgZHJhZ01pbkRpc3RhbmNlIHBpeGVscyBpbnN0ZWFkIG9mIGF0IDAuXG4gICAgICAgICAgLy8gSXQgbWlnaHQgYmUgdXNlZnVsIHRvIHNhdmUgdGhlIG9yaWdpbmFsIHN0YXJ0IHBvaW50IHNvbWV3aGVyZVxuICAgICAgICAgIHZhciBmYWN0b3IgPSBNYXRoLmFicyhpbnN0Lm9wdGlvbnMuZHJhZ01pbkRpc3RhbmNlIC8gZXYuZGlzdGFuY2UpO1xuICAgICAgICAgIHN0YXJ0Q2VudGVyLnBhZ2VYICs9IGV2LmRlbHRhWCAqIGZhY3RvcjtcbiAgICAgICAgICBzdGFydENlbnRlci5wYWdlWSArPSBldi5kZWx0YVkgKiBmYWN0b3I7XG4gICAgICAgICAgc3RhcnRDZW50ZXIuY2xpZW50WCArPSBldi5kZWx0YVggKiBmYWN0b3I7XG4gICAgICAgICAgc3RhcnRDZW50ZXIuY2xpZW50WSArPSBldi5kZWx0YVkgKiBmYWN0b3I7XG5cbiAgICAgICAgICAvLyByZWNhbGN1bGF0ZSBldmVudCBkYXRhIHVzaW5nIG5ldyBzdGFydCBwb2ludFxuICAgICAgICAgIGV2ID0gRGV0ZWN0aW9uLmV4dGVuZEV2ZW50RGF0YShldik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gbG9jayBkcmFnIHRvIGF4aXM/XG4gICAgICBpZiAoY3VyLmxhc3RFdmVudC5kcmFnTG9ja1RvQXhpcyB8fFxuICAgICAgICAoIGluc3Qub3B0aW9ucy5kcmFnTG9ja1RvQXhpcyAmJlxuICAgICAgICAgIGluc3Qub3B0aW9ucy5kcmFnTG9ja01pbkRpc3RhbmNlIDw9IGV2LmRpc3RhbmNlXG4gICAgICAgICkpIHtcbiAgICAgICAgICBldi5kcmFnTG9ja1RvQXhpcyA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBrZWVwIGRpcmVjdGlvbiBvbiB0aGUgYXhpcyB0aGF0IHRoZSBkcmFnIGdlc3R1cmUgc3RhcnRlZCBvblxuICAgICAgICB2YXIgbGFzdERpcmVjdGlvbiA9IGN1ci5sYXN0RXZlbnQuZGlyZWN0aW9uO1xuICAgICAgICBpZiAoZXYuZHJhZ0xvY2tUb0F4aXMgJiYgbGFzdERpcmVjdGlvbiAhPT0gZXYuZGlyZWN0aW9uKSB7XG4gICAgICAgICAgaWYgKFV0aWxzLmlzVmVydGljYWwobGFzdERpcmVjdGlvbikpIHtcbiAgICAgICAgICAgIGV2LmRpcmVjdGlvbiA9IChldi5kZWx0YVkgPCAwKSA/IERJUkVDVElPTl9VUCA6IERJUkVDVElPTl9ET1dOO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBldi5kaXJlY3Rpb24gPSAoZXYuZGVsdGFYIDwgMCkgPyBESVJFQ1RJT05fTEVGVCA6IERJUkVDVElPTl9SSUdIVDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBmaXJzdCB0aW1lLCB0cmlnZ2VyIGRyYWdzdGFydCBldmVudFxuICAgICAgICBpZiAoIXRyaWdnZXJlZCkge1xuICAgICAgICAgIGluc3QudHJpZ2dlcihuYW1lICsgJ3N0YXJ0JywgZXYpO1xuICAgICAgICAgIHRyaWdnZXJlZCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB0cmlnZ2VyIGV2ZW50c1xuICAgICAgICBpbnN0LnRyaWdnZXIobmFtZSwgZXYpO1xuICAgICAgICBpbnN0LnRyaWdnZXIobmFtZSArIGV2LmRpcmVjdGlvbiwgZXYpO1xuXG4gICAgICAgIHZhciBpc1ZlcnRpY2FsID0gVXRpbHMuaXNWZXJ0aWNhbChldi5kaXJlY3Rpb24pO1xuXG4gICAgICAgIC8vIGJsb2NrIHRoZSBicm93c2VyIGV2ZW50c1xuICAgICAgICBpZiAoKGluc3Qub3B0aW9ucy5kcmFnQmxvY2tWZXJ0aWNhbCAmJiBpc1ZlcnRpY2FsKSB8fFxuICAgICAgICAgIChpbnN0Lm9wdGlvbnMuZHJhZ0Jsb2NrSG9yaXpvbnRhbCAmJiAhaXNWZXJ0aWNhbCkpIHtcbiAgICAgICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIEVWRU5UX1JFTEVBU0U6XG4gICAgICAgIGlmICh0cmlnZ2VyZWQgJiYgZXYuY2hhbmdlZExlbmd0aCA8PSBpbnN0Lm9wdGlvbnMuZHJhZ01heFRvdWNoZXMpIHtcbiAgICAgICAgICBpbnN0LnRyaWdnZXIobmFtZSArICdlbmQnLCBldik7XG4gICAgICAgICAgdHJpZ2dlcmVkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgRVZFTlRfRU5EOlxuICAgICAgICB0cmlnZ2VyZWQgPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgR2VzdHVyZURldGVjdG9yLmdlc3R1cmVzLkRyYWcgPSB7XG4gICAgICBuYW1lOiBuYW1lLFxuICAgICAgaW5kZXg6IDUwLFxuICAgICAgaGFuZGxlcjogZHJhZ0dlc3R1cmUsXG4gICAgICBkZWZhdWx0czoge1xuICAgICAgICAvKipcbiAgICAgICAgICogbWluaW1hbCBtb3ZlbWVudCB0aGF0IGhhdmUgdG8gYmUgbWFkZSBiZWZvcmUgdGhlIGRyYWcgZXZlbnQgZ2V0cyB0cmlnZ2VyZWRcbiAgICAgICAgICogQHByb3BlcnR5IGRyYWdNaW5EaXN0YW5jZVxuICAgICAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAgICAgKiBAZGVmYXVsdCAxMFxuICAgICAgICAgKi9cbiAgICAgICAgZHJhZ01pbkRpc3RhbmNlOiAxMCxcblxuICAgICAgICAvKipcbiAgICAgICAgICogU2V0IGRyYWdEaXN0YW5jZUNvcnJlY3Rpb24gdG8gdHJ1ZSB0byBtYWtlIHRoZSBzdGFydGluZyBwb2ludCBvZiB0aGUgZHJhZ1xuICAgICAgICAgKiBiZSBjYWxjdWxhdGVkIGZyb20gd2hlcmUgdGhlIGRyYWcgd2FzIHRyaWdnZXJlZCwgbm90IGZyb20gd2hlcmUgdGhlIHRvdWNoIHN0YXJ0ZWQuXG4gICAgICAgICAqIFVzZWZ1bCB0byBhdm9pZCBhIGplcmstc3RhcnRpbmcgZHJhZywgd2hpY2ggY2FuIG1ha2UgZmluZS1hZGp1c3RtZW50c1xuICAgICAgICAgKiB0aHJvdWdoIGRyYWdnaW5nIGRpZmZpY3VsdCwgYW5kIGJlIHZpc3VhbGx5IHVuYXBwZWFsaW5nLlxuICAgICAgICAgKiBAcHJvcGVydHkgZHJhZ0Rpc3RhbmNlQ29ycmVjdGlvblxuICAgICAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgICAgICogQGRlZmF1bHQgdHJ1ZVxuICAgICAgICAgKi9cbiAgICAgICAgZHJhZ0Rpc3RhbmNlQ29ycmVjdGlvbjogdHJ1ZSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogc2V0IDAgZm9yIHVubGltaXRlZCwgYnV0IHRoaXMgY2FuIGNvbmZsaWN0IHdpdGggdHJhbnNmb3JtXG4gICAgICAgICAqIEBwcm9wZXJ0eSBkcmFnTWF4VG91Y2hlc1xuICAgICAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAgICAgKiBAZGVmYXVsdCAxXG4gICAgICAgICAqL1xuICAgICAgICBkcmFnTWF4VG91Y2hlczogMSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogcHJldmVudCBkZWZhdWx0IGJyb3dzZXIgYmVoYXZpb3Igd2hlbiBkcmFnZ2luZyBvY2N1cnNcbiAgICAgICAgICogYmUgY2FyZWZ1bCB3aXRoIGl0LCBpdCBtYWtlcyB0aGUgZWxlbWVudCBhIGJsb2NraW5nIGVsZW1lbnRcbiAgICAgICAgICogd2hlbiB5b3UgYXJlIHVzaW5nIHRoZSBkcmFnIGdlc3R1cmUsIGl0IGlzIGEgZ29vZCBwcmFjdGljZSB0byBzZXQgdGhpcyB0cnVlXG4gICAgICAgICAqIEBwcm9wZXJ0eSBkcmFnQmxvY2tIb3Jpem9udGFsXG4gICAgICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgZHJhZ0Jsb2NrSG9yaXpvbnRhbDogZmFsc2UsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIHNhbWUgYXMgYGRyYWdCbG9ja0hvcml6b250YWxgLCBidXQgZm9yIHZlcnRpY2FsIG1vdmVtZW50XG4gICAgICAgICAqIEBwcm9wZXJ0eSBkcmFnQmxvY2tWZXJ0aWNhbFxuICAgICAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgICAgICovXG4gICAgICAgIGRyYWdCbG9ja1ZlcnRpY2FsOiBmYWxzZSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogZHJhZ0xvY2tUb0F4aXMga2VlcHMgdGhlIGRyYWcgZ2VzdHVyZSBvbiB0aGUgYXhpcyB0aGF0IGl0IHN0YXJ0ZWQgb24sXG4gICAgICAgICAqIEl0IGRpc2FsbG93cyB2ZXJ0aWNhbCBkaXJlY3Rpb25zIGlmIHRoZSBpbml0aWFsIGRpcmVjdGlvbiB3YXMgaG9yaXpvbnRhbCwgYW5kIHZpY2UgdmVyc2EuXG4gICAgICAgICAqIEBwcm9wZXJ0eSBkcmFnTG9ja1RvQXhpc1xuICAgICAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgICAgICovXG4gICAgICAgIGRyYWdMb2NrVG9BeGlzOiBmYWxzZSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogZHJhZyBsb2NrIG9ubHkga2lja3MgaW4gd2hlbiBkaXN0YW5jZSA+IGRyYWdMb2NrTWluRGlzdGFuY2VcbiAgICAgICAgICogVGhpcyB3YXksIGxvY2tpbmcgb2NjdXJzIG9ubHkgd2hlbiB0aGUgZGlzdGFuY2UgaGFzIGJlY29tZSBsYXJnZSBlbm91Z2ggdG8gcmVsaWFibHkgZGV0ZXJtaW5lIHRoZSBkaXJlY3Rpb25cbiAgICAgICAgICogQHByb3BlcnR5IGRyYWdMb2NrTWluRGlzdGFuY2VcbiAgICAgICAgICogQHR5cGUge051bWJlcn1cbiAgICAgICAgICogQGRlZmF1bHQgMjVcbiAgICAgICAgICovXG4gICAgICAgIGRyYWdMb2NrTWluRGlzdGFuY2U6IDI1XG4gICAgICB9XG4gICAgfTtcbiAgfSkoJ2RyYWcnKTtcblxuICAvKipcbiAgICogQG1vZHVsZSBnZXN0dXJlc1xuICAgKi9cbiAgLyoqXG4gICAqIHRyaWdnZXIgYSBzaW1wbGUgZ2VzdHVyZSBldmVudCwgc28geW91IGNhbiBkbyBhbnl0aGluZyBpbiB5b3VyIGhhbmRsZXIuXG4gICAqIG9ubHkgdXNhYmxlIGlmIHlvdSBrbm93IHdoYXQgeW91ciBkb2luZy4uLlxuICAgKlxuICAgKiBAY2xhc3MgR2VzdHVyZVxuICAgKiBAc3RhdGljXG4gICAqL1xuICAvKipcbiAgICogQGV2ZW50IGdlc3R1cmVcbiAgICogQHBhcmFtIHtPYmplY3R9IGV2XG4gICAqL1xuICBHZXN0dXJlRGV0ZWN0b3IuZ2VzdHVyZXMuR2VzdHVyZSA9IHtcbiAgICBuYW1lOiAnZ2VzdHVyZScsXG4gICAgaW5kZXg6IDEzMzcsXG4gICAgaGFuZGxlcjogZnVuY3Rpb24gcmVsZWFzZUdlc3R1cmUoZXYsIGluc3QpIHtcbiAgICAgIGluc3QudHJpZ2dlcih0aGlzLm5hbWUsIGV2KTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEBtb2R1bGUgZ2VzdHVyZXNcbiAgICovXG4gIC8qKlxuICAgKiBUb3VjaCBzdGF5cyBhdCB0aGUgc2FtZSBwbGFjZSBmb3IgeCB0aW1lXG4gICAqXG4gICAqIEBjbGFzcyBIb2xkXG4gICAqIEBzdGF0aWNcbiAgICovXG4gIC8qKlxuICAgKiBAZXZlbnQgaG9sZFxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZcbiAgICovXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gICAqL1xuICAoZnVuY3Rpb24obmFtZSkge1xuICAgIHZhciB0aW1lcjtcblxuICAgIGZ1bmN0aW9uIGhvbGRHZXN0dXJlKGV2LCBpbnN0KSB7XG4gICAgICB2YXIgb3B0aW9ucyA9IGluc3Qub3B0aW9ucyxcbiAgICAgICAgICBjdXJyZW50ID0gRGV0ZWN0aW9uLmN1cnJlbnQ7XG5cbiAgICAgIHN3aXRjaCAoZXYuZXZlbnRUeXBlKSB7XG4gICAgICBjYXNlIEVWRU5UX1NUQVJUOlxuICAgICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuXG4gICAgICAgIC8vIHNldCB0aGUgZ2VzdHVyZSBzbyB3ZSBjYW4gY2hlY2sgaW4gdGhlIHRpbWVvdXQgaWYgaXQgc3RpbGwgaXNcbiAgICAgICAgY3VycmVudC5uYW1lID0gbmFtZTtcblxuICAgICAgICAvLyBzZXQgdGltZXIgYW5kIGlmIGFmdGVyIHRoZSB0aW1lb3V0IGl0IHN0aWxsIGlzIGhvbGQsXG4gICAgICAgIC8vIHdlIHRyaWdnZXIgdGhlIGhvbGQgZXZlbnRcbiAgICAgICAgdGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGlmIChjdXJyZW50ICYmIGN1cnJlbnQubmFtZSA9PSBuYW1lKSB7XG4gICAgICAgICAgICBpbnN0LnRyaWdnZXIobmFtZSwgZXYpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgb3B0aW9ucy5ob2xkVGltZW91dCk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIEVWRU5UX01PVkU6XG4gICAgICAgIGlmIChldi5kaXN0YW5jZSA+IG9wdGlvbnMuaG9sZFRocmVzaG9sZCkge1xuICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgRVZFTlRfUkVMRUFTRTpcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgR2VzdHVyZURldGVjdG9yLmdlc3R1cmVzLkhvbGQgPSB7XG4gICAgICBuYW1lOiBuYW1lLFxuICAgICAgaW5kZXg6IDEwLFxuICAgICAgZGVmYXVsdHM6IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBob2xkVGltZW91dFxuICAgICAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAgICAgKiBAZGVmYXVsdCA1MDBcbiAgICAgICAgICovXG4gICAgICAgIGhvbGRUaW1lb3V0OiA1MDAsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIG1vdmVtZW50IGFsbG93ZWQgd2hpbGUgaG9sZGluZ1xuICAgICAgICAgKiBAcHJvcGVydHkgaG9sZFRocmVzaG9sZFxuICAgICAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAgICAgKiBAZGVmYXVsdCAyXG4gICAgICAgICAqL1xuICAgICAgICBob2xkVGhyZXNob2xkOiAyXG4gICAgICB9LFxuICAgICAgaGFuZGxlcjogaG9sZEdlc3R1cmVcbiAgICB9O1xuICB9KSgnaG9sZCcpO1xuXG4gIC8qKlxuICAgKiBAbW9kdWxlIGdlc3R1cmVzXG4gICAqL1xuICAvKipcbiAgICogd2hlbiBhIHRvdWNoIGlzIGJlaW5nIHJlbGVhc2VkIGZyb20gdGhlIHBhZ2VcbiAgICpcbiAgICogQGNsYXNzIFJlbGVhc2VcbiAgICogQHN0YXRpY1xuICAgKi9cbiAgLyoqXG4gICAqIEBldmVudCByZWxlYXNlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldlxuICAgKi9cbiAgR2VzdHVyZURldGVjdG9yLmdlc3R1cmVzLlJlbGVhc2UgPSB7XG4gICAgbmFtZTogJ3JlbGVhc2UnLFxuICAgIGluZGV4OiBJbmZpbml0eSxcbiAgICBoYW5kbGVyOiBmdW5jdGlvbiByZWxlYXNlR2VzdHVyZShldiwgaW5zdCkge1xuICAgICAgaWYgKGV2LmV2ZW50VHlwZSA9PSBFVkVOVF9SRUxFQVNFKSB7XG4gICAgICAgIGluc3QudHJpZ2dlcih0aGlzLm5hbWUsIGV2KTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEBtb2R1bGUgZ2VzdHVyZXNcbiAgICovXG4gIC8qKlxuICAgKiB0cmlnZ2VycyBzd2lwZSBldmVudHMgd2hlbiB0aGUgZW5kIHZlbG9jaXR5IGlzIGFib3ZlIHRoZSB0aHJlc2hvbGRcbiAgICogZm9yIGJlc3QgdXNhZ2UsIHNldCBgcHJldmVudERlZmF1bHRgIChvbiB0aGUgZHJhZyBnZXN0dXJlKSB0byBgdHJ1ZWBcbiAgICogYGBgYFxuICAgKiAgR2VzdHVyZURldGVjdG9ydGltZS5vbihcImRyYWdsZWZ0IHN3aXBlbGVmdFwiLCBmdW5jdGlvbihldikge1xuICAgKiAgICBjb25zb2xlLmxvZyhldik7XG4gICAqICAgIGV2Lmdlc3R1cmUucHJldmVudERlZmF1bHQoKTtcbiAgICogIH0pO1xuICAgKiBgYGBgXG4gICAqXG4gICAqIEBjbGFzcyBTd2lwZVxuICAgKiBAc3RhdGljXG4gICAqL1xuICAvKipcbiAgICogQGV2ZW50IHN3aXBlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldlxuICAgKi9cbiAgLyoqXG4gICAqIEBldmVudCBzd2lwZWxlZnRcbiAgICogQHBhcmFtIHtPYmplY3R9IGV2XG4gICAqL1xuICAvKipcbiAgICogQGV2ZW50IHN3aXBlcmlnaHRcbiAgICogQHBhcmFtIHtPYmplY3R9IGV2XG4gICAqL1xuICAvKipcbiAgICogQGV2ZW50IHN3aXBldXBcbiAgICogQHBhcmFtIHtPYmplY3R9IGV2XG4gICAqL1xuICAvKipcbiAgICogQGV2ZW50IHN3aXBlZG93blxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZcbiAgICovXG4gIEdlc3R1cmVEZXRlY3Rvci5nZXN0dXJlcy5Td2lwZSA9IHtcbiAgICBuYW1lOiAnc3dpcGUnLFxuICAgIGluZGV4OiA0MCxcbiAgICBkZWZhdWx0czoge1xuICAgICAgLyoqXG4gICAgICAgKiBAcHJvcGVydHkgc3dpcGVNaW5Ub3VjaGVzXG4gICAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAgICogQGRlZmF1bHQgMVxuICAgICAgICovXG4gICAgICBzd2lwZU1pblRvdWNoZXM6IDEsXG5cbiAgICAgIC8qKlxuICAgICAgICogQHByb3BlcnR5IHN3aXBlTWF4VG91Y2hlc1xuICAgICAgICogQHR5cGUge051bWJlcn1cbiAgICAgICAqIEBkZWZhdWx0IDFcbiAgICAgICAqL1xuICAgICAgc3dpcGVNYXhUb3VjaGVzOiAxLFxuXG4gICAgICAvKipcbiAgICAgICAqIGhvcml6b250YWwgc3dpcGUgdmVsb2NpdHlcbiAgICAgICAqIEBwcm9wZXJ0eSBzd2lwZVZlbG9jaXR5WFxuICAgICAgICogQHR5cGUge051bWJlcn1cbiAgICAgICAqIEBkZWZhdWx0IDAuNlxuICAgICAgICovXG4gICAgICBzd2lwZVZlbG9jaXR5WDogMC42LFxuXG4gICAgICAvKipcbiAgICAgICAqIHZlcnRpY2FsIHN3aXBlIHZlbG9jaXR5XG4gICAgICAgKiBAcHJvcGVydHkgc3dpcGVWZWxvY2l0eVlcbiAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICAgKiBAZGVmYXVsdCAwLjZcbiAgICAgICAqL1xuICAgICAgc3dpcGVWZWxvY2l0eVk6IDAuNlxuICAgIH0sXG5cbiAgICBoYW5kbGVyOiBmdW5jdGlvbiBzd2lwZUdlc3R1cmUoZXYsIGluc3QpIHtcbiAgICAgIGlmIChldi5ldmVudFR5cGUgPT0gRVZFTlRfUkVMRUFTRSkge1xuICAgICAgICB2YXIgdG91Y2hlcyA9IGV2LnRvdWNoZXMubGVuZ3RoLFxuICAgICAgICAgICAgb3B0aW9ucyA9IGluc3Qub3B0aW9ucztcblxuICAgICAgICAvLyBtYXggdG91Y2hlc1xuICAgICAgICBpZiAodG91Y2hlcyA8IG9wdGlvbnMuc3dpcGVNaW5Ub3VjaGVzIHx8XG4gICAgICAgICAgdG91Y2hlcyA+IG9wdGlvbnMuc3dpcGVNYXhUb3VjaGVzKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gd2hlbiB0aGUgZGlzdGFuY2Ugd2UgbW92ZWQgaXMgdG9vIHNtYWxsIHdlIHNraXAgdGhpcyBnZXN0dXJlXG4gICAgICAgIC8vIG9yIHdlIGNhbiBiZSBhbHJlYWR5IGluIGRyYWdnaW5nXG4gICAgICAgIGlmIChldi52ZWxvY2l0eVggPiBvcHRpb25zLnN3aXBlVmVsb2NpdHlYIHx8XG4gICAgICAgICAgZXYudmVsb2NpdHlZID4gb3B0aW9ucy5zd2lwZVZlbG9jaXR5WSkge1xuICAgICAgICAgIC8vIHRyaWdnZXIgc3dpcGUgZXZlbnRzXG4gICAgICAgICAgaW5zdC50cmlnZ2VyKHRoaXMubmFtZSwgZXYpO1xuICAgICAgICAgIGluc3QudHJpZ2dlcih0aGlzLm5hbWUgKyBldi5kaXJlY3Rpb24sIGV2KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQG1vZHVsZSBnZXN0dXJlc1xuICAgKi9cbiAgLyoqXG4gICAqIFNpbmdsZSB0YXAgYW5kIGEgZG91YmxlIHRhcCBvbiBhIHBsYWNlXG4gICAqXG4gICAqIEBjbGFzcyBUYXBcbiAgICogQHN0YXRpY1xuICAgKi9cbiAgLyoqXG4gICAqIEBldmVudCB0YXBcbiAgICogQHBhcmFtIHtPYmplY3R9IGV2XG4gICAqL1xuICAvKipcbiAgICogQGV2ZW50IGRvdWJsZXRhcFxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZcbiAgICovXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gICAqL1xuICAoZnVuY3Rpb24obmFtZSkge1xuICAgIHZhciBoYXNNb3ZlZCA9IGZhbHNlO1xuXG4gICAgZnVuY3Rpb24gdGFwR2VzdHVyZShldiwgaW5zdCkge1xuICAgICAgdmFyIG9wdGlvbnMgPSBpbnN0Lm9wdGlvbnMsXG4gICAgICAgICAgY3VycmVudCA9IERldGVjdGlvbi5jdXJyZW50LFxuICAgICAgICAgIHByZXYgPSBEZXRlY3Rpb24ucHJldmlvdXMsXG4gICAgICAgICAgc2luY2VQcmV2LFxuICAgICAgICAgIGRpZERvdWJsZVRhcDtcblxuICAgICAgc3dpdGNoIChldi5ldmVudFR5cGUpIHtcbiAgICAgIGNhc2UgRVZFTlRfU1RBUlQ6XG4gICAgICAgIGhhc01vdmVkID0gZmFsc2U7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIEVWRU5UX01PVkU6XG4gICAgICAgIGhhc01vdmVkID0gaGFzTW92ZWQgfHwgKGV2LmRpc3RhbmNlID4gb3B0aW9ucy50YXBNYXhEaXN0YW5jZSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIEVWRU5UX0VORDpcbiAgICAgICAgaWYgKCFVdGlscy5pblN0cihldi5zcmNFdmVudC50eXBlLCAnY2FuY2VsJykgJiYgZXYuZGVsdGFUaW1lIDwgb3B0aW9ucy50YXBNYXhUaW1lICYmICFoYXNNb3ZlZCkge1xuICAgICAgICAgIC8vIHByZXZpb3VzIGdlc3R1cmUsIGZvciB0aGUgZG91YmxlIHRhcCBzaW5jZSB0aGVzZSBhcmUgdHdvIGRpZmZlcmVudCBnZXN0dXJlIGRldGVjdGlvbnNcbiAgICAgICAgICBzaW5jZVByZXYgPSBwcmV2ICYmIHByZXYubGFzdEV2ZW50ICYmIGV2LnRpbWVTdGFtcCAtIHByZXYubGFzdEV2ZW50LnRpbWVTdGFtcDtcbiAgICAgICAgICBkaWREb3VibGVUYXAgPSBmYWxzZTtcblxuICAgICAgICAgIC8vIGNoZWNrIGlmIGRvdWJsZSB0YXBcbiAgICAgICAgICBpZiAocHJldiAmJiBwcmV2Lm5hbWUgPT0gbmFtZSAmJlxuICAgICAgICAgICAgKHNpbmNlUHJldiAmJiBzaW5jZVByZXYgPCBvcHRpb25zLmRvdWJsZVRhcEludGVydmFsKSAmJlxuICAgICAgICAgICAgZXYuZGlzdGFuY2UgPCBvcHRpb25zLmRvdWJsZVRhcERpc3RhbmNlKSB7XG4gICAgICAgICAgICBpbnN0LnRyaWdnZXIoJ2RvdWJsZXRhcCcsIGV2KTtcbiAgICAgICAgICAgIGRpZERvdWJsZVRhcCA9IHRydWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gZG8gYSBzaW5nbGUgdGFwXG4gICAgICAgICAgaWYgKCFkaWREb3VibGVUYXAgfHwgb3B0aW9ucy50YXBBbHdheXMpIHtcbiAgICAgICAgICAgIGN1cnJlbnQubmFtZSA9IG5hbWU7XG4gICAgICAgICAgICBpbnN0LnRyaWdnZXIoY3VycmVudC5uYW1lLCBldik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIEdlc3R1cmVEZXRlY3Rvci5nZXN0dXJlcy5UYXAgPSB7XG4gICAgICBuYW1lOiBuYW1lLFxuICAgICAgaW5kZXg6IDEwMCxcbiAgICAgIGhhbmRsZXI6IHRhcEdlc3R1cmUsXG4gICAgICBkZWZhdWx0czoge1xuICAgICAgICAvKipcbiAgICAgICAgICogbWF4IHRpbWUgb2YgYSB0YXAsIHRoaXMgaXMgZm9yIHRoZSBzbG93IHRhcHBlcnNcbiAgICAgICAgICogQHByb3BlcnR5IHRhcE1heFRpbWVcbiAgICAgICAgICogQHR5cGUge051bWJlcn1cbiAgICAgICAgICogQGRlZmF1bHQgMjUwXG4gICAgICAgICAqL1xuICAgICAgICB0YXBNYXhUaW1lOiAyNTAsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIG1heCBkaXN0YW5jZSBvZiBtb3ZlbWVudCBvZiBhIHRhcCwgdGhpcyBpcyBmb3IgdGhlIHNsb3cgdGFwcGVyc1xuICAgICAgICAgKiBAcHJvcGVydHkgdGFwTWF4RGlzdGFuY2VcbiAgICAgICAgICogQHR5cGUge051bWJlcn1cbiAgICAgICAgICogQGRlZmF1bHQgMTBcbiAgICAgICAgICovXG4gICAgICAgIHRhcE1heERpc3RhbmNlOiAxMCxcblxuICAgICAgICAvKipcbiAgICAgICAgICogYWx3YXlzIHRyaWdnZXIgdGhlIGB0YXBgIGV2ZW50LCBldmVuIHdoaWxlIGRvdWJsZS10YXBwaW5nXG4gICAgICAgICAqIEBwcm9wZXJ0eSB0YXBBbHdheXNcbiAgICAgICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICAgICAqIEBkZWZhdWx0IHRydWVcbiAgICAgICAgICovXG4gICAgICAgIHRhcEFsd2F5czogdHJ1ZSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogbWF4IGRpc3RhbmNlIGJldHdlZW4gdHdvIHRhcHNcbiAgICAgICAgICogQHByb3BlcnR5IGRvdWJsZVRhcERpc3RhbmNlXG4gICAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICAgICAqIEBkZWZhdWx0IDIwXG4gICAgICAgICAqL1xuICAgICAgICBkb3VibGVUYXBEaXN0YW5jZTogMjAsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIG1heCB0aW1lIGJldHdlZW4gdHdvIHRhcHNcbiAgICAgICAgICogQHByb3BlcnR5IGRvdWJsZVRhcEludGVydmFsXG4gICAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICAgICAqIEBkZWZhdWx0IDMwMFxuICAgICAgICAgKi9cbiAgICAgICAgZG91YmxlVGFwSW50ZXJ2YWw6IDMwMFxuICAgICAgfVxuICAgIH07XG4gIH0pKCd0YXAnKTtcblxuICAvKipcbiAgICogQG1vZHVsZSBnZXN0dXJlc1xuICAgKi9cbiAgLyoqXG4gICAqIHdoZW4gYSB0b3VjaCBpcyBiZWluZyB0b3VjaGVkIGF0IHRoZSBwYWdlXG4gICAqXG4gICAqIEBjbGFzcyBUb3VjaFxuICAgKiBAc3RhdGljXG4gICAqL1xuICAvKipcbiAgICogQGV2ZW50IHRvdWNoXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldlxuICAgKi9cbiAgR2VzdHVyZURldGVjdG9yLmdlc3R1cmVzLlRvdWNoID0ge1xuICAgIG5hbWU6ICd0b3VjaCcsXG4gICAgaW5kZXg6IC1JbmZpbml0eSxcbiAgICBkZWZhdWx0czoge1xuICAgICAgLyoqXG4gICAgICAgKiBjYWxsIHByZXZlbnREZWZhdWx0IGF0IHRvdWNoc3RhcnQsIGFuZCBtYWtlcyB0aGUgZWxlbWVudCBibG9ja2luZyBieSBkaXNhYmxpbmcgdGhlIHNjcm9sbGluZyBvZiB0aGUgcGFnZSxcbiAgICAgICAqIGJ1dCBpdCBpbXByb3ZlcyBnZXN0dXJlcyBsaWtlIHRyYW5zZm9ybWluZyBhbmQgZHJhZ2dpbmcuXG4gICAgICAgKiBiZSBjYXJlZnVsIHdpdGggdXNpbmcgdGhpcywgaXQgY2FuIGJlIHZlcnkgYW5ub3lpbmcgZm9yIHVzZXJzIHRvIGJlIHN0dWNrIG9uIHRoZSBwYWdlXG4gICAgICAgKiBAcHJvcGVydHkgcHJldmVudERlZmF1bHRcbiAgICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgICAqL1xuICAgICAgcHJldmVudERlZmF1bHQ6IGZhbHNlLFxuXG4gICAgICAvKipcbiAgICAgICAqIGRpc2FibGUgbW91c2UgZXZlbnRzLCBzbyBvbmx5IHRvdWNoIChvciBwZW4hKSBpbnB1dCB0cmlnZ2VycyBldmVudHNcbiAgICAgICAqIEBwcm9wZXJ0eSBwcmV2ZW50TW91c2VcbiAgICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgICAqL1xuICAgICAgcHJldmVudE1vdXNlOiBmYWxzZVxuICAgIH0sXG4gICAgaGFuZGxlcjogZnVuY3Rpb24gdG91Y2hHZXN0dXJlKGV2LCBpbnN0KSB7XG4gICAgICBpZiAoaW5zdC5vcHRpb25zLnByZXZlbnRNb3VzZSAmJiBldi5wb2ludGVyVHlwZSA9PSBQT0lOVEVSX01PVVNFKSB7XG4gICAgICAgIGV2LnN0b3BEZXRlY3QoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoaW5zdC5vcHRpb25zLnByZXZlbnREZWZhdWx0KSB7XG4gICAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChldi5ldmVudFR5cGUgPT0gRVZFTlRfVE9VQ0gpIHtcbiAgICAgICAgaW5zdC50cmlnZ2VyKCd0b3VjaCcsIGV2KTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEBtb2R1bGUgZ2VzdHVyZXNcbiAgICovXG4gIC8qKlxuICAgKiBVc2VyIHdhbnQgdG8gc2NhbGUgb3Igcm90YXRlIHdpdGggMiBmaW5nZXJzXG4gICAqIFByZXZlbnRpbmcgdGhlIGRlZmF1bHQgYnJvd3NlciBiZWhhdmlvciBpcyBhIGdvb2Qgd2F5IHRvIGltcHJvdmUgZmVlbCBhbmQgd29ya2luZy4gVGhpcyBjYW4gYmUgZG9uZSB3aXRoIHRoZVxuICAgKiBgcHJldmVudERlZmF1bHRgIG9wdGlvbi5cbiAgICpcbiAgICogQGNsYXNzIFRyYW5zZm9ybVxuICAgKiBAc3RhdGljXG4gICAqL1xuICAvKipcbiAgICogQGV2ZW50IHRyYW5zZm9ybVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZcbiAgICovXG4gIC8qKlxuICAgKiBAZXZlbnQgdHJhbnNmb3Jtc3RhcnRcbiAgICogQHBhcmFtIHtPYmplY3R9IGV2XG4gICAqL1xuICAvKipcbiAgICogQGV2ZW50IHRyYW5zZm9ybWVuZFxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZcbiAgICovXG4gIC8qKlxuICAgKiBAZXZlbnQgcGluY2hpblxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZcbiAgICovXG4gIC8qKlxuICAgKiBAZXZlbnQgcGluY2hvdXRcbiAgICogQHBhcmFtIHtPYmplY3R9IGV2XG4gICAqL1xuICAvKipcbiAgICogQGV2ZW50IHJvdGF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZcbiAgICovXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gICAqL1xuICAoZnVuY3Rpb24obmFtZSkge1xuICAgIHZhciB0cmlnZ2VyZWQgPSBmYWxzZTtcblxuICAgIGZ1bmN0aW9uIHRyYW5zZm9ybUdlc3R1cmUoZXYsIGluc3QpIHtcbiAgICAgIHN3aXRjaCAoZXYuZXZlbnRUeXBlKSB7XG4gICAgICBjYXNlIEVWRU5UX1NUQVJUOlxuICAgICAgICB0cmlnZ2VyZWQgPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgRVZFTlRfTU9WRTpcbiAgICAgICAgLy8gYXQgbGVhc3QgbXVsdGl0b3VjaFxuICAgICAgICBpZiAoZXYudG91Y2hlcy5sZW5ndGggPCAyKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHNjYWxlVGhyZXNob2xkID0gTWF0aC5hYnMoMSAtIGV2LnNjYWxlKTtcbiAgICAgICAgdmFyIHJvdGF0aW9uVGhyZXNob2xkID0gTWF0aC5hYnMoZXYucm90YXRpb24pO1xuXG4gICAgICAgIC8vIHdoZW4gdGhlIGRpc3RhbmNlIHdlIG1vdmVkIGlzIHRvbyBzbWFsbCB3ZSBza2lwIHRoaXMgZ2VzdHVyZVxuICAgICAgICAvLyBvciB3ZSBjYW4gYmUgYWxyZWFkeSBpbiBkcmFnZ2luZ1xuICAgICAgICBpZiAoc2NhbGVUaHJlc2hvbGQgPCBpbnN0Lm9wdGlvbnMudHJhbnNmb3JtTWluU2NhbGUgJiZcbiAgICAgICAgICByb3RhdGlvblRocmVzaG9sZCA8IGluc3Qub3B0aW9ucy50cmFuc2Zvcm1NaW5Sb3RhdGlvbikge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHdlIGFyZSB0cmFuc2Zvcm1pbmchXG4gICAgICAgIERldGVjdGlvbi5jdXJyZW50Lm5hbWUgPSBuYW1lO1xuXG4gICAgICAgIC8vIGZpcnN0IHRpbWUsIHRyaWdnZXIgZHJhZ3N0YXJ0IGV2ZW50XG4gICAgICAgIGlmICghdHJpZ2dlcmVkKSB7XG4gICAgICAgICAgaW5zdC50cmlnZ2VyKG5hbWUgKyAnc3RhcnQnLCBldik7XG4gICAgICAgICAgdHJpZ2dlcmVkID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGluc3QudHJpZ2dlcihuYW1lLCBldik7IC8vIGJhc2ljIHRyYW5zZm9ybSBldmVudFxuXG4gICAgICAgIC8vIHRyaWdnZXIgcm90YXRlIGV2ZW50XG4gICAgICAgIGlmIChyb3RhdGlvblRocmVzaG9sZCA+IGluc3Qub3B0aW9ucy50cmFuc2Zvcm1NaW5Sb3RhdGlvbikge1xuICAgICAgICAgIGluc3QudHJpZ2dlcigncm90YXRlJywgZXYpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gdHJpZ2dlciBwaW5jaCBldmVudFxuICAgICAgICBpZiAoc2NhbGVUaHJlc2hvbGQgPiBpbnN0Lm9wdGlvbnMudHJhbnNmb3JtTWluU2NhbGUpIHtcbiAgICAgICAgICBpbnN0LnRyaWdnZXIoJ3BpbmNoJywgZXYpO1xuICAgICAgICAgIGluc3QudHJpZ2dlcigncGluY2gnICsgKGV2LnNjYWxlIDwgMSA/ICdpbicgOiAnb3V0JyksIGV2KTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBFVkVOVF9SRUxFQVNFOlxuICAgICAgICBpZiAodHJpZ2dlcmVkICYmIGV2LmNoYW5nZWRMZW5ndGggPCAyKSB7XG4gICAgICAgICAgaW5zdC50cmlnZ2VyKG5hbWUgKyAnZW5kJywgZXYpO1xuICAgICAgICAgIHRyaWdnZXJlZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIEdlc3R1cmVEZXRlY3Rvci5nZXN0dXJlcy5UcmFuc2Zvcm0gPSB7XG4gICAgICBuYW1lOiBuYW1lLFxuICAgICAgaW5kZXg6IDQ1LFxuICAgICAgZGVmYXVsdHM6IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIG1pbmltYWwgc2NhbGUgZmFjdG9yLCBubyBzY2FsZSBpcyAxLCB6b29taW4gaXMgdG8gMCBhbmQgem9vbW91dCB1bnRpbCBoaWdoZXIgdGhlbiAxXG4gICAgICAgICAqIEBwcm9wZXJ0eSB0cmFuc2Zvcm1NaW5TY2FsZVxuICAgICAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAgICAgKiBAZGVmYXVsdCAwLjAxXG4gICAgICAgICAqL1xuICAgICAgICB0cmFuc2Zvcm1NaW5TY2FsZTogMC4wMSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogcm90YXRpb24gaW4gZGVncmVlc1xuICAgICAgICAgKiBAcHJvcGVydHkgdHJhbnNmb3JtTWluUm90YXRpb25cbiAgICAgICAgICogQHR5cGUge051bWJlcn1cbiAgICAgICAgICogQGRlZmF1bHQgMVxuICAgICAgICAgKi9cbiAgICAgICAgdHJhbnNmb3JtTWluUm90YXRpb246IDFcbiAgICAgIH0sXG5cbiAgICAgIGhhbmRsZXI6IHRyYW5zZm9ybUdlc3R1cmVcbiAgICB9O1xuICB9KSgndHJhbnNmb3JtJyk7XG5cbmV4cG9ydCBkZWZhdWx0IEdlc3R1cmVEZXRlY3RvcjtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmxldCByZWFkeU1hcCwgcXVldWVNYXA7XG5cbmZ1bmN0aW9uIGlzQ29udGVudFJlYWR5KGVsZW1lbnQpIHtcbiAgaWYgKGVsZW1lbnQuY2hpbGROb2Rlcy5sZW5ndGggPiAwKSB7XG4gICAgc2V0Q29udGVudFJlYWR5KGVsZW1lbnQpO1xuICB9XG4gIHJldHVybiByZWFkeU1hcC5oYXMoZWxlbWVudCk7XG59XG5cbmZ1bmN0aW9uIHNldENvbnRlbnRSZWFkeShlbGVtZW50KSB7XG4gIHJlYWR5TWFwLnNldChlbGVtZW50LCB0cnVlKTtcbn1cblxuZnVuY3Rpb24gYWRkQ2FsbGJhY2soZWxlbWVudCwgZm4pIHtcbiAgaWYgKCFxdWV1ZU1hcC5oYXMoZWxlbWVudCkpIHtcbiAgICBxdWV1ZU1hcC5zZXQoZWxlbWVudCwgW10pO1xuICB9XG4gIHF1ZXVlTWFwLmdldChlbGVtZW50KS5wdXNoKGZuKTtcbn1cblxuZnVuY3Rpb24gY29uc3VtZVF1ZXVlKGVsZW1lbnQpIHtcbiAgY29uc3QgY2FsbGJhY2tzID0gcXVldWVNYXAuZ2V0KGVsZW1lbnQsIFtdKSB8fCBbXTtcbiAgcXVldWVNYXAuZGVsZXRlKGVsZW1lbnQpO1xuICBjYWxsYmFja3MuZm9yRWFjaChjYWxsYmFjayA9PiBjYWxsYmFjaygpKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY29udGVudFJlYWR5KGVsZW1lbnQsIGZuID0gKCkgPT4ge30pIHtcbiAgaWYgKHJlYWR5TWFwID09PSB1bmRlZmluZWQpIHtcbiAgICByZWFkeU1hcCA9IG5ldyBXZWFrTWFwKCk7XG4gICAgcXVldWVNYXAgPSBuZXcgV2Vha01hcCgpO1xuICB9XG5cbiAgYWRkQ2FsbGJhY2soZWxlbWVudCwgZm4pO1xuXG4gIGlmIChpc0NvbnRlbnRSZWFkeShlbGVtZW50KSkge1xuICAgIGNvbnN1bWVRdWV1ZShlbGVtZW50KTtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCBvYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKGNoYW5nZXMgPT4ge1xuICAgIHNldENvbnRlbnRSZWFkeShlbGVtZW50KTtcbiAgICBjb25zdW1lUXVldWUoZWxlbWVudCk7XG4gIH0pO1xuICBvYnNlcnZlci5vYnNlcnZlKGVsZW1lbnQsIHtjaGlsZExpc3Q6IHRydWUsIGNoYXJhY3RlckRhdGE6IHRydWV9KTtcblxuICAvLyBmYWlsYmFjayBmb3IgZWxlbWVudHMgaGFzIGVtcHR5IGNvbnRlbnQuXG4gIHNldEltbWVkaWF0ZSgoKSA9PiB7XG4gICAgc2V0Q29udGVudFJlYWR5KGVsZW1lbnQpO1xuICAgIGNvbnN1bWVRdWV1ZShlbGVtZW50KTtcbiAgfSk7XG59XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5jbGFzcyBUb2FzdFF1ZXVlIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5xdWV1ZSA9IFtdO1xuICB9XG5cbiAgYWRkKGZuLCBwcm9taXNlKSB7XG4gICAgdGhpcy5xdWV1ZS5wdXNoKGZuKTtcblxuICAgIGlmICh0aGlzLnF1ZXVlLmxlbmd0aCA9PT0gMSkge1xuICAgICAgc2V0SW1tZWRpYXRlKHRoaXMucXVldWVbMF0pO1xuICAgIH1cblxuICAgIHByb21pc2UudGhlbigoKSA9PiB7XG4gICAgICB0aGlzLnF1ZXVlLnNoaWZ0KCk7XG5cbiAgICAgIGlmICh0aGlzLnF1ZXVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgc2V0VGltZW91dCh0aGlzLnF1ZXVlWzBdLCAxMDAwLzMwKTsgLy8gQXBwbHkgc29tZSB2aXN1YWwgZGVsYXlcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBuZXcgVG9hc3RRdWV1ZSgpO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IHV0aWwgZnJvbSAnLi91dGlsJztcbmltcG9ydCBjb250ZW50UmVhZHkgZnJvbSAnLi9jb250ZW50LXJlYWR5JztcbmltcG9ydCBUb2FzdFF1ZXVlIGZyb20gJy4vaW50ZXJuYWwvdG9hc3QtcXVldWUnO1xuXG5jb25zdCBfc2V0QXR0cmlidXRlcyA9IChlbGVtZW50LCBvcHRpb25zKSA9PiB7XG4gIFsnaWQnLCAnY2xhc3MnLCAnYW5pbWF0aW9uJ11cbiAgICAuZm9yRWFjaChhID0+IG9wdGlvbnMuaGFzT3duUHJvcGVydHkoYSkgJiYgZWxlbWVudC5zZXRBdHRyaWJ1dGUoYSwgb3B0aW9uc1thXSkpO1xuXG4gIGlmIChvcHRpb25zLm1vZGlmaWVyKSB7XG4gICAgdXRpbC5hZGRNb2RpZmllcihlbGVtZW50LCBvcHRpb25zLm1vZGlmaWVyKTtcbiAgfVxufTtcblxuY29uc3QgX25vcm1hbGl6ZUFyZ3VtZW50cyA9IChtZXNzYWdlLCBvcHRpb25zID0ge30sIGRlZmF1bHRzID0ge30pID0+IHtcbiAgb3B0aW9ucyA9IHsgLi4ub3B0aW9ucyB9O1xuICB0eXBlb2YgbWVzc2FnZSA9PT0gJ3N0cmluZycgPyAob3B0aW9ucy5tZXNzYWdlID0gbWVzc2FnZSkgOiAob3B0aW9ucyA9IG1lc3NhZ2UpO1xuICBpZiAoIW9wdGlvbnMgfHwgIW9wdGlvbnMubWVzc2FnZSAmJiAhb3B0aW9ucy5tZXNzYWdlSFRNTCkge1xuICAgIHV0aWwudGhyb3coJ05vdGlmaWNhdGlvbnMgbXVzdCBjb250YWluIGEgbWVzc2FnZScpO1xuICB9XG5cbiAgaWYgKG9wdGlvbnMuaGFzT3duUHJvcGVydHkoJ2J1dHRvbkxhYmVscycpIHx8IG9wdGlvbnMuaGFzT3duUHJvcGVydHkoJ2J1dHRvbkxhYmVsJykpIHtcbiAgICBvcHRpb25zLmJ1dHRvbkxhYmVscyA9IG9wdGlvbnMuYnV0dG9uTGFiZWxzIHx8IG9wdGlvbnMuYnV0dG9uTGFiZWw7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KG9wdGlvbnMuYnV0dG9uTGFiZWxzKSkge1xuICAgICAgb3B0aW9ucy5idXR0b25MYWJlbHMgPSBbb3B0aW9ucy5idXR0b25MYWJlbHMgfHwgJyddXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHV0aWwuZXh0ZW5kKHtcbiAgICAgIGNvbXBpbGU6IHBhcmFtID0+IHBhcmFtLFxuICAgICAgY2FsbGJhY2s6IHBhcmFtID0+IHBhcmFtLFxuICAgICAgYW5pbWF0aW9uOiAnZGVmYXVsdCcsXG4gICAgICBjYW5jZWxhYmxlOiBmYWxzZSxcbiAgICAgIHByaW1hcnlCdXR0b25JbmRleDogKG9wdGlvbnMuYnV0dG9uTGFiZWxzIHx8IGRlZmF1bHRzLmJ1dHRvbkxhYmVscyB8fCBbXSkubGVuZ3RoIC0gMVxuICAgIH0sIGRlZmF1bHRzLCBvcHRpb25zKTtcbn07XG5cbi8qKlxuICogQG9iamVjdCBvbnMubm90aWZpY2F0aW9uXG4gKiBAY2F0ZWdvcnkgZGlhbG9nXG4gKiBAdHV0b3JpYWwgdmFuaWxsYS9SZWZlcmVuY2Uvbm90aWZpY2F0aW9uXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXVxuICogICAgIFV0aWxpdHkgbWV0aG9kcyB0byBjcmVhdGUgZGlmZmVyZW50IGtpbmRzIG9mIG5vdGlmaWNhdGlvbnMuIFRoZXJlIGFyZSB0aHJlZSBtZXRob2RzIGF2YWlsYWJsZTpcbiAqXG4gKiAgICAgKiBgb25zLm5vdGlmaWNhdGlvbi5hbGVydCgpYFxuICogICAgICogYG9ucy5ub3RpZmljYXRpb24uY29uZmlybSgpYFxuICogICAgICogYG9ucy5ub3RpZmljYXRpb24ucHJvbXB0KClgXG4gKiAgICAgKiBgb25zLm5vdGlmaWNhdGlvbi50b2FzdCgpYFxuICpcbiAqICAgICBJdCB3aWxsIGF1dG9tYXRpY2FsbHkgZGlzcGxheSBhIE1hdGVyaWFsIERlc2lnbiBkaWFsb2cgb24gQW5kcm9pZCBkZXZpY2VzLlxuICogICBbL2VuXVxuICogICBbamFd44GE44GP44Gk44GL44Gu56iu6aGe44Gu44Ki44Op44O844OI44OA44Kk44Ki44Ot44Kw44KS5L2c5oiQ44GZ44KL44Gf44KB44Gu44Om44O844OG44Kj44Oq44OG44Kj44Oh44K944OD44OJ44KS5Y+O44KB44Gf44Kq44OW44K444Kn44Kv44OI44Gn44GZ44CCWy9qYV1cbiAqIEBleGFtcGxlXG4gKiBvbnMubm90aWZpY2F0aW9uLmFsZXJ0KCdIZWxsbywgd29ybGQhJyk7XG4gKlxuICogb25zLm5vdGlmaWNhdGlvbi5jb25maXJtKCdBcmUgeW91IHJlYWR5PycpXG4gKiAgIC50aGVuKFxuICogICAgIGZ1bmN0aW9uKGFuc3dlcikge1xuICogICAgICAgaWYgKGFuc3dlciA9PT0gMSkge1xuICogICAgICAgICBvbnMubm90aWZpY2F0aW9uLmFsZXJ0KCdMZXRcXCdzIGdvIScpO1xuICogICAgICAgfVxuICogICAgIH1cbiAqICAgKTtcbiAqXG4gKiBvbnMubm90aWZpY2F0aW9uLnByb21wdCgnSG93IG9sZCBhcmUgPycpXG4gKiAgIC50aGVuKFxuICogICAgIGZ1bmN0aW9uKGFnZSkge1xuICogICAgICAgb25zLm5vdGlmaWNhdGlvbi5hbGVydCgnWW91IGFyZSAnICsgYWdlICsgJyB5ZWFycyBvbGQuJyk7XG4gKiAgICAgfVxuICogICApO1xuICovXG5jb25zdCBub3RpZmljYXRpb24gPSB7fTtcblxubm90aWZpY2F0aW9uLl9jcmVhdGVBbGVydERpYWxvZyA9ICguLi5wYXJhbXMpID0+IG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICBjb25zdCBvcHRpb25zID0gX25vcm1hbGl6ZUFyZ3VtZW50cyguLi5wYXJhbXMpO1xuICB1dGlsLmNoZWNrTWlzc2luZ0ltcG9ydCgnQWxlcnREaWFsb2cnLCAnQWxlcnREaWFsb2dCdXR0b24nKTtcblxuICAvLyBQcm9tcHQgaW5wdXQgc3RyaW5nXG4gIGxldCBpbnB1dFN0cmluZyA9ICcnO1xuICBpZiAob3B0aW9ucy5pc1Byb21wdCkge1xuICAgIGlucHV0U3RyaW5nID0gYFxuICAgICAgPGlucHV0XG4gICAgICAgIGNsYXNzPVwidGV4dC1pbnB1dCB0ZXh0LWlucHV0LS11bmRlcmJhclwiXG4gICAgICAgIHR5cGU9XCIke29wdGlvbnMuaW5wdXRUeXBlIHx8ICd0ZXh0J31cIlxuICAgICAgICBwbGFjZWhvbGRlcj1cIiR7b3B0aW9ucy5wbGFjZWhvbGRlciB8fCAnJ31cIlxuICAgICAgICB2YWx1ZT1cIiR7b3B0aW9ucy5kZWZhdWx0VmFsdWUgfHwgJyd9XCJcbiAgICAgICAgc3R5bGU9XCJ3aWR0aDogMTAwJTsgbWFyZ2luLXRvcDogMTBweDtcIlxuICAgICAgLz5cbiAgICBgO1xuICB9XG5cbiAgLy8gQnV0dG9ucyBzdHJpbmdcbiAgbGV0IGJ1dHRvbnMgPSAnJztcbiAgb3B0aW9ucy5idXR0b25MYWJlbHMuZm9yRWFjaCgobGFiZWwsIGluZGV4KSA9PiB7XG4gICAgYnV0dG9ucyArPSBgXG4gICAgICA8b25zLWFsZXJ0LWRpYWxvZy1idXR0b25cbiAgICAgICAgY2xhc3M9XCJcbiAgICAgICAgICAke2luZGV4ID09PSBvcHRpb25zLnByaW1hcnlCdXR0b25JbmRleCA/ICcgYWxlcnQtZGlhbG9nLWJ1dHRvbi0tcHJpbWFsJyA6ICcnfVxuICAgICAgICAgICR7b3B0aW9ucy5idXR0b25MYWJlbHMubGVuZ3RoIDw9IDIgPyAnIGFsZXJ0LWRpYWxvZy1idXR0b24tLXJvd2Zvb3RlcicgOiAnJ31cbiAgICAgICAgXCJcbiAgICAgICAgc3R5bGU9XCJwb3NpdGlvbjogcmVsYXRpdmU7XCI+XG4gICAgICAgICR7bGFiZWx9XG4gICAgICA8L29ucy1hbGVydC1kaWFsb2ctYnV0dG9uPlxuICAgIGA7XG4gIH0pO1xuXG4gIC8vIERpYWxvZyBFbGVtZW50XG4gIGxldCBlbCA9IHt9O1xuICBjb25zdCBfZGVzdHJveURpYWxvZyA9ICgpID0+IHtcbiAgICBpZiAoZWwuZGlhbG9nLm9uRGlhbG9nQ2FuY2VsKSB7XG4gICAgICBlbC5kaWFsb2cucmVtb3ZlRXZlbnRMaXN0ZW5lcignZGlhbG9nLWNhbmNlbCcsIGVsLmRpYWxvZy5vbkRpYWxvZ0NhbmNlbCk7XG4gICAgfVxuXG4gICAgT2JqZWN0LmtleXMoZWwpLmZvckVhY2goa2V5ID0+IGRlbGV0ZSBlbFtrZXldKTtcbiAgICBlbCA9IG51bGw7XG5cbiAgICBpZiAob3B0aW9ucy5kZXN0cm95IGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcbiAgICAgIG9wdGlvbnMuZGVzdHJveSgpO1xuICAgIH1cbiAgfTtcblxuICBlbC5kaWFsb2cgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdvbnMtYWxlcnQtZGlhbG9nJyk7XG4gIGVsLmRpYWxvZy5pbm5lckhUTUwgPSBgXG4gICAgPGRpdiBjbGFzcz1cImFsZXJ0LWRpYWxvZy1tYXNrXCJcbiAgICAgIHN0eWxlPVwiXG4gICAgICAgICR7b3B0aW9ucy5tYXNrQ29sb3IgPyAnYmFja2dyb3VuZC1jb2xvcjogJyArIG9wdGlvbnMubWFza0NvbG9yIDogJyd9XG4gICAgICBcIj48L2Rpdj5cbiAgICA8ZGl2IGNsYXNzPVwiYWxlcnQtZGlhbG9nXCI+XG4gICAgICA8ZGl2IGNsYXNzPVwiYWxlcnQtZGlhbG9nLWNvbnRhaW5lclwiPlxuICAgICAgICA8ZGl2IGNsYXNzPVwiYWxlcnQtZGlhbG9nLXRpdGxlXCI+XG4gICAgICAgICAgJHtvcHRpb25zLnRpdGxlIHx8ICcnfVxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgPGRpdiBjbGFzcz1cImFsZXJ0LWRpYWxvZy1jb250ZW50XCI+XG4gICAgICAgICAgJHtvcHRpb25zLm1lc3NhZ2UgfHwgb3B0aW9ucy5tZXNzYWdlSFRNTH1cbiAgICAgICAgICAke2lucHV0U3RyaW5nfVxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgPGRpdiBjbGFzcz1cIlxuICAgICAgICAgIGFsZXJ0LWRpYWxvZy1mb290ZXJcbiAgICAgICAgICAke29wdGlvbnMuYnV0dG9uTGFiZWxzLmxlbmd0aCA8PSAyID8gJyBhbGVydC1kaWFsb2ctZm9vdGVyLS1yb3dmb290ZXInIDogJyd9XG4gICAgICAgIFwiPlxuICAgICAgICAgICR7YnV0dG9uc31cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbiAgYDtcbiAgY29udGVudFJlYWR5KGVsLmRpYWxvZyk7XG5cbiAgLy8gU2V0IGF0dHJpYnV0ZXNcbiAgX3NldEF0dHJpYnV0ZXMoZWwuZGlhbG9nLCBvcHRpb25zKTtcblxuICAvLyBQcm9tcHQgZXZlbnRzXG4gIGlmIChvcHRpb25zLmlzUHJvbXB0ICYmIG9wdGlvbnMuc3VibWl0T25FbnRlcikge1xuICAgIGVsLmlucHV0ID0gZWwuZGlhbG9nLnF1ZXJ5U2VsZWN0b3IoJy50ZXh0LWlucHV0Jyk7XG4gICAgZWwuaW5wdXQub25rZXlwcmVzcyA9IGV2ZW50ID0+IHtcbiAgICAgIGlmIChldmVudC5rZXlDb2RlID09PSAxMykge1xuICAgICAgICBlbC5kaWFsb2cuaGlkZSgpXG4gICAgICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgaWYgKGVsKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHJlc29sdmVWYWx1ZSA9IGVsLmlucHV0LnZhbHVlO1xuICAgICAgICAgICAgICBfZGVzdHJveURpYWxvZygpO1xuICAgICAgICAgICAgICBvcHRpb25zLmNhbGxiYWNrKHJlc29sdmVWYWx1ZSk7XG4gICAgICAgICAgICAgIHJlc29sdmUocmVzb2x2ZVZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgLy8gQnV0dG9uIGV2ZW50c1xuICBlbC5mb290ZXIgPSBlbC5kaWFsb2cucXVlcnlTZWxlY3RvcignLmFsZXJ0LWRpYWxvZy1mb290ZXInKTtcbiAgdXRpbC5hcnJheUZyb20oZWwuZGlhbG9nLnF1ZXJ5U2VsZWN0b3JBbGwoJy5hbGVydC1kaWFsb2ctYnV0dG9uJykpLmZvckVhY2goKGJ1dHRvbkVsZW1lbnQsIGluZGV4KSA9PiB7XG4gICAgYnV0dG9uRWxlbWVudC5vbmNsaWNrID0gKCkgPT4ge1xuICAgICAgICBlbC5kaWFsb2cuaGlkZSgpXG4gICAgICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgaWYgKGVsKSB7XG4gICAgICAgICAgICAgIGxldCByZXNvbHZlVmFsdWUgPSBpbmRleDtcbiAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuaXNQcm9tcHQpIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlVmFsdWUgPSBpbmRleCA9PT0gb3B0aW9ucy5wcmltYXJ5QnV0dG9uSW5kZXggPyBlbC5pbnB1dC52YWx1ZSA6IG51bGw7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWwuZGlhbG9nLnJlbW92ZSgpO1xuICAgICAgICAgICAgICBfZGVzdHJveURpYWxvZygpO1xuICAgICAgICAgICAgICBvcHRpb25zLmNhbGxiYWNrKHJlc29sdmVWYWx1ZSk7XG4gICAgICAgICAgICAgIHJlc29sdmUocmVzb2x2ZVZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgZWwuZm9vdGVyLmFwcGVuZENoaWxkKGJ1dHRvbkVsZW1lbnQpO1xuICB9KTtcblxuICAvLyBDYW5jZWwgZXZlbnRzXG4gIGlmIChvcHRpb25zLmNhbmNlbGFibGUpIHtcbiAgICBlbC5kaWFsb2cuY2FuY2VsYWJsZSA9IHRydWU7XG4gICAgZWwuZGlhbG9nLm9uRGlhbG9nQ2FuY2VsID0gKCkgPT4ge1xuICAgICAgc2V0SW1tZWRpYXRlKCgpID0+IHtcbiAgICAgICAgZWwuZGlhbG9nLnJlbW92ZSgpO1xuICAgICAgICBfZGVzdHJveURpYWxvZygpO1xuICAgICAgfSk7XG4gICAgICBjb25zdCByZXNvbHZlVmFsdWUgPSBvcHRpb25zLmlzUHJvbXB0ID8gbnVsbCA6IC0xO1xuICAgICAgb3B0aW9ucy5jYWxsYmFjayhyZXNvbHZlVmFsdWUpO1xuICAgICAgcmVzb2x2ZShyZXNvbHZlVmFsdWUpO1xuICAgIH07XG4gICAgZWwuZGlhbG9nLmFkZEV2ZW50TGlzdGVuZXIoJ2RpYWxvZy1jYW5jZWwnLCBlbC5kaWFsb2cub25EaWFsb2dDYW5jZWwsIGZhbHNlKTtcbiAgfVxuXG4gIC8vIFNob3cgZGlhbG9nXG4gIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZWwuZGlhbG9nKTtcbiAgb3B0aW9ucy5jb21waWxlKGVsLmRpYWxvZyk7XG4gIHNldEltbWVkaWF0ZSgoKSA9PiB7XG4gICAgZWwuZGlhbG9nLnNob3coKVxuICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICBpZiAoZWwuaW5wdXQgJiYgb3B0aW9ucy5pc1Byb21wdCAmJiBvcHRpb25zLmF1dG9mb2N1cykge1xuICAgICAgICAgIGNvbnN0IHN0ckxlbmd0aCA9IGVsLmlucHV0LnZhbHVlLmxlbmd0aDtcbiAgICAgICAgICBlbC5pbnB1dC5mb2N1cygpO1xuICAgICAgICAgIGVsLmlucHV0LnNldFNlbGVjdGlvblJhbmdlKHN0ckxlbmd0aCwgc3RyTGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gIH0pO1xufSk7XG5cbi8qKlxuICogQG1ldGhvZCBhbGVydFxuICogQHNpZ25hdHVyZSBhbGVydChtZXNzYWdlIFssIG9wdGlvbnNdIHwgb3B0aW9ucylcbiAqIEByZXR1cm4ge1Byb21pc2V9XG4gKiAgIFtlbl1XaWxsIHJlc29sdmUgdG8gdGhlIGluZGV4IG9mIHRoZSBidXR0b24gdGhhdCB3YXMgcHJlc3NlZCBvciBgLTFgIHdoZW4gY2FuY2VsZWQuWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICogICBbZW5dTm90aWZpY2F0aW9uIG1lc3NhZ2UuIFRoaXMgYXJndW1lbnQgaXMgb3B0aW9uYWwgYnV0IGlmIGl0J3Mgbm90IGRlZmluZWQgZWl0aGVyIGBvcHRpb25zLm1lc3NhZ2VgIG9yIGBvcHRpb25zLm1lc3NhZ2VIVE1MYCBtdXN0IGJlIGRlZmluZWQgaW5zdGVhZC5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiAgIFtlbl1QYXJhbWV0ZXIgb2JqZWN0LlsvZW5dXG4gKiAgIFtqYV3jgqrjg5fjgrfjg6fjg7PjgpLmjIflrprjgZnjgovjgqrjg5bjgrjjgqfjgq/jg4jjgafjgZnjgIJbL2phXVxuICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLm1lc3NhZ2VdXG4gKiAgIFtlbl1Ob3RpZmljYXRpb24gbWVzc2FnZS5bL2VuXVxuICogICBbamFd44Ki44Op44O844OI44OA44Kk44Ki44Ot44Kw44Gr6KGo56S644GZ44KL5paH5a2X5YiX44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5tZXNzYWdlSFRNTF1cbiAqICAgW2VuXU5vdGlmaWNhdGlvbiBtZXNzYWdlIGluIEhUTUwuWy9lbl1cbiAqICAgW2phXeOCouODqeODvOODiOODgOOCpOOCouODreOCsOOBq+ihqOekuuOBmeOCi0hUTUzjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICogQHBhcmFtIHtTdHJpbmcgfCBBcnJheX0gW29wdGlvbnMuYnV0dG9uTGFiZWxzXVxuICogICBbZW5dTGFiZWxzIGZvciB0aGUgYnV0dG9ucy4gRGVmYXVsdCBpcyBgXCJPS1wiYC5bL2VuXVxuICogICBbamFd56K66KqN44Oc44K/44Oz44Gu44Op44OZ44Or44KS5oyH5a6a44GX44G+44GZ44CCXCJPS1wi44GM44OH44OV44Kp44Or44OI44Gn44GZ44CCWy9qYV1cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5wcmltYXJ5QnV0dG9uSW5kZXhdXG4gKiAgIFtlbl1JbmRleCBvZiBwcmltYXJ5IGJ1dHRvbi4gRGVmYXVsdCBpcyB0aGUgbGFzdCBvbmUuWy9lbl1cbiAqICAgW2phXeODl+ODqeOCpOODnuODquODnOOCv+ODs+OBruOCpOODs+ODh+ODg+OCr+OCueOCkuaMh+WumuOBl+OBvuOBmeOAguODh+ODleOCqeODq+ODiOOBryAwIOOBp+OBmeOAglsvamFdXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmNhbmNlbGFibGVdXG4gKiAgIFtlbl1XaGV0aGVyIHRoZSBkaWFsb2cgaXMgY2FuY2VsYWJsZSBvciBub3QuIERlZmF1bHQgaXMgYGZhbHNlYC4gSWYgdGhlIGRpYWxvZyBpcyBjYW5jZWxhYmxlIGl0IGNhbiBiZSBjbG9zZWQgYnkgY2xpY2tpbmcgdGhlIGJhY2tncm91bmQgb3IgcHJlc3NpbmcgdGhlIEFuZHJvaWQgYmFjayBidXR0b24uWy9lbl1cbiAqICAgW2phXeODgOOCpOOCouODreOCsOOBjOOCreODo+ODs+OCu+ODq+WPr+iDveOBi+OBqeOBhuOBi+OCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuYW5pbWF0aW9uXVxuICogICBbZW5dQW5pbWF0aW9uIG5hbWUuIEF2YWlsYWJsZSBhbmltYXRpb25zIGFyZSBgbm9uZWAgYW5kIGBmYWRlYC4gRGVmYXVsdCBpcyBgZmFkZWAuWy9lbl1cbiAqICAgW2phXeOCouODqeODvOODiOODgOOCpOOCouODreOCsOOCkuihqOekuuOBmeOCi+mam+OBruOCouODi+ODoeODvOOCt+ODp+ODs+WQjeOCkuaMh+WumuOBl+OBvuOBmeOAglwibm9uZVwiLCBcImZhZGVcIuOBruOBhOOBmuOCjOOBi+OCkuaMh+WumuOBp+OBjeOBvuOBmeOAglsvamFdXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuaWRdXG4gKiAgIFtlbl1UaGUgYDxvbnMtYWxlcnQtZGlhbG9nPmAgZWxlbWVudCdzIElELlsvZW5dXG4gKiAgIFtqYV1vbnMtYWxlcnQtZGlhbG9n6KaB57Sg44GuSUTjgIJbL2phXVxuICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmNsYXNzXVxuICogICBbZW5dVGhlIGA8b25zLWFsZXJ0LWRpYWxvZz5gIGVsZW1lbnQncyBjbGFzcy5bL2VuXVxuICogICBbamFdb25zLWFsZXJ0LWRpYWxvZ+imgee0oOOBrmNsYXNz44CCWy9qYV1cbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy50aXRsZV1cbiAqICAgW2VuXURpYWxvZyB0aXRsZS4gRGVmYXVsdCBpcyBgXCJBbGVydFwiYC5bL2VuXVxuICogICBbamFd44Ki44Op44O844OI44OA44Kk44Ki44Ot44Kw44Gu5LiK6YOo44Gr6KGo56S644GZ44KL44K/44Kk44OI44Or44KS5oyH5a6a44GX44G+44GZ44CCXCJBbGVydFwi44GM44OH44OV44Kp44Or44OI44Gn44GZ44CCWy9qYV1cbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5tb2RpZmllcl1cbiAqICAgW2VuXU1vZGlmaWVyIGZvciB0aGUgZGlhbG9nLlsvZW5dXG4gKiAgIFtqYV3jgqLjg6njg7zjg4jjg4DjgqTjgqLjg63jgrDjga5tb2RpZmllcuWxnuaAp+OBruWApOOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMubWFza0NvbG9yXVxuICogICBbZW5dQ29sb3Igb2YgdGhlIGJhY2tncm91bmQgbWFzay4gRGVmYXVsdCBpcyBcInJnYmEoMCwgMCwgMCwgMC4yKVwiIChcInJnYmEoMCwgMCwgMCwgMC4zKVwiIGZvciBNYXRlcmlhbCkuWy9lbl1cbiAqICAgW2phXeiDjOaZr+OBruODnuOCueOCr+OBruiJsuOCkuaMh+WumuOBl+OBvuOBmeOAglwicmdiYSgwLCAwLCAwLCAwLjIpXCLjgYzjg4fjg5Xjgqnjg6vjg4jlgKTjgafjgZnjgIJbL2phXVxuICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuY2FsbGJhY2tdXG4gKiAgIFtlbl1GdW5jdGlvbiB0aGF0IGV4ZWN1dGVzIGFmdGVyIGRpYWxvZyBoYXMgYmVlbiBjbG9zZWQuWy9lbl1cbiAqICAgW2phXeOCouODqeODvOODiOODgOOCpOOCouODreOCsOOBjOmWieOBmOOCieOCjOOBn+aZguOBq+WRvOOBs+WHuuOBleOCjOOCi+mWouaVsOOCquODluOCuOOCp+OCr+ODiOOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXVxuICogICAgIERpc3BsYXkgYW4gYWxlcnQgZGlhbG9nIHRvIHNob3cgdGhlIHVzZXIgYSBtZXNzYWdlLlxuICpcbiAqICAgICBUaGUgY29udGVudCBvZiB0aGUgbWVzc2FnZSBjYW4gYmUgZWl0aGVyIHNpbXBsZSB0ZXh0IG9yIEhUTUwuXG4gKlxuICogICAgIEl0IGNhbiBiZSBjYWxsZWQgaW4gdGhlIGZvbGxvd2luZyB3YXlzOlxuICpcbiAqICAgICBgYGBcbiAqICAgICBvbnMubm90aWZpY2F0aW9uLmFsZXJ0KG1lc3NhZ2UsIG9wdGlvbnMpO1xuICogICAgIG9ucy5ub3RpZmljYXRpb24uYWxlcnQob3B0aW9ucyk7XG4gKiAgICAgYGBgXG4gKlxuICogICAgIE11c3Qgc3BlY2lmeSBlaXRoZXIgYG1lc3NhZ2VgIG9yIGBtZXNzYWdlSFRNTGAuXG4gKiAgIFsvZW5dXG4gKiAgIFtqYV1cbiAqICAgICDjg6bjg7zjgrbjg7zjgbjjg6Hjg4Pjgrvjg7zjgrjjgpLopovjgZvjgovjgZ/jgoHjga7jgqLjg6njg7zjg4jjg4DjgqTjgqLjg63jgrDjgpLooajnpLrjgZfjgb7jgZnjgIJcbiAqICAgICDooajnpLrjgZnjgovjg6Hjg4Pjgrvjg7zjgrjjga/jgIHjg4bjgq3jgrnjg4jjgYvjgoLjgZfjgY/jga9IVE1M44KS5oyH5a6a44Gn44GN44G+44GZ44CCXG4gKiAgICAg44GT44Gu44Oh44K944OD44OJ44Gu5byV5pWw44Gr44Gv44CBb3B0aW9ucy5tZXNzYWdl44KC44GX44GP44Gvb3B0aW9ucy5tZXNzYWdlSFRNTOOBruOBqeOBoeOCieOBi+OCkuW/heOBmuaMh+WumuOBmeOCi+W/heimgeOBjOOBguOCiuOBvuOBmeOAglxuICogICBbL2phXVxuICovXG5ub3RpZmljYXRpb24uYWxlcnQgPSAobWVzc2FnZSwgb3B0aW9ucykgPT5cbiAgbm90aWZpY2F0aW9uLl9jcmVhdGVBbGVydERpYWxvZyhtZXNzYWdlLCBvcHRpb25zLCB7XG4gICAgYnV0dG9uTGFiZWxzOiBbJ09LJ10sXG4gICAgdGl0bGU6ICdBbGVydCdcbiAgfSk7XG5cbi8qKlxuICogQG1ldGhvZCBjb25maXJtXG4gKiBAc2lnbmF0dXJlIGNvbmZpcm0obWVzc2FnZSBbLCBvcHRpb25zXSB8IG9wdGlvbnMpXG4gKiBAcmV0dXJuIHtQcm9taXNlfVxuICogICBbZW5dV2lsbCByZXNvbHZlIHRvIHRoZSBpbmRleCBvZiB0aGUgYnV0dG9uIHRoYXQgd2FzIHByZXNzZWQgb3IgYC0xYCB3aGVuIGNhbmNlbGVkLlsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAqICAgW2VuXU5vdGlmaWNhdGlvbiBtZXNzYWdlLiBUaGlzIGFyZ3VtZW50IGlzIG9wdGlvbmFsIGJ1dCBpZiBpdCdzIG5vdCBkZWZpbmVkIGVpdGhlciBgb3B0aW9ucy5tZXNzYWdlYCBvciBgb3B0aW9ucy5tZXNzYWdlSFRNTGAgbXVzdCBiZSBkZWZpbmVkIGluc3RlYWQuWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogICBbZW5dUGFyYW1ldGVyIG9iamVjdC5bL2VuXVxuICogQHBhcmFtIHtBcnJheX0gW29wdGlvbnMuYnV0dG9uTGFiZWxzXVxuICogICBbZW5dTGFiZWxzIGZvciB0aGUgYnV0dG9ucy4gRGVmYXVsdCBpcyBgW1wiQ2FuY2VsXCIsIFwiT0tcIl1gLlsvZW5dXG4gKiAgIFtqYV3jg5zjgr/jg7Pjga7jg6njg5njg6vjga7phY3liJfjgpLmjIflrprjgZfjgb7jgZnjgIJbXCJDYW5jZWxcIiwgXCJPS1wiXeOBjOODh+ODleOCqeODq+ODiOOBp+OBmeOAglsvamFdXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucHJpbWFyeUJ1dHRvbkluZGV4XVxuICogICBbZW5dSW5kZXggb2YgcHJpbWFyeSBidXR0b24uIERlZmF1bHQgaXMgdGhlIGxhc3Qgb25lLlsvZW5dXG4gKiAgIFtqYV3jg5fjg6njgqTjg57jg6rjg5zjgr/jg7Pjga7jgqTjg7Pjg4fjg4Pjgq/jgrnjgpLmjIflrprjgZfjgb7jgZnjgILjg4fjg5Xjgqnjg6vjg4jjga8gMSDjgafjgZnjgIJbL2phXVxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1cbiAqICAgICBEaXNwbGF5IGEgZGlhbG9nIHRvIGFzayB0aGUgdXNlciBmb3IgY29uZmlybWF0aW9uLiBFeHRlbmRzIGBhbGVydCgpYCBwYXJhbWV0ZXJzLlxuICogICAgIFRoZSBkZWZhdWx0IGJ1dHRvbiBsYWJlbHMgYXJlIGBcIkNhbmNlbFwiYCBhbmQgYFwiT0tcImAgYnV0IHRoZXkgY2FuIGJlIGN1c3RvbWl6ZWQuXG4gKlxuICogICAgIEl0IGNhbiBiZSBjYWxsZWQgaW4gdGhlIGZvbGxvd2luZyB3YXlzOlxuICpcbiAqICAgICBgYGBcbiAqICAgICBvbnMubm90aWZpY2F0aW9uLmNvbmZpcm0obWVzc2FnZSwgb3B0aW9ucyk7XG4gKiAgICAgb25zLm5vdGlmaWNhdGlvbi5jb25maXJtKG9wdGlvbnMpO1xuICogICAgIGBgYFxuICpcbiAqICAgICBNdXN0IHNwZWNpZnkgZWl0aGVyIGBtZXNzYWdlYCBvciBgbWVzc2FnZUhUTUxgLlxuICogICBbL2VuXVxuICogICBbamFdXG4gKiAgICAg44Om44O844K244Gr56K66KqN44KS5L+D44GZ44OA44Kk44Ki44Ot44Kw44KS6KGo56S644GX44G+44GZ44CCXG4gKiAgICAg44OH44Kq44Or44Go44Gu44Oc44K/44Oz44Op44OZ44Or44Gv44CBXCJDYW5jZWxcIuOBqFwiT0tcIuOBp+OBmeOBjOOAgeOBk+OCjOOBr+OBk+OBruODoeOCveODg+ODieOBruW8leaVsOOBp+OCq+OCueOCv+ODnuOCpOOCuuOBp+OBjeOBvuOBmeOAglxuICogICAgIOOBk+OBruODoeOCveODg+ODieOBruW8leaVsOOBq+OBr+OAgW9wdGlvbnMubWVzc2FnZeOCguOBl+OBj+OBr29wdGlvbnMubWVzc2FnZUhUTUzjga7jganjgaHjgonjgYvjgpLlv4XjgZrmjIflrprjgZnjgovlv4XopoHjgYzjgYLjgorjgb7jgZnjgIJcbiAqICAgWy9qYV1cbiAqL1xubm90aWZpY2F0aW9uLmNvbmZpcm0gPSAobWVzc2FnZSwgb3B0aW9ucykgPT5cbiAgbm90aWZpY2F0aW9uLl9jcmVhdGVBbGVydERpYWxvZyhtZXNzYWdlLCBvcHRpb25zLCB7XG4gICAgYnV0dG9uTGFiZWxzOiBbJ0NhbmNlbCcsICdPSyddLFxuICAgIHRpdGxlOiAnQ29uZmlybSdcbiAgfSk7XG5cbi8qKlxuICogQG1ldGhvZCBwcm9tcHRcbiAqIEBzaWduYXR1cmUgcHJvbXB0KG1lc3NhZ2UgWywgb3B0aW9uc10gfCBvcHRpb25zKVxuICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAqICAgW2VuXU5vdGlmaWNhdGlvbiBtZXNzYWdlLiBUaGlzIGFyZ3VtZW50IGlzIG9wdGlvbmFsIGJ1dCBpZiBpdCdzIG5vdCBkZWZpbmVkIGVpdGhlciBgb3B0aW9ucy5tZXNzYWdlYCBvciBgb3B0aW9ucy5tZXNzYWdlSFRNTGAgbXVzdCBiZSBkZWZpbmVkIGluc3RlYWQuWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAcmV0dXJuIHtQcm9taXNlfVxuICogICBbZW5dV2lsbCByZXNvbHZlIHRvIHRoZSBpbnB1dCB2YWx1ZSB3aGVuIHRoZSBkaWFsb2cgaXMgY2xvc2VkIG9yIGBudWxsYCB3aGVuIGNhbmNlbGVkLlsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqICAgW2VuXVBhcmFtZXRlciBvYmplY3QuWy9lbl1cbiAqICAgW2phXeOCquODl+OCt+ODp+ODs+OCkuaMh+WumuOBmeOCi+OCquODluOCuOOCp+OCr+ODiOOBp+OBmeOAglsvamFdXG4gKiBAcGFyYW0ge1N0cmluZyB8IEFycmF5fSBbb3B0aW9ucy5idXR0b25MYWJlbHNdXG4gKiAgIFtlbl1MYWJlbHMgZm9yIHRoZSBidXR0b25zLiBEZWZhdWx0IGlzIGBcIk9LXCJgLlsvZW5dXG4gKiAgIFtqYV3norroqo3jg5zjgr/jg7Pjga7jg6njg5njg6vjgpLmjIflrprjgZfjgb7jgZnjgIJcIk9LXCLjgYzjg4fjg5Xjgqnjg6vjg4jjgafjgZnjgIJbL2phXVxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnByaW1hcnlCdXR0b25JbmRleF1cbiAqICAgW2VuXUluZGV4IG9mIHByaW1hcnkgYnV0dG9uLiBEZWZhdWx0IGlzIHRoZSBsYXN0IG9uZS5bL2VuXVxuICogICBbamFd44OX44Op44Kk44Oe44Oq44Oc44K/44Oz44Gu44Kk44Oz44OH44OD44Kv44K544KS5oyH5a6a44GX44G+44GZ44CC44OH44OV44Kp44Or44OI44GvIDAg44Gn44GZ44CCWy9qYV1cbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5wbGFjZWhvbGRlcl1cbiAqICAgW2VuXVBsYWNlaG9sZGVyIGZvciB0aGUgdGV4dCBpbnB1dC5bL2VuXVxuICogICBbamFd44OG44Kt44K544OI5qyE44Gu44OX44Os44O844K544Ob44Or44OA44Gr6KGo56S644GZ44KL44OG44Kt44K544OI44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5kZWZhdWx0VmFsdWVdXG4gKiAgIFtlbl1EZWZhdWx0IHZhbHVlIGZvciB0aGUgdGV4dCBpbnB1dC5bL2VuXVxuICogICBbamFd44OG44Kt44K544OI5qyE44Gu44OH44OV44Kp44Or44OI44Gu5YCk44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5pbnB1dFR5cGVdXG4gKiAgIFtlbl1UeXBlIG9mIHRoZSBpbnB1dCBlbGVtZW50IChgcGFzc3dvcmRgLCBgZGF0ZWAuLi4pLiBEZWZhdWx0IGlzIGB0ZXh0YC5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuYXV0b2ZvY3VzXVxuICogICBbZW5dQXV0b2ZvY3VzIHRoZSBpbnB1dCBlbGVtZW50LiBEZWZhdWx0IGlzIGB0cnVlYC4gSW4gQ29yZG92YSwgYEtleWJvYXJkRGlzcGxheVJlcXVpcmVzVXNlckFjdGlvbmAgaW4gYGNvbmZpZy54bWxgIG11c3QgYmUgYGZhbHNlYCB0byBhY3RpdmF0ZSB0aGlzIGZlYXR1cmUuWy9lbl1cbiAqICAgW2phXWlucHV06KaB57Sg44Gr6Ieq5YuV55qE44Gr44OV44Kp44O844Kr44K544GZ44KL44GL44Gp44GG44GL44KS5oyH5a6a44GX44G+44GZ44CC44OH44OV44Kp44Or44OI44GvdHJ1ZeOBp+OBmeOAgkNvcmRvdmHnkrDlooPjgafjga/jgIHjgZPjga7mqZ/og73jgpLmnInlirnjgavjgZnjgovjgZ/jgoHjgavjga8gYGNvbmZpZy54bWxgIOOBpyBgS2V5Ym9hcmREaXNwbGF5UmVxdWlyZXNVc2VyQWN0aW9uYCDjgpIgYGZhbHNlYCDjgavoqK3lrprjgZnjgovlv4XopoHjgYzjgYLjgorjgb7jgZnjgIJbL2phXVxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5zdWJtaXRPbkVudGVyXVxuICogICBbZW5dU3VibWl0IGF1dG9tYXRpY2FsbHkgd2hlbiBlbnRlciBpcyBwcmVzc2VkLiBEZWZhdWx0IGlzIGB0cnVlYC5bL2VuXVxuICogICBbamFdRW50ZXLjgYzmirzjgZXjgozjgZ/pmpvjgavjgZ3jga5mb3Jt44KSc3VibWl044GZ44KL44GL44Gp44GG44GL44KS5oyH5a6a44GX44G+44GZ44CC44OH44OV44Kp44Or44OI44GvdHJ1ZeOBp+OBmeOAglsvamFdXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXVxuICogICAgIERpc3BsYXkgYSBkaWFsb2cgd2l0aCBhIHByb21wdCB0byBhc2sgdGhlIHVzZXIgYSBxdWVzdGlvbi4gRXh0ZW5kcyBgYWxlcnQoKWAgcGFyYW1ldGVycy5cbiAqXG4gKiAgICAgSXQgY2FuIGJlIGNhbGxlZCBpbiB0aGUgZm9sbG93aW5nIHdheXM6XG4gKlxuICogICAgIGBgYFxuICogICAgIG9ucy5ub3RpZmljYXRpb24ucHJvbXB0KG1lc3NhZ2UsIG9wdGlvbnMpO1xuICogICAgIG9ucy5ub3RpZmljYXRpb24ucHJvbXB0KG9wdGlvbnMpO1xuICogICAgIGBgYFxuICpcbiAqICAgICBNdXN0IHNwZWNpZnkgZWl0aGVyIGBtZXNzYWdlYCBvciBgbWVzc2FnZUhUTUxgLlxuICogICBbL2VuXVxuICogICBbamFdXG4gKiAgICAg44Om44O844K244O844Gr5YWl5Yqb44KS5L+D44GZ44OA44Kk44Ki44Ot44Kw44KS6KGo56S644GX44G+44GZ44CCXG4gKiAgICAg44GT44Gu44Oh44K944OD44OJ44Gu5byV5pWw44Gr44Gv44CBb3B0aW9ucy5tZXNzYWdl44KC44GX44GP44Gvb3B0aW9ucy5tZXNzYWdlSFRNTOOBruOBqeOBoeOCieOBi+OCkuW/heOBmuaMh+WumuOBmeOCi+W/heimgeOBjOOBguOCiuOBvuOBmeOAglxuICogICBbL2phXVxuICovXG5ub3RpZmljYXRpb24ucHJvbXB0ID0gKG1lc3NhZ2UsIG9wdGlvbnMpID0+XG4gIG5vdGlmaWNhdGlvbi5fY3JlYXRlQWxlcnREaWFsb2cobWVzc2FnZSwgb3B0aW9ucywge1xuICAgIGJ1dHRvbkxhYmVsczogWydPSyddLFxuICAgIHRpdGxlOiAnQWxlcnQnLFxuICAgIGlzUHJvbXB0OiB0cnVlLFxuICAgIGF1dG9mb2N1czogdHJ1ZSxcbiAgICBzdWJtaXRPbkVudGVyOiB0cnVlXG4gIH0pO1xuXG4vKipcbiAqIEBtZXRob2QgdG9hc3RcbiAqIEBzaWduYXR1cmUgdG9hc3QobWVzc2FnZSBbLCBvcHRpb25zXSB8IG9wdGlvbnMpXG4gKiBAcmV0dXJuIHtQcm9taXNlfVxuICogICBbZW5dV2lsbCByZXNvbHZlIHdoZW4gdGhlIHRvYXN0IGlzIGhpZGRlbi5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gKiAgIFtlbl1Ub2FzdCBtZXNzYWdlLiBUaGlzIGFyZ3VtZW50IGlzIG9wdGlvbmFsIGJ1dCBpZiBpdCdzIG5vdCBkZWZpbmVkIHRoZW4gYG9wdGlvbnMubWVzc2FnZWAgbXVzdCBiZSBkZWZpbmVkIGluc3RlYWQuWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogICBbZW5dUGFyYW1ldGVyIG9iamVjdC5bL2VuXVxuICogICBbamFd44Kq44OX44K344On44Oz44KS5oyH5a6a44GZ44KL44Kq44OW44K444Kn44Kv44OI44Gn44GZ44CCWy9qYV1cbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5tZXNzYWdlXVxuICogICBbZW5dTm90aWZpY2F0aW9uIG1lc3NhZ2UuWy9lbl1cbiAqICAgW2phXeODiOODvOOCueODiOOBq+ihqOekuuOBmeOCi+aWh+Wtl+WIl+OCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuYnV0dG9uTGFiZWxdXG4gKiAgIFtlbl1MYWJlbCBmb3IgdGhlIGJ1dHRvbi5bL2VuXVxuICogICBbamFd56K66KqN44Oc44K/44Oz44Gu44Op44OZ44Or44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5hbmltYXRpb25dXG4gKiAgIFtlbl1BbmltYXRpb24gbmFtZS4gQXZhaWxhYmxlIGFuaW1hdGlvbnMgYXJlIGBub25lYCwgYGZhZGVgLCBgYXNjZW5kYCwgYGxpZnRgIGFuZCBgZmFsbGAuIERlZmF1bHQgaXMgYGFzY2VuZGAgZm9yIEFuZHJvaWQgYW5kIGBsaWZ0YCBmb3IgaU9TLlsvZW5dXG4gKiAgIFtqYV3jg4jjg7zjgrnjg4jjgpLooajnpLrjgZnjgovpmpvjga7jgqLjg4vjg6Hjg7zjgrfjg6fjg7PlkI3jgpLmjIflrprjgZfjgb7jgZnjgIJcIm5vbmVcIiwgXCJmYWRlXCIsIFwiYXNjZW5kXCIsIFwibGlmdFwiLCBcImZhbGxcIuOBruOBhOOBmuOCjOOBi+OCkuaMh+WumuOBp+OBjeOBvuOBmeOAglsvamFdXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMudGltZW91dF1cbiAqICAgW2VuXU51bWJlciBvZiBtaWxpc2Vjb25kcyB3aGVyZSB0aGUgdG9hc3QgaXMgdmlzaWJsZSBiZWZvcmUgaGlkaW5nIGF1dG9tYXRpY2FsbHkuWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmZvcmNlXVxuICogICBbZW5dSWYgYHRydWVgLCB0aGUgdG9hc3Qgc2tpcHMgdGhlIG5vdGlmaWNhdGlvbiBxdWV1ZSBhbmQgaXMgc2hvd24gaW1tZWRpYXRlbHkuIERlZmF1bHRzIHRvIGBmYWxzZWAuWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuaWRdXG4gKiAgIFtlbl1UaGUgYDxvbnMtdG9hc3Q+YCBlbGVtZW50J3MgSUQuWy9lbl1cbiAqICAgW2phXW9ucy10b2FzdOimgee0oOOBrklE44CCWy9qYV1cbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5jbGFzc11cbiAqICAgW2VuXVRoZSBgPG9ucy10b2FzdD5gIGVsZW1lbnQncyBjbGFzcy5bL2VuXVxuICogICBbamFdb25zLXRvYXN06KaB57Sg44GuY2xhc3PjgIJbL2phXVxuICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLm1vZGlmaWVyXVxuICogICBbZW5dTW9kaWZpZXIgZm9yIHRoZSBlbGVtZW50LlsvZW5dXG4gKiAgIFtqYV3jg4jjg7zjgrnjg4jjga5tb2RpZmllcuWxnuaAp+OBruWApOOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5jYWxsYmFja11cbiAqICAgW2VuXUZ1bmN0aW9uIHRoYXQgZXhlY3V0ZXMgYWZ0ZXIgdG9hc3QgaGFzIGJlZW4gaGlkZGVuLlsvZW5dXG4gKiAgIFtqYV3jg4jjg7zjgrnjg4jjgYzplonjgZjjgonjgozjgZ/mmYLjgavlkbzjgbPlh7rjgZXjgozjgovplqLmlbDjgqrjg5bjgrjjgqfjgq/jg4jjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1cbiAqICAgICBEaXNwbGF5IGEgc2ltcGxlIG5vdGlmaWNhdGlvbiB0b2FzdCB3aXRoIGFuIG9wdGlvbmFsIGJ1dHRvbiB0aGF0IGNhbiBiZSB1c2VkIGZvciBzaW1wbGUgYWN0aW9ucy5cbiAqXG4gKiAgICAgSXQgY2FuIGJlIGNhbGxlZCBpbiB0aGUgZm9sbG93aW5nIHdheXM6XG4gKlxuICogICAgIGBgYFxuICogICAgIG9ucy5ub3RpZmljYXRpb24udG9hc3QobWVzc2FnZSwgb3B0aW9ucyk7XG4gKiAgICAgb25zLm5vdGlmaWNhdGlvbi50b2FzdChvcHRpb25zKTtcbiAqICAgICBgYGBcbiAqICAgWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKi9cbm5vdGlmaWNhdGlvbi50b2FzdCA9IChtZXNzYWdlLCBvcHRpb25zKSA9PiB7XG4gIGNvbnN0IHByb21pc2UgPSBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICB1dGlsLmNoZWNrTWlzc2luZ0ltcG9ydCgnVG9hc3QnKTsgLy8gVGhyb3dzIGVycm9yLCBtdXN0IGJlIGluc2lkZSBwcm9taXNlXG5cbiAgICBvcHRpb25zID0gX25vcm1hbGl6ZUFyZ3VtZW50cyhtZXNzYWdlLCBvcHRpb25zLCB7XG4gICAgICB0aW1lb3V0OiAwLFxuICAgICAgZm9yY2U6IGZhbHNlXG4gICAgfSk7XG5cbiAgICBsZXQgdG9hc3QgPSB1dGlsLmNyZWF0ZUVsZW1lbnQoYFxuICAgICAgPG9ucy10b2FzdD5cbiAgICAgICAgJHtvcHRpb25zLm1lc3NhZ2V9XG4gICAgICAgICR7b3B0aW9ucy5idXR0b25MYWJlbHMgPyBgPGJ1dHRvbj4ke29wdGlvbnMuYnV0dG9uTGFiZWxzWzBdfTwvYnV0dG9uPmAgOiAnJ31cbiAgICAgIDwvb25zLXRvYXN0PlxuICAgIGApO1xuXG4gICAgX3NldEF0dHJpYnV0ZXModG9hc3QsIG9wdGlvbnMpO1xuXG4gICAgY29uc3QgZmluaXNoID0gdmFsdWUgPT4ge1xuICAgICAgaWYgKHRvYXN0KSB7XG4gICAgICAgIHRvYXN0XG4gICAgICAgIC5oaWRlKClcbiAgICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICAgIGlmICh0b2FzdCkge1xuICAgICAgICAgICAgdG9hc3QucmVtb3ZlKCk7XG4gICAgICAgICAgICB0b2FzdCA9IG51bGw7XG4gICAgICAgICAgICBvcHRpb25zLmNhbGxiYWNrKHZhbHVlKTtcbiAgICAgICAgICAgIHJlc29sdmUodmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGlmIChvcHRpb25zLmJ1dHRvbkxhYmVscykge1xuICAgICAgdXRpbC5maW5kQ2hpbGQodG9hc3QuX3RvYXN0LCAnYnV0dG9uJykub25jbGljayA9ICgpID0+IGZpbmlzaCgwKTtcbiAgICB9XG5cbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRvYXN0KTtcbiAgICBvcHRpb25zLmNvbXBpbGUodG9hc3QpO1xuXG4gICAgY29uc3Qgc2hvdyA9ICgpID0+IHtcbiAgICAgIHRvYXN0LnBhcmVudEVsZW1lbnQgJiYgdG9hc3Quc2hvdyhvcHRpb25zKS50aGVuKCgpID0+IHtcbiAgICAgICAgaWYgKG9wdGlvbnMudGltZW91dCkge1xuICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4gZmluaXNoKC0xKSwgb3B0aW9ucy50aW1lb3V0KVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgc2V0SW1tZWRpYXRlKCgpID0+IG9wdGlvbnMuZm9yY2UgPyBzaG93KCkgOiBUb2FzdFF1ZXVlLmFkZChzaG93LCBwcm9taXNlKSlcbiAgfSk7XG5cbiAgcmV0dXJuIHByb21pc2U7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBub3RpZmljYXRpb247XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgdXRpbCBmcm9tICcuL3V0aWwnO1xuXG4vLyBWYWxpZGF0ZSBwYXJhbWV0ZXJzXG5jb25zdCBjaGVja09wdGlvbnMgPSBvcHRpb25zID0+IHtcbiAgY29uc3QgZXJyID0gKHByb3AsIHR5cGUgPSAnRnVuY3Rpb24nKSA9PiB1dGlsLnRocm93KGBcIm9wdGlvbnMuJHtwcm9wfVwiIG11c3QgYmUgYW4gaW5zdGFuY2Ugb2YgJHt0eXBlfWApO1xuICBjb25zdCBoYXNPd25Qcm9wZXJ0eSA9IHByb3AgPT4gT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwob3B0aW9ucywgcHJvcCk7XG4gIGNvbnN0IGluc3RhbmNlT2YgPSAocHJvcCwgdHlwZSA9IEZ1bmN0aW9uKSA9PiBvcHRpb25zW3Byb3BdIGluc3RhbmNlb2YgdHlwZTtcblxuICBjb25zdCBiID0gJ2J1dHRvbnMnLCBjYiA9ICdjYWxsYmFjaycsIGMgPSAnY29tcGlsZScsIGQgPSAnZGVzdHJveSc7XG4gICghaGFzT3duUHJvcGVydHkoYikgfHwgIWluc3RhbmNlT2YoYiwgQXJyYXkpKSAmJiBlcnIoYiwgJ0FycmF5Jyk7XG4gIChoYXNPd25Qcm9wZXJ0eShjYikgJiYgIWluc3RhbmNlT2YoY2IpKSAmJiBlcnIoY2IpO1xuICAoaGFzT3duUHJvcGVydHkoYykgJiYgIWluc3RhbmNlT2YoYykpICYmIGVycihjKTtcbiAgKGhhc093blByb3BlcnR5KGQpICYmICFpbnN0YW5jZU9mKGQpKSAmJiBlcnIoZCk7XG59O1xuXG4vLyBBY3Rpb24gU2hlZXRcbmV4cG9ydCBkZWZhdWx0IChvcHRpb25zID0ge30pID0+IG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICB1dGlsLmNoZWNrTWlzc2luZ0ltcG9ydCgnQWN0aW9uU2hlZXQnKTtcbiAgY2hlY2tPcHRpb25zKG9wdGlvbnMpO1xuXG4gIC8vIE1haW4gY29tcG9uZW50XG4gIGxldCBhY3Rpb25TaGVldCA9IHV0aWwuY3JlYXRlRWxlbWVudChgXG4gICAgPG9ucy1hY3Rpb24tc2hlZXRcbiAgICAgICR7b3B0aW9ucy50aXRsZSA/IGB0aXRsZT1cIiR7b3B0aW9ucy50aXRsZX1cImAgOiAnJ31cbiAgICAgICR7b3B0aW9ucy5jYW5jZWxhYmxlID8gJ2NhbmNlbGFibGUnIDogJyd9XG4gICAgICAke29wdGlvbnMubW9kaWZpZXIgPyBgbW9kaWZpZXI9XCIke29wdGlvbnMubW9kaWZpZXJ9XCJgIDogJyd9XG4gICAgICAke29wdGlvbnMubWFza0NvbG9yID8gYG1hc2stY29sb3I9XCIke29wdGlvbnMubWFza0NvbG9yfVwiYCA6ICcnfVxuICAgICAgJHtvcHRpb25zLmlkID8gYGlkPVwiJHtvcHRpb25zLmlkfVwiYCA6ICcnfVxuICAgICAgJHtvcHRpb25zLmNsYXNzID8gYGNsYXNzPVwiJHtvcHRpb25zLmNsYXNzfVwiYCA6ICcnfVxuICAgID5cbiAgICAgIDxkaXYgY2xhc3M9XCJhY3Rpb24tc2hlZXRcIj48L2Rpdj5cbiAgICA8L29ucy1hY3Rpb24tc2hlZXQ+XG4gIGApO1xuXG4gIC8vIFJlc29sdmUgYWN0aW9uIGFuZCBjbGVhbiB1cFxuICBjb25zdCBmaW5pc2ggPSAoZXZlbnQsIGluZGV4ID0gLTEpID0+IHtcbiAgICBpZiAoYWN0aW9uU2hlZXQpIHtcbiAgICAgIG9wdGlvbnMuZGVzdHJveSAmJiBvcHRpb25zLmRlc3Ryb3koYWN0aW9uU2hlZXQpO1xuXG4gICAgICBhY3Rpb25TaGVldC5yZW1vdmVFdmVudExpc3RlbmVyKCdkaWFsb2ctY2FuY2VsJywgZmluaXNoLCBmYWxzZSk7XG4gICAgICBhY3Rpb25TaGVldC5yZW1vdmUoKTtcbiAgICAgIGFjdGlvblNoZWV0ID0gbnVsbDtcblxuICAgICAgb3B0aW9ucy5jYWxsYmFjayAmJiBvcHRpb25zLmNhbGxiYWNrKGluZGV4KTtcbiAgICAgIHJlc29sdmUoaW5kZXgpO1xuICAgIH1cbiAgfTtcblxuICAvLyBMaW5rIGNhbmNlbCBoYW5kbGVyXG4gIGFjdGlvblNoZWV0LmFkZEV2ZW50TGlzdGVuZXIoJ2RpYWxvZy1jYW5jZWwnLCBmaW5pc2gsIGZhbHNlKTtcblxuICAvLyBDcmVhdGUgYnV0dG9ucyBhbmQgbGluayBhY3Rpb24gaGFuZGxlclxuICBjb25zdCBidXR0b25zID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuICBvcHRpb25zLmJ1dHRvbnMuZm9yRWFjaCgoaXRlbSwgaW5kZXgpID0+IHtcbiAgICBjb25zdCBidXR0b25PcHRpb25zID0gKHR5cGVvZiBpdGVtID09PSAnc3RyaW5nJykgPyB7IGxhYmVsOiBpdGVtIH0gOiB7IC4uLml0ZW0gfTtcbiAgICBpZiAob3B0aW9ucy5kZXN0cnVjdGl2ZSA9PT0gaW5kZXgpIHtcbiAgICAgIGJ1dHRvbk9wdGlvbnMubW9kaWZpZXIgPSAoYnV0dG9uT3B0aW9ucy5tb2RpZmllciB8fCAnJykgKyAnIGRlc3RydWN0aXZlJztcbiAgICB9XG5cbiAgICBjb25zdCBidXR0b24gPSB1dGlsLmNyZWF0ZUVsZW1lbnQoYFxuICAgICAgPG9ucy1hY3Rpb24tc2hlZXQtYnV0dG9uXG4gICAgICAgICR7YnV0dG9uT3B0aW9ucy5pY29uID8gYGljb249XCIke2J1dHRvbk9wdGlvbnMuaWNvbn1cImAgOiAnJ31cbiAgICAgICAgJHtidXR0b25PcHRpb25zLm1vZGlmaWVyID8gYG1vZGlmaWVyPVwiJHtidXR0b25PcHRpb25zLm1vZGlmaWVyfVwiYCA6ICcnfVxuICAgICAgPlxuICAgICAgICAke2J1dHRvbk9wdGlvbnMubGFiZWx9XG4gICAgICA8L29ucy1hY3Rpb24tc2hlZXQtYnV0dG9uPlxuICAgIGApO1xuXG4gICAgYnV0dG9uLm9uY2xpY2sgPSBldmVudCA9PiBhY3Rpb25TaGVldC5oaWRlKCkudGhlbigoKSA9PiBmaW5pc2goZXZlbnQsIGluZGV4KSk7XG4gICAgYnV0dG9ucy5hcHBlbmRDaGlsZChidXR0b24pO1xuICB9KTtcblxuICAvLyBGaW5pc2ggY29tcG9uZW50IGFuZCBhdHRhY2hcbiAgdXRpbC5maW5kQ2hpbGQoYWN0aW9uU2hlZXQsICcuYWN0aW9uLXNoZWV0JykuYXBwZW5kQ2hpbGQoYnV0dG9ucyk7XG4gIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoYWN0aW9uU2hlZXQpO1xuICBvcHRpb25zLmNvbXBpbGUgJiYgb3B0aW9ucy5jb21waWxlKGVsLmRpYWxvZyk7XG5cbiAgLy8gU2hvd1xuICBzZXRJbW1lZGlhdGUoKCkgPT4gYWN0aW9uU2hlZXQuc2hvdyh7XG4gICAgYW5pbWF0aW9uOiBvcHRpb25zLmFuaW1hdGlvbixcbiAgICBhbmltYXRpb25PcHRpb25zOiBvcHRpb25zLmFuaW1hdGlvbk9wdGlvbnNcbiAgfSkpO1xufSk7XG4iLCIvKipcbiAqIE1pY3JvRXZlbnQgLSB0byBtYWtlIGFueSBqcyBvYmplY3QgYW4gZXZlbnQgZW1pdHRlciAoc2VydmVyIG9yIGJyb3dzZXIpXG4gKlxuICogLSBwdXJlIGphdmFzY3JpcHQgLSBzZXJ2ZXIgY29tcGF0aWJsZSwgYnJvd3NlciBjb21wYXRpYmxlXG4gKiAtIGRvbnQgcmVseSBvbiB0aGUgYnJvd3NlciBkb21zXG4gKiAtIHN1cGVyIHNpbXBsZSAtIHlvdSBnZXQgaXQgaW1tZWRpYXRlbHksIG5vIG15c3RlcnksIG5vIG1hZ2ljIGludm9sdmVkXG4gKlxuICogLSBjcmVhdGUgYSBNaWNyb0V2ZW50RGVidWcgd2l0aCBnb29kaWVzIHRvIGRlYnVnXG4gKiAgIC0gbWFrZSBpdCBzYWZlciB0byB1c2VcbiovXG5cbi8qKiBOT1RFOiBUaGlzIGxpYnJhcnkgaXMgY3VzdG9taXplZCBmb3IgT25zZW4gVUkuICovXG5cbmNvbnN0IE1pY3JvRXZlbnQgID0gZnVuY3Rpb24oKXt9O1xuTWljcm9FdmVudC5wcm90b3R5cGUgID0ge1xuICBvbjogZnVuY3Rpb24oZXZlbnQsIGZjdCl7XG4gICAgdGhpcy5fZXZlbnRzID0gdGhpcy5fZXZlbnRzIHx8IHt9O1xuICAgIHRoaXMuX2V2ZW50c1tldmVudF0gPSB0aGlzLl9ldmVudHNbZXZlbnRdIHx8IFtdO1xuICAgIHRoaXMuX2V2ZW50c1tldmVudF0ucHVzaChmY3QpO1xuICB9LFxuICBvbmNlOiBmdW5jdGlvbihldmVudCwgZmN0KXtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIHdyYXBwZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgIHNlbGYub2ZmKGV2ZW50LCB3cmFwcGVyKTtcbiAgICAgIHJldHVybiBmY3QuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICB9O1xuICAgIHRoaXMub24oZXZlbnQsIHdyYXBwZXIpO1xuICB9LFxuICBvZmY6IGZ1bmN0aW9uKGV2ZW50LCBmY3Qpe1xuICAgIHRoaXMuX2V2ZW50cyA9IHRoaXMuX2V2ZW50cyB8fCB7fTtcbiAgICBpZiAoZXZlbnQgaW4gdGhpcy5fZXZlbnRzID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuX2V2ZW50c1tldmVudF0gPSB0aGlzLl9ldmVudHNbZXZlbnRdXG4gICAgICAuZmlsdGVyKGZ1bmN0aW9uKF9mY3QpIHtcbiAgICAgICAgaWYgKGZjdCkge1xuICAgICAgICAgICByZXR1cm4gZmN0ICE9PSBfZmN0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gIH0sXG4gIGVtaXQ6IGZ1bmN0aW9uKGV2ZW50IC8qICwgYXJncy4uLiAqLyl7XG4gICAgdGhpcy5fZXZlbnRzID0gdGhpcy5fZXZlbnRzIHx8IHt9O1xuICAgIGlmIChldmVudCBpbiB0aGlzLl9ldmVudHMgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fZXZlbnRzW2V2ZW50XS5sZW5ndGg7IGkrKyl7XG4gICAgICB0aGlzLl9ldmVudHNbZXZlbnRdW2ldLmFwcGx5KHRoaXMsIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBtaXhpbiB3aWxsIGRlbGVnYXRlIGFsbCBNaWNyb0V2ZW50LmpzIGZ1bmN0aW9uIGluIHRoZSBkZXN0aW5hdGlvbiBvYmplY3RcbiAqXG4gKiAtIHJlcXVpcmUoJ01pY3JvRXZlbnQnKS5taXhpbihGb29iYXIpIHdpbGwgbWFrZSBGb29iYXIgYWJsZSB0byB1c2UgTWljcm9FdmVudFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB0aGUgb2JqZWN0IHdoaWNoIHdpbGwgc3VwcG9ydCBNaWNyb0V2ZW50XG4qL1xuTWljcm9FdmVudC5taXhpbiAgPSBmdW5jdGlvbihkZXN0T2JqZWN0KXtcbiAgdmFyIHByb3BzID0gWydvbicsICdvbmNlJywgJ29mZicsICdlbWl0J107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpICsrKXtcbiAgICBpZiAodHlwZW9mIGRlc3RPYmplY3QgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGRlc3RPYmplY3QucHJvdG90eXBlW3Byb3BzW2ldXSAgPSBNaWNyb0V2ZW50LnByb3RvdHlwZVtwcm9wc1tpXV07XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlc3RPYmplY3RbcHJvcHNbaV1dID0gTWljcm9FdmVudC5wcm90b3R5cGVbcHJvcHNbaV1dO1xuICAgIH1cbiAgfVxufVxuXG53aW5kb3cuTWljcm9FdmVudCA9IE1pY3JvRXZlbnQ7XG5leHBvcnQgZGVmYXVsdCBNaWNyb0V2ZW50O1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IE1pY3JvRXZlbnQgZnJvbSAnLi9taWNyb2V2ZW50JztcblxuY29uc3QgY3JlYXRlID0gKCkgPT4ge1xuXG4gIC8qKlxuICAgKiBAb2JqZWN0IG9ucy5vcmllbnRhdGlvblxuICAgKiBAY2F0ZWdvcnkgdXRpbFxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dVXRpbGl0eSBtZXRob2RzIGZvciBvcmllbnRhdGlvbiBkZXRlY3Rpb24uWy9lbl1cbiAgICogICBbamFd55S76Z2i44Gu44Kq44Oq44Ko44Oz44OG44O844K344On44Oz5qSc55+l44Gu44Gf44KB44Gu44Om44O844OG44Kj44Oq44OG44Kj44Oh44K944OD44OJ44KS5Y+O44KB44Gm44GE44KL44Kq44OW44K444Kn44Kv44OI44Gn44GZ44CCWy9qYV1cbiAgICovXG4gIGNvbnN0IG9iaiA9IHtcbiAgICAvKipcbiAgICAgKiBAZXZlbnQgY2hhbmdlXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogICBbZW5dRmlyZWQgd2hlbiB0aGUgZGV2aWNlIG9yaWVudGF0aW9uIGNoYW5nZXMuWy9lbl1cbiAgICAgKiAgIFtqYV3jg4fjg5DjgqTjgrnjga7jgqrjg6rjgqjjg7Pjg4bjg7zjgrfjg6fjg7PjgYzlpInljJbjgZfjgZ/pmpvjgavnmbrngavjgZfjgb7jgZnjgIJbL2phXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudFxuICAgICAqICAgW2VuXUV2ZW50IG9iamVjdC5bL2VuXVxuICAgICAqICAgW2phXeOCpOODmeODs+ODiOOCquODluOCuOOCp+OCr+ODiOOBp+OBmeOAglsvamFdXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBldmVudC5pc1BvcnRyYWl0XG4gICAgICogICBbZW5dV2lsbCBiZSB0cnVlIGlmIHRoZSBjdXJyZW50IG9yaWVudGF0aW9uIGlzIHBvcnRyYWl0IG1vZGUuWy9lbl1cbiAgICAgKiAgIFtqYV3nj77lnKjjga7jgqrjg6rjgqjjg7Pjg4bjg7zjgrfjg6fjg7PjgYxwb3J0cmFpdOOBruWgtOWQiOOBq3RydWXjgpLov5TjgZfjgb7jgZnjgIJbL2phXVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQG1ldGhvZCBvblxuICAgICAqIEBzaWduYXR1cmUgb24oZXZlbnROYW1lLCBsaXN0ZW5lcilcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiAgIFtlbl1BZGQgYW4gZXZlbnQgbGlzdGVuZXIuWy9lbl1cbiAgICAgKiAgIFtqYV3jgqTjg5njg7Pjg4jjg6rjgrnjg4rjg7zjgpLov73liqDjgZfjgb7jgZnjgIJbL2phXVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudE5hbWVcbiAgICAgKiAgIFtlbl1OYW1lIG9mIHRoZSBldmVudC5bL2VuXVxuICAgICAqICAgW2phXeOCpOODmeODs+ODiOWQjeOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gbGlzdGVuZXJcbiAgICAgKiAgIFtlbl1GdW5jdGlvbiB0byBleGVjdXRlIHdoZW4gdGhlIGV2ZW50IGlzIHRyaWdnZXJlZC5bL2VuXVxuICAgICAqICAgW2phXeOBk+OBruOCpOODmeODs+ODiOOBjOeZuueBq+OBleOCjOOBn+mam+OBq+WRvOOBs+WHuuOBleOCjOOCi+mWouaVsOOCquODluOCuOOCp+OCr+ODiOOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBAbWV0aG9kIG9uY2VcbiAgICAgKiBAc2lnbmF0dXJlIG9uY2UoZXZlbnROYW1lLCBsaXN0ZW5lcilcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiAgW2VuXUFkZCBhbiBldmVudCBsaXN0ZW5lciB0aGF0J3Mgb25seSB0cmlnZ2VyZWQgb25jZS5bL2VuXVxuICAgICAqICBbamFd5LiA5bqm44Gg44GR5ZG844Gz5Ye644GV44KM44KL44Kk44OZ44Oz44OI44Oq44K544OK44O844KS6L+95Yqg44GX44G+44GZ44CCWy9qYV1cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnROYW1lXG4gICAgICogICBbZW5dTmFtZSBvZiB0aGUgZXZlbnQuWy9lbl1cbiAgICAgKiAgIFtqYV3jgqTjg5njg7Pjg4jlkI3jgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGxpc3RlbmVyXG4gICAgICogICBbZW5dRnVuY3Rpb24gdG8gZXhlY3V0ZSB3aGVuIHRoZSBldmVudCBpcyB0cmlnZ2VyZWQuWy9lbl1cbiAgICAgKiAgIFtqYV3jgqTjg5njg7Pjg4jjgYznmbrngavjgZfjgZ/pmpvjgavlkbzjgbPlh7rjgZXjgozjgovplqLmlbDjgqrjg5bjgrjjgqfjgq/jg4jjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQG1ldGhvZCBvZmZcbiAgICAgKiBAc2lnbmF0dXJlIG9mZihldmVudE5hbWUsIFtsaXN0ZW5lcl0pXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogIFtlbl1SZW1vdmUgYW4gZXZlbnQgbGlzdGVuZXIuIElmIHRoZSBsaXN0ZW5lciBpcyBub3Qgc3BlY2lmaWVkIGFsbCBsaXN0ZW5lcnMgZm9yIHRoZSBldmVudCB0eXBlIHdpbGwgYmUgcmVtb3ZlZC5bL2VuXVxuICAgICAqICBbamFd44Kk44OZ44Oz44OI44Oq44K544OK44O844KS5YmK6Zmk44GX44G+44GZ44CC44KC44GX44Kk44OZ44Oz44OI44Oq44K544OK44O844KS5oyH5a6a44GX44Gq44GL44Gj44Gf5aC05ZCI44Gr44Gv44CB44Gd44Gu44Kk44OZ44Oz44OI44Gr57SQ44Gl44GP5YWo44Gm44Gu44Kk44OZ44Oz44OI44Oq44K544OK44O844GM5YmK6Zmk44GV44KM44G+44GZ44CCWy9qYV1cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnROYW1lXG4gICAgICogICBbZW5dTmFtZSBvZiB0aGUgZXZlbnQuWy9lbl1cbiAgICAgKiAgIFtqYV3jgqTjg5njg7Pjg4jlkI3jgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGxpc3RlbmVyXG4gICAgICogICBbZW5dRnVuY3Rpb24gdG8gZXhlY3V0ZSB3aGVuIHRoZSBldmVudCBpcyB0cmlnZ2VyZWQuWy9lbl1cbiAgICAgKiAgIFtqYV3liYrpmaTjgZnjgovjgqTjg5njg7Pjg4jjg6rjgrnjg4rjg7zjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgICAqL1xuXG4gICAgLy8gYWN0dWFsIGltcGxlbWVudGF0aW9uIHRvIGRldGVjdCBpZiB3aGV0aGVyIGN1cnJlbnQgc2NyZWVuIGlzIHBvcnRyYWl0IG9yIG5vdFxuICAgIF9pc1BvcnRyYWl0OiBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIEBtZXRob2QgaXNQb3J0cmFpdFxuICAgICAqIEBzaWduYXR1cmUgaXNQb3J0cmFpdCgpXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgKiAgIFtlbl1XaWxsIGJlIHRydWUgaWYgdGhlIGN1cnJlbnQgb3JpZW50YXRpb24gaXMgcG9ydHJhaXQgbW9kZS5bL2VuXVxuICAgICAqICAgW2phXeOCquODquOCqOODs+ODhuODvOOCt+ODp+ODs+OBjHBvcnRyYWl044Oi44O844OJ44Gu5aC05ZCI44GrdHJ1ZeOBq+OBquOCiuOBvuOBmeOAglsvamFdXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogICBbZW5dUmV0dXJucyB3aGV0aGVyIHRoZSBjdXJyZW50IHNjcmVlbiBvcmllbnRhdGlvbiBpcyBwb3J0cmFpdCBvciBub3QuWy9lbl1cbiAgICAgKiAgIFtqYV3jgqrjg6rjgqjjg7Pjg4bjg7zjgrfjg6fjg7PjgYxwb3J0cmFpdOODouODvOODieOBi+OBqeOBhuOBi+OCkui/lOOBl+OBvuOBmeOAglsvamFdXG4gICAgICovXG4gICAgaXNQb3J0cmFpdDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5faXNQb3J0cmFpdCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWV0aG9kIGlzTGFuZHNjYXBlXG4gICAgICogQHNpZ25hdHVyZSBpc0xhbmRzY2FwZSgpXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgKiAgIFtlbl1XaWxsIGJlIHRydWUgaWYgdGhlIGN1cnJlbnQgb3JpZW50YXRpb24gaXMgbGFuZHNjYXBlIG1vZGUuWy9lbl1cbiAgICAgKiAgIFtqYV3jgqrjg6rjgqjjg7Pjg4bjg7zjgrfjg6fjg7PjgYxsYW5kc2NhcGXjg6Ljg7zjg4njga7loLTlkIjjgat0cnVl44Gr44Gq44KK44G+44GZ44CCWy9qYV1cbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiAgIFtlbl1SZXR1cm5zIHdoZXRoZXIgdGhlIGN1cnJlbnQgc2NyZWVuIG9yaWVudGF0aW9uIGlzIGxhbmRzY2FwZSBvciBub3QuWy9lbl1cbiAgICAgKiAgIFtqYV3jgqrjg6rjgqjjg7Pjg4bjg7zjgrfjg6fjg7PjgYxsYW5kc2NhcGXjg6Ljg7zjg4njgYvjganjgYbjgYvjgpLov5TjgZfjgb7jgZnjgIJbL2phXVxuICAgICAqL1xuICAgIGlzTGFuZHNjYXBlOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiAhdGhpcy5pc1BvcnRyYWl0KCk7XG4gICAgfSxcblxuICAgIF9pbml0OiBmdW5jdGlvbigpIHtcbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ0RPTUNvbnRlbnRMb2FkZWQnLCB0aGlzLl9vbkRPTUNvbnRlbnRMb2FkZWQuYmluZCh0aGlzKSwgZmFsc2UpO1xuXG4gICAgICBpZiAoJ29yaWVudGF0aW9uJyBpbiB3aW5kb3cpIHtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ29yaWVudGF0aW9uY2hhbmdlJywgdGhpcy5fb25PcmllbnRhdGlvbkNoYW5nZS5iaW5kKHRoaXMpLCBmYWxzZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcy5fb25SZXNpemUuYmluZCh0aGlzKSwgZmFsc2UpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9pc1BvcnRyYWl0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB3aW5kb3cuaW5uZXJIZWlnaHQgPiB3aW5kb3cuaW5uZXJXaWR0aDtcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBfb25ET01Db250ZW50TG9hZGVkOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuX2luc3RhbGxJc1BvcnRyYWl0SW1wbGVtZW50YXRpb24oKTtcbiAgICAgIHRoaXMuZW1pdCgnY2hhbmdlJywge2lzUG9ydHJhaXQ6IHRoaXMuaXNQb3J0cmFpdCgpfSk7XG4gICAgfSxcblxuICAgIF9pbnN0YWxsSXNQb3J0cmFpdEltcGxlbWVudGF0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgIGNvbnN0IGlzUG9ydHJhaXQgPSB3aW5kb3cuaW5uZXJXaWR0aCA8IHdpbmRvdy5pbm5lckhlaWdodDtcblxuICAgICAgaWYgKCEoJ29yaWVudGF0aW9uJyBpbiB3aW5kb3cpKSB7XG4gICAgICAgIHRoaXMuX2lzUG9ydHJhaXQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gd2luZG93LmlubmVySGVpZ2h0ID4gd2luZG93LmlubmVyV2lkdGg7XG4gICAgICAgIH07XG4gICAgICB9IGVsc2UgaWYgKHdpbmRvdy5vcmllbnRhdGlvbiAlIDE4MCA9PT0gMCkge1xuICAgICAgICB0aGlzLl9pc1BvcnRyYWl0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIE1hdGguYWJzKHdpbmRvdy5vcmllbnRhdGlvbiAlIDE4MCkgPT09IDAgPyBpc1BvcnRyYWl0IDogIWlzUG9ydHJhaXQ7XG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9pc1BvcnRyYWl0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIE1hdGguYWJzKHdpbmRvdy5vcmllbnRhdGlvbiAlIDE4MCkgPT09IDkwID8gaXNQb3J0cmFpdCA6ICFpc1BvcnRyYWl0O1xuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBfb25PcmllbnRhdGlvbkNoYW5nZTogZnVuY3Rpb24oKSB7XG4gICAgICBjb25zdCBpc1BvcnRyYWl0ID0gdGhpcy5faXNQb3J0cmFpdCgpO1xuXG4gICAgICAvLyBXYWl0IGZvciB0aGUgZGltZW5zaW9ucyB0byBjaGFuZ2UgYmVjYXVzZVxuICAgICAgLy8gb2YgQW5kcm9pZCBpbmNvbnNpc3RlbmN5LlxuICAgICAgbGV0IG5JdGVyID0gMDtcbiAgICAgIGNvbnN0IGludGVydmFsID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgICBuSXRlcisrO1xuXG4gICAgICAgIGNvbnN0IHcgPSB3aW5kb3cuaW5uZXJXaWR0aDtcbiAgICAgICAgY29uc3QgaCA9IHdpbmRvdy5pbm5lckhlaWdodDtcblxuICAgICAgICBpZiAoKGlzUG9ydHJhaXQgJiYgdyA8PSBoKSB8fFxuICAgICAgICAgICAoIWlzUG9ydHJhaXQgJiYgdyA+PSBoKSkge1xuICAgICAgICAgIHRoaXMuZW1pdCgnY2hhbmdlJywge2lzUG9ydHJhaXQ6IGlzUG9ydHJhaXR9KTtcbiAgICAgICAgICBjbGVhckludGVydmFsKGludGVydmFsKTtcbiAgICAgICAgfSBlbHNlIGlmIChuSXRlciA9PT0gNTApIHtcbiAgICAgICAgICB0aGlzLmVtaXQoJ2NoYW5nZScsIHtpc1BvcnRyYWl0OiBpc1BvcnRyYWl0fSk7XG4gICAgICAgICAgY2xlYXJJbnRlcnZhbChpbnRlcnZhbCk7XG4gICAgICAgIH1cbiAgICAgIH0sIDIwKTtcbiAgICB9LFxuXG4gICAgLy8gUnVuIG9uIG5vdCBtb2JpbGUgYnJvd3Nlci5cbiAgICBfb25SZXNpemU6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5lbWl0KCdjaGFuZ2UnLCB7aXNQb3J0cmFpdDogdGhpcy5pc1BvcnRyYWl0KCl9KTtcbiAgICB9XG4gIH07XG5cbiAgTWljcm9FdmVudC5taXhpbihvYmopO1xuXG4gIHJldHVybiBvYmo7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBjcmVhdGUoKS5faW5pdCgpO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IHV0aWwgZnJvbSAnLi91dGlsJztcblxuLyoqXG4gKiBAb2JqZWN0IG9ucy5tb2RpZmllclxuICogQGNhdGVnb3J5IHZpc3VhbFxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1cbiAqICAgICBVdGlsaXR5IG1ldGhvZHMgdG8gY2hhbmdlIG1vZGlmaWVyIGF0dHJpYnV0ZXMgb2YgT25zZW4gVUkgZWxlbWVudHMuLlxuICogICBbL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBleGFtcGxlXG4gKiBvbnMubW9kaWZpZXIuYWRkKG15T25zSW5wdXRFbGVtZW50LCAndW5kZXJiYXInKTtcbiAqIG9ucy5tb2RpZmllci50b2dnbGUobXlPbnNUb2FzdEVsZW1lbnQsICdjdXN0b20tbW9kaWZpZXInKTtcbiAqXG4gKi9cbmV4cG9ydCBkZWZhdWx0IHtcbiAgLyoqXG4gICAqIEBtZXRob2QgYWRkXG4gICAqIEBzaWduYXR1cmUgYWRkKGVsZW1lbnQsIG1vZGlmaWVyIFssIG1vZGlmaWVyXSlcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUFkZCB0aGUgc3BlY2lmaWVkIG1vZGlmaWVycyB0byB0aGUgZWxlbWVudCBpZiB0aGV5IGFyZSBub3QgYWxyZWFkeSBpbmNsdWRlZC5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gICAqICAgW2VuXVRhcmdldCBlbGVtZW50LlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtb2RpZmllclxuICAgKiAgIFtlbl1OYW1lIG9mIHRoZSBtb2RpZmllci5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cbiAgYWRkOiAoZWxlbWVudCwgLi4ubW9kaWZpZXJzKSA9PiBtb2RpZmllcnMuZm9yRWFjaChtb2RpZmllciA9PiB1dGlsLmFkZE1vZGlmaWVyKGVsZW1lbnQsIG1vZGlmaWVyKSksXG4gIC8qKlxuICAgKiBAbWV0aG9kIHJlbW92ZVxuICAgKiBAc2lnbmF0dXJlIHJlbW92ZShlbGVtZW50LCBtb2RpZmllciBbLCBtb2RpZmllcl0pXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1SZW1vdmUgdGhlIHNwZWNpZmllZCBtb2RpZmllcnMgZnJvbSB0aGUgZWxlbWVudCBpZiB0aGV5IGFyZSBpbmNsdWRlZC5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gICAqICAgW2VuXVRhcmdldCBlbGVtZW50LlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtb2RpZmllclxuICAgKiAgIFtlbl1OYW1lIG9mIHRoZSBtb2RpZmllci5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cbiAgcmVtb3ZlOiAoZWxlbWVudCwgLi4ubW9kaWZpZXJzKSA9PiBtb2RpZmllcnMuZm9yRWFjaChtb2RpZmllciA9PiB1dGlsLnJlbW92ZU1vZGlmaWVyKGVsZW1lbnQsIG1vZGlmaWVyKSksXG4gIC8qKlxuICAgKiBAbWV0aG9kIGNvbnRhaW5zXG4gICAqIEBzaWduYXR1cmUgY29udGFpbnMoZWxlbWVudCwgbW9kaWZpZXIpXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1DaGVjayB3aGV0aGVyIHRoZSBzcGVjaWZpZWQgbW9kaWZpZXIgaXMgaW5jbHVkZWQgaW4gdGhlIGVsZW1lbnQuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICAgKiAgIFtlbl1UYXJnZXQgZWxlbWVudC5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbW9kaWZpZXJcbiAgICogICBbZW5dTmFtZSBvZiB0aGUgbW9kaWZpZXIuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICogICBbZW5dYHRydWVgIHdoZW4gdGhlIHNwZWNpZmllZCBtb2RpZmllciBpcyBmb3VuZCBpbiB0aGUgZWxlbWVudCdzIGBtb2RpZmllcmAgYXR0cmlidXRlLiBgZmFsc2VgIG90aGVyd2lzZS5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cbiAgY29udGFpbnM6IHV0aWwuaGFzTW9kaWZpZXIsXG4gIC8qKlxuICAgKiBAbWV0aG9kIHRvZ2dsZVxuICAgKiBAc2lnbmF0dXJlIHRvZ2dsZShlbGVtZW50LCBtb2RpZmllciBbLCBmb3JjZV0pXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1Ub2dnbGUgdGhlIHNwZWNpZmllZCBtb2RpZmllci5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gICAqICAgW2VuXVRhcmdldCBlbGVtZW50LlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtb2RpZmllclxuICAgKiAgIFtlbl1OYW1lIG9mIHRoZSBtb2RpZmllci5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKiBAcGFyYW0ge1N0cmluZ30gZm9yY2VcbiAgICogICBbZW5dSWYgaXQgZXZhbHVhdGVzIHRvIHRydWUsIGFkZCBzcGVjaWZpZWQgbW9kaWZpZXIgdmFsdWUsIGFuZCBpZiBpdCBldmFsdWF0ZXMgdG8gZmFsc2UsIHJlbW92ZSBpdC5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cbiAgdG9nZ2xlOiB1dGlsLnRvZ2dsZU1vZGlmaWVyXG59O1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IHV0aWwgZnJvbSAnLi91dGlsJztcbmltcG9ydCBNaWNyb0V2ZW50IGZyb20gJy4vbWljcm9ldmVudCc7XG5cbmNvbnN0IHNvZnR3YXJlS2V5Ym9hcmQgPSBuZXcgTWljcm9FdmVudCgpO1xuc29mdHdhcmVLZXlib2FyZC5fdmlzaWJsZSA9IGZhbHNlO1xuXG5jb25zdCBvblNob3cgPSAoKSA9PiB7XG4gIHNvZnR3YXJlS2V5Ym9hcmQuX3Zpc2libGUgPSB0cnVlO1xuICBzb2Z0d2FyZUtleWJvYXJkLmVtaXQoJ3Nob3cnKTtcbn07XG5cbmNvbnN0IG9uSGlkZSA9ICgpID0+IHtcbiAgc29mdHdhcmVLZXlib2FyZC5fdmlzaWJsZSA9IGZhbHNlO1xuICBzb2Z0d2FyZUtleWJvYXJkLmVtaXQoJ2hpZGUnKTtcbn07XG5cbmNvbnN0IGJpbmRFdmVudHMgPSAoKSA9PiB7XG4gIGlmICh0eXBlb2YgS2V5Ym9hcmQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL21hcnRpbm1vc2UvY29yZG92YS1rZXlib2FyZC9ibG9iLzk1ZjNkYTNhMzhkOGY4ZTFmYTQxZmJmNDAxNDUzNTJjMTM1MzVhMDAvUkVBRE1FLm1kXG4gICAgS2V5Ym9hcmQub25zaG93ID0gb25TaG93O1xuICAgIEtleWJvYXJkLm9uaGlkZSA9IG9uSGlkZTtcbiAgICBzb2Z0d2FyZUtleWJvYXJkLmVtaXQoJ2luaXQnLCB7dmlzaWJsZTogS2V5Ym9hcmQuaXNWaXNpYmxlfSk7XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgY29yZG92YS5wbHVnaW5zICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgY29yZG92YS5wbHVnaW5zLktleWJvYXJkICE9PSAndW5kZWZpbmVkJykge1xuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9kcmlmdHljby9pb25pYy1wbHVnaW5zLWtleWJvYXJkL2Jsb2IvY2EyN2VjZi9SRUFETUUubWRcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbmF0aXZlLmtleWJvYXJkc2hvdycsIG9uU2hvdyk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ25hdGl2ZS5rZXlib2FyZGhpZGUnLCBvbkhpZGUpO1xuICAgIHNvZnR3YXJlS2V5Ym9hcmQuZW1pdCgnaW5pdCcsIHt2aXNpYmxlOiBjb3Jkb3ZhLnBsdWdpbnMuS2V5Ym9hcmQuaXNWaXNpYmxlfSk7XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn07XG5cbmNvbnN0IG5vUGx1Z2luRXJyb3IgPSAoKSA9PiB7XG4gIHV0aWwud2Fybignb25zLWtleWJvYXJkOiBDb3Jkb3ZhIEtleWJvYXJkIHBsdWdpbiBpcyBub3QgcHJlc2VudC4nKTtcbn07XG5cbmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2RldmljZXJlYWR5JywgKCkgPT4ge1xuICBpZiAoIWJpbmRFdmVudHMoKSkge1xuICAgIGlmIChkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdbb25zLWtleWJvYXJkLWFjdGl2ZV0nKSB8fFxuICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcignW29ucy1rZXlib2FyZC1pbmFjdGl2ZV0nKSkge1xuICAgICAgbm9QbHVnaW5FcnJvcigpO1xuICAgIH1cblxuICAgIHNvZnR3YXJlS2V5Ym9hcmQub24gPSBub1BsdWdpbkVycm9yO1xuICB9XG59KTtcblxuZXhwb3J0IGRlZmF1bHQgc29mdHdhcmVLZXlib2FyZDtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmNvbnN0IGdlbmVyYXRlSWQgPSAoZnVuY3Rpb24oKSB7XG4gIGxldCBpID0gMDtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBpKys7XG4gIH07XG59KSgpO1xuXG4vKipcbiAqIERvb3IgbG9ja2luZyBzeXN0ZW0uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMubG9nXVxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBEb29yTG9jayB7XG5cbiAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XG4gICAgdGhpcy5fbG9ja0xpc3QgPSBbXTtcbiAgICB0aGlzLl93YWl0TGlzdCA9IFtdO1xuICAgIHRoaXMuX2xvZyA9IG9wdGlvbnMubG9nIHx8IGZ1bmN0aW9uKCkge307XG4gIH1cblxuICAvKipcbiAgICogUmVnaXN0ZXIgYSBsb2NrLlxuICAgKlxuICAgKiBAcmV0dXJuIHtGdW5jdGlvbn0gQ2FsbGJhY2sgZm9yIHVubG9ja2luZy5cbiAgICovXG4gIGxvY2soKSB7XG4gICAgY29uc3QgdW5sb2NrID0gKCkgPT4ge1xuICAgICAgdGhpcy5fdW5sb2NrKHVubG9jayk7XG4gICAgfTtcbiAgICB1bmxvY2suaWQgPSBnZW5lcmF0ZUlkKCk7XG4gICAgdGhpcy5fbG9ja0xpc3QucHVzaCh1bmxvY2spO1xuICAgIHRoaXMuX2xvZygnbG9jazogJyArICh1bmxvY2suaWQpKTtcblxuICAgIHJldHVybiB1bmxvY2s7XG4gIH1cblxuICBfdW5sb2NrKGZuKSB7XG4gICAgY29uc3QgaW5kZXggPSB0aGlzLl9sb2NrTGlzdC5pbmRleE9mKGZuKTtcbiAgICBpZiAoaW5kZXggPT09IC0xKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgZnVuY3Rpb24gaXMgbm90IHJlZ2lzdGVyZWQgaW4gdGhlIGxvY2sgbGlzdC4nKTtcbiAgICB9XG5cbiAgICB0aGlzLl9sb2NrTGlzdC5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIHRoaXMuX2xvZygndW5sb2NrOiAnICsgZm4uaWQpO1xuXG4gICAgdGhpcy5fdHJ5VG9GcmVlV2FpdExpc3QoKTtcbiAgfVxuXG4gIF90cnlUb0ZyZWVXYWl0TGlzdCgpIHtcbiAgICB3aGlsZSAoIXRoaXMuaXNMb2NrZWQoKSAmJiB0aGlzLl93YWl0TGlzdC5sZW5ndGggPiAwKSB7XG4gICAgICB0aGlzLl93YWl0TGlzdC5zaGlmdCgpKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVyIGEgY2FsbGJhY2sgZm9yIHdhaXRpbmcgdW5sb2NrZWQgZG9vci5cbiAgICpcbiAgICogQHBhcmFtcyB7RnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrIG9uIHVubG9ja2luZyB0aGUgZG9vciBjb21wbGV0ZWx5LlxuICAgKi9cbiAgd2FpdFVubG9jayhjYWxsYmFjaykge1xuICAgIGlmICghKGNhbGxiYWNrIGluc3RhbmNlb2YgRnVuY3Rpb24pKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBjYWxsYmFjayBwYXJhbSBtdXN0IGJlIGEgZnVuY3Rpb24uJyk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaXNMb2NrZWQoKSkge1xuICAgICAgdGhpcy5fd2FpdExpc3QucHVzaChjYWxsYmFjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNhbGxiYWNrKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuICBpc0xvY2tlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fbG9ja0xpc3QubGVuZ3RoID4gMDtcbiAgfVxufVxuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cbmltcG9ydCB1dGlsIGZyb20gJy4vdXRpbCc7XG5pbXBvcnQgaW50ZXJuYWwgZnJvbSAnLi9pbnRlcm5hbCc7XG5cbi8vIERlZmF1bHQgaW1wbGVtZW50YXRpb24gZm9yIGdsb2JhbCBQYWdlTG9hZGVyLlxuZnVuY3Rpb24gbG9hZFBhZ2Uoe3BhZ2UsIHBhcmVudCwgcGFyYW1zID0ge319LCBkb25lKSB7XG4gIGludGVybmFsLmdldFBhZ2VIVE1MQXN5bmMocGFnZSkudGhlbihodG1sID0+IHtcbiAgICBjb25zdCBwYWdlRWxlbWVudCA9IHV0aWwuY3JlYXRlRWxlbWVudChodG1sKTtcbiAgICBwYXJlbnQuYXBwZW5kQ2hpbGQocGFnZUVsZW1lbnQpO1xuXG4gICAgZG9uZShwYWdlRWxlbWVudCk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiB1bmxvYWRQYWdlKGVsZW1lbnQpIHtcbiAgaWYgKGVsZW1lbnQuX2Rlc3Ryb3kgaW5zdGFuY2VvZiBGdW5jdGlvbikge1xuICAgIGVsZW1lbnQuX2Rlc3Ryb3koKTtcbiAgfSBlbHNlIHtcbiAgICBlbGVtZW50LnJlbW92ZSgpO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBQYWdlTG9hZGVyIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtmbl0gUmV0dXJucyBhbiBvYmplY3QgdGhhdCBoYXMgXCJlbGVtZW50XCIgcHJvcGVydHkgYW5kIFwidW5sb2FkXCIgZnVuY3Rpb24uXG4gICAqL1xuICBjb25zdHJ1Y3Rvcihsb2FkZXIsIHVubG9hZGVyKSB7XG4gICAgdGhpcy5fbG9hZGVyID0gbG9hZGVyIGluc3RhbmNlb2YgRnVuY3Rpb24gPyBsb2FkZXIgOiBsb2FkUGFnZTtcbiAgICB0aGlzLl91bmxvYWRlciA9IHVubG9hZGVyIGluc3RhbmNlb2YgRnVuY3Rpb24gPyB1bmxvYWRlciA6IHVubG9hZFBhZ2U7XG4gIH1cblxuICAvKipcbiAgICogU2V0IGludGVybmFsIGxvYWRlciBpbXBsZW1lbnRhdGlvbi5cbiAgICovXG4gIHNldCBpbnRlcm5hbExvYWRlcihmbikge1xuICAgIGlmICghKGZuIGluc3RhbmNlb2YgRnVuY3Rpb24pKSB7XG4gICAgICB0aHJvdyBFcnJvcignRmlyc3QgcGFyYW1ldGVyIG11c3QgYmUgYW4gaW5zdGFuY2Ugb2YgRnVuY3Rpb24nKTtcbiAgICB9XG4gICAgdGhpcy5fbG9hZGVyID0gZm47XG4gIH1cblxuICBnZXQgaW50ZXJuYWxMb2FkZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2xvYWRlcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2FueX0gb3B0aW9ucy5wYWdlXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gb3B0aW9ucy5wYXJlbnQgQSBsb2NhdGlvbiB0byBsb2FkIHBhZ2UuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5wYXJhbXNdIEV4dHJhIHBhcmFtZXRlcnMgZm9yIG9ucy1wYWdlLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBkb25lIFRha2UgYW4gb2JqZWN0IHRoYXQgaGFzIFwiZWxlbWVudFwiIHByb3BlcnR5IGFuZCBcInVubG9hZFwiIGZ1bmN0aW9uLlxuICAgKi9cbiAgbG9hZCh7cGFnZSwgcGFyZW50LCBwYXJhbXMgPSB7fX0sIGRvbmUpIHtcbiAgICB0aGlzLl9sb2FkZXIoe3BhZ2UsIHBhcmVudCwgcGFyYW1zfSwgcGFnZUVsZW1lbnQgPT4ge1xuICAgICAgaWYgKCEocGFnZUVsZW1lbnQgaW5zdGFuY2VvZiBFbGVtZW50KSkge1xuICAgICAgICB0aHJvdyBFcnJvcigncGFnZUVsZW1lbnQgbXVzdCBiZSBhbiBpbnN0YW5jZSBvZiBFbGVtZW50LicpO1xuICAgICAgfVxuXG4gICAgICBkb25lKHBhZ2VFbGVtZW50KTtcbiAgICB9KTtcbiAgfVxuXG4gIHVubG9hZChwYWdlRWxlbWVudCkge1xuICAgIGlmICghKHBhZ2VFbGVtZW50IGluc3RhbmNlb2YgRWxlbWVudCkpIHtcbiAgICAgIHRocm93IEVycm9yKCdwYWdlRWxlbWVudCBtdXN0IGJlIGFuIGluc3RhbmNlIG9mIEVsZW1lbnQuJyk7XG4gICAgfVxuXG4gICAgdGhpcy5fdW5sb2FkZXIocGFnZUVsZW1lbnQpO1xuICB9XG59XG5cbmV4cG9ydCBjb25zdCBkZWZhdWx0UGFnZUxvYWRlciA9IG5ldyBQYWdlTG9hZGVyKCk7XG5cbmV4cG9ydCBjb25zdCBpbnN0YW50UGFnZUxvYWRlciA9IG5ldyBQYWdlTG9hZGVyKFxuICBmdW5jdGlvbih7cGFnZSwgcGFyZW50LCBwYXJhbXMgPSB7fX0sIGRvbmUpIHtcbiAgICBjb25zdCBlbGVtZW50ID0gdXRpbC5jcmVhdGVFbGVtZW50KHBhZ2UudHJpbSgpKTtcbiAgICBwYXJlbnQuYXBwZW5kQ2hpbGQoZWxlbWVudCk7XG5cbiAgICBkb25lKGVsZW1lbnQpO1xuICB9LFxuICB1bmxvYWRQYWdlXG4pO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IHV0aWwgZnJvbSAnLi91dGlsJztcbmltcG9ydCBlbGVtZW50cyBmcm9tICcuL2VsZW1lbnRzJ1xuaW1wb3J0IGFuaW1pdCBmcm9tICcuL2FuaW1pdCdcbmltcG9ydCBHZXN0dXJlRGV0ZWN0b3IgZnJvbSAnLi9nZXN0dXJlLWRldGVjdG9yJztcbmltcG9ydCBwbGF0Zm9ybSBmcm9tICcuL3BsYXRmb3JtJztcbmltcG9ydCBub3RpZmljYXRpb24gZnJvbSAnLi9ub3RpZmljYXRpb24nO1xuaW1wb3J0IGFjdGlvblNoZWV0IGZyb20gJy4vYWN0aW9uLXNoZWV0JztcbmltcG9ydCBpbnRlcm5hbCBmcm9tICcuL2ludGVybmFsJztcbmltcG9ydCBvcmllbnRhdGlvbiBmcm9tICcuL29yaWVudGF0aW9uJztcbmltcG9ydCBtb2RpZmllciBmcm9tICcuL21vZGlmaWVyJztcbmltcG9ydCBzb2Z0d2FyZUtleWJvYXJkIGZyb20gJy4vc29mdHdhcmUta2V5Ym9hcmQnO1xuaW1wb3J0IHBhZ2VBdHRyaWJ1dGVFeHByZXNzaW9uIGZyb20gJy4vcGFnZS1hdHRyaWJ1dGUtZXhwcmVzc2lvbic7XG5pbXBvcnQgYXV0b1N0eWxlIGZyb20gJy4vYXV0b3N0eWxlJztcbmltcG9ydCBEb29yTG9jayBmcm9tICcuL2Rvb3Jsb2NrJztcbmltcG9ydCB7IGRlZmF1bHRQYWdlTG9hZGVyLCBQYWdlTG9hZGVyIH0gZnJvbSAnLi9wYWdlLWxvYWRlcic7XG5cbi8qKlxuICogQG9iamVjdCBvbnNcbiAqIEBjYXRlZ29yeSB1dGlsXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2phXU9uc2VuIFVJ44Gn5Yip55So44Gn44GN44KL44Kw44Ot44O844OQ44Or44Gq44Kq44OW44K444Kn44Kv44OI44Gn44GZ44CCWy9qYV1cbiAqICAgW2VuXUEgZ2xvYmFsIG9iamVjdCB0aGF0J3MgdXNlZCBpbiBPbnNlbiBVSS4gWy9lbl1cbiAqL1xuY29uc3Qgb25zID0ge1xuICBhbmltaXQsXG4gIGRlZmF1bHRQYWdlTG9hZGVyLFxuICBlbGVtZW50cyxcbiAgR2VzdHVyZURldGVjdG9yLFxuICBtb2RpZmllcixcbiAgbm90aWZpY2F0aW9uLFxuICBvcmllbnRhdGlvbixcbiAgcGFnZUF0dHJpYnV0ZUV4cHJlc3Npb24sXG4gIFBhZ2VMb2FkZXIsXG4gIHBsYXRmb3JtLFxuICBzb2Z0d2FyZUtleWJvYXJkLFxuICBfYXV0b1N0eWxlOiBhdXRvU3R5bGUsXG4gIF9pbnRlcm5hbDogaW50ZXJuYWwsXG4gIF9yZWFkeUxvY2s6IG5ldyBEb29yTG9jaygpLFxuICBfdXRpbDogdXRpbCxcbn07XG5cbm9ucy5wbGF0Zm9ybS5zZWxlY3QoKHdpbmRvdy5sb2NhdGlvbi5zZWFyY2gubWF0Y2goL3BsYXRmb3JtPShbXFx3LV0rKS8pIHx8IFtdKVsxXSk7XG5cbndhaXREZXZpY2VSZWFkeSgpO1xuXG5jb25zdCByZWFkeUVycm9yID0gYWZ0ZXIgPT4gdXRpbC50aHJvdyhgVGhpcyBtZXRob2QgbXVzdCBiZSBjYWxsZWQgJHthZnRlciA/ICdhZnRlcicgOiAnYmVmb3JlJ30gb25zLmlzUmVhZHkoKSBpcyB0cnVlYCk7XG5cbi8qKlxuICogQG1ldGhvZCBpc1JlYWR5XG4gKiBAc2lnbmF0dXJlIGlzUmVhZHkoKVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqICAgW2VuXVdpbGwgYmUgdHJ1ZSBpZiBPbnNlbiBVSSBpcyBpbml0aWFsaXplZC5bL2VuXVxuICogICBbamFd5Yid5pyf5YyW44GV44KM44Gm44GE44KL44GL44Gp44GG44GL44KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dUmV0dXJucyB0cnVlIGlmIE9uc2VuIFVJIGlzIGluaXRpYWxpemVkLlsvZW5dXG4gKiAgIFtqYV1PbnNlbiBVSeOBjOOBmeOBp+OBq+WIneacn+WMluOBleOCjOOBpuOBhOOCi+OBi+OBqeOBhuOBi+OCkui/lOOBmeODoeOCveODg+ODieOBp+OBmeOAglsvamFdXG4gKi9cbm9ucy5pc1JlYWR5ID0gKCkgPT4ge1xuICByZXR1cm4gIW9ucy5fcmVhZHlMb2NrLmlzTG9ja2VkKCk7XG59O1xuXG4vKipcbiAqIEBtZXRob2QgaXNXZWJWaWV3XG4gKiBAc2lnbmF0dXJlIGlzV2ViVmlldygpXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogICBbZW5dV2lsbCBiZSB0cnVlIGlmIHRoZSBhcHAgaXMgcnVubmluZyBpbiBDb3Jkb3ZhLlsvZW5dXG4gKiAgIFtqYV1Db3Jkb3Zh44Gn5a6f6KGM44GV44KM44Gm44GE44KL5aC05ZCI44GrdHJ1ZeOBq+OBquOCiuOBvuOBmeOAglsvamFdXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXVJldHVybnMgdHJ1ZSBpZiBydW5uaW5nIGluc2lkZSBDb3Jkb3ZhLlsvZW5dXG4gKiAgIFtqYV1Db3Jkb3Zh44Gn5a6f6KGM44GV44KM44Gm44GE44KL44GL44Gp44GG44GL44KS6L+U44GZ44Oh44K944OD44OJ44Gn44GZ44CCWy9qYV1cbiAqL1xub25zLmlzV2ViVmlldyA9IG9ucy5wbGF0Zm9ybS5pc1dlYlZpZXc7XG5cbi8qKlxuICogQG1ldGhvZCByZWFkeVxuICogQHNpZ25hdHVyZSByZWFkeShjYWxsYmFjaylcbiAqIEBkZXNjcmlwdGlvblxuICogICBbamFd44Ki44OX44Oq44Gu5Yid5pyf5YyW44Gr5Yip55So44GZ44KL44Oh44K944OD44OJ44Gn44GZ44CC5rih44GV44KM44Gf6Zai5pWw44Gv44CBT25zZW4gVUnjga7liJ3mnJ/ljJbjgYzntYLkuobjgZfjgabjgYTjgovmmYLngrnjgaflv4XjgZrlkbzjgbDjgozjgb7jgZnjgIJbL2phXVxuICogICBbZW5dTWV0aG9kIHVzZWQgdG8gd2FpdCBmb3IgYXBwIGluaXRpYWxpemF0aW9uLiBXYWl0cyBmb3IgYERPTUNvbnRlbnRMb2FkZWRgIGFuZCBgZGV2aWNlcmVhZHlgLCB3aGVuIG5lY2Vzc2FyeSwgYmVmb3JlIGV4ZWN1dGluZyB0aGUgY2FsbGJhY2suWy9lbl1cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gKiAgIFtlbl1GdW5jdGlvbiB0aGF0IGV4ZWN1dGVzIGFmdGVyIE9uc2VuIFVJIGhhcyBiZWVuIGluaXRpYWxpemVkLlsvZW5dXG4gKiAgIFtqYV1PbnNlbiBVSeOBjOWIneacn+WMluOBjOWujOS6huOBl+OBn+W+jOOBq+WRvOOBs+WHuuOBleOCjOOCi+mWouaVsOOCquODluOCuOOCp+OCr+ODiOOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gKi9cbm9ucy5yZWFkeSA9IGNhbGxiYWNrID0+IHtcbiAgaWYgKG9ucy5pc1JlYWR5KCkpIHtcbiAgICBjYWxsYmFjaygpO1xuICB9IGVsc2Uge1xuICAgIG9ucy5fcmVhZHlMb2NrLndhaXRVbmxvY2soY2FsbGJhY2spO1xuICB9XG59O1xuXG4vKipcbiAqIEBtZXRob2Qgc2V0RGVmYXVsdERldmljZUJhY2tCdXR0b25MaXN0ZW5lclxuICogQHNpZ25hdHVyZSBzZXREZWZhdWx0RGV2aWNlQmFja0J1dHRvbkxpc3RlbmVyKGxpc3RlbmVyKVxuICogQHBhcmFtIHtGdW5jdGlvbn0gbGlzdGVuZXJcbiAqICAgW2VuXUZ1bmN0aW9uIHRoYXQgZXhlY3V0ZXMgd2hlbiBkZXZpY2UgYmFjayBidXR0b24gaXMgcHJlc3NlZC4gTXVzdCBiZSBjYWxsZWQgb24gYG9ucy5yZWFkeWAuWy9lbl1cbiAqICAgW2phXeODh+ODkOOCpOOCueOBruODkOODg+OCr+ODnOOCv+ODs+OBjOaKvOOBleOCjOOBn+aZguOBq+Wun+ihjOOBleOCjOOCi+mWouaVsOOCquODluOCuOOCp+OCr+ODiOOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXVNldCBkZWZhdWx0IGhhbmRsZXIgZm9yIGRldmljZSBiYWNrIGJ1dHRvbi5bL2VuXVxuICogICBbamFd44OH44OQ44Kk44K544Gu44OQ44OD44Kv44Oc44K/44Oz44Gu44Gf44KB44Gu44OH44OV44Kp44Or44OI44Gu44OP44Oz44OJ44Op44KS6Kit5a6a44GX44G+44GZ44CCWy9qYV1cbiAqL1xub25zLnNldERlZmF1bHREZXZpY2VCYWNrQnV0dG9uTGlzdGVuZXIgPSBmdW5jdGlvbihsaXN0ZW5lcikge1xuICBpZiAoIW9ucy5pc1JlYWR5KCkpIHtcbiAgICByZWFkeUVycm9yKHRydWUpO1xuICB9XG4gIG9ucy5fZGVmYXVsdERldmljZUJhY2tCdXR0b25IYW5kbGVyLnNldExpc3RlbmVyKGxpc3RlbmVyKTtcbn07XG5cbi8qKlxuICogQG1ldGhvZCBkaXNhYmxlRGV2aWNlQmFja0J1dHRvbkhhbmRsZXJcbiAqIEBzaWduYXR1cmUgZGlzYWJsZURldmljZUJhY2tCdXR0b25IYW5kbGVyKClcbiAqIEBkZXNjcmlwdGlvblxuICogW2VuXURpc2FibGUgZGV2aWNlIGJhY2sgYnV0dG9uIGV2ZW50IGhhbmRsZXIuIE11c3QgYmUgY2FsbGVkIG9uIGBvbnMucmVhZHlgLlsvZW5dXG4gKiBbamFd44OH44OQ44Kk44K544Gu44OQ44OD44Kv44Oc44K/44Oz44Gu44Kk44OZ44Oz44OI44KS5Y+X44GR5LuY44GR44Gq44GE44KI44GG44Gr44GX44G+44GZ44CCWy9qYV1cbiAqL1xub25zLmRpc2FibGVEZXZpY2VCYWNrQnV0dG9uSGFuZGxlciA9IGZ1bmN0aW9uKCkge1xuICBpZiAoIW9ucy5pc1JlYWR5KCkpIHtcbiAgICByZWFkeUVycm9yKHRydWUpO1xuICB9XG4gIGludGVybmFsLmRiYkRpc3BhdGNoZXIuZGlzYWJsZSgpO1xufTtcblxuLyoqXG4gKiBAbWV0aG9kIGVuYWJsZURldmljZUJhY2tCdXR0b25IYW5kbGVyXG4gKiBAc2lnbmF0dXJlIGVuYWJsZURldmljZUJhY2tCdXR0b25IYW5kbGVyKClcbiAqIEBkZXNjcmlwdGlvblxuICogW2VuXUVuYWJsZSBkZXZpY2UgYmFjayBidXR0b24gZXZlbnQgaGFuZGxlci4gTXVzdCBiZSBjYWxsZWQgb24gYG9ucy5yZWFkeWAuWy9lbl1cbiAqIFtqYV3jg4fjg5DjgqTjgrnjga7jg5Djg4Pjgq/jg5zjgr/jg7Pjga7jgqTjg5njg7Pjg4jjgpLlj5fjgZHku5jjgZHjgovjgojjgYbjgavjgZfjgb7jgZnjgIJbL2phXVxuICovXG5vbnMuZW5hYmxlRGV2aWNlQmFja0J1dHRvbkhhbmRsZXIgPSBmdW5jdGlvbigpIHtcbiAgaWYgKCFvbnMuaXNSZWFkeSgpKSB7XG4gICAgcmVhZHlFcnJvcih0cnVlKTtcbiAgfVxuICBpbnRlcm5hbC5kYmJEaXNwYXRjaGVyLmVuYWJsZSgpO1xufTtcblxub25zLmZpcmVEZXZpY2VCYWNrQnV0dG9uRXZlbnQgPSBmdW5jdGlvbigpIHtcbiAgaW50ZXJuYWwuZGJiRGlzcGF0Y2hlci5maXJlRGV2aWNlQmFja0J1dHRvbkV2ZW50KCk7XG59O1xuXG4vKipcbiAqIEBtZXRob2QgZW5hYmxlQXV0b1N0YXR1c0JhckZpbGxcbiAqIEBzaWduYXR1cmUgZW5hYmxlQXV0b1N0YXR1c0JhckZpbGwoKVxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1FbmFibGUgc3RhdHVzIGJhciBmaWxsIGZlYXR1cmUgb24gaU9TNyBhbmQgYWJvdmUgKGV4Y2VwdCBmb3IgaVBob25lIFgpLiBNdXN0IGJlIGNhbGxlZCBiZWZvcmUgYG9ucy5yZWFkeWAuWy9lbl1cbiAqICAgW2phXWlPUzfku6XkuIrvvIhpUGhvbmUgWOOBr+mZpOOBj++8ieOBp+OAgeOCueODhuODvOOCv+OCueODkOODvOmDqOWIhuOBrumrmOOBleOCkuiHquWLleeahOOBq+Wfi+OCgeOCi+WHpueQhuOCkuacieWKueOBq+OBl+OBvuOBmeOAglsvamFdXG4gKi9cbm9ucy5lbmFibGVBdXRvU3RhdHVzQmFyRmlsbCA9ICgpID0+IHtcbiAgaWYgKG9ucy5pc1JlYWR5KCkpIHtcbiAgICByZWFkeUVycm9yKGZhbHNlKTtcbiAgfVxuICBpbnRlcm5hbC5jb25maWcuYXV0b1N0YXR1c0JhckZpbGwgPSB0cnVlO1xufTtcblxuLyoqXG4gKiBAbWV0aG9kIGRpc2FibGVBdXRvU3RhdHVzQmFyRmlsbFxuICogQHNpZ25hdHVyZSBkaXNhYmxlQXV0b1N0YXR1c0JhckZpbGwoKVxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1EaXNhYmxlIHN0YXR1cyBiYXIgZmlsbCBmZWF0dXJlIG9uIGlPUzcgYW5kIGFib3ZlIChleGNlcHQgZm9yIGlQaG9uZSBYKS4gTXVzdCBiZSBjYWxsZWQgYmVmb3JlIGBvbnMucmVhZHlgLlsvZW5dXG4gKiAgIFtqYV1pT1M35Lul5LiK77yIaVBob25lIFjjga/pmaTjgY/vvInjgafjgIHjgrnjg4bjg7zjgr/jgrnjg5Djg7zpg6jliIbjga7pq5jjgZXjgpLoh6rli5XnmoTjgavln4vjgoHjgovlh6bnkIbjgpLnhKHlirnjgavjgZfjgb7jgZnjgIJbL2phXVxuICovXG5vbnMuZGlzYWJsZUF1dG9TdGF0dXNCYXJGaWxsID0gKCkgPT4ge1xuICBpZiAob25zLmlzUmVhZHkoKSkge1xuICAgIHJlYWR5RXJyb3IoZmFsc2UpO1xuICB9XG4gIGludGVybmFsLmNvbmZpZy5hdXRvU3RhdHVzQmFyRmlsbCA9IGZhbHNlO1xufTtcblxuLyoqXG4gKiBAbWV0aG9kIG1vY2tTdGF0dXNCYXJcbiAqIEBzaWduYXR1cmUgbW9ja1N0YXR1c0JhcigpXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXUNyZWF0ZXMgYSBzdGF0aWMgZWxlbWVudCBzaW1pbGFyIHRvIGlPUyBzdGF0dXMgYmFyLiBPbmx5IHVzZWZ1bCBmb3IgYnJvd3NlciB0ZXN0aW5nLiBNdXN0IGJlIGNhbGxlZCBiZWZvcmUgYG9ucy5yZWFkeWAuWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKi9cbm9ucy5tb2NrU3RhdHVzQmFyID0gKCkgPT4ge1xuICBpZiAob25zLmlzUmVhZHkoKSkge1xuICAgIHJlYWR5RXJyb3IoZmFsc2UpO1xuICB9XG5cbiAgY29uc3QgbW9jayA9ICgpID0+IHtcbiAgICBpZiAoIWRvY3VtZW50LmJvZHkuY2hpbGRyZW5bMF0gfHwgIWRvY3VtZW50LmJvZHkuY2hpbGRyZW5bMF0uY2xhc3NMaXN0LmNvbnRhaW5zKCdvbnMtc3RhdHVzLWJhci1tb2NrJykpIHtcbiAgICAgIGNvbnN0IGFuZHJvaWQgPSBwbGF0Zm9ybS5pc0FuZHJvaWQoKSwgaSA9IGkgPT4gYDxpIGNsYXNzPVwiJHtpLnNwbGl0KCctJylbMF19ICR7aX1cIj48L2k+YDtcbiAgICAgIGNvbnN0IGxlZnQgPSBhbmRyb2lkID8gYCR7aSgnem1kaS10d2l0dGVyJyl9ICR7aSgnem1kaS1nb29nbGUtcGxheScpfWAgOiBgTm8gU0lNICR7aSgnZmEtd2lmaScpfWAsXG4gICAgICAgIGNlbnRlciA9IGFuZHJvaWQgPyAnJyA6ICcxMjoyOCBQTScsXG4gICAgICAgIHJpZ2h0ID0gYW5kcm9pZCA/IGAke2koJ3ptZGktbmV0d29yaycpfSAke2koJ3ptZGktd2lmaScpfSAke2koJ3ptZGktYmF0dGVyeScpfSAxMjoyOCBQTWAgOiBgODAlICR7aSgnZmEtYmF0dGVyeS10aHJlZS1xdWFydGVycycpfWA7XG5cbiAgICAgIGRvY3VtZW50LmJvZHkuaW5zZXJ0QmVmb3JlKHV0aWwuY3JlYXRlRWxlbWVudChcbiAgICAgICAgYDxkaXYgY2xhc3M9XCJvbnMtc3RhdHVzLWJhci1tb2NrICR7YW5kcm9pZCA/ICdhbmRyb2lkJyA6ICdpb3MnfVwiPmAgK1xuICAgICAgICAgIGA8ZGl2PiR7bGVmdH08L2Rpdj48ZGl2PiR7Y2VudGVyfTwvZGl2PjxkaXY+JHtyaWdodH08L2Rpdj5gICtcbiAgICAgICAgYDwvZGl2PmBcbiAgICAgICksIGRvY3VtZW50LmJvZHkuZmlyc3RDaGlsZCk7XG4gICAgfVxuICB9O1xuXG4gIGRvY3VtZW50LmJvZHlcbiAgICA/IG1vY2soKVxuICAgIDogaW50ZXJuYWwud2FpdERPTUNvbnRlbnRMb2FkZWQobW9jayk7XG59O1xuXG4vKipcbiAqIEBtZXRob2QgZGlzYWJsZUFuaW1hdGlvbnNcbiAqIEBzaWduYXR1cmUgZGlzYWJsZUFuaW1hdGlvbnMoKVxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1EaXNhYmxlIGFsbCBhbmltYXRpb25zLiBDb3VsZCBiZSBoYW5keSBmb3IgdGVzdGluZyBhbmQgb2xkZXIgZGV2aWNlcy5bL2VuXVxuICogICBbamFd44Ki44OL44Oh44O844K344On44Oz44KS5YWo44Gm54Sh5Yq544Gr44GX44G+44GZ44CC44OG44K544OI44Gu6Zqb44Gr5L6/5Yip44Gn44GZ44CCWy9qYV1cbiAqL1xub25zLmRpc2FibGVBbmltYXRpb25zID0gKCkgPT4ge1xuICBpbnRlcm5hbC5jb25maWcuYW5pbWF0aW9uc0Rpc2FibGVkID0gdHJ1ZTtcbn07XG5cbi8qKlxuICogQG1ldGhvZCBlbmFibGVBbmltYXRpb25zXG4gKiBAc2lnbmF0dXJlIGVuYWJsZUFuaW1hdGlvbnMoKVxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1FbmFibGUgYW5pbWF0aW9ucyAoZGVmYXVsdCkuWy9lbl1cbiAqICAgW2phXeOCouODi+ODoeODvOOCt+ODp+ODs+OCkuacieWKueOBq+OBl+OBvuOBmeOAglsvamFdXG4gKi9cbm9ucy5lbmFibGVBbmltYXRpb25zID0gKCkgPT4ge1xuICBpbnRlcm5hbC5jb25maWcuYW5pbWF0aW9uc0Rpc2FibGVkID0gZmFsc2U7XG59O1xuXG5vbnMuX2Rpc2FibGVXYXJuaW5ncyA9ICgpID0+IHtcbiAgaW50ZXJuYWwuY29uZmlnLndhcm5pbmdzRGlzYWJsZWQgPSB0cnVlO1xufTtcblxub25zLl9lbmFibGVXYXJuaW5ncyA9ICgpID0+IHtcbiAgaW50ZXJuYWwuY29uZmlnLndhcm5pbmdzRGlzYWJsZWQgPSBmYWxzZTtcbn07XG5cbi8qKlxuICogQG1ldGhvZCBkaXNhYmxlQXV0b1N0eWxpbmdcbiAqIEBzaWduYXR1cmUgZGlzYWJsZUF1dG9TdHlsaW5nKClcbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dRGlzYWJsZSBhdXRvbWF0aWMgc3R5bGluZy5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqL1xub25zLmRpc2FibGVBdXRvU3R5bGluZyA9IGF1dG9TdHlsZS5kaXNhYmxlO1xuXG4vKipcbiAqIEBtZXRob2QgZW5hYmxlQXV0b1N0eWxpbmdcbiAqIEBzaWduYXR1cmUgZW5hYmxlQXV0b1N0eWxpbmcoKVxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1FbmFibGUgYXV0b21hdGljIHN0eWxpbmcgYmFzZWQgb24gT1MgKGRlZmF1bHQpLlsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICovXG5vbnMuZW5hYmxlQXV0b1N0eWxpbmcgPSBhdXRvU3R5bGUuZW5hYmxlO1xuXG4vKipcbiAqIEBtZXRob2QgZGlzYWJsZUljb25BdXRvUHJlZml4XG4gKiBAc2lnbmF0dXJlIGRpc2FibGVJY29uQXV0b1ByZWZpeCgpXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXURpc2FibGUgYWRkaW5nIGBmYS1gIHByZWZpeCBhdXRvbWF0aWNhbGx5IHRvIGBvbnMtaWNvbmAgY2xhc3Nlcy4gVXNlZnVsIHdoZW4gaW5jbHVkaW5nIGN1c3RvbSBpY29uIHBhY2tzLlsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICovXG5vbnMuZGlzYWJsZUljb25BdXRvUHJlZml4ID0gKCkgPT4ge1xuICB1dGlsLmNoZWNrTWlzc2luZ0ltcG9ydCgnSWNvbicpO1xuICBlbGVtZW50cy5JY29uLnNldEF1dG9QcmVmaXgoZmFsc2UpO1xufTtcblxuLyoqXG4gKiBAbWV0aG9kIGZvcmNlVUlXZWJWaWV3U2Nyb2xsRml4XG4gKiBAc2lnbmF0dXJlIGZvcmNlVUlXZWJWaWV3U2Nyb2xsRml4KClcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gZm9yY2UgRW5hYmxlIG9yIGRpc2FibGUgdGhlIGZpeC5cbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dQXBwbGllcyBhIGZpeCBmb3IgaU9TIFVJV2ViVmlldyB3aGljaCBwcmV2ZW50cyBzY3JvbGwgZXZlbnRzIGp1bXBpbmcgdG8gcGFnZXMgdW5kZXIgdGhlIHRvcCBsYXllci4gVGhpcyBtYXkgdmlzdWFsbHkgYWZmZWN0IG5vcm1hbCBzY3JvbGxpbmcgb2YgVUlXZWJWaWV3IGlmIHlvdSBvcGVuIGEgZGlhbG9nL21lbnUgYmVmb3JlIHRoZSBzY3JvbGwgbW9tZW50dW0gZmluaXNoZWQuIERpc2FibGVkIGJ5IGRlZmF1bHQuWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKi9cbm9ucy5mb3JjZVVJV2ViVmlld1Njcm9sbEZpeCA9IChmb3JjZSA9IHRydWUpID0+IHtcbiAgaW50ZXJuYWwuY29uZmlnLmZvcmNlVUlXZWJWaWV3U2Nyb2xsRml4ID0gZm9yY2U7XG59O1xuXG4vKipcbiAqIEBtZXRob2QgZm9yY2VQbGF0Zm9ybVN0eWxpbmdcbiAqIEBzaWduYXR1cmUgZm9yY2VQbGF0Zm9ybVN0eWxpbmcocGxhdGZvcm0pXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXVJlZnJlc2ggc3R5bGluZyBmb3IgdGhlIGdpdmVuIHBsYXRmb3JtLiBPbmx5IHVzZWZ1bCBmb3IgZGVtb3MuIFVzZSBgb25zLnBsYXRmb3JtLnNlbGVjdCguLi4pYCBpbnN0ZWFkIGZvciBkZXZlbG9wbWVudCBhbmQgcHJvZHVjdGlvbi5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBwYXJhbSB7c3RyaW5nfSBwbGF0Zm9ybSBOZXcgcGxhdGZvcm0gdG8gc3R5bGUgdGhlIGVsZW1lbnRzLlxuICovXG5vbnMuZm9yY2VQbGF0Zm9ybVN0eWxpbmcgPSBuZXdQbGF0Zm9ybSA9PiB7XG4gIG9ucy5lbmFibGVBdXRvU3R5bGluZygpO1xuICBvbnMucGxhdGZvcm0uc2VsZWN0KG5ld1BsYXRmb3JtIHx8ICdpb3MnKTtcblxuICBvbnMuX3V0aWwuYXJyYXlGcm9tKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJyonKSlcbiAgICAuZm9yRWFjaChmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICBpZiAoZWxlbWVudC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdvbnMtaWYnKSB7XG4gICAgICAgIGVsZW1lbnQuX3BsYXRmb3JtVXBkYXRlKCk7XG4gICAgICB9IGVsc2UgaWYgKGVsZW1lbnQudGFnTmFtZS5tYXRjaCgvXm9ucy0vaSkpIHtcbiAgICAgICAgYXV0b1N0eWxlLnByZXBhcmUoZWxlbWVudCwgdHJ1ZSk7XG4gICAgICAgIGlmIChlbGVtZW50LnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ29ucy10YWJiYXInKSB7XG4gICAgICAgICAgZWxlbWVudC5fdXBkYXRlUG9zaXRpb24oKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xufTtcblxuLyoqXG4gKiBAbWV0aG9kIHByZWxvYWRcbiAqIEBzaWduYXR1cmUgcHJlbG9hZCh0ZW1wbGF0ZVBhdGhzKVxuICogQHBhcmFtIHtTdHJpbmd8QXJyYXl9IHRlbXBsYXRlUGF0aHNcbiAqICAgW2VuXVNldCBvZiBIVE1MIGZpbGUgcGF0aHMgY29udGFpbmluZyAnb25zLXBhZ2UnIGVsZW1lbnRzLlsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQHJldHVybiB7UHJvbWlzZX1cbiAqICAgW2VuXVByb21pc2UgdGhhdCByZXNvbHZlcyB3aGVuIGFsbCB0aGUgdGVtcGxhdGVzIGFyZSBjYWNoZWQuWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXVNlcGFyYXRlZCBmaWxlcyBuZWVkIHRvIGJlIHJlcXVlc3RlZCBvbiBkZW1hbmQgYW5kIHRoaXMgY2FuIHNsaWdodGx5IGRlbGF5IHB1c2hpbmcgbmV3IHBhZ2VzLiBUaGlzIG1ldGhvZCByZXF1ZXN0cyBhbmQgY2FjaGVzIHRlbXBsYXRlcyBmb3IgbGF0ZXIgdXNlLlsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICovXG5vbnMucHJlbG9hZCA9IGZ1bmN0aW9uKHRlbXBsYXRlcyA9IFtdKSB7XG4gIHJldHVybiBQcm9taXNlLmFsbCgodGVtcGxhdGVzIGluc3RhbmNlb2YgQXJyYXkgPyB0ZW1wbGF0ZXMgOiBbdGVtcGxhdGVzXSkubWFwKHRlbXBsYXRlID0+IHtcbiAgICBpZiAodHlwZW9mIHRlbXBsYXRlICE9PSAnc3RyaW5nJykge1xuICAgICAgdXRpbC50aHJvdygnRXhwZWN0ZWQgc3RyaW5nIGFyZ3VtZW50cyBidXQgZ290ICcgKyB0eXBlb2YgdGVtcGxhdGUpO1xuICAgIH1cbiAgICByZXR1cm4gaW50ZXJuYWwuZ2V0VGVtcGxhdGVIVE1MQXN5bmModGVtcGxhdGUpO1xuICB9KSk7XG59O1xuXG4vKipcbiAqIEBtZXRob2QgY3JlYXRlRWxlbWVudFxuICogQHNpZ25hdHVyZSBjcmVhdGVFbGVtZW50KHRlbXBsYXRlLCBvcHRpb25zKVxuICogQHBhcmFtIHtTdHJpbmd9IHRlbXBsYXRlXG4gKiAgIFtlbl1FaXRoZXIgYW4gSFRNTCBmaWxlIHBhdGgsIGEgYDx0ZW1wbGF0ZT5gIGlkIG9yIGFuIEhUTUwgc3RyaW5nIHN1Y2ggYXMgYCc8ZGl2IGlkPVwiZm9vXCI+aG9nZTwvZGl2PidgLlsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogICBbZW5dUGFyYW1ldGVyIG9iamVjdC5bL2VuXVxuICogICBbamFd44Kq44OX44K344On44Oz44KS5oyH5a6a44GZ44KL44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAqIEBwYXJhbSB7Qm9vbGVhbnxIVE1MRWxlbWVudH0gW29wdGlvbnMuYXBwZW5kXVxuICogICBbZW5dV2hldGhlciBvciBub3QgdGhlIGVsZW1lbnQgc2hvdWxkIGJlIGF1dG9tYXRpY2FsbHkgYXBwZW5kZWQgdG8gdGhlIERPTS4gIERlZmF1bHRzIHRvIGBmYWxzZWAuIElmIGB0cnVlYCB2YWx1ZSBpcyBnaXZlbiwgYGRvY3VtZW50LmJvZHlgIHdpbGwgYmUgdXNlZCBhcyB0aGUgdGFyZ2V0LlsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gW29wdGlvbnMuaW5zZXJ0QmVmb3JlXVxuICogICBbZW5dUmVmZXJlbmNlIG5vZGUgdGhhdCBiZWNvbWVzIHRoZSBuZXh0IHNpYmxpbmcgb2YgdGhlIG5ldyBub2RlIChgb3B0aW9ucy5hcHBlbmRgIGVsZW1lbnQpLlsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQHJldHVybiB7SFRNTEVsZW1lbnR8UHJvbWlzZX1cbiAqICAgW2VuXUlmIHRoZSBwcm92aWRlZCB0ZW1wbGF0ZSB3YXMgYW4gaW5saW5lIEhUTUwgc3RyaW5nLCBpdCByZXR1cm5zIHRoZSBuZXcgZWxlbWVudC4gT3RoZXJ3aXNlLCBpdCByZXR1cm5zIGEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSBuZXcgZWxlbWVudC5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dQ3JlYXRlIGEgbmV3IGVsZW1lbnQgZnJvbSBhIHRlbXBsYXRlLiBCb3RoIGlubGluZSBIVE1MIGFuZCBleHRlcm5hbCBmaWxlcyBhcmUgc3VwcG9ydGVkIGFsdGhvdWdoIHRoZSByZXR1cm4gdmFsdWUgZGlmZmVycy5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqL1xub25zLmNyZWF0ZUVsZW1lbnQgPSAodGVtcGxhdGUsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICB0ZW1wbGF0ZSA9IHRlbXBsYXRlLnRyaW0oKTtcblxuICBjb25zdCBjcmVhdGUgPSBodG1sID0+IHtcbiAgICBjb25zdCBlbGVtZW50ID0gb25zLl91dGlsLmNyZWF0ZUVsZW1lbnQoaHRtbCk7XG4gICAgZWxlbWVudC5yZW1vdmUoKTtcblxuICAgIGlmIChvcHRpb25zLmFwcGVuZCkge1xuICAgICAgY29uc3QgdGFyZ2V0ID0gb3B0aW9ucy5hcHBlbmQgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCA/IG9wdGlvbnMuYXBwZW5kIDogZG9jdW1lbnQuYm9keTtcbiAgICAgIHRhcmdldC5pbnNlcnRCZWZvcmUoZWxlbWVudCwgb3B0aW9ucy5pbnNlcnRCZWZvcmUgfHwgbnVsbCk7XG4gICAgICBvcHRpb25zLmxpbmsgaW5zdGFuY2VvZiBGdW5jdGlvbiAmJiBvcHRpb25zLmxpbmsoZWxlbWVudCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH07XG5cbiAgcmV0dXJuIHRlbXBsYXRlLmNoYXJBdCgwKSA9PT0gJzwnID8gY3JlYXRlKHRlbXBsYXRlKSA6IGludGVybmFsLmdldFBhZ2VIVE1MQXN5bmModGVtcGxhdGUpLnRoZW4oY3JlYXRlKTtcbn07XG5cbi8qKlxuICogQG1ldGhvZCBjcmVhdGVQb3BvdmVyXG4gKiBAc2lnbmF0dXJlIGNyZWF0ZVBvcG92ZXIocGFnZSwgW29wdGlvbnNdKVxuICogQHBhcmFtIHtTdHJpbmd9IHBhZ2VcbiAqICAgW2VuXVBhZ2UgbmFtZS4gQ2FuIGJlIGVpdGhlciBhbiBIVE1MIGZpbGUgb3IgYSA8dGVtcGxhdGU+IGNvbnRhaW5pbmcgYSA8b25zLWRpYWxvZz4gY29tcG9uZW50LlsvZW5dXG4gKiAgIFtqYV1wYWdl44GuVVJM44GL44CB44KC44GX44GP44GvYDx0ZW1wbGF0ZT5g44Gn5a6j6KiA44GX44Gf44OG44Oz44OX44Os44O844OI44GuaWTlsZ7mgKfjga7lgKTjgpLmjIflrprjgafjgY3jgb7jgZnjgIJbL2phXVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogICBbZW5dUGFyYW1ldGVyIG9iamVjdC5bL2VuXVxuICogICBbamFd44Kq44OX44K344On44Oz44KS5oyH5a6a44GZ44KL44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5wYXJlbnRTY29wZV1cbiAqICAgW2VuXVBhcmVudCBzY29wZSBvZiB0aGUgZGlhbG9nLiBVc2VkIHRvIGJpbmQgbW9kZWxzIGFuZCBhY2Nlc3Mgc2NvcGUgbWV0aG9kcyBmcm9tIHRoZSBkaWFsb2cuWy9lbl1cbiAqICAgW2phXeODgOOCpOOCouODreOCsOWGheOBp+WIqeeUqOOBmeOCi+imquOCueOCs+ODvOODl+OCkuaMh+WumuOBl+OBvuOBmeOAguODgOOCpOOCouODreOCsOOBi+OCieODouODh+ODq+OChOOCueOCs+ODvOODl+OBruODoeOCveODg+ODieOBq+OCouOCr+OCu+OCueOBmeOCi+OBruOBq+S9v+OBhOOBvuOBmeOAguOBk+OBruODkeODqeODoeODvOOCv+OBr0FuZ3VsYXJKU+ODkOOCpOODs+ODh+OCo+ODs+OCsOOBp+OBruOBv+WIqeeUqOOBp+OBjeOBvuOBmeOAglsvamFdXG4gKiBAcmV0dXJuIHtQcm9taXNlfVxuICogICBbZW5dUHJvbWlzZSBvYmplY3QgdGhhdCByZXNvbHZlcyB0byB0aGUgcG9wb3ZlciBjb21wb25lbnQgb2JqZWN0LlsvZW5dXG4gKiAgIFtqYV3jg53jg4Pjg5fjgqrjg7zjg5Djg7zjga7jgrPjg7Pjg53jg7zjg43jg7Pjg4jjgqrjg5bjgrjjgqfjgq/jg4jjgpLop6PmsbrjgZnjgotQcm9taXNl44Kq44OW44K444Kn44Kv44OI44KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dQ3JlYXRlIGEgcG9wb3ZlciBpbnN0YW5jZSBmcm9tIGEgdGVtcGxhdGUuWy9lbl1cbiAqICAgW2phXeODhuODs+ODl+ODrOODvOODiOOBi+OCieODneODg+ODl+OCquODvOODkOODvOOBruOCpOODs+OCueOCv+ODs+OCueOCkueUn+aIkOOBl+OBvuOBmeOAglsvamFdXG4gKi9cbi8qKlxuICogQG1ldGhvZCBjcmVhdGVEaWFsb2dcbiAqIEBzaWduYXR1cmUgY3JlYXRlRGlhbG9nKHBhZ2UsIFtvcHRpb25zXSlcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYWdlXG4gKiAgIFtlbl1QYWdlIG5hbWUuIENhbiBiZSBlaXRoZXIgYW4gSFRNTCBmaWxlIG9yIGFuIGA8dGVtcGxhdGU+YCBjb250YWluaW5nIGEgPG9ucy1kaWFsb2c+IGNvbXBvbmVudC5bL2VuXVxuICogICBbamFdcGFnZeOBrlVSTOOBi+OAgeOCguOBl+OBj+OBr2A8dGVtcGxhdGU+YOOBp+Wuo+iogOOBl+OBn+ODhuODs+ODl+ODrOODvOODiOOBrmlk5bGe5oCn44Gu5YCk44KS5oyH5a6a44Gn44GN44G+44GZ44CCWy9qYV1cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqICAgW2VuXVBhcmFtZXRlciBvYmplY3QuWy9lbl1cbiAqICAgW2phXeOCquODl+OCt+ODp+ODs+OCkuaMh+WumuOBmeOCi+OCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gKiBAcmV0dXJuIHtQcm9taXNlfVxuICogICBbZW5dUHJvbWlzZSBvYmplY3QgdGhhdCByZXNvbHZlcyB0byB0aGUgZGlhbG9nIGNvbXBvbmVudCBvYmplY3QuWy9lbl1cbiAqICAgW2phXeODgOOCpOOCouODreOCsOOBruOCs+ODs+ODneODvOODjeODs+ODiOOCquODluOCuOOCp+OCr+ODiOOCkuino+axuuOBmeOCi1Byb21pc2Xjgqrjg5bjgrjjgqfjgq/jg4jjgpLov5TjgZfjgb7jgZnjgIJbL2phXVxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1DcmVhdGUgYSBkaWFsb2cgaW5zdGFuY2UgZnJvbSBhIHRlbXBsYXRlLlsvZW5dXG4gKiAgIFtqYV3jg4bjg7Pjg5fjg6zjg7zjg4jjgYvjgonjg4DjgqTjgqLjg63jgrDjga7jgqTjg7Pjgrnjgr/jg7PjgrnjgpLnlJ/miJDjgZfjgb7jgZnjgIJbL2phXVxuICovXG4vKipcbiAqIEBtZXRob2QgY3JlYXRlQWxlcnREaWFsb2dcbiAqIEBzaWduYXR1cmUgY3JlYXRlQWxlcnREaWFsb2cocGFnZSwgW29wdGlvbnNdKVxuICogQHBhcmFtIHtTdHJpbmd9IHBhZ2VcbiAqICAgW2VuXVBhZ2UgbmFtZS4gQ2FuIGJlIGVpdGhlciBhbiBIVE1MIGZpbGUgb3IgYW4gYDx0ZW1wbGF0ZT5gIGNvbnRhaW5pbmcgYSA8b25zLWFsZXJ0LWRpYWxvZz4gY29tcG9uZW50LlsvZW5dXG4gKiAgIFtqYV1wYWdl44GuVVJM44GL44CB44KC44GX44GP44GvYDx0ZW1wbGF0ZT5g44Gn5a6j6KiA44GX44Gf44OG44Oz44OX44Os44O844OI44GuaWTlsZ7mgKfjga7lgKTjgpLmjIflrprjgafjgY3jgb7jgZnjgIJbL2phXVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogICBbZW5dUGFyYW1ldGVyIG9iamVjdC5bL2VuXVxuICogICBbamFd44Kq44OX44K344On44Oz44KS5oyH5a6a44GZ44KL44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAqIEByZXR1cm4ge1Byb21pc2V9XG4gKiAgIFtlbl1Qcm9taXNlIG9iamVjdCB0aGF0IHJlc29sdmVzIHRvIHRoZSBhbGVydCBkaWFsb2cgY29tcG9uZW50IG9iamVjdC5bL2VuXVxuICogICBbamFd44OA44Kk44Ki44Ot44Kw44Gu44Kz44Oz44Od44O844ON44Oz44OI44Kq44OW44K444Kn44Kv44OI44KS6Kej5rG644GZ44KLUHJvbWlzZeOCquODluOCuOOCp+OCr+ODiOOCkui/lOOBl+OBvuOBmeOAglsvamFdXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXUNyZWF0ZSBhIGFsZXJ0IGRpYWxvZyBpbnN0YW5jZSBmcm9tIGEgdGVtcGxhdGUuWy9lbl1cbiAqICAgW2phXeODhuODs+ODl+ODrOODvOODiOOBi+OCieOCouODqeODvOODiOODgOOCpOOCouODreOCsOOBruOCpOODs+OCueOCv+ODs+OCueOCkueUn+aIkOOBl+OBvuOBmeOAglsvamFdXG4gKi9cbm9ucy5jcmVhdGVQb3BvdmVyID0gb25zLmNyZWF0ZURpYWxvZyA9IG9ucy5jcmVhdGVBbGVydERpYWxvZyA9ICh0ZW1wbGF0ZSwgb3B0aW9ucyA9IHt9KSA9PiBvbnMuY3JlYXRlRWxlbWVudCh0ZW1wbGF0ZSwgeyBhcHBlbmQ6IHRydWUsIC4uLm9wdGlvbnMgfSk7XG5cbi8qKlxuICogQG1ldGhvZCBvcGVuQWN0aW9uU2hlZXRcbiAqIEBzaWduYXR1cmUgb3BlbkFjdGlvblNoZWV0KG9wdGlvbnMpXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXVNob3dzIGFuIGluc3RhbnQgQWN0aW9uIFNoZWV0IGFuZCBsZXRzIHRoZSB1c2VyIGNob29zZSBhbiBhY3Rpb24uWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiAgIFtlbl1QYXJhbWV0ZXIgb2JqZWN0LlsvZW5dXG4gKiAgIFtqYV3jgqrjg5fjgrfjg6fjg7PjgpLmjIflrprjgZnjgovjgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICogQHBhcmFtIHtBcnJheX0gW29wdGlvbnMuYnV0dG9uc11cbiAqICAgW2VuXVJlcHJlc2VudCBlYWNoIGJ1dHRvbiBvZiB0aGUgYWN0aW9uIHNoZWV0IGZvbGxvd2luZyB0aGUgc3BlY2lmaWVkIG9yZGVyLiBFdmVyeSBpdGVtIGNhbiBiZSBlaXRoZXIgYSBzdHJpbmcgbGFiZWwgb3IgYW4gb2JqZWN0IGNvbnRhaW5pbmcgYGxhYmVsYCwgYGljb25gIGFuZCBgbW9kaWZpZXJgIHByb3BlcnRpZXMuWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMudGl0bGVdXG4gKiAgIFtlbl1PcHRpb25hbCB0aXRsZSBmb3IgdGhlIGFjdGlvbiBzaGVldC5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5kZXN0cnVjdGl2ZV1cbiAqICAgW2VuXU9wdGlvbmFsIGluZGV4IG9mIHRoZSBcImRlc3RydWN0aXZlXCIgYnV0dG9uIChvbmx5IGZvciBpT1MpLiBJdCBjYW4gYmUgc3BlY2lmaWVkIGluIHRoZSBidXR0b24gYXJyYXkgYXMgd2VsbC5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuY2FuY2VsYWJsZV1cbiAqICAgW2VuXVdoZXRoZXIgdGhlIGFjdGlvbiBzaGVldCBjYW4gYmUgY2FuY2VsZWQgYnkgdGFwcGluZyBvbiB0aGUgYmFja2dyb3VuZCBtYXNrIG9yIG5vdC5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5tb2RpZmllcl1cbiAqICAgW2VuXU1vZGlmaWVyIGF0dHJpYnV0ZSBvZiB0aGUgYWN0aW9uIHNoZWV0LiBFLmcuIGAnZGVzdHJ1Y3RpdmUnYC5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5tYXNrQ29sb3JdXG4gKiAgIFtlbl1PcHRpb25hbGx5IGNoYW5nZSB0aGUgYmFja2dyb3VuZCBtYXNrIGNvbG9yLlsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmlkXVxuICogICBbZW5dVGhlIGVsZW1lbnQncyBpZCBhdHRyaWJ1dGUuWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuY2xhc3NdXG4gKiAgIFtlbl1UaGUgZWxlbWVudCdzIGNsYXNzIGF0dHJpYnV0ZS5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEByZXR1cm4ge1Byb21pc2V9XG4gKiAgIFtlbl1XaWxsIHJlc29sdmUgd2hlbiB0aGUgYWN0aW9uIHNoZWV0IGlzIGNsb3NlZC4gVGhlIHJlc29sdmUgdmFsdWUgaXMgZWl0aGVyIHRoZSBpbmRleCBvZiB0aGUgdGFwcGVkIGJ1dHRvbiBvciAtMSB3aGVuIGNhbmNlbGVkLlsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICovXG5vbnMub3BlbkFjdGlvblNoZWV0ID0gYWN0aW9uU2hlZXQ7XG5cbi8qKlxuICogQG1ldGhvZCByZXNvbHZlTG9hZGluZ1BsYWNlaG9sZGVyXG4gKiBAc2lnbmF0dXJlIHJlc29sdmVMb2FkaW5nUGxhY2Vob2xkZXIocGFnZSlcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYWdlXG4gKiAgIFtlbl1QYWdlIG5hbWUuIENhbiBiZSBlaXRoZXIgYW4gSFRNTCBmaWxlIG9yIGEgYDx0ZW1wbGF0ZT5gIGlkLlsvZW5dXG4gKiAgIFtqYV1wYWdl44GuVVJM44GL44CB44KC44GX44GP44GvYDx0ZW1wbGF0ZT5g44Gn5a6j6KiA44GX44Gf44OG44Oz44OX44Os44O844OI44GuaWTlsZ7mgKfjga7lgKTjgpLmjIflrprjgafjgY3jgb7jgZnjgIJbL2phXVxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1JZiBubyBwYWdlIGlzIGRlZmluZWQgZm9yIHRoZSBgb25zLWxvYWRpbmctcGxhY2Vob2xkZXJgIGF0dHJpYnV0ZSBpdCB3aWxsIHdhaXQgZm9yIHRoaXMgbWV0aG9kIGJlaW5nIGNhbGxlZCBiZWZvcmUgbG9hZGluZyB0aGUgcGFnZS5bL2VuXVxuICogICBbamFdb25zLWxvYWRpbmctcGxhY2Vob2xkZXLjga7lsZ7mgKflgKTjgajjgZfjgabjg5rjg7zjgrjjgYzmjIflrprjgZXjgozjgabjgYTjgarjgYTloLTlkIjjga/jgIHjg5rjg7zjgrjjg63jg7zjg4nliY3jgavlkbzjgbDjgozjgotvbnMucmVzb2x2ZUxvYWRpbmdQbGFjZWhvbGRlcuWHpueQhuOBjOihjOOCj+OCjOOCi+OBvuOBp+ihqOekuuOBleOCjOOBvuOBm+OCk+OAglsvamFdXG4gKi9cbm9ucy5yZXNvbHZlTG9hZGluZ1BsYWNlaG9sZGVyID0gKHBhZ2UsIGxpbmspID0+IHtcbiAgY29uc3QgZWxlbWVudHMgPSBvbnMuX3V0aWwuYXJyYXlGcm9tKHdpbmRvdy5kb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdbb25zLWxvYWRpbmctcGxhY2Vob2xkZXJdJykpO1xuICBpZiAoZWxlbWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgdXRpbC50aHJvdygnTm8gb25zLWxvYWRpbmctcGxhY2Vob2xkZXIgZXhpc3RzJyk7XG4gIH1cblxuICBlbGVtZW50c1xuICAgIC5maWx0ZXIoZWxlbWVudCA9PiAhZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3BhZ2UnKSlcbiAgICAuZm9yRWFjaChlbGVtZW50ID0+IHtcbiAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCdvbnMtbG9hZGluZy1wbGFjZWhvbGRlcicsIHBhZ2UpO1xuICAgICAgb25zLl9yZXNvbHZlTG9hZGluZ1BsYWNlaG9sZGVyKGVsZW1lbnQsIHBhZ2UsIGxpbmspO1xuICAgIH0pO1xufTtcblxuXG5vbnMuX3NldHVwTG9hZGluZ1BsYWNlSG9sZGVycyA9IGZ1bmN0aW9uKCkge1xuICBvbnMucmVhZHkoKCkgPT4ge1xuICAgIGNvbnN0IGVsZW1lbnRzID0gb25zLl91dGlsLmFycmF5RnJvbSh3aW5kb3cuZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnW29ucy1sb2FkaW5nLXBsYWNlaG9sZGVyXScpKTtcblxuICAgIGVsZW1lbnRzLmZvckVhY2goZWxlbWVudCA9PiB7XG4gICAgICBjb25zdCBwYWdlID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ29ucy1sb2FkaW5nLXBsYWNlaG9sZGVyJyk7XG4gICAgICBpZiAodHlwZW9mIHBhZ2UgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIG9ucy5fcmVzb2x2ZUxvYWRpbmdQbGFjZWhvbGRlcihlbGVtZW50LCBwYWdlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG59O1xuXG5vbnMuX3Jlc29sdmVMb2FkaW5nUGxhY2Vob2xkZXIgPSBmdW5jdGlvbihwYXJlbnQsIHBhZ2UsIGxpbmsgPSAoKGVsLCBkb25lKSA9PiBkb25lKCkpKSB7XG4gIHBhZ2UgJiYgb25zLmNyZWF0ZUVsZW1lbnQocGFnZSlcbiAgICAudGhlbihlbGVtZW50ID0+IHtcbiAgICAgIGVsZW1lbnQuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgIHBhcmVudC5hcHBlbmRDaGlsZChlbGVtZW50KTtcbiAgICAgIGxpbmsoZWxlbWVudCwgKCkgPT4ge1xuICAgICAgICB3aGlsZSAocGFyZW50LmZpcnN0Q2hpbGQgJiYgcGFyZW50LmZpcnN0Q2hpbGQgIT09IGVsZW1lbnQpIHtcbiAgICAgICAgICBwYXJlbnQucmVtb3ZlQ2hpbGQocGFyZW50LmZpcnN0Q2hpbGQpO1xuICAgICAgICB9XG4gICAgICAgIGVsZW1lbnQuc3R5bGUuZGlzcGxheSA9ICcnO1xuICAgICAgfSk7XG4gICAgfSlcbiAgICAuY2F0Y2goZXJyb3IgPT4gUHJvbWlzZS5yZWplY3QoJ1VuYWJsZWQgdG8gcmVzb2x2ZSBwbGFjZWhvbGRlcjogJyArIGVycm9yKSk7XG59O1xuXG5mdW5jdGlvbiB3YWl0RGV2aWNlUmVhZHkoKSB7XG4gIGNvbnN0IHVubG9ja0RldmljZVJlYWR5ID0gb25zLl9yZWFkeUxvY2subG9jaygpO1xuICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignRE9NQ29udGVudExvYWRlZCcsICgpID0+IHtcbiAgICBpZiAob25zLmlzV2ViVmlldygpKSB7XG4gICAgICB3aW5kb3cuZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignZGV2aWNlcmVhZHknLCB1bmxvY2tEZXZpY2VSZWFkeSwgZmFsc2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICB1bmxvY2tEZXZpY2VSZWFkeSgpO1xuICAgIH1cbiAgfSwgZmFsc2UpO1xufVxuXG4vKipcbiAqIEBtZXRob2QgZ2V0U2NyaXB0UGFnZVxuICogQHNpZ25hdHVyZSBnZXRTY3JpcHRQYWdlKClcbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dQWNjZXNzIHRoZSBsYXN0IGNyZWF0ZWQgcGFnZSBmcm9tIHRoZSBjdXJyZW50IGBzY3JpcHRgIHNjb3BlLiBPbmx5IHdvcmtzIGluc2lkZSBgPHNjcmlwdD48L3NjcmlwdD5gIHRhZ3MgdGhhdCBhcmUgZGlyZWN0IGNoaWxkcmVuIG9mIGBvbnMtcGFnZWAgZWxlbWVudC4gVXNlIHRoaXMgdG8gYWRkIGxpZmVjeWNsZSBob29rcyB0byBhIHBhZ2UuWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAcmV0dXJuIHtIVE1MRWxlbWVudH1cbiAqICAgW2VuXVJldHVybnMgdGhlIGNvcnJlc3BvbmRpbmcgcGFnZSBlbGVtZW50LlsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICovXG5jb25zdCBnZXRDUyA9ICdjdXJyZW50U2NyaXB0JyBpbiBkb2N1bWVudCA/ICgpID0+IGRvY3VtZW50LmN1cnJlbnRTY3JpcHQgOiAoKSA9PiBkb2N1bWVudC5zY3JpcHRzW2RvY3VtZW50LnNjcmlwdHMubGVuZ3RoIC0gMV07XG5vbnMuZ2V0U2NyaXB0UGFnZSA9ICgpID0+IGdldENTKCkgJiYgL29ucy1wYWdlL2kudGVzdChnZXRDUygpLnBhcmVudEVsZW1lbnQudGFnTmFtZSkgJiYgZ2V0Q1MoKS5wYXJlbnRFbGVtZW50IHx8IG51bGw7XG5cbmV4cG9ydCBkZWZhdWx0IG9ucztcbiIsIjsoZnVuY3Rpb24gKCkge1xuXHQndXNlIHN0cmljdCc7XG5cblx0LyoqXG5cdCAqIEBwcmVzZXJ2ZSBGYXN0Q2xpY2s6IHBvbHlmaWxsIHRvIHJlbW92ZSBjbGljayBkZWxheXMgb24gYnJvd3NlcnMgd2l0aCB0b3VjaCBVSXMuXG5cdCAqXG5cdCAqIEBjb2RpbmdzdGFuZGFyZCBmdGxhYnMtanN2MlxuXHQgKiBAY29weXJpZ2h0IFRoZSBGaW5hbmNpYWwgVGltZXMgTGltaXRlZCBbQWxsIFJpZ2h0cyBSZXNlcnZlZF1cblx0ICogQGxpY2Vuc2UgTUlUIExpY2Vuc2UgKHNlZSBMSUNFTlNFLnR4dClcblx0ICovXG5cblx0Lypqc2xpbnQgYnJvd3Nlcjp0cnVlLCBub2RlOnRydWUqL1xuXHQvKmdsb2JhbCBkZWZpbmUsIEV2ZW50LCBOb2RlKi9cblxuXG5cdC8qKlxuXHQgKiBJbnN0YW50aWF0ZSBmYXN0LWNsaWNraW5nIGxpc3RlbmVycyBvbiB0aGUgc3BlY2lmaWVkIGxheWVyLlxuXHQgKlxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICogQHBhcmFtIHtFbGVtZW50fSBsYXllciBUaGUgbGF5ZXIgdG8gbGlzdGVuIG9uXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gVGhlIG9wdGlvbnMgdG8gb3ZlcnJpZGUgdGhlIGRlZmF1bHRzXG5cdCAqL1xuXHRmdW5jdGlvbiBGYXN0Q2xpY2sobGF5ZXIsIG9wdGlvbnMpIHtcblx0XHR2YXIgb2xkT25DbGljaztcblxuXHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG5cdFx0LyoqXG5cdFx0ICogV2hldGhlciBhIGNsaWNrIGlzIGN1cnJlbnRseSBiZWluZyB0cmFja2VkLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUgYm9vbGVhblxuXHRcdCAqL1xuXHRcdHRoaXMudHJhY2tpbmdDbGljayA9IGZhbHNlO1xuXG5cblx0XHQvKipcblx0XHQgKiBUaW1lc3RhbXAgZm9yIHdoZW4gY2xpY2sgdHJhY2tpbmcgc3RhcnRlZC5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIG51bWJlclxuXHRcdCAqL1xuXHRcdHRoaXMudHJhY2tpbmdDbGlja1N0YXJ0ID0gMDtcblxuXG5cdFx0LyoqXG5cdFx0ICogVGhlIGVsZW1lbnQgYmVpbmcgdHJhY2tlZCBmb3IgYSBjbGljay5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIEV2ZW50VGFyZ2V0XG5cdFx0ICovXG5cdFx0dGhpcy50YXJnZXRFbGVtZW50ID0gbnVsbDtcblxuXG5cdFx0LyoqXG5cdFx0ICogWC1jb29yZGluYXRlIG9mIHRvdWNoIHN0YXJ0IGV2ZW50LlxuXHRcdCAqXG5cdFx0ICogQHR5cGUgbnVtYmVyXG5cdFx0ICovXG5cdFx0dGhpcy50b3VjaFN0YXJ0WCA9IDA7XG5cblxuXHRcdC8qKlxuXHRcdCAqIFktY29vcmRpbmF0ZSBvZiB0b3VjaCBzdGFydCBldmVudC5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIG51bWJlclxuXHRcdCAqL1xuXHRcdHRoaXMudG91Y2hTdGFydFkgPSAwO1xuXG5cblx0XHQvKipcblx0XHQgKiBJRCBvZiB0aGUgbGFzdCB0b3VjaCwgcmV0cmlldmVkIGZyb20gVG91Y2guaWRlbnRpZmllci5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIG51bWJlclxuXHRcdCAqL1xuXHRcdHRoaXMubGFzdFRvdWNoSWRlbnRpZmllciA9IDA7XG5cblxuXHRcdC8qKlxuXHRcdCAqIFRvdWNobW92ZSBib3VuZGFyeSwgYmV5b25kIHdoaWNoIGEgY2xpY2sgd2lsbCBiZSBjYW5jZWxsZWQuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSBudW1iZXJcblx0XHQgKi9cblx0XHR0aGlzLnRvdWNoQm91bmRhcnkgPSBvcHRpb25zLnRvdWNoQm91bmRhcnkgfHwgMTA7XG5cblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBGYXN0Q2xpY2sgbGF5ZXIuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSBFbGVtZW50XG5cdFx0ICovXG5cdFx0dGhpcy5sYXllciA9IGxheWVyO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIG1pbmltdW0gdGltZSBiZXR3ZWVuIHRhcCh0b3VjaHN0YXJ0IGFuZCB0b3VjaGVuZCkgZXZlbnRzXG5cdFx0ICpcblx0XHQgKiBAdHlwZSBudW1iZXJcblx0XHQgKi9cblx0XHR0aGlzLnRhcERlbGF5ID0gb3B0aW9ucy50YXBEZWxheSB8fCAyMDA7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgbWF4aW11bSB0aW1lIGZvciBhIHRhcFxuXHRcdCAqXG5cdFx0ICogQHR5cGUgbnVtYmVyXG5cdFx0ICovXG5cdFx0dGhpcy50YXBUaW1lb3V0ID0gb3B0aW9ucy50YXBUaW1lb3V0IHx8IDcwMDtcblxuXHRcdGlmIChGYXN0Q2xpY2subm90TmVlZGVkKGxheWVyKSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIFNvbWUgb2xkIHZlcnNpb25zIG9mIEFuZHJvaWQgZG9uJ3QgaGF2ZSBGdW5jdGlvbi5wcm90b3R5cGUuYmluZFxuXHRcdGZ1bmN0aW9uIGJpbmQobWV0aG9kLCBjb250ZXh0KSB7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oKSB7IHJldHVybiBtZXRob2QuYXBwbHkoY29udGV4dCwgYXJndW1lbnRzKTsgfTtcblx0XHR9XG5cblxuXHRcdHZhciBtZXRob2RzID0gWydvbk1vdXNlJywgJ29uQ2xpY2snLCAnb25Ub3VjaFN0YXJ0JywgJ29uVG91Y2hNb3ZlJywgJ29uVG91Y2hFbmQnLCAnb25Ub3VjaENhbmNlbCddO1xuXHRcdHZhciBjb250ZXh0ID0gdGhpcztcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IG1ldGhvZHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRjb250ZXh0W21ldGhvZHNbaV1dID0gYmluZChjb250ZXh0W21ldGhvZHNbaV1dLCBjb250ZXh0KTtcblx0XHR9XG5cblx0XHQvLyBTZXQgdXAgZXZlbnQgaGFuZGxlcnMgYXMgcmVxdWlyZWRcblx0XHRpZiAoZGV2aWNlSXNBbmRyb2lkKSB7XG5cdFx0XHRsYXllci5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW92ZXInLCB0aGlzLm9uTW91c2UsIHRydWUpO1xuXHRcdFx0bGF5ZXIuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5vbk1vdXNlLCB0cnVlKTtcblx0XHRcdGxheWVyLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLm9uTW91c2UsIHRydWUpO1xuXHRcdH1cblxuXHRcdGxheWVyLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5vbkNsaWNrLCB0cnVlKTtcblx0XHRsYXllci5hZGRFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgdGhpcy5vblRvdWNoU3RhcnQsIGZhbHNlKTtcblx0XHRsYXllci5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCB0aGlzLm9uVG91Y2hNb3ZlLCBmYWxzZSk7XG5cdFx0bGF5ZXIuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCB0aGlzLm9uVG91Y2hFbmQsIGZhbHNlKTtcblx0XHRsYXllci5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGNhbmNlbCcsIHRoaXMub25Ub3VjaENhbmNlbCwgZmFsc2UpO1xuXG5cdFx0Ly8gSGFjayBpcyByZXF1aXJlZCBmb3IgYnJvd3NlcnMgdGhhdCBkb24ndCBzdXBwb3J0IEV2ZW50I3N0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbiAoZS5nLiBBbmRyb2lkIDIpXG5cdFx0Ly8gd2hpY2ggaXMgaG93IEZhc3RDbGljayBub3JtYWxseSBzdG9wcyBjbGljayBldmVudHMgYnViYmxpbmcgdG8gY2FsbGJhY2tzIHJlZ2lzdGVyZWQgb24gdGhlIEZhc3RDbGlja1xuXHRcdC8vIGxheWVyIHdoZW4gdGhleSBhcmUgY2FuY2VsbGVkLlxuXHRcdGlmICghRXZlbnQucHJvdG90eXBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbikge1xuXHRcdFx0bGF5ZXIucmVtb3ZlRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKHR5cGUsIGNhbGxiYWNrLCBjYXB0dXJlKSB7XG5cdFx0XHRcdHZhciBybXYgPSBOb2RlLnByb3RvdHlwZS5yZW1vdmVFdmVudExpc3RlbmVyO1xuXHRcdFx0XHRpZiAodHlwZSA9PT0gJ2NsaWNrJykge1xuXHRcdFx0XHRcdHJtdi5jYWxsKGxheWVyLCB0eXBlLCBjYWxsYmFjay5oaWphY2tlZCB8fCBjYWxsYmFjaywgY2FwdHVyZSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cm12LmNhbGwobGF5ZXIsIHR5cGUsIGNhbGxiYWNrLCBjYXB0dXJlKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblxuXHRcdFx0bGF5ZXIuYWRkRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKHR5cGUsIGNhbGxiYWNrLCBjYXB0dXJlKSB7XG5cdFx0XHRcdHZhciBhZHYgPSBOb2RlLnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVyO1xuXHRcdFx0XHRpZiAodHlwZSA9PT0gJ2NsaWNrJykge1xuXHRcdFx0XHRcdGFkdi5jYWxsKGxheWVyLCB0eXBlLCBjYWxsYmFjay5oaWphY2tlZCB8fCAoY2FsbGJhY2suaGlqYWNrZWQgPSBmdW5jdGlvbihldmVudCkge1xuXHRcdFx0XHRcdFx0aWYgKCFldmVudC5wcm9wYWdhdGlvblN0b3BwZWQpIHtcblx0XHRcdFx0XHRcdFx0Y2FsbGJhY2soZXZlbnQpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0pLCBjYXB0dXJlKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRhZHYuY2FsbChsYXllciwgdHlwZSwgY2FsbGJhY2ssIGNhcHR1cmUpO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdH1cblxuXHRcdC8vIElmIGEgaGFuZGxlciBpcyBhbHJlYWR5IGRlY2xhcmVkIGluIHRoZSBlbGVtZW50J3Mgb25jbGljayBhdHRyaWJ1dGUsIGl0IHdpbGwgYmUgZmlyZWQgYmVmb3JlXG5cdFx0Ly8gRmFzdENsaWNrJ3Mgb25DbGljayBoYW5kbGVyLiBGaXggdGhpcyBieSBwdWxsaW5nIG91dCB0aGUgdXNlci1kZWZpbmVkIGhhbmRsZXIgZnVuY3Rpb24gYW5kXG5cdFx0Ly8gYWRkaW5nIGl0IGFzIGxpc3RlbmVyLlxuXHRcdGlmICh0eXBlb2YgbGF5ZXIub25jbGljayA9PT0gJ2Z1bmN0aW9uJykge1xuXG5cdFx0XHQvLyBBbmRyb2lkIGJyb3dzZXIgb24gYXQgbGVhc3QgMy4yIHJlcXVpcmVzIGEgbmV3IHJlZmVyZW5jZSB0byB0aGUgZnVuY3Rpb24gaW4gbGF5ZXIub25jbGlja1xuXHRcdFx0Ly8gLSB0aGUgb2xkIG9uZSB3b24ndCB3b3JrIGlmIHBhc3NlZCB0byBhZGRFdmVudExpc3RlbmVyIGRpcmVjdGx5LlxuXHRcdFx0b2xkT25DbGljayA9IGxheWVyLm9uY2xpY2s7XG5cdFx0XHRsYXllci5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0XHRcdG9sZE9uQ2xpY2soZXZlbnQpO1xuXHRcdFx0fSwgZmFsc2UpO1xuXHRcdFx0bGF5ZXIub25jbGljayA9IG51bGw7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCogV2luZG93cyBQaG9uZSA4LjEgZmFrZXMgdXNlciBhZ2VudCBzdHJpbmcgdG8gbG9vayBsaWtlIEFuZHJvaWQgYW5kIGlQaG9uZS5cblx0KlxuXHQqIEB0eXBlIGJvb2xlYW5cblx0Ki9cblx0dmFyIGRldmljZUlzV2luZG93c1Bob25lID0gbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKFwiV2luZG93cyBQaG9uZVwiKSA+PSAwO1xuXG5cdC8qKlxuXHQgKiBBbmRyb2lkIHJlcXVpcmVzIGV4Y2VwdGlvbnMuXG5cdCAqXG5cdCAqIEB0eXBlIGJvb2xlYW5cblx0ICovXG5cdHZhciBkZXZpY2VJc0FuZHJvaWQgPSBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ0FuZHJvaWQnKSA+IDAgJiYgIWRldmljZUlzV2luZG93c1Bob25lO1xuXG5cblx0LyoqXG5cdCAqIGlPUyByZXF1aXJlcyBleGNlcHRpb25zLlxuXHQgKlxuXHQgKiBAdHlwZSBib29sZWFuXG5cdCAqL1xuXHR2YXIgZGV2aWNlSXNJT1MgPSAvaVAoYWR8aG9uZXxvZCkvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkgJiYgIWRldmljZUlzV2luZG93c1Bob25lO1xuXG5cblx0LyoqXG5cdCAqIGlPUyA0IHJlcXVpcmVzIGFuIGV4Y2VwdGlvbiBmb3Igc2VsZWN0IGVsZW1lbnRzLlxuXHQgKlxuXHQgKiBAdHlwZSBib29sZWFuXG5cdCAqL1xuXHR2YXIgZGV2aWNlSXNJT1M0ID0gZGV2aWNlSXNJT1MgJiYgKC9PUyA0X1xcZChfXFxkKT8vKS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuXG5cblx0LyoqXG5cdCAqIGlPUyA2LjAtNy4qIHJlcXVpcmVzIHRoZSB0YXJnZXQgZWxlbWVudCB0byBiZSBtYW51YWxseSBkZXJpdmVkXG5cdCAqXG5cdCAqIEB0eXBlIGJvb2xlYW5cblx0ICovXG5cdHZhciBkZXZpY2VJc0lPU1dpdGhCYWRUYXJnZXQgPSBkZXZpY2VJc0lPUyAmJiAoL09TIFs2LTddX1xcZC8pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG5cblx0LyoqXG5cdCAqIEJsYWNrQmVycnkgcmVxdWlyZXMgZXhjZXB0aW9ucy5cblx0ICpcblx0ICogQHR5cGUgYm9vbGVhblxuXHQgKi9cblx0dmFyIGRldmljZUlzQmxhY2tCZXJyeTEwID0gbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdCQjEwJykgPiAwO1xuXG5cdC8qKlxuXHQgKiBWYWxpZCB0eXBlcyBmb3IgdGV4dCBpbnB1dHNcblx0ICpcblx0ICogQHR5cGUgYXJyYXlcblx0ICovXG5cdHZhciB0ZXh0RmllbGRzID0gWydlbWFpbCcsICdudW1iZXInLCAncGFzc3dvcmQnLCAnc2VhcmNoJywgJ3RlbCcsICd0ZXh0JywgJ3VybCddO1xuXG5cdC8qKlxuXHQgKiBEZXRlcm1pbmUgd2hldGhlciBhIGdpdmVuIGVsZW1lbnQgcmVxdWlyZXMgYSBuYXRpdmUgY2xpY2suXG5cdCAqXG5cdCAqIEBwYXJhbSB7RXZlbnRUYXJnZXR8RWxlbWVudH0gdGFyZ2V0IFRhcmdldCBET00gZWxlbWVudFxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyB0cnVlIGlmIHRoZSBlbGVtZW50IG5lZWRzIGEgbmF0aXZlIGNsaWNrXG5cdCAqL1xuXHRGYXN0Q2xpY2sucHJvdG90eXBlLm5lZWRzQ2xpY2sgPSBmdW5jdGlvbih0YXJnZXQpIHtcblx0XHRzd2l0Y2ggKHRhcmdldC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpKSB7XG5cblx0XHQvLyBEb24ndCBzZW5kIGEgc3ludGhldGljIGNsaWNrIHRvIGRpc2FibGVkIGlucHV0cyAoaXNzdWUgIzYyKVxuXHRcdGNhc2UgJ2J1dHRvbic6XG5cdFx0Y2FzZSAnc2VsZWN0Jzpcblx0XHRjYXNlICd0ZXh0YXJlYSc6XG5cdFx0XHRpZiAodGFyZ2V0LmRpc2FibGVkKSB7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRicmVhaztcblx0XHRjYXNlICdpbnB1dCc6XG5cblx0XHRcdC8vIEZpbGUgaW5wdXRzIG5lZWQgcmVhbCBjbGlja3Mgb24gaU9TIDYgZHVlIHRvIGEgYnJvd3NlciBidWcgKGlzc3VlICM2OClcblx0XHRcdGlmICgoZGV2aWNlSXNJT1MgJiYgdGFyZ2V0LnR5cGUgPT09ICdmaWxlJykgfHwgdGFyZ2V0LmRpc2FibGVkKSB7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRicmVhaztcblx0XHRjYXNlICdsYWJlbCc6XG5cdFx0Y2FzZSAnaWZyYW1lJzogLy8gaU9TOCBob21lc2NyZWVuIGFwcHMgY2FuIHByZXZlbnQgZXZlbnRzIGJ1YmJsaW5nIGludG8gZnJhbWVzXG5cdFx0Y2FzZSAndmlkZW8nOlxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXG5cdFx0cmV0dXJuICgvXFxibmVlZHNjbGlja1xcYi8pLnRlc3QodGFyZ2V0LmNsYXNzTmFtZSk7XG5cdH07XG5cblxuXHQvKipcblx0ICogRGV0ZXJtaW5lIHdoZXRoZXIgYSBnaXZlbiBlbGVtZW50IHJlcXVpcmVzIGEgY2FsbCB0byBmb2N1cyB0byBzaW11bGF0ZSBjbGljayBpbnRvIGVsZW1lbnQuXG5cdCAqXG5cdCAqIEBwYXJhbSB7RXZlbnRUYXJnZXR8RWxlbWVudH0gdGFyZ2V0IFRhcmdldCBET00gZWxlbWVudFxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyB0cnVlIGlmIHRoZSBlbGVtZW50IHJlcXVpcmVzIGEgY2FsbCB0byBmb2N1cyB0byBzaW11bGF0ZSBuYXRpdmUgY2xpY2suXG5cdCAqL1xuXHRGYXN0Q2xpY2sucHJvdG90eXBlLm5lZWRzRm9jdXMgPSBmdW5jdGlvbih0YXJnZXQpIHtcblx0XHRzd2l0Y2ggKHRhcmdldC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpKSB7XG5cdFx0Y2FzZSAndGV4dGFyZWEnOlxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0Y2FzZSAnc2VsZWN0Jzpcblx0XHRcdHJldHVybiAhZGV2aWNlSXNBbmRyb2lkO1xuXHRcdGNhc2UgJ2lucHV0Jzpcblx0XHRcdHN3aXRjaCAodGFyZ2V0LnR5cGUpIHtcblx0XHRcdGNhc2UgJ2J1dHRvbic6XG5cdFx0XHRjYXNlICdjaGVja2JveCc6XG5cdFx0XHRjYXNlICdmaWxlJzpcblx0XHRcdGNhc2UgJ2ltYWdlJzpcblx0XHRcdGNhc2UgJ3JhZGlvJzpcblx0XHRcdGNhc2UgJ3N1Ym1pdCc6XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gTm8gcG9pbnQgaW4gYXR0ZW1wdGluZyB0byBmb2N1cyBkaXNhYmxlZCBpbnB1dHNcblx0XHRcdHJldHVybiAhdGFyZ2V0LmRpc2FibGVkICYmICF0YXJnZXQucmVhZE9ubHk7XG5cdFx0ZGVmYXVsdDpcblx0XHRcdHJldHVybiAoL1xcYm5lZWRzZm9jdXNcXGIvKS50ZXN0KHRhcmdldC5jbGFzc05hbWUpO1xuXHRcdH1cblx0fTtcblxuXG5cdC8qKlxuXHQgKiBTZW5kIGEgY2xpY2sgZXZlbnQgdG8gdGhlIHNwZWNpZmllZCBlbGVtZW50LlxuXHQgKlxuXHQgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fEVsZW1lbnR9IHRhcmdldEVsZW1lbnRcblx0ICogQHBhcmFtIHtFdmVudH0gZXZlbnRcblx0ICovXG5cdEZhc3RDbGljay5wcm90b3R5cGUuc2VuZENsaWNrID0gZnVuY3Rpb24odGFyZ2V0RWxlbWVudCwgZXZlbnQpIHtcblx0XHR2YXIgY2xpY2tFdmVudCwgdG91Y2g7XG5cblx0XHQvLyBPbiBzb21lIEFuZHJvaWQgZGV2aWNlcyBhY3RpdmVFbGVtZW50IG5lZWRzIHRvIGJlIGJsdXJyZWQgb3RoZXJ3aXNlIHRoZSBzeW50aGV0aWMgY2xpY2sgd2lsbCBoYXZlIG5vIGVmZmVjdCAoIzI0KVxuXHRcdGlmIChkb2N1bWVudC5hY3RpdmVFbGVtZW50ICYmIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgIT09IHRhcmdldEVsZW1lbnQpIHtcblx0XHRcdGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQuYmx1cigpO1xuXHRcdH1cblxuXHRcdHRvdWNoID0gZXZlbnQuY2hhbmdlZFRvdWNoZXNbMF07XG5cblx0XHQvLyBTeW50aGVzaXNlIGEgY2xpY2sgZXZlbnQsIHdpdGggYW4gZXh0cmEgYXR0cmlidXRlIHNvIGl0IGNhbiBiZSB0cmFja2VkXG5cdFx0Y2xpY2tFdmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdNb3VzZUV2ZW50cycpO1xuXHRcdGNsaWNrRXZlbnQuaW5pdE1vdXNlRXZlbnQodGhpcy5kZXRlcm1pbmVFdmVudFR5cGUodGFyZ2V0RWxlbWVudCksIHRydWUsIHRydWUsIHdpbmRvdywgMSwgdG91Y2guc2NyZWVuWCwgdG91Y2guc2NyZWVuWSwgdG91Y2guY2xpZW50WCwgdG91Y2guY2xpZW50WSwgZmFsc2UsIGZhbHNlLCBmYWxzZSwgZmFsc2UsIDAsIG51bGwpO1xuXHRcdGNsaWNrRXZlbnQuZm9yd2FyZGVkVG91Y2hFdmVudCA9IHRydWU7XG5cdFx0dGFyZ2V0RWxlbWVudC5kaXNwYXRjaEV2ZW50KGNsaWNrRXZlbnQpO1xuXHR9O1xuXG5cdEZhc3RDbGljay5wcm90b3R5cGUuZGV0ZXJtaW5lRXZlbnRUeXBlID0gZnVuY3Rpb24odGFyZ2V0RWxlbWVudCkge1xuXG5cdFx0Ly9Jc3N1ZSAjMTU5OiBBbmRyb2lkIENocm9tZSBTZWxlY3QgQm94IGRvZXMgbm90IG9wZW4gd2l0aCBhIHN5bnRoZXRpYyBjbGljayBldmVudFxuXHRcdGlmIChkZXZpY2VJc0FuZHJvaWQgJiYgdGFyZ2V0RWxlbWVudC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdzZWxlY3QnKSB7XG5cdFx0XHRyZXR1cm4gJ21vdXNlZG93bic7XG5cdFx0fVxuXG5cdFx0cmV0dXJuICdjbGljayc7XG5cdH07XG5cblxuXHQvKipcblx0ICogQHBhcmFtIHtFdmVudFRhcmdldHxFbGVtZW50fSB0YXJnZXRFbGVtZW50XG5cdCAqL1xuXHRGYXN0Q2xpY2sucHJvdG90eXBlLmZvY3VzID0gZnVuY3Rpb24odGFyZ2V0RWxlbWVudCkge1xuXHRcdHZhciBsZW5ndGg7XG5cblx0XHQvLyBJc3N1ZSAjMTYwOiBvbiBpT1MgNywgc29tZSBpbnB1dCBlbGVtZW50cyAoZS5nLiBkYXRlIGRhdGV0aW1lIG1vbnRoKSB0aHJvdyBhIHZhZ3VlIFR5cGVFcnJvciBvbiBzZXRTZWxlY3Rpb25SYW5nZS4gVGhlc2UgZWxlbWVudHMgZG9uJ3QgaGF2ZSBhbiBpbnRlZ2VyIHZhbHVlIGZvciB0aGUgc2VsZWN0aW9uU3RhcnQgYW5kIHNlbGVjdGlvbkVuZCBwcm9wZXJ0aWVzLCBidXQgdW5mb3J0dW5hdGVseSB0aGF0IGNhbid0IGJlIHVzZWQgZm9yIGRldGVjdGlvbiBiZWNhdXNlIGFjY2Vzc2luZyB0aGUgcHJvcGVydGllcyBhbHNvIHRocm93cyBhIFR5cGVFcnJvci4gSnVzdCBjaGVjayB0aGUgdHlwZSBpbnN0ZWFkLiBGaWxlZCBhcyBBcHBsZSBidWcgIzE1MTIyNzI0LlxuXHRcdGlmIChkZXZpY2VJc0lPUyAmJiB0YXJnZXRFbGVtZW50LnNldFNlbGVjdGlvblJhbmdlICYmIHRhcmdldEVsZW1lbnQudHlwZS5pbmRleE9mKCdkYXRlJykgIT09IDAgJiYgdGFyZ2V0RWxlbWVudC50eXBlICE9PSAndGltZScgJiYgdGFyZ2V0RWxlbWVudC50eXBlICE9PSAnbW9udGgnICYmIHRhcmdldEVsZW1lbnQudHlwZSAhPT0gJ2VtYWlsJyAmJiB0YXJnZXRFbGVtZW50LnR5cGUgIT09ICdudW1iZXInKSB7XG5cdFx0XHRsZW5ndGggPSB0YXJnZXRFbGVtZW50LnZhbHVlLmxlbmd0aDtcblx0XHRcdHRhcmdldEVsZW1lbnQuc2V0U2VsZWN0aW9uUmFuZ2UobGVuZ3RoLCBsZW5ndGgpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0YXJnZXRFbGVtZW50LmZvY3VzKCk7XG5cdFx0fVxuXHR9O1xuXG5cblx0LyoqXG5cdCAqIENoZWNrIHdoZXRoZXIgdGhlIGdpdmVuIHRhcmdldCBlbGVtZW50IGlzIGEgY2hpbGQgb2YgYSBzY3JvbGxhYmxlIGxheWVyIGFuZCBpZiBzbywgc2V0IGEgZmxhZyBvbiBpdC5cblx0ICpcblx0ICogQHBhcmFtIHtFdmVudFRhcmdldHxFbGVtZW50fSB0YXJnZXRFbGVtZW50XG5cdCAqL1xuXHRGYXN0Q2xpY2sucHJvdG90eXBlLnVwZGF0ZVNjcm9sbFBhcmVudCA9IGZ1bmN0aW9uKHRhcmdldEVsZW1lbnQpIHtcblx0XHR2YXIgc2Nyb2xsUGFyZW50LCBwYXJlbnRFbGVtZW50O1xuXG5cdFx0c2Nyb2xsUGFyZW50ID0gdGFyZ2V0RWxlbWVudC5mYXN0Q2xpY2tTY3JvbGxQYXJlbnQ7XG5cblx0XHQvLyBBdHRlbXB0IHRvIGRpc2NvdmVyIHdoZXRoZXIgdGhlIHRhcmdldCBlbGVtZW50IGlzIGNvbnRhaW5lZCB3aXRoaW4gYSBzY3JvbGxhYmxlIGxheWVyLiBSZS1jaGVjayBpZiB0aGVcblx0XHQvLyB0YXJnZXQgZWxlbWVudCB3YXMgbW92ZWQgdG8gYW5vdGhlciBwYXJlbnQuXG5cdFx0aWYgKCFzY3JvbGxQYXJlbnQgfHwgIXNjcm9sbFBhcmVudC5jb250YWlucyh0YXJnZXRFbGVtZW50KSkge1xuXHRcdFx0cGFyZW50RWxlbWVudCA9IHRhcmdldEVsZW1lbnQ7XG5cdFx0XHRkbyB7XG5cdFx0XHRcdGlmIChwYXJlbnRFbGVtZW50LnNjcm9sbEhlaWdodCA+IHBhcmVudEVsZW1lbnQub2Zmc2V0SGVpZ2h0KSB7XG5cdFx0XHRcdFx0c2Nyb2xsUGFyZW50ID0gcGFyZW50RWxlbWVudDtcblx0XHRcdFx0XHR0YXJnZXRFbGVtZW50LmZhc3RDbGlja1Njcm9sbFBhcmVudCA9IHBhcmVudEVsZW1lbnQ7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRwYXJlbnRFbGVtZW50ID0gcGFyZW50RWxlbWVudC5wYXJlbnRFbGVtZW50O1xuXHRcdFx0fSB3aGlsZSAocGFyZW50RWxlbWVudCk7XG5cdFx0fVxuXG5cdFx0Ly8gQWx3YXlzIHVwZGF0ZSB0aGUgc2Nyb2xsIHRvcCB0cmFja2VyIGlmIHBvc3NpYmxlLlxuXHRcdGlmIChzY3JvbGxQYXJlbnQpIHtcblx0XHRcdHNjcm9sbFBhcmVudC5mYXN0Q2xpY2tMYXN0U2Nyb2xsVG9wID0gc2Nyb2xsUGFyZW50LnNjcm9sbFRvcDtcblx0XHR9XG5cdH07XG5cblxuXHQvKipcblx0ICogQHBhcmFtIHtFdmVudFRhcmdldH0gdGFyZ2V0RWxlbWVudFxuXHQgKiBAcmV0dXJucyB7RWxlbWVudHxFdmVudFRhcmdldH1cblx0ICovXG5cdEZhc3RDbGljay5wcm90b3R5cGUuZ2V0VGFyZ2V0RWxlbWVudEZyb21FdmVudFRhcmdldCA9IGZ1bmN0aW9uKGV2ZW50VGFyZ2V0KSB7XG5cblx0XHQvLyBPbiBzb21lIG9sZGVyIGJyb3dzZXJzIChub3RhYmx5IFNhZmFyaSBvbiBpT1MgNC4xIC0gc2VlIGlzc3VlICM1NikgdGhlIGV2ZW50IHRhcmdldCBtYXkgYmUgYSB0ZXh0IG5vZGUuXG5cdFx0aWYgKGV2ZW50VGFyZ2V0Lm5vZGVUeXBlID09PSBOb2RlLlRFWFRfTk9ERSkge1xuXHRcdFx0cmV0dXJuIGV2ZW50VGFyZ2V0LnBhcmVudE5vZGU7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGV2ZW50VGFyZ2V0O1xuXHR9O1xuXG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7RXZlbnRUYXJnZXR9IHRhcmdldEVsZW1lbnRcblx0ICogQHJldHVybnMge2Jvb2xlYW59XG5cdCAqL1xuXHRGYXN0Q2xpY2sucHJvdG90eXBlLmlzVGV4dEZpZWxkID0gZnVuY3Rpb24odGFyZ2V0RWxlbWVudCkge1xuXHRcdHJldHVybiAoXG5cdFx0XHR0YXJnZXRFbGVtZW50LnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ3RleHRhcmVhJ1xuXHRcdFx0fHwgdGV4dEZpZWxkcy5pbmRleE9mKHRhcmdldEVsZW1lbnQudHlwZSkgIT09IC0xXG5cdFx0KTtcblx0fTtcblxuXHQvKipcblx0ICogT24gdG91Y2ggc3RhcnQsIHJlY29yZCB0aGUgcG9zaXRpb24gYW5kIHNjcm9sbCBvZmZzZXQuXG5cdCAqXG5cdCAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG5cdCAqIEByZXR1cm5zIHtib29sZWFufVxuXHQgKi9cblx0RmFzdENsaWNrLnByb3RvdHlwZS5vblRvdWNoU3RhcnQgPSBmdW5jdGlvbihldmVudCkge1xuXHRcdHZhciB0YXJnZXRFbGVtZW50LCB0b3VjaCwgc2VsZWN0aW9uO1xuXG5cdFx0Ly8gSWdub3JlIG11bHRpcGxlIHRvdWNoZXMsIG90aGVyd2lzZSBwaW5jaC10by16b29tIGlzIHByZXZlbnRlZCBpZiBib3RoIGZpbmdlcnMgYXJlIG9uIHRoZSBGYXN0Q2xpY2sgZWxlbWVudCAoaXNzdWUgIzExMSkuXG5cdFx0aWYgKGV2ZW50LnRhcmdldFRvdWNoZXMubGVuZ3RoID4gMSkge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXG5cdFx0dGFyZ2V0RWxlbWVudCA9IHRoaXMuZ2V0VGFyZ2V0RWxlbWVudEZyb21FdmVudFRhcmdldChldmVudC50YXJnZXQpO1xuXHRcdHRvdWNoID0gZXZlbnQudGFyZ2V0VG91Y2hlc1swXTtcblxuXHRcdC8vIElnbm9yZSB0b3VjaGVzIG9uIGNvbnRlbnRlZGl0YWJsZSBlbGVtZW50cyB0byBwcmV2ZW50IGNvbmZsaWN0IHdpdGggdGV4dCBzZWxlY3Rpb24uXG5cdFx0Ly8gKEZvciBkZXRhaWxzOiBodHRwczovL2dpdGh1Yi5jb20vZnRsYWJzL2Zhc3RjbGljay9wdWxsLzIxMSApXG5cdFx0aWYgKHRhcmdldEVsZW1lbnQuaXNDb250ZW50RWRpdGFibGUpIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblxuXHRcdGlmIChkZXZpY2VJc0lPUykge1xuXHRcdFx0Ly8gSWdub3JlIHRvdWNoc3RhcnQgaW4gZm9jdXNlZCB0ZXh0IGZpZWxkXG5cdFx0XHQvLyBBbGxvd3Mgbm9ybWFsIHRleHQgc2VsZWN0aW9uIGFuZCBjb21tYW5kcyAoc2VsZWN0L3Bhc3RlL2N1dCkgd2hlbiBhIGZpZWxkIGhhcyBmb2N1cywgd2hpbGUgc3RpbGwgYWxsb3dpbmcgZmFzdCB0YXAtdG8tZm9jdXMuXG5cdFx0XHQvLyBXaXRob3V0IHRoaXMgZml4LCB1c2VyIG5lZWRzIHRvIHRhcC1hbmQtaG9sZCBhIHRleHQgZmllbGQgZm9yIGNvbnRleHQgbWVudSwgYW5kIGRvdWJsZS10YXAgdG8gc2VsZWN0IHRleHQgZG9lc24ndCB3b3JrIGF0IGFsbC5cblx0XHRcdGlmICh0YXJnZXRFbGVtZW50ID09PSBkb2N1bWVudC5hY3RpdmVFbGVtZW50ICYmIHRoaXMuaXNUZXh0RmllbGQodGFyZ2V0RWxlbWVudCkpIHtcblx0XHRcdCAgcmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cblx0XHRcdGlmICghZGV2aWNlSXNJT1M0KSB7XG5cblx0XHRcdFx0Ly8gV2VpcmQgdGhpbmdzIGhhcHBlbiBvbiBpT1Mgd2hlbiBhbiBhbGVydCBvciBjb25maXJtIGRpYWxvZyBpcyBvcGVuZWQgZnJvbSBhIGNsaWNrIGV2ZW50IGNhbGxiYWNrIChpc3N1ZSAjMjMpOlxuXHRcdFx0XHQvLyB3aGVuIHRoZSB1c2VyIG5leHQgdGFwcyBhbnl3aGVyZSBlbHNlIG9uIHRoZSBwYWdlLCBuZXcgdG91Y2hzdGFydCBhbmQgdG91Y2hlbmQgZXZlbnRzIGFyZSBkaXNwYXRjaGVkXG5cdFx0XHRcdC8vIHdpdGggdGhlIHNhbWUgaWRlbnRpZmllciBhcyB0aGUgdG91Y2ggZXZlbnQgdGhhdCBwcmV2aW91c2x5IHRyaWdnZXJlZCB0aGUgY2xpY2sgdGhhdCB0cmlnZ2VyZWQgdGhlIGFsZXJ0LlxuXHRcdFx0XHQvLyBTYWRseSwgdGhlcmUgaXMgYW4gaXNzdWUgb24gaU9TIDQgdGhhdCBjYXVzZXMgc29tZSBub3JtYWwgdG91Y2ggZXZlbnRzIHRvIGhhdmUgdGhlIHNhbWUgaWRlbnRpZmllciBhcyBhblxuXHRcdFx0XHQvLyBpbW1lZGlhdGVseSBwcmVjZWVkaW5nIHRvdWNoIGV2ZW50IChpc3N1ZSAjNTIpLCBzbyB0aGlzIGZpeCBpcyB1bmF2YWlsYWJsZSBvbiB0aGF0IHBsYXRmb3JtLlxuXHRcdFx0XHQvLyBJc3N1ZSAxMjA6IHRvdWNoLmlkZW50aWZpZXIgaXMgMCB3aGVuIENocm9tZSBkZXYgdG9vbHMgJ0VtdWxhdGUgdG91Y2ggZXZlbnRzJyBpcyBzZXQgd2l0aCBhbiBpT1MgZGV2aWNlIFVBIHN0cmluZyxcblx0XHRcdFx0Ly8gd2hpY2ggY2F1c2VzIGFsbCB0b3VjaCBldmVudHMgdG8gYmUgaWdub3JlZC4gQXMgdGhpcyBibG9jayBvbmx5IGFwcGxpZXMgdG8gaU9TLCBhbmQgaU9TIGlkZW50aWZpZXJzIGFyZSBhbHdheXMgbG9uZyxcblx0XHRcdFx0Ly8gcmFuZG9tIGludGVnZXJzLCBpdCdzIHNhZmUgdG8gdG8gY29udGludWUgaWYgdGhlIGlkZW50aWZpZXIgaXMgMCBoZXJlLlxuXHRcdFx0XHRpZiAodG91Y2guaWRlbnRpZmllciAmJiB0b3VjaC5pZGVudGlmaWVyID09PSB0aGlzLmxhc3RUb3VjaElkZW50aWZpZXIpIHtcblx0XHRcdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRoaXMubGFzdFRvdWNoSWRlbnRpZmllciA9IHRvdWNoLmlkZW50aWZpZXI7XG5cblx0XHRcdFx0Ly8gSWYgdGhlIHRhcmdldCBlbGVtZW50IGlzIGEgY2hpbGQgb2YgYSBzY3JvbGxhYmxlIGxheWVyICh1c2luZyAtd2Via2l0LW92ZXJmbG93LXNjcm9sbGluZzogdG91Y2gpIGFuZDpcblx0XHRcdFx0Ly8gMSkgdGhlIHVzZXIgZG9lcyBhIGZsaW5nIHNjcm9sbCBvbiB0aGUgc2Nyb2xsYWJsZSBsYXllclxuXHRcdFx0XHQvLyAyKSB0aGUgdXNlciBzdG9wcyB0aGUgZmxpbmcgc2Nyb2xsIHdpdGggYW5vdGhlciB0YXBcblx0XHRcdFx0Ly8gdGhlbiB0aGUgZXZlbnQudGFyZ2V0IG9mIHRoZSBsYXN0ICd0b3VjaGVuZCcgZXZlbnQgd2lsbCBiZSB0aGUgZWxlbWVudCB0aGF0IHdhcyB1bmRlciB0aGUgdXNlcidzIGZpbmdlclxuXHRcdFx0XHQvLyB3aGVuIHRoZSBmbGluZyBzY3JvbGwgd2FzIHN0YXJ0ZWQsIGNhdXNpbmcgRmFzdENsaWNrIHRvIHNlbmQgYSBjbGljayBldmVudCB0byB0aGF0IGxheWVyIC0gdW5sZXNzIGEgY2hlY2tcblx0XHRcdFx0Ly8gaXMgbWFkZSB0byBlbnN1cmUgdGhhdCBhIHBhcmVudCBsYXllciB3YXMgbm90IHNjcm9sbGVkIGJlZm9yZSBzZW5kaW5nIGEgc3ludGhldGljIGNsaWNrIChpc3N1ZSAjNDIpLlxuXHRcdFx0XHR0aGlzLnVwZGF0ZVNjcm9sbFBhcmVudCh0YXJnZXRFbGVtZW50KTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR0aGlzLnRyYWNraW5nQ2xpY2sgPSB0cnVlO1xuXHRcdHRoaXMudHJhY2tpbmdDbGlja1N0YXJ0ID0gZXZlbnQudGltZVN0YW1wO1xuXHRcdHRoaXMudGFyZ2V0RWxlbWVudCA9IHRhcmdldEVsZW1lbnQ7XG5cblx0XHR0aGlzLnRvdWNoU3RhcnRYID0gdG91Y2gucGFnZVg7XG5cdFx0dGhpcy50b3VjaFN0YXJ0WSA9IHRvdWNoLnBhZ2VZO1xuXG5cdFx0Ly8gUHJldmVudCBwaGFudG9tIGNsaWNrcyBvbiBmYXN0IGRvdWJsZS10YXAgKGlzc3VlICMzNilcblx0XHRpZiAoKGV2ZW50LnRpbWVTdGFtcCAtIHRoaXMubGFzdENsaWNrVGltZSkgPCB0aGlzLnRhcERlbGF5ICYmIChldmVudC50aW1lU3RhbXAgLSB0aGlzLmxhc3RDbGlja1RpbWUpID4gLTEpIHtcblx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRydWU7XG5cdH07XG5cblxuXHQvKipcblx0ICogQmFzZWQgb24gYSB0b3VjaG1vdmUgZXZlbnQgb2JqZWN0LCBjaGVjayB3aGV0aGVyIHRoZSB0b3VjaCBoYXMgbW92ZWQgcGFzdCBhIGJvdW5kYXJ5IHNpbmNlIGl0IHN0YXJ0ZWQuXG5cdCAqXG5cdCAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG5cdCAqIEByZXR1cm5zIHtib29sZWFufVxuXHQgKi9cblx0RmFzdENsaWNrLnByb3RvdHlwZS50b3VjaEhhc01vdmVkID0gZnVuY3Rpb24oZXZlbnQpIHtcblx0XHR2YXIgdG91Y2ggPSBldmVudC5jaGFuZ2VkVG91Y2hlc1swXSwgYm91bmRhcnkgPSB0aGlzLnRvdWNoQm91bmRhcnk7XG5cblx0XHRpZiAoTWF0aC5hYnModG91Y2gucGFnZVggLSB0aGlzLnRvdWNoU3RhcnRYKSA+IGJvdW5kYXJ5IHx8IE1hdGguYWJzKHRvdWNoLnBhZ2VZIC0gdGhpcy50b3VjaFN0YXJ0WSkgPiBib3VuZGFyeSkge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9O1xuXG5cblx0LyoqXG5cdCAqIFVwZGF0ZSB0aGUgbGFzdCBwb3NpdGlvbi5cblx0ICpcblx0ICogQHBhcmFtIHtFdmVudH0gZXZlbnRcblx0ICogQHJldHVybnMge2Jvb2xlYW59XG5cdCAqL1xuXHRGYXN0Q2xpY2sucHJvdG90eXBlLm9uVG91Y2hNb3ZlID0gZnVuY3Rpb24oZXZlbnQpIHtcblx0XHRpZiAoIXRoaXMudHJhY2tpbmdDbGljaykge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXG5cdFx0Ly8gSWYgdGhlIHRvdWNoIGhhcyBtb3ZlZCwgY2FuY2VsIHRoZSBjbGljayB0cmFja2luZ1xuXHRcdGlmICh0aGlzLnRhcmdldEVsZW1lbnQgIT09IHRoaXMuZ2V0VGFyZ2V0RWxlbWVudEZyb21FdmVudFRhcmdldChldmVudC50YXJnZXQpIHx8IHRoaXMudG91Y2hIYXNNb3ZlZChldmVudCkpIHtcblx0XHRcdHRoaXMudHJhY2tpbmdDbGljayA9IGZhbHNlO1xuXHRcdFx0dGhpcy50YXJnZXRFbGVtZW50ID0gbnVsbDtcblx0XHR9XG5cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fTtcblxuXG5cdC8qKlxuXHQgKiBBdHRlbXB0IHRvIGZpbmQgdGhlIGxhYmVsbGVkIGNvbnRyb2wgZm9yIHRoZSBnaXZlbiBsYWJlbCBlbGVtZW50LlxuXHQgKlxuXHQgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fEhUTUxMYWJlbEVsZW1lbnR9IGxhYmVsRWxlbWVudFxuXHQgKiBAcmV0dXJucyB7RWxlbWVudHxudWxsfVxuXHQgKi9cblx0RmFzdENsaWNrLnByb3RvdHlwZS5maW5kQ29udHJvbCA9IGZ1bmN0aW9uKGxhYmVsRWxlbWVudCkge1xuXG5cdFx0Ly8gRmFzdCBwYXRoIGZvciBuZXdlciBicm93c2VycyBzdXBwb3J0aW5nIHRoZSBIVE1MNSBjb250cm9sIGF0dHJpYnV0ZVxuXHRcdGlmIChsYWJlbEVsZW1lbnQuY29udHJvbCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRyZXR1cm4gbGFiZWxFbGVtZW50LmNvbnRyb2w7XG5cdFx0fVxuXG5cdFx0Ly8gQWxsIGJyb3dzZXJzIHVuZGVyIHRlc3QgdGhhdCBzdXBwb3J0IHRvdWNoIGV2ZW50cyBhbHNvIHN1cHBvcnQgdGhlIEhUTUw1IGh0bWxGb3IgYXR0cmlidXRlXG5cdFx0aWYgKGxhYmVsRWxlbWVudC5odG1sRm9yKSB7XG5cdFx0XHRyZXR1cm4gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQobGFiZWxFbGVtZW50Lmh0bWxGb3IpO1xuXHRcdH1cblxuXHRcdC8vIElmIG5vIGZvciBhdHRyaWJ1dGUgZXhpc3RzLCBhdHRlbXB0IHRvIHJldHJpZXZlIHRoZSBmaXJzdCBsYWJlbGxhYmxlIGRlc2NlbmRhbnQgZWxlbWVudFxuXHRcdC8vIHRoZSBsaXN0IG9mIHdoaWNoIGlzIGRlZmluZWQgaGVyZTogaHR0cDovL3d3dy53My5vcmcvVFIvaHRtbDUvZm9ybXMuaHRtbCNjYXRlZ29yeS1sYWJlbFxuXHRcdHJldHVybiBsYWJlbEVsZW1lbnQucXVlcnlTZWxlY3RvcignYnV0dG9uLCBpbnB1dDpub3QoW3R5cGU9aGlkZGVuXSksIGtleWdlbiwgbWV0ZXIsIG91dHB1dCwgcHJvZ3Jlc3MsIHNlbGVjdCwgdGV4dGFyZWEnKTtcblx0fTtcblxuXG5cdC8qKlxuXHQgKiBPbiB0b3VjaCBlbmQsIGRldGVybWluZSB3aGV0aGVyIHRvIHNlbmQgYSBjbGljayBldmVudCBhdCBvbmNlLlxuXHQgKlxuXHQgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn1cblx0ICovXG5cdEZhc3RDbGljay5wcm90b3R5cGUub25Ub3VjaEVuZCA9IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0dmFyIGZvckVsZW1lbnQsIHRyYWNraW5nQ2xpY2tTdGFydCwgdGFyZ2V0VGFnTmFtZSwgc2Nyb2xsUGFyZW50LCB0b3VjaCwgdGFyZ2V0RWxlbWVudCA9IHRoaXMudGFyZ2V0RWxlbWVudDtcblxuXHRcdGlmICghdGhpcy50cmFja2luZ0NsaWNrKSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cblx0XHQvLyBQcmV2ZW50IHBoYW50b20gY2xpY2tzIG9uIGZhc3QgZG91YmxlLXRhcCAoaXNzdWUgIzM2KVxuXHRcdGlmICgoZXZlbnQudGltZVN0YW1wIC0gdGhpcy5sYXN0Q2xpY2tUaW1lKSA8IHRoaXMudGFwRGVsYXkgJiYgKGV2ZW50LnRpbWVTdGFtcCAtIHRoaXMubGFzdENsaWNrVGltZSkgPiAtMSkge1xuXHRcdFx0dGhpcy5jYW5jZWxOZXh0Q2xpY2sgPSB0cnVlO1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXG5cdFx0aWYgKChldmVudC50aW1lU3RhbXAgLSB0aGlzLnRyYWNraW5nQ2xpY2tTdGFydCkgPiB0aGlzLnRhcFRpbWVvdXQpIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblxuXHRcdC8vIFJlc2V0IHRvIHByZXZlbnQgd3JvbmcgY2xpY2sgY2FuY2VsIG9uIGlucHV0IChpc3N1ZSAjMTU2KS5cblx0XHR0aGlzLmNhbmNlbE5leHRDbGljayA9IGZhbHNlO1xuXG5cdFx0dGhpcy5sYXN0Q2xpY2tUaW1lID0gZXZlbnQudGltZVN0YW1wO1xuXG5cdFx0dHJhY2tpbmdDbGlja1N0YXJ0ID0gdGhpcy50cmFja2luZ0NsaWNrU3RhcnQ7XG5cdFx0dGhpcy50cmFja2luZ0NsaWNrID0gZmFsc2U7XG5cdFx0dGhpcy50cmFja2luZ0NsaWNrU3RhcnQgPSAwO1xuXG5cdFx0Ly8gT24gc29tZSBpT1MgZGV2aWNlcywgdGhlIHRhcmdldEVsZW1lbnQgc3VwcGxpZWQgd2l0aCB0aGUgZXZlbnQgaXMgaW52YWxpZCBpZiB0aGUgbGF5ZXJcblx0XHQvLyBpcyBwZXJmb3JtaW5nIGEgdHJhbnNpdGlvbiBvciBzY3JvbGwsIGFuZCBoYXMgdG8gYmUgcmUtZGV0ZWN0ZWQgbWFudWFsbHkuIE5vdGUgdGhhdFxuXHRcdC8vIGZvciB0aGlzIHRvIGZ1bmN0aW9uIGNvcnJlY3RseSwgaXQgbXVzdCBiZSBjYWxsZWQgKmFmdGVyKiB0aGUgZXZlbnQgdGFyZ2V0IGlzIGNoZWNrZWQhXG5cdFx0Ly8gU2VlIGlzc3VlICM1NzsgYWxzbyBmaWxlZCBhcyByZGFyOi8vMTMwNDg1ODkgLlxuXHRcdGlmIChkZXZpY2VJc0lPU1dpdGhCYWRUYXJnZXQpIHtcblx0XHRcdHRvdWNoID0gZXZlbnQuY2hhbmdlZFRvdWNoZXNbMF07XG5cblx0XHRcdC8vIEluIGNlcnRhaW4gY2FzZXMgYXJndW1lbnRzIG9mIGVsZW1lbnRGcm9tUG9pbnQgY2FuIGJlIG5lZ2F0aXZlLCBzbyBwcmV2ZW50IHNldHRpbmcgdGFyZ2V0RWxlbWVudCB0byBudWxsXG5cdFx0XHR0YXJnZXRFbGVtZW50ID0gZG9jdW1lbnQuZWxlbWVudEZyb21Qb2ludCh0b3VjaC5wYWdlWCAtIHdpbmRvdy5wYWdlWE9mZnNldCwgdG91Y2gucGFnZVkgLSB3aW5kb3cucGFnZVlPZmZzZXQpIHx8IHRhcmdldEVsZW1lbnQ7XG5cdFx0XHR0YXJnZXRFbGVtZW50LmZhc3RDbGlja1Njcm9sbFBhcmVudCA9IHRoaXMudGFyZ2V0RWxlbWVudC5mYXN0Q2xpY2tTY3JvbGxQYXJlbnQ7XG5cdFx0fVxuXG5cdFx0dGFyZ2V0VGFnTmFtZSA9IHRhcmdldEVsZW1lbnQudGFnTmFtZS50b0xvd2VyQ2FzZSgpO1xuXHRcdGlmICh0YXJnZXRUYWdOYW1lID09PSAnbGFiZWwnKSB7XG5cdFx0XHRmb3JFbGVtZW50ID0gdGhpcy5maW5kQ29udHJvbCh0YXJnZXRFbGVtZW50KTtcblx0XHRcdGlmIChmb3JFbGVtZW50KSB7XG5cdFx0XHRcdHRoaXMuZm9jdXModGFyZ2V0RWxlbWVudCk7XG5cdFx0XHRcdGlmIChkZXZpY2VJc0FuZHJvaWQpIHtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0YXJnZXRFbGVtZW50ID0gZm9yRWxlbWVudDtcblx0XHRcdH1cblx0XHR9IGVsc2UgaWYgKHRoaXMubmVlZHNGb2N1cyh0YXJnZXRFbGVtZW50KSkge1xuXG5cdFx0XHQvLyBDYXNlIDE6IElmIHRoZSB0b3VjaCBzdGFydGVkIGEgd2hpbGUgYWdvIChiZXN0IGd1ZXNzIGlzIDEwMG1zIGJhc2VkIG9uIHRlc3RzIGZvciBpc3N1ZSAjMzYpIHRoZW4gZm9jdXMgd2lsbCBiZSB0cmlnZ2VyZWQgYW55d2F5LiBSZXR1cm4gZWFybHkgYW5kIHVuc2V0IHRoZSB0YXJnZXQgZWxlbWVudCByZWZlcmVuY2Ugc28gdGhhdCB0aGUgc3Vic2VxdWVudCBjbGljayB3aWxsIGJlIGFsbG93ZWQgdGhyb3VnaC5cblx0XHRcdC8vIENhc2UgMjogV2l0aG91dCB0aGlzIGV4Y2VwdGlvbiBmb3IgaW5wdXQgZWxlbWVudHMgdGFwcGVkIHdoZW4gdGhlIGRvY3VtZW50IGlzIGNvbnRhaW5lZCBpbiBhbiBpZnJhbWUsIHRoZW4gYW55IGlucHV0dGVkIHRleHQgd29uJ3QgYmUgdmlzaWJsZSBldmVuIHRob3VnaCB0aGUgdmFsdWUgYXR0cmlidXRlIGlzIHVwZGF0ZWQgYXMgdGhlIHVzZXIgdHlwZXMgKGlzc3VlICMzNykuXG5cdFx0XHRpZiAoKGV2ZW50LnRpbWVTdGFtcCAtIHRyYWNraW5nQ2xpY2tTdGFydCkgPiAxMDAgfHwgKGRldmljZUlzSU9TICYmIHdpbmRvdy50b3AgIT09IHdpbmRvdyAmJiB0YXJnZXRUYWdOYW1lID09PSAnaW5wdXQnKSkge1xuXHRcdFx0XHR0aGlzLnRhcmdldEVsZW1lbnQgPSBudWxsO1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuZm9jdXModGFyZ2V0RWxlbWVudCk7XG5cdFx0XHR0aGlzLnNlbmRDbGljayh0YXJnZXRFbGVtZW50LCBldmVudCk7XG5cblx0XHRcdC8vIFNlbGVjdCBlbGVtZW50cyBuZWVkIHRoZSBldmVudCB0byBnbyB0aHJvdWdoIG9uIGlPUyA0LCBvdGhlcndpc2UgdGhlIHNlbGVjdG9yIG1lbnUgd29uJ3Qgb3Blbi5cblx0XHRcdC8vIEFsc28gdGhpcyBicmVha3Mgb3BlbmluZyBzZWxlY3RzIHdoZW4gVm9pY2VPdmVyIGlzIGFjdGl2ZSBvbiBpT1M2LCBpT1M3IChhbmQgcG9zc2libHkgb3RoZXJzKVxuXHRcdFx0aWYgKCFkZXZpY2VJc0lPUzQgfHwgdGFyZ2V0VGFnTmFtZSAhPT0gJ3NlbGVjdCcpIHtcblx0XHRcdFx0dGhpcy50YXJnZXRFbGVtZW50ID0gbnVsbDtcblx0XHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdGlmIChkZXZpY2VJc0lPUyAmJiAhZGV2aWNlSXNJT1M0KSB7XG5cblx0XHRcdC8vIERvbid0IHNlbmQgYSBzeW50aGV0aWMgY2xpY2sgZXZlbnQgaWYgdGhlIHRhcmdldCBlbGVtZW50IGlzIGNvbnRhaW5lZCB3aXRoaW4gYSBwYXJlbnQgbGF5ZXIgdGhhdCB3YXMgc2Nyb2xsZWRcblx0XHRcdC8vIGFuZCB0aGlzIHRhcCBpcyBiZWluZyB1c2VkIHRvIHN0b3AgdGhlIHNjcm9sbGluZyAodXN1YWxseSBpbml0aWF0ZWQgYnkgYSBmbGluZyAtIGlzc3VlICM0MikuXG5cdFx0XHRzY3JvbGxQYXJlbnQgPSB0YXJnZXRFbGVtZW50LmZhc3RDbGlja1Njcm9sbFBhcmVudDtcblx0XHRcdGlmIChzY3JvbGxQYXJlbnQgJiYgc2Nyb2xsUGFyZW50LmZhc3RDbGlja0xhc3RTY3JvbGxUb3AgIT09IHNjcm9sbFBhcmVudC5zY3JvbGxUb3ApIHtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gUHJldmVudCB0aGUgYWN0dWFsIGNsaWNrIGZyb20gZ29pbmcgdGhvdWdoIC0gdW5sZXNzIHRoZSB0YXJnZXQgbm9kZSBpcyBtYXJrZWQgYXMgcmVxdWlyaW5nXG5cdFx0Ly8gcmVhbCBjbGlja3Mgb3IgaWYgaXQgaXMgaW4gdGhlIHdoaXRlbGlzdCBpbiB3aGljaCBjYXNlIG9ubHkgbm9uLXByb2dyYW1tYXRpYyBjbGlja3MgYXJlIHBlcm1pdHRlZC5cblx0XHRpZiAoIXRoaXMubmVlZHNDbGljayh0YXJnZXRFbGVtZW50KSkge1xuXHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRcdHRoaXMuc2VuZENsaWNrKHRhcmdldEVsZW1lbnQsIGV2ZW50KTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH07XG5cblxuXHQvKipcblx0ICogT24gdG91Y2ggY2FuY2VsLCBzdG9wIHRyYWNraW5nIHRoZSBjbGljay5cblx0ICpcblx0ICogQHJldHVybnMge3ZvaWR9XG5cdCAqL1xuXHRGYXN0Q2xpY2sucHJvdG90eXBlLm9uVG91Y2hDYW5jZWwgPSBmdW5jdGlvbigpIHtcblx0XHR0aGlzLnRyYWNraW5nQ2xpY2sgPSBmYWxzZTtcblx0XHR0aGlzLnRhcmdldEVsZW1lbnQgPSBudWxsO1xuXHR9O1xuXG5cblx0LyoqXG5cdCAqIERldGVybWluZSBtb3VzZSBldmVudHMgd2hpY2ggc2hvdWxkIGJlIHBlcm1pdHRlZC5cblx0ICpcblx0ICogQHBhcmFtIHtFdmVudH0gZXZlbnRcblx0ICogQHJldHVybnMge2Jvb2xlYW59XG5cdCAqL1xuXHRGYXN0Q2xpY2sucHJvdG90eXBlLm9uTW91c2UgPSBmdW5jdGlvbihldmVudCkge1xuXG5cdFx0Ly8gSWYgYSB0YXJnZXQgZWxlbWVudCB3YXMgbmV2ZXIgc2V0IChiZWNhdXNlIGEgdG91Y2ggZXZlbnQgd2FzIG5ldmVyIGZpcmVkKSBhbGxvdyB0aGUgZXZlbnRcblx0XHRpZiAoIXRoaXMudGFyZ2V0RWxlbWVudCkge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXG5cdFx0aWYgKGV2ZW50LmZvcndhcmRlZFRvdWNoRXZlbnQpIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblxuXHRcdC8vIFByb2dyYW1tYXRpY2FsbHkgZ2VuZXJhdGVkIGV2ZW50cyB0YXJnZXRpbmcgYSBzcGVjaWZpYyBlbGVtZW50IHNob3VsZCBiZSBwZXJtaXR0ZWRcblx0XHRpZiAoIWV2ZW50LmNhbmNlbGFibGUpIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblxuXHRcdC8vIERlcml2ZSBhbmQgY2hlY2sgdGhlIHRhcmdldCBlbGVtZW50IHRvIHNlZSB3aGV0aGVyIHRoZSBtb3VzZSBldmVudCBuZWVkcyB0byBiZSBwZXJtaXR0ZWQ7XG5cdFx0Ly8gdW5sZXNzIGV4cGxpY2l0bHkgZW5hYmxlZCwgcHJldmVudCBub24tdG91Y2ggY2xpY2sgZXZlbnRzIGZyb20gdHJpZ2dlcmluZyBhY3Rpb25zLFxuXHRcdC8vIHRvIHByZXZlbnQgZ2hvc3QvZG91YmxlY2xpY2tzLlxuXHRcdGlmICghdGhpcy5uZWVkc0NsaWNrKHRoaXMudGFyZ2V0RWxlbWVudCkgfHwgdGhpcy5jYW5jZWxOZXh0Q2xpY2spIHtcblxuXHRcdFx0Ly8gUHJldmVudCBhbnkgdXNlci1hZGRlZCBsaXN0ZW5lcnMgZGVjbGFyZWQgb24gRmFzdENsaWNrIGVsZW1lbnQgZnJvbSBiZWluZyBmaXJlZC5cblx0XHRcdGlmIChldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24pIHtcblx0XHRcdFx0ZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdC8vIFBhcnQgb2YgdGhlIGhhY2sgZm9yIGJyb3dzZXJzIHRoYXQgZG9uJ3Qgc3VwcG9ydCBFdmVudCNzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24gKGUuZy4gQW5kcm9pZCAyKVxuXHRcdFx0XHRldmVudC5wcm9wYWdhdGlvblN0b3BwZWQgPSB0cnVlO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDYW5jZWwgdGhlIGV2ZW50XG5cdFx0XHRldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBJZiB0aGUgbW91c2UgZXZlbnQgaXMgcGVybWl0dGVkLCByZXR1cm4gdHJ1ZSBmb3IgdGhlIGFjdGlvbiB0byBnbyB0aHJvdWdoLlxuXHRcdHJldHVybiB0cnVlO1xuXHR9O1xuXG5cblx0LyoqXG5cdCAqIE9uIGFjdHVhbCBjbGlja3MsIGRldGVybWluZSB3aGV0aGVyIHRoaXMgaXMgYSB0b3VjaC1nZW5lcmF0ZWQgY2xpY2ssIGEgY2xpY2sgYWN0aW9uIG9jY3VycmluZ1xuXHQgKiBuYXR1cmFsbHkgYWZ0ZXIgYSBkZWxheSBhZnRlciBhIHRvdWNoICh3aGljaCBuZWVkcyB0byBiZSBjYW5jZWxsZWQgdG8gYXZvaWQgZHVwbGljYXRpb24pLCBvclxuXHQgKiBhbiBhY3R1YWwgY2xpY2sgd2hpY2ggc2hvdWxkIGJlIHBlcm1pdHRlZC5cblx0ICpcblx0ICogQHBhcmFtIHtFdmVudH0gZXZlbnRcblx0ICogQHJldHVybnMge2Jvb2xlYW59XG5cdCAqL1xuXHRGYXN0Q2xpY2sucHJvdG90eXBlLm9uQ2xpY2sgPSBmdW5jdGlvbihldmVudCkge1xuXHRcdHZhciBwZXJtaXR0ZWQ7XG5cblx0XHQvLyBJdCdzIHBvc3NpYmxlIGZvciBhbm90aGVyIEZhc3RDbGljay1saWtlIGxpYnJhcnkgZGVsaXZlcmVkIHdpdGggdGhpcmQtcGFydHkgY29kZSB0byBmaXJlIGEgY2xpY2sgZXZlbnQgYmVmb3JlIEZhc3RDbGljayBkb2VzIChpc3N1ZSAjNDQpLiBJbiB0aGF0IGNhc2UsIHNldCB0aGUgY2xpY2stdHJhY2tpbmcgZmxhZyBiYWNrIHRvIGZhbHNlIGFuZCByZXR1cm4gZWFybHkuIFRoaXMgd2lsbCBjYXVzZSBvblRvdWNoRW5kIHRvIHJldHVybiBlYXJseS5cblx0XHRpZiAodGhpcy50cmFja2luZ0NsaWNrKSB7XG5cdFx0XHR0aGlzLnRhcmdldEVsZW1lbnQgPSBudWxsO1xuXHRcdFx0dGhpcy50cmFja2luZ0NsaWNrID0gZmFsc2U7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cblx0XHQvLyBWZXJ5IG9kZCBiZWhhdmlvdXIgb24gaU9TIChpc3N1ZSAjMTgpOiBpZiBhIHN1Ym1pdCBlbGVtZW50IGlzIHByZXNlbnQgaW5zaWRlIGEgZm9ybSBhbmQgdGhlIHVzZXIgaGl0cyBlbnRlciBpbiB0aGUgaU9TIHNpbXVsYXRvciBvciBjbGlja3MgdGhlIEdvIGJ1dHRvbiBvbiB0aGUgcG9wLXVwIE9TIGtleWJvYXJkIHRoZSBhIGtpbmQgb2YgJ2Zha2UnIGNsaWNrIGV2ZW50IHdpbGwgYmUgdHJpZ2dlcmVkIHdpdGggdGhlIHN1Ym1pdC10eXBlIGlucHV0IGVsZW1lbnQgYXMgdGhlIHRhcmdldC5cblx0XHRpZiAoZXZlbnQudGFyZ2V0LnR5cGUgPT09ICdzdWJtaXQnICYmIGV2ZW50LmRldGFpbCA9PT0gMCkge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXG5cdFx0cGVybWl0dGVkID0gdGhpcy5vbk1vdXNlKGV2ZW50KTtcblxuXHRcdC8vIE9ubHkgdW5zZXQgdGFyZ2V0RWxlbWVudCBpZiB0aGUgY2xpY2sgaXMgbm90IHBlcm1pdHRlZC4gVGhpcyB3aWxsIGVuc3VyZSB0aGF0IHRoZSBjaGVjayBmb3IgIXRhcmdldEVsZW1lbnQgaW4gb25Nb3VzZSBmYWlscyBhbmQgdGhlIGJyb3dzZXIncyBjbGljayBkb2Vzbid0IGdvIHRocm91Z2guXG5cdFx0aWYgKCFwZXJtaXR0ZWQpIHtcblx0XHRcdHRoaXMudGFyZ2V0RWxlbWVudCA9IG51bGw7XG5cdFx0fVxuXG5cdFx0Ly8gSWYgY2xpY2tzIGFyZSBwZXJtaXR0ZWQsIHJldHVybiB0cnVlIGZvciB0aGUgYWN0aW9uIHRvIGdvIHRocm91Z2guXG5cdFx0cmV0dXJuIHBlcm1pdHRlZDtcblx0fTtcblxuXG5cdC8qKlxuXHQgKiBSZW1vdmUgYWxsIEZhc3RDbGljaydzIGV2ZW50IGxpc3RlbmVycy5cblx0ICpcblx0ICogQHJldHVybnMge3ZvaWR9XG5cdCAqL1xuXHRGYXN0Q2xpY2sucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcblx0XHR2YXIgbGF5ZXIgPSB0aGlzLmxheWVyO1xuXG5cdFx0aWYgKGRldmljZUlzQW5kcm9pZCkge1xuXHRcdFx0bGF5ZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2VvdmVyJywgdGhpcy5vbk1vdXNlLCB0cnVlKTtcblx0XHRcdGxheWVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMub25Nb3VzZSwgdHJ1ZSk7XG5cdFx0XHRsYXllci5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcy5vbk1vdXNlLCB0cnVlKTtcblx0XHR9XG5cblx0XHRsYXllci5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMub25DbGljaywgdHJ1ZSk7XG5cdFx0bGF5ZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIHRoaXMub25Ub3VjaFN0YXJ0LCBmYWxzZSk7XG5cdFx0bGF5ZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgdGhpcy5vblRvdWNoTW92ZSwgZmFsc2UpO1xuXHRcdGxheWVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgdGhpcy5vblRvdWNoRW5kLCBmYWxzZSk7XG5cdFx0bGF5ZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hjYW5jZWwnLCB0aGlzLm9uVG91Y2hDYW5jZWwsIGZhbHNlKTtcblx0fTtcblxuXG5cdC8qKlxuXHQgKiBDaGVjayB3aGV0aGVyIEZhc3RDbGljayBpcyBuZWVkZWQuXG5cdCAqXG5cdCAqIEBwYXJhbSB7RWxlbWVudH0gbGF5ZXIgVGhlIGxheWVyIHRvIGxpc3RlbiBvblxuXHQgKi9cblx0RmFzdENsaWNrLm5vdE5lZWRlZCA9IGZ1bmN0aW9uKGxheWVyKSB7XG5cdFx0dmFyIG1ldGFWaWV3cG9ydDtcblx0XHR2YXIgY2hyb21lVmVyc2lvbjtcblx0XHR2YXIgYmxhY2tiZXJyeVZlcnNpb247XG5cdFx0dmFyIGZpcmVmb3hWZXJzaW9uO1xuXG5cdFx0Ly8gRGV2aWNlcyB0aGF0IGRvbid0IHN1cHBvcnQgdG91Y2ggZG9uJ3QgbmVlZCBGYXN0Q2xpY2tcblx0XHRpZiAodHlwZW9mIHdpbmRvdy5vbnRvdWNoc3RhcnQgPT09ICd1bmRlZmluZWQnKSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cblx0XHQvLyBDaHJvbWUgdmVyc2lvbiAtIHplcm8gZm9yIG90aGVyIGJyb3dzZXJzXG5cdFx0Y2hyb21lVmVyc2lvbiA9ICsoL0Nocm9tZVxcLyhbMC05XSspLy5leGVjKG5hdmlnYXRvci51c2VyQWdlbnQpIHx8IFssMF0pWzFdO1xuXG5cdFx0aWYgKGNocm9tZVZlcnNpb24pIHtcblxuXHRcdFx0aWYgKGRldmljZUlzQW5kcm9pZCkge1xuXHRcdFx0XHRtZXRhVmlld3BvcnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdtZXRhW25hbWU9dmlld3BvcnRdJyk7XG5cblx0XHRcdFx0aWYgKG1ldGFWaWV3cG9ydCkge1xuXHRcdFx0XHRcdC8vIENocm9tZSBvbiBBbmRyb2lkIHdpdGggdXNlci1zY2FsYWJsZT1cIm5vXCIgZG9lc24ndCBuZWVkIEZhc3RDbGljayAoaXNzdWUgIzg5KVxuXHRcdFx0XHRcdGlmIChtZXRhVmlld3BvcnQuY29udGVudC5pbmRleE9mKCd1c2VyLXNjYWxhYmxlPW5vJykgIT09IC0xKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Ly8gQ2hyb21lIDMyIGFuZCBhYm92ZSB3aXRoIHdpZHRoPWRldmljZS13aWR0aCBvciBsZXNzIGRvbid0IG5lZWQgRmFzdENsaWNrXG5cdFx0XHRcdFx0aWYgKGNocm9tZVZlcnNpb24gPiAzMSAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsV2lkdGggPD0gd2luZG93Lm91dGVyV2lkdGgpIHtcblx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHQvLyBDaHJvbWUgZGVza3RvcCBkb2Vzbid0IG5lZWQgRmFzdENsaWNrIChpc3N1ZSAjMTUpXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoZGV2aWNlSXNCbGFja0JlcnJ5MTApIHtcblx0XHRcdGJsYWNrYmVycnlWZXJzaW9uID0gbmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaCgvVmVyc2lvblxcLyhbMC05XSopXFwuKFswLTldKikvKTtcblxuXHRcdFx0Ly8gQmxhY2tCZXJyeSAxMC4zKyBkb2VzIG5vdCByZXF1aXJlIEZhc3RjbGljayBsaWJyYXJ5LlxuXHRcdFx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL2Z0bGFicy9mYXN0Y2xpY2svaXNzdWVzLzI1MVxuXHRcdFx0aWYgKGJsYWNrYmVycnlWZXJzaW9uWzFdID49IDEwICYmIGJsYWNrYmVycnlWZXJzaW9uWzJdID49IDMpIHtcblx0XHRcdFx0bWV0YVZpZXdwb3J0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignbWV0YVtuYW1lPXZpZXdwb3J0XScpO1xuXG5cdFx0XHRcdGlmIChtZXRhVmlld3BvcnQpIHtcblx0XHRcdFx0XHQvLyB1c2VyLXNjYWxhYmxlPW5vIGVsaW1pbmF0ZXMgY2xpY2sgZGVsYXkuXG5cdFx0XHRcdFx0aWYgKG1ldGFWaWV3cG9ydC5jb250ZW50LmluZGV4T2YoJ3VzZXItc2NhbGFibGU9bm8nKSAhPT0gLTEpIHtcblx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHQvLyB3aWR0aD1kZXZpY2Utd2lkdGggKG9yIGxlc3MgdGhhbiBkZXZpY2Utd2lkdGgpIGVsaW1pbmF0ZXMgY2xpY2sgZGVsYXkuXG5cdFx0XHRcdFx0aWYgKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxXaWR0aCA8PSB3aW5kb3cub3V0ZXJXaWR0aCkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gSUUxMCB3aXRoIC1tcy10b3VjaC1hY3Rpb246IG5vbmUgb3IgbWFuaXB1bGF0aW9uLCB3aGljaCBkaXNhYmxlcyBkb3VibGUtdGFwLXRvLXpvb20gKGlzc3VlICM5Nylcblx0XHRpZiAobGF5ZXIuc3R5bGUubXNUb3VjaEFjdGlvbiA9PT0gJ25vbmUnIHx8IGxheWVyLnN0eWxlLnRvdWNoQWN0aW9uID09PSAnbWFuaXB1bGF0aW9uJykge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXG5cdFx0Ly8gRmlyZWZveCB2ZXJzaW9uIC0gemVybyBmb3Igb3RoZXIgYnJvd3NlcnNcblx0XHRmaXJlZm94VmVyc2lvbiA9ICsoL0ZpcmVmb3hcXC8oWzAtOV0rKS8uZXhlYyhuYXZpZ2F0b3IudXNlckFnZW50KSB8fCBbLDBdKVsxXTtcblxuXHRcdGlmIChmaXJlZm94VmVyc2lvbiA+PSAyNykge1xuXHRcdFx0Ly8gRmlyZWZveCAyNysgZG9lcyBub3QgaGF2ZSB0YXAgZGVsYXkgaWYgdGhlIGNvbnRlbnQgaXMgbm90IHpvb21hYmxlIC0gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9OTIyODk2XG5cblx0XHRcdG1ldGFWaWV3cG9ydCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ21ldGFbbmFtZT12aWV3cG9ydF0nKTtcblx0XHRcdGlmIChtZXRhVmlld3BvcnQgJiYgKG1ldGFWaWV3cG9ydC5jb250ZW50LmluZGV4T2YoJ3VzZXItc2NhbGFibGU9bm8nKSAhPT0gLTEgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFdpZHRoIDw9IHdpbmRvdy5vdXRlcldpZHRoKSkge1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBJRTExOiBwcmVmaXhlZCAtbXMtdG91Y2gtYWN0aW9uIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQgYW5kIGl0J3MgcmVjb21lbmRlZCB0byB1c2Ugbm9uLXByZWZpeGVkIHZlcnNpb25cblx0XHQvLyBodHRwOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvd2luZG93cy9hcHBzL0hoNzY3MzEzLmFzcHhcblx0XHRpZiAobGF5ZXIuc3R5bGUudG91Y2hBY3Rpb24gPT09ICdub25lJyB8fCBsYXllci5zdHlsZS50b3VjaEFjdGlvbiA9PT0gJ21hbmlwdWxhdGlvbicpIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblxuXHRcdHJldHVybiBmYWxzZTtcblx0fTtcblxuXG5cdC8qKlxuXHQgKiBGYWN0b3J5IG1ldGhvZCBmb3IgY3JlYXRpbmcgYSBGYXN0Q2xpY2sgb2JqZWN0XG5cdCAqXG5cdCAqIEBwYXJhbSB7RWxlbWVudH0gbGF5ZXIgVGhlIGxheWVyIHRvIGxpc3RlbiBvblxuXHQgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIFRoZSBvcHRpb25zIHRvIG92ZXJyaWRlIHRoZSBkZWZhdWx0c1xuXHQgKi9cblx0RmFzdENsaWNrLmF0dGFjaCA9IGZ1bmN0aW9uKGxheWVyLCBvcHRpb25zKSB7XG5cdFx0cmV0dXJuIG5ldyBGYXN0Q2xpY2sobGF5ZXIsIG9wdGlvbnMpO1xuXHR9O1xuXG5cblx0aWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGRlZmluZS5hbWQgPT09ICdvYmplY3QnICYmIGRlZmluZS5hbWQpIHtcblxuXHRcdC8vIEFNRC4gUmVnaXN0ZXIgYXMgYW4gYW5vbnltb3VzIG1vZHVsZS5cblx0XHRkZWZpbmUoZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gRmFzdENsaWNrO1xuXHRcdH0pO1xuXHR9IGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKSB7XG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBGYXN0Q2xpY2suYXR0YWNoO1xuXHRcdG1vZHVsZS5leHBvcnRzLkZhc3RDbGljayA9IEZhc3RDbGljaztcblx0fSBlbHNlIHtcblx0XHR3aW5kb3cuRmFzdENsaWNrID0gRmFzdENsaWNrO1xuXHR9XG59KCkpO1xuIiwiLy8gRm9yIEBvbnNlbnVpL2N1c3RvbS1lbGVtZW50c1xuaWYgKHdpbmRvdy5jdXN0b21FbGVtZW50cykgeyAvLyBldmVuIGlmIG5hdGl2ZSBDRTEgaW1wbCBleGlzdHMsIHVzZSBwb2x5ZmlsbFxuICAgIHdpbmRvdy5jdXN0b21FbGVtZW50cy5mb3JjZVBvbHlmaWxsID0gdHJ1ZTtcbn1cbiIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy84NiNpc3N1ZWNvbW1lbnQtMTE1NzU5MDI4XG52YXIgZ2xvYmFsID0gbW9kdWxlLmV4cG9ydHMgPSB0eXBlb2Ygd2luZG93ICE9ICd1bmRlZmluZWQnICYmIHdpbmRvdy5NYXRoID09IE1hdGhcbiAgPyB3aW5kb3cgOiB0eXBlb2Ygc2VsZiAhPSAndW5kZWZpbmVkJyAmJiBzZWxmLk1hdGggPT0gTWF0aCA/IHNlbGZcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW5ldy1mdW5jXG4gIDogRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcbmlmICh0eXBlb2YgX19nID09ICdudW1iZXInKSBfX2cgPSBnbG9iYWw7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcbiIsInZhciBjb3JlID0gbW9kdWxlLmV4cG9ydHMgPSB7IHZlcnNpb246ICcyLjYuNScgfTtcbmlmICh0eXBlb2YgX19lID09ICdudW1iZXInKSBfX2UgPSBjb3JlOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gdHlwZW9mIGl0ID09PSAnb2JqZWN0JyA/IGl0ICE9PSBudWxsIDogdHlwZW9mIGl0ID09PSAnZnVuY3Rpb24nO1xufTtcbiIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKCFpc09iamVjdChpdCkpIHRocm93IFR5cGVFcnJvcihpdCArICcgaXMgbm90IGFuIG9iamVjdCEnKTtcbiAgcmV0dXJuIGl0O1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGV4ZWMpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gISFleGVjKCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufTtcbiIsIi8vIFRoYW5rJ3MgSUU4IGZvciBoaXMgZnVubnkgZGVmaW5lUHJvcGVydHlcbm1vZHVsZS5leHBvcnRzID0gIXJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAnYScsIHsgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiA3OyB9IH0pLmEgIT0gNztcbn0pO1xuIiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgZG9jdW1lbnQgPSByZXF1aXJlKCcuL19nbG9iYWwnKS5kb2N1bWVudDtcbi8vIHR5cGVvZiBkb2N1bWVudC5jcmVhdGVFbGVtZW50IGlzICdvYmplY3QnIGluIG9sZCBJRVxudmFyIGlzID0gaXNPYmplY3QoZG9jdW1lbnQpICYmIGlzT2JqZWN0KGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGlzID8gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChpdCkgOiB7fTtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9ICFyZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpICYmICFyZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyZXF1aXJlKCcuL19kb20tY3JlYXRlJykoJ2RpdicpLCAnYScsIHsgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiA3OyB9IH0pLmEgIT0gNztcbn0pO1xuIiwiLy8gNy4xLjEgVG9QcmltaXRpdmUoaW5wdXQgWywgUHJlZmVycmVkVHlwZV0pXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbi8vIGluc3RlYWQgb2YgdGhlIEVTNiBzcGVjIHZlcnNpb24sIHdlIGRpZG4ndCBpbXBsZW1lbnQgQEB0b1ByaW1pdGl2ZSBjYXNlXG4vLyBhbmQgdGhlIHNlY29uZCBhcmd1bWVudCAtIGZsYWcgLSBwcmVmZXJyZWQgdHlwZSBpcyBhIHN0cmluZ1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQsIFMpIHtcbiAgaWYgKCFpc09iamVjdChpdCkpIHJldHVybiBpdDtcbiAgdmFyIGZuLCB2YWw7XG4gIGlmIChTICYmIHR5cGVvZiAoZm4gPSBpdC50b1N0cmluZykgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpdCkpKSByZXR1cm4gdmFsO1xuICBpZiAodHlwZW9mIChmbiA9IGl0LnZhbHVlT2YpID09ICdmdW5jdGlvbicgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaXQpKSkgcmV0dXJuIHZhbDtcbiAgaWYgKCFTICYmIHR5cGVvZiAoZm4gPSBpdC50b1N0cmluZykgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpdCkpKSByZXR1cm4gdmFsO1xuICB0aHJvdyBUeXBlRXJyb3IoXCJDYW4ndCBjb252ZXJ0IG9iamVjdCB0byBwcmltaXRpdmUgdmFsdWVcIik7XG59O1xuIiwidmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgSUU4X0RPTV9ERUZJTkUgPSByZXF1aXJlKCcuL19pZTgtZG9tLWRlZmluZScpO1xudmFyIHRvUHJpbWl0aXZlID0gcmVxdWlyZSgnLi9fdG8tcHJpbWl0aXZlJyk7XG52YXIgZFAgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG5cbmV4cG9ydHMuZiA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgPyBPYmplY3QuZGVmaW5lUHJvcGVydHkgOiBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKSB7XG4gIGFuT2JqZWN0KE8pO1xuICBQID0gdG9QcmltaXRpdmUoUCwgdHJ1ZSk7XG4gIGFuT2JqZWN0KEF0dHJpYnV0ZXMpO1xuICBpZiAoSUU4X0RPTV9ERUZJTkUpIHRyeSB7XG4gICAgcmV0dXJuIGRQKE8sIFAsIEF0dHJpYnV0ZXMpO1xuICB9IGNhdGNoIChlKSB7IC8qIGVtcHR5ICovIH1cbiAgaWYgKCdnZXQnIGluIEF0dHJpYnV0ZXMgfHwgJ3NldCcgaW4gQXR0cmlidXRlcykgdGhyb3cgVHlwZUVycm9yKCdBY2Nlc3NvcnMgbm90IHN1cHBvcnRlZCEnKTtcbiAgaWYgKCd2YWx1ZScgaW4gQXR0cmlidXRlcykgT1tQXSA9IEF0dHJpYnV0ZXMudmFsdWU7XG4gIHJldHVybiBPO1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGJpdG1hcCwgdmFsdWUpIHtcbiAgcmV0dXJuIHtcbiAgICBlbnVtZXJhYmxlOiAhKGJpdG1hcCAmIDEpLFxuICAgIGNvbmZpZ3VyYWJsZTogIShiaXRtYXAgJiAyKSxcbiAgICB3cml0YWJsZTogIShiaXRtYXAgJiA0KSxcbiAgICB2YWx1ZTogdmFsdWVcbiAgfTtcbn07XG4iLCJ2YXIgZFAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKTtcbnZhciBjcmVhdGVEZXNjID0gcmVxdWlyZSgnLi9fcHJvcGVydHktZGVzYycpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpID8gZnVuY3Rpb24gKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICByZXR1cm4gZFAuZihvYmplY3QsIGtleSwgY3JlYXRlRGVzYygxLCB2YWx1ZSkpO1xufSA6IGZ1bmN0aW9uIChvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgb2JqZWN0W2tleV0gPSB2YWx1ZTtcbiAgcmV0dXJuIG9iamVjdDtcbn07XG4iLCJ2YXIgaGFzT3duUHJvcGVydHkgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0LCBrZXkpIHtcbiAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwoaXQsIGtleSk7XG59O1xuIiwidmFyIGlkID0gMDtcbnZhciBweCA9IE1hdGgucmFuZG9tKCk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgcmV0dXJuICdTeW1ib2woJy5jb25jYXQoa2V5ID09PSB1bmRlZmluZWQgPyAnJyA6IGtleSwgJylfJywgKCsraWQgKyBweCkudG9TdHJpbmcoMzYpKTtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZhbHNlO1xuIiwidmFyIGNvcmUgPSByZXF1aXJlKCcuL19jb3JlJyk7XG52YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgU0hBUkVEID0gJ19fY29yZS1qc19zaGFyZWRfXyc7XG52YXIgc3RvcmUgPSBnbG9iYWxbU0hBUkVEXSB8fCAoZ2xvYmFsW1NIQVJFRF0gPSB7fSk7XG5cbihtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gIHJldHVybiBzdG9yZVtrZXldIHx8IChzdG9yZVtrZXldID0gdmFsdWUgIT09IHVuZGVmaW5lZCA/IHZhbHVlIDoge30pO1xufSkoJ3ZlcnNpb25zJywgW10pLnB1c2goe1xuICB2ZXJzaW9uOiBjb3JlLnZlcnNpb24sXG4gIG1vZGU6IHJlcXVpcmUoJy4vX2xpYnJhcnknKSA/ICdwdXJlJyA6ICdnbG9iYWwnLFxuICBjb3B5cmlnaHQ6ICfCqSAyMDE5IERlbmlzIFB1c2hrYXJldiAoemxvaXJvY2sucnUpJ1xufSk7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX3NoYXJlZCcpKCduYXRpdmUtZnVuY3Rpb24tdG8tc3RyaW5nJywgRnVuY3Rpb24udG9TdHJpbmcpO1xuIiwidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIGhpZGUgPSByZXF1aXJlKCcuL19oaWRlJyk7XG52YXIgaGFzID0gcmVxdWlyZSgnLi9faGFzJyk7XG52YXIgU1JDID0gcmVxdWlyZSgnLi9fdWlkJykoJ3NyYycpO1xudmFyICR0b1N0cmluZyA9IHJlcXVpcmUoJy4vX2Z1bmN0aW9uLXRvLXN0cmluZycpO1xudmFyIFRPX1NUUklORyA9ICd0b1N0cmluZyc7XG52YXIgVFBMID0gKCcnICsgJHRvU3RyaW5nKS5zcGxpdChUT19TVFJJTkcpO1xuXG5yZXF1aXJlKCcuL19jb3JlJykuaW5zcGVjdFNvdXJjZSA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gJHRvU3RyaW5nLmNhbGwoaXQpO1xufTtcblxuKG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKE8sIGtleSwgdmFsLCBzYWZlKSB7XG4gIHZhciBpc0Z1bmN0aW9uID0gdHlwZW9mIHZhbCA9PSAnZnVuY3Rpb24nO1xuICBpZiAoaXNGdW5jdGlvbikgaGFzKHZhbCwgJ25hbWUnKSB8fCBoaWRlKHZhbCwgJ25hbWUnLCBrZXkpO1xuICBpZiAoT1trZXldID09PSB2YWwpIHJldHVybjtcbiAgaWYgKGlzRnVuY3Rpb24pIGhhcyh2YWwsIFNSQykgfHwgaGlkZSh2YWwsIFNSQywgT1trZXldID8gJycgKyBPW2tleV0gOiBUUEwuam9pbihTdHJpbmcoa2V5KSkpO1xuICBpZiAoTyA9PT0gZ2xvYmFsKSB7XG4gICAgT1trZXldID0gdmFsO1xuICB9IGVsc2UgaWYgKCFzYWZlKSB7XG4gICAgZGVsZXRlIE9ba2V5XTtcbiAgICBoaWRlKE8sIGtleSwgdmFsKTtcbiAgfSBlbHNlIGlmIChPW2tleV0pIHtcbiAgICBPW2tleV0gPSB2YWw7XG4gIH0gZWxzZSB7XG4gICAgaGlkZShPLCBrZXksIHZhbCk7XG4gIH1cbi8vIGFkZCBmYWtlIEZ1bmN0aW9uI3RvU3RyaW5nIGZvciBjb3JyZWN0IHdvcmsgd3JhcHBlZCBtZXRob2RzIC8gY29uc3RydWN0b3JzIHdpdGggbWV0aG9kcyBsaWtlIExvRGFzaCBpc05hdGl2ZVxufSkoRnVuY3Rpb24ucHJvdG90eXBlLCBUT19TVFJJTkcsIGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICByZXR1cm4gdHlwZW9mIHRoaXMgPT0gJ2Z1bmN0aW9uJyAmJiB0aGlzW1NSQ10gfHwgJHRvU3RyaW5nLmNhbGwodGhpcyk7XG59KTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmICh0eXBlb2YgaXQgIT0gJ2Z1bmN0aW9uJykgdGhyb3cgVHlwZUVycm9yKGl0ICsgJyBpcyBub3QgYSBmdW5jdGlvbiEnKTtcbiAgcmV0dXJuIGl0O1xufTtcbiIsIi8vIG9wdGlvbmFsIC8gc2ltcGxlIGNvbnRleHQgYmluZGluZ1xudmFyIGFGdW5jdGlvbiA9IHJlcXVpcmUoJy4vX2EtZnVuY3Rpb24nKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGZuLCB0aGF0LCBsZW5ndGgpIHtcbiAgYUZ1bmN0aW9uKGZuKTtcbiAgaWYgKHRoYXQgPT09IHVuZGVmaW5lZCkgcmV0dXJuIGZuO1xuICBzd2l0Y2ggKGxlbmd0aCkge1xuICAgIGNhc2UgMTogcmV0dXJuIGZ1bmN0aW9uIChhKSB7XG4gICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhKTtcbiAgICB9O1xuICAgIGNhc2UgMjogcmV0dXJuIGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhLCBiKTtcbiAgICB9O1xuICAgIGNhc2UgMzogcmV0dXJuIGZ1bmN0aW9uIChhLCBiLCBjKSB7XG4gICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhLCBiLCBjKTtcbiAgICB9O1xuICB9XG4gIHJldHVybiBmdW5jdGlvbiAoLyogLi4uYXJncyAqLykge1xuICAgIHJldHVybiBmbi5hcHBseSh0aGF0LCBhcmd1bWVudHMpO1xuICB9O1xufTtcbiIsInZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbnZhciBjb3JlID0gcmVxdWlyZSgnLi9fY29yZScpO1xudmFyIGhpZGUgPSByZXF1aXJlKCcuL19oaWRlJyk7XG52YXIgcmVkZWZpbmUgPSByZXF1aXJlKCcuL19yZWRlZmluZScpO1xudmFyIGN0eCA9IHJlcXVpcmUoJy4vX2N0eCcpO1xudmFyIFBST1RPVFlQRSA9ICdwcm90b3R5cGUnO1xuXG52YXIgJGV4cG9ydCA9IGZ1bmN0aW9uICh0eXBlLCBuYW1lLCBzb3VyY2UpIHtcbiAgdmFyIElTX0ZPUkNFRCA9IHR5cGUgJiAkZXhwb3J0LkY7XG4gIHZhciBJU19HTE9CQUwgPSB0eXBlICYgJGV4cG9ydC5HO1xuICB2YXIgSVNfU1RBVElDID0gdHlwZSAmICRleHBvcnQuUztcbiAgdmFyIElTX1BST1RPID0gdHlwZSAmICRleHBvcnQuUDtcbiAgdmFyIElTX0JJTkQgPSB0eXBlICYgJGV4cG9ydC5CO1xuICB2YXIgdGFyZ2V0ID0gSVNfR0xPQkFMID8gZ2xvYmFsIDogSVNfU1RBVElDID8gZ2xvYmFsW25hbWVdIHx8IChnbG9iYWxbbmFtZV0gPSB7fSkgOiAoZ2xvYmFsW25hbWVdIHx8IHt9KVtQUk9UT1RZUEVdO1xuICB2YXIgZXhwb3J0cyA9IElTX0dMT0JBTCA/IGNvcmUgOiBjb3JlW25hbWVdIHx8IChjb3JlW25hbWVdID0ge30pO1xuICB2YXIgZXhwUHJvdG8gPSBleHBvcnRzW1BST1RPVFlQRV0gfHwgKGV4cG9ydHNbUFJPVE9UWVBFXSA9IHt9KTtcbiAgdmFyIGtleSwgb3duLCBvdXQsIGV4cDtcbiAgaWYgKElTX0dMT0JBTCkgc291cmNlID0gbmFtZTtcbiAgZm9yIChrZXkgaW4gc291cmNlKSB7XG4gICAgLy8gY29udGFpbnMgaW4gbmF0aXZlXG4gICAgb3duID0gIUlTX0ZPUkNFRCAmJiB0YXJnZXQgJiYgdGFyZ2V0W2tleV0gIT09IHVuZGVmaW5lZDtcbiAgICAvLyBleHBvcnQgbmF0aXZlIG9yIHBhc3NlZFxuICAgIG91dCA9IChvd24gPyB0YXJnZXQgOiBzb3VyY2UpW2tleV07XG4gICAgLy8gYmluZCB0aW1lcnMgdG8gZ2xvYmFsIGZvciBjYWxsIGZyb20gZXhwb3J0IGNvbnRleHRcbiAgICBleHAgPSBJU19CSU5EICYmIG93biA/IGN0eChvdXQsIGdsb2JhbCkgOiBJU19QUk9UTyAmJiB0eXBlb2Ygb3V0ID09ICdmdW5jdGlvbicgPyBjdHgoRnVuY3Rpb24uY2FsbCwgb3V0KSA6IG91dDtcbiAgICAvLyBleHRlbmQgZ2xvYmFsXG4gICAgaWYgKHRhcmdldCkgcmVkZWZpbmUodGFyZ2V0LCBrZXksIG91dCwgdHlwZSAmICRleHBvcnQuVSk7XG4gICAgLy8gZXhwb3J0XG4gICAgaWYgKGV4cG9ydHNba2V5XSAhPSBvdXQpIGhpZGUoZXhwb3J0cywga2V5LCBleHApO1xuICAgIGlmIChJU19QUk9UTyAmJiBleHBQcm90b1trZXldICE9IG91dCkgZXhwUHJvdG9ba2V5XSA9IG91dDtcbiAgfVxufTtcbmdsb2JhbC5jb3JlID0gY29yZTtcbi8vIHR5cGUgYml0bWFwXG4kZXhwb3J0LkYgPSAxOyAgIC8vIGZvcmNlZFxuJGV4cG9ydC5HID0gMjsgICAvLyBnbG9iYWxcbiRleHBvcnQuUyA9IDQ7ICAgLy8gc3RhdGljXG4kZXhwb3J0LlAgPSA4OyAgIC8vIHByb3RvXG4kZXhwb3J0LkIgPSAxNjsgIC8vIGJpbmRcbiRleHBvcnQuVyA9IDMyOyAgLy8gd3JhcFxuJGV4cG9ydC5VID0gNjQ7ICAvLyBzYWZlXG4kZXhwb3J0LlIgPSAxMjg7IC8vIHJlYWwgcHJvdG8gbWV0aG9kIGZvciBgbGlicmFyeWBcbm1vZHVsZS5leHBvcnRzID0gJGV4cG9ydDtcbiIsImV4cG9ydHMuZiA9IHt9LnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuIiwidmFyIHRvU3RyaW5nID0ge30udG9TdHJpbmc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKGl0KS5zbGljZSg4LCAtMSk7XG59O1xuIiwiLy8gZmFsbGJhY2sgZm9yIG5vbi1hcnJheS1saWtlIEVTMyBhbmQgbm9uLWVudW1lcmFibGUgb2xkIFY4IHN0cmluZ3NcbnZhciBjb2YgPSByZXF1aXJlKCcuL19jb2YnKTtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wcm90b3R5cGUtYnVpbHRpbnNcbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0KCd6JykucHJvcGVydHlJc0VudW1lcmFibGUoMCkgPyBPYmplY3QgOiBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGNvZihpdCkgPT0gJ1N0cmluZycgPyBpdC5zcGxpdCgnJykgOiBPYmplY3QoaXQpO1xufTtcbiIsIi8vIDcuMi4xIFJlcXVpcmVPYmplY3RDb2VyY2libGUoYXJndW1lbnQpXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAoaXQgPT0gdW5kZWZpbmVkKSB0aHJvdyBUeXBlRXJyb3IoXCJDYW4ndCBjYWxsIG1ldGhvZCBvbiAgXCIgKyBpdCk7XG4gIHJldHVybiBpdDtcbn07XG4iLCIvLyB0byBpbmRleGVkIG9iamVjdCwgdG9PYmplY3Qgd2l0aCBmYWxsYmFjayBmb3Igbm9uLWFycmF5LWxpa2UgRVMzIHN0cmluZ3NcbnZhciBJT2JqZWN0ID0gcmVxdWlyZSgnLi9faW9iamVjdCcpO1xudmFyIGRlZmluZWQgPSByZXF1aXJlKCcuL19kZWZpbmVkJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gSU9iamVjdChkZWZpbmVkKGl0KSk7XG59O1xuIiwidmFyIHBJRSA9IHJlcXVpcmUoJy4vX29iamVjdC1waWUnKTtcbnZhciBjcmVhdGVEZXNjID0gcmVxdWlyZSgnLi9fcHJvcGVydHktZGVzYycpO1xudmFyIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKTtcbnZhciB0b1ByaW1pdGl2ZSA9IHJlcXVpcmUoJy4vX3RvLXByaW1pdGl2ZScpO1xudmFyIGhhcyA9IHJlcXVpcmUoJy4vX2hhcycpO1xudmFyIElFOF9ET01fREVGSU5FID0gcmVxdWlyZSgnLi9faWU4LWRvbS1kZWZpbmUnKTtcbnZhciBnT1BEID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcblxuZXhwb3J0cy5mID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSA/IGdPUEQgOiBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTywgUCkge1xuICBPID0gdG9JT2JqZWN0KE8pO1xuICBQID0gdG9QcmltaXRpdmUoUCwgdHJ1ZSk7XG4gIGlmIChJRThfRE9NX0RFRklORSkgdHJ5IHtcbiAgICByZXR1cm4gZ09QRChPLCBQKTtcbiAgfSBjYXRjaCAoZSkgeyAvKiBlbXB0eSAqLyB9XG4gIGlmIChoYXMoTywgUCkpIHJldHVybiBjcmVhdGVEZXNjKCFwSUUuZi5jYWxsKE8sIFApLCBPW1BdKTtcbn07XG4iLCIvLyBXb3JrcyB3aXRoIF9fcHJvdG9fXyBvbmx5LiBPbGQgdjggY2FuJ3Qgd29yayB3aXRoIG51bGwgcHJvdG8gb2JqZWN0cy5cbi8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvICovXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIGNoZWNrID0gZnVuY3Rpb24gKE8sIHByb3RvKSB7XG4gIGFuT2JqZWN0KE8pO1xuICBpZiAoIWlzT2JqZWN0KHByb3RvKSAmJiBwcm90byAhPT0gbnVsbCkgdGhyb3cgVHlwZUVycm9yKHByb3RvICsgXCI6IGNhbid0IHNldCBhcyBwcm90b3R5cGUhXCIpO1xufTtcbm1vZHVsZS5leHBvcnRzID0ge1xuICBzZXQ6IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCAoJ19fcHJvdG9fXycgaW4ge30gPyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgZnVuY3Rpb24gKHRlc3QsIGJ1Z2d5LCBzZXQpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHNldCA9IHJlcXVpcmUoJy4vX2N0eCcpKEZ1bmN0aW9uLmNhbGwsIHJlcXVpcmUoJy4vX29iamVjdC1nb3BkJykuZihPYmplY3QucHJvdG90eXBlLCAnX19wcm90b19fJykuc2V0LCAyKTtcbiAgICAgICAgc2V0KHRlc3QsIFtdKTtcbiAgICAgICAgYnVnZ3kgPSAhKHRlc3QgaW5zdGFuY2VvZiBBcnJheSk7XG4gICAgICB9IGNhdGNoIChlKSB7IGJ1Z2d5ID0gdHJ1ZTsgfVxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIHNldFByb3RvdHlwZU9mKE8sIHByb3RvKSB7XG4gICAgICAgIGNoZWNrKE8sIHByb3RvKTtcbiAgICAgICAgaWYgKGJ1Z2d5KSBPLl9fcHJvdG9fXyA9IHByb3RvO1xuICAgICAgICBlbHNlIHNldChPLCBwcm90byk7XG4gICAgICAgIHJldHVybiBPO1xuICAgICAgfTtcbiAgICB9KHt9LCBmYWxzZSkgOiB1bmRlZmluZWQpLFxuICBjaGVjazogY2hlY2tcbn07XG4iLCIvLyAxOS4xLjMuMTkgT2JqZWN0LnNldFByb3RvdHlwZU9mKE8sIHByb3RvKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbiRleHBvcnQoJGV4cG9ydC5TLCAnT2JqZWN0JywgeyBzZXRQcm90b3R5cGVPZjogcmVxdWlyZSgnLi9fc2V0LXByb3RvJykuc2V0IH0pO1xuIiwicmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczYub2JqZWN0LnNldC1wcm90b3R5cGUtb2YnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9fY29yZScpLk9iamVjdC5zZXRQcm90b3R5cGVPZjtcbiIsInZhciBzdG9yZSA9IHJlcXVpcmUoJy4vX3NoYXJlZCcpKCd3a3MnKTtcbnZhciB1aWQgPSByZXF1aXJlKCcuL191aWQnKTtcbnZhciBTeW1ib2wgPSByZXF1aXJlKCcuL19nbG9iYWwnKS5TeW1ib2w7XG52YXIgVVNFX1NZTUJPTCA9IHR5cGVvZiBTeW1ib2wgPT0gJ2Z1bmN0aW9uJztcblxudmFyICRleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobmFtZSkge1xuICByZXR1cm4gc3RvcmVbbmFtZV0gfHwgKHN0b3JlW25hbWVdID1cbiAgICBVU0VfU1lNQk9MICYmIFN5bWJvbFtuYW1lXSB8fCAoVVNFX1NZTUJPTCA/IFN5bWJvbCA6IHVpZCkoJ1N5bWJvbC4nICsgbmFtZSkpO1xufTtcblxuJGV4cG9ydHMuc3RvcmUgPSBzdG9yZTtcbiIsIi8vIGdldHRpbmcgdGFnIGZyb20gMTkuMS4zLjYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZygpXG52YXIgY29mID0gcmVxdWlyZSgnLi9fY29mJyk7XG52YXIgVEFHID0gcmVxdWlyZSgnLi9fd2tzJykoJ3RvU3RyaW5nVGFnJyk7XG4vLyBFUzMgd3JvbmcgaGVyZVxudmFyIEFSRyA9IGNvZihmdW5jdGlvbiAoKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSkgPT0gJ0FyZ3VtZW50cyc7XG5cbi8vIGZhbGxiYWNrIGZvciBJRTExIFNjcmlwdCBBY2Nlc3MgRGVuaWVkIGVycm9yXG52YXIgdHJ5R2V0ID0gZnVuY3Rpb24gKGl0LCBrZXkpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gaXRba2V5XTtcbiAgfSBjYXRjaCAoZSkgeyAvKiBlbXB0eSAqLyB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICB2YXIgTywgVCwgQjtcbiAgcmV0dXJuIGl0ID09PSB1bmRlZmluZWQgPyAnVW5kZWZpbmVkJyA6IGl0ID09PSBudWxsID8gJ051bGwnXG4gICAgLy8gQEB0b1N0cmluZ1RhZyBjYXNlXG4gICAgOiB0eXBlb2YgKFQgPSB0cnlHZXQoTyA9IE9iamVjdChpdCksIFRBRykpID09ICdzdHJpbmcnID8gVFxuICAgIC8vIGJ1aWx0aW5UYWcgY2FzZVxuICAgIDogQVJHID8gY29mKE8pXG4gICAgLy8gRVMzIGFyZ3VtZW50cyBmYWxsYmFja1xuICAgIDogKEIgPSBjb2YoTykpID09ICdPYmplY3QnICYmIHR5cGVvZiBPLmNhbGxlZSA9PSAnZnVuY3Rpb24nID8gJ0FyZ3VtZW50cycgOiBCO1xufTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8vIDE5LjEuMy42IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcoKVxudmFyIGNsYXNzb2YgPSByZXF1aXJlKCcuL19jbGFzc29mJyk7XG52YXIgdGVzdCA9IHt9O1xudGVzdFtyZXF1aXJlKCcuL193a3MnKSgndG9TdHJpbmdUYWcnKV0gPSAneic7XG5pZiAodGVzdCArICcnICE9ICdbb2JqZWN0IHpdJykge1xuICByZXF1aXJlKCcuL19yZWRlZmluZScpKE9iamVjdC5wcm90b3R5cGUsICd0b1N0cmluZycsIGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiAnW29iamVjdCAnICsgY2xhc3NvZih0aGlzKSArICddJztcbiAgfSwgdHJ1ZSk7XG59XG4iLCIvLyA3LjEuNCBUb0ludGVnZXJcbnZhciBjZWlsID0gTWF0aC5jZWlsO1xudmFyIGZsb29yID0gTWF0aC5mbG9vcjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBpc05hTihpdCA9ICtpdCkgPyAwIDogKGl0ID4gMCA/IGZsb29yIDogY2VpbCkoaXQpO1xufTtcbiIsInZhciB0b0ludGVnZXIgPSByZXF1aXJlKCcuL190by1pbnRlZ2VyJyk7XG52YXIgZGVmaW5lZCA9IHJlcXVpcmUoJy4vX2RlZmluZWQnKTtcbi8vIHRydWUgIC0+IFN0cmluZyNhdFxuLy8gZmFsc2UgLT4gU3RyaW5nI2NvZGVQb2ludEF0XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChUT19TVFJJTkcpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICh0aGF0LCBwb3MpIHtcbiAgICB2YXIgcyA9IFN0cmluZyhkZWZpbmVkKHRoYXQpKTtcbiAgICB2YXIgaSA9IHRvSW50ZWdlcihwb3MpO1xuICAgIHZhciBsID0gcy5sZW5ndGg7XG4gICAgdmFyIGEsIGI7XG4gICAgaWYgKGkgPCAwIHx8IGkgPj0gbCkgcmV0dXJuIFRPX1NUUklORyA/ICcnIDogdW5kZWZpbmVkO1xuICAgIGEgPSBzLmNoYXJDb2RlQXQoaSk7XG4gICAgcmV0dXJuIGEgPCAweGQ4MDAgfHwgYSA+IDB4ZGJmZiB8fCBpICsgMSA9PT0gbCB8fCAoYiA9IHMuY2hhckNvZGVBdChpICsgMSkpIDwgMHhkYzAwIHx8IGIgPiAweGRmZmZcbiAgICAgID8gVE9fU1RSSU5HID8gcy5jaGFyQXQoaSkgOiBhXG4gICAgICA6IFRPX1NUUklORyA/IHMuc2xpY2UoaSwgaSArIDIpIDogKGEgLSAweGQ4MDAgPDwgMTApICsgKGIgLSAweGRjMDApICsgMHgxMDAwMDtcbiAgfTtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHt9O1xuIiwiLy8gNy4xLjE1IFRvTGVuZ3RoXG52YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi9fdG8taW50ZWdlcicpO1xudmFyIG1pbiA9IE1hdGgubWluO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGl0ID4gMCA/IG1pbih0b0ludGVnZXIoaXQpLCAweDFmZmZmZmZmZmZmZmZmKSA6IDA7IC8vIHBvdygyLCA1MykgLSAxID09IDkwMDcxOTkyNTQ3NDA5OTFcbn07XG4iLCJ2YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi9fdG8taW50ZWdlcicpO1xudmFyIG1heCA9IE1hdGgubWF4O1xudmFyIG1pbiA9IE1hdGgubWluO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaW5kZXgsIGxlbmd0aCkge1xuICBpbmRleCA9IHRvSW50ZWdlcihpbmRleCk7XG4gIHJldHVybiBpbmRleCA8IDAgPyBtYXgoaW5kZXggKyBsZW5ndGgsIDApIDogbWluKGluZGV4LCBsZW5ndGgpO1xufTtcbiIsIi8vIGZhbHNlIC0+IEFycmF5I2luZGV4T2Zcbi8vIHRydWUgIC0+IEFycmF5I2luY2x1ZGVzXG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG52YXIgdG9BYnNvbHV0ZUluZGV4ID0gcmVxdWlyZSgnLi9fdG8tYWJzb2x1dGUtaW5kZXgnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKElTX0lOQ0xVREVTKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoJHRoaXMsIGVsLCBmcm9tSW5kZXgpIHtcbiAgICB2YXIgTyA9IHRvSU9iamVjdCgkdGhpcyk7XG4gICAgdmFyIGxlbmd0aCA9IHRvTGVuZ3RoKE8ubGVuZ3RoKTtcbiAgICB2YXIgaW5kZXggPSB0b0Fic29sdXRlSW5kZXgoZnJvbUluZGV4LCBsZW5ndGgpO1xuICAgIHZhciB2YWx1ZTtcbiAgICAvLyBBcnJheSNpbmNsdWRlcyB1c2VzIFNhbWVWYWx1ZVplcm8gZXF1YWxpdHkgYWxnb3JpdGhtXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZVxuICAgIGlmIChJU19JTkNMVURFUyAmJiBlbCAhPSBlbCkgd2hpbGUgKGxlbmd0aCA+IGluZGV4KSB7XG4gICAgICB2YWx1ZSA9IE9baW5kZXgrK107XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlXG4gICAgICBpZiAodmFsdWUgIT0gdmFsdWUpIHJldHVybiB0cnVlO1xuICAgIC8vIEFycmF5I2luZGV4T2YgaWdub3JlcyBob2xlcywgQXJyYXkjaW5jbHVkZXMgLSBub3RcbiAgICB9IGVsc2UgZm9yICg7bGVuZ3RoID4gaW5kZXg7IGluZGV4KyspIGlmIChJU19JTkNMVURFUyB8fCBpbmRleCBpbiBPKSB7XG4gICAgICBpZiAoT1tpbmRleF0gPT09IGVsKSByZXR1cm4gSVNfSU5DTFVERVMgfHwgaW5kZXggfHwgMDtcbiAgICB9IHJldHVybiAhSVNfSU5DTFVERVMgJiYgLTE7XG4gIH07XG59O1xuIiwidmFyIHNoYXJlZCA9IHJlcXVpcmUoJy4vX3NoYXJlZCcpKCdrZXlzJyk7XG52YXIgdWlkID0gcmVxdWlyZSgnLi9fdWlkJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgcmV0dXJuIHNoYXJlZFtrZXldIHx8IChzaGFyZWRba2V5XSA9IHVpZChrZXkpKTtcbn07XG4iLCJ2YXIgaGFzID0gcmVxdWlyZSgnLi9faGFzJyk7XG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpO1xudmFyIGFycmF5SW5kZXhPZiA9IHJlcXVpcmUoJy4vX2FycmF5LWluY2x1ZGVzJykoZmFsc2UpO1xudmFyIElFX1BST1RPID0gcmVxdWlyZSgnLi9fc2hhcmVkLWtleScpKCdJRV9QUk9UTycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvYmplY3QsIG5hbWVzKSB7XG4gIHZhciBPID0gdG9JT2JqZWN0KG9iamVjdCk7XG4gIHZhciBpID0gMDtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICB2YXIga2V5O1xuICBmb3IgKGtleSBpbiBPKSBpZiAoa2V5ICE9IElFX1BST1RPKSBoYXMoTywga2V5KSAmJiByZXN1bHQucHVzaChrZXkpO1xuICAvLyBEb24ndCBlbnVtIGJ1ZyAmIGhpZGRlbiBrZXlzXG4gIHdoaWxlIChuYW1lcy5sZW5ndGggPiBpKSBpZiAoaGFzKE8sIGtleSA9IG5hbWVzW2krK10pKSB7XG4gICAgfmFycmF5SW5kZXhPZihyZXN1bHQsIGtleSkgfHwgcmVzdWx0LnB1c2goa2V5KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcbiIsIi8vIElFIDgtIGRvbid0IGVudW0gYnVnIGtleXNcbm1vZHVsZS5leHBvcnRzID0gKFxuICAnY29uc3RydWN0b3IsaGFzT3duUHJvcGVydHksaXNQcm90b3R5cGVPZixwcm9wZXJ0eUlzRW51bWVyYWJsZSx0b0xvY2FsZVN0cmluZyx0b1N0cmluZyx2YWx1ZU9mJ1xuKS5zcGxpdCgnLCcpO1xuIiwiLy8gMTkuMS4yLjE0IC8gMTUuMi4zLjE0IE9iamVjdC5rZXlzKE8pXG52YXIgJGtleXMgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cy1pbnRlcm5hbCcpO1xudmFyIGVudW1CdWdLZXlzID0gcmVxdWlyZSgnLi9fZW51bS1idWcta2V5cycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIGtleXMoTykge1xuICByZXR1cm4gJGtleXMoTywgZW51bUJ1Z0tleXMpO1xufTtcbiIsInZhciBkUCA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgZ2V0S2V5cyA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzIDogZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyhPLCBQcm9wZXJ0aWVzKSB7XG4gIGFuT2JqZWN0KE8pO1xuICB2YXIga2V5cyA9IGdldEtleXMoUHJvcGVydGllcyk7XG4gIHZhciBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgdmFyIGkgPSAwO1xuICB2YXIgUDtcbiAgd2hpbGUgKGxlbmd0aCA+IGkpIGRQLmYoTywgUCA9IGtleXNbaSsrXSwgUHJvcGVydGllc1tQXSk7XG4gIHJldHVybiBPO1xufTtcbiIsInZhciBkb2N1bWVudCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpLmRvY3VtZW50O1xubW9kdWxlLmV4cG9ydHMgPSBkb2N1bWVudCAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4iLCIvLyAxOS4xLjIuMiAvIDE1LjIuMy41IE9iamVjdC5jcmVhdGUoTyBbLCBQcm9wZXJ0aWVzXSlcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIGRQcyA9IHJlcXVpcmUoJy4vX29iamVjdC1kcHMnKTtcbnZhciBlbnVtQnVnS2V5cyA9IHJlcXVpcmUoJy4vX2VudW0tYnVnLWtleXMnKTtcbnZhciBJRV9QUk9UTyA9IHJlcXVpcmUoJy4vX3NoYXJlZC1rZXknKSgnSUVfUFJPVE8nKTtcbnZhciBFbXB0eSA9IGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfTtcbnZhciBQUk9UT1RZUEUgPSAncHJvdG90eXBlJztcblxuLy8gQ3JlYXRlIG9iamVjdCB3aXRoIGZha2UgYG51bGxgIHByb3RvdHlwZTogdXNlIGlmcmFtZSBPYmplY3Qgd2l0aCBjbGVhcmVkIHByb3RvdHlwZVxudmFyIGNyZWF0ZURpY3QgPSBmdW5jdGlvbiAoKSB7XG4gIC8vIFRocmFzaCwgd2FzdGUgYW5kIHNvZG9teTogSUUgR0MgYnVnXG4gIHZhciBpZnJhbWUgPSByZXF1aXJlKCcuL19kb20tY3JlYXRlJykoJ2lmcmFtZScpO1xuICB2YXIgaSA9IGVudW1CdWdLZXlzLmxlbmd0aDtcbiAgdmFyIGx0ID0gJzwnO1xuICB2YXIgZ3QgPSAnPic7XG4gIHZhciBpZnJhbWVEb2N1bWVudDtcbiAgaWZyYW1lLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gIHJlcXVpcmUoJy4vX2h0bWwnKS5hcHBlbmRDaGlsZChpZnJhbWUpO1xuICBpZnJhbWUuc3JjID0gJ2phdmFzY3JpcHQ6JzsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zY3JpcHQtdXJsXG4gIC8vIGNyZWF0ZURpY3QgPSBpZnJhbWUuY29udGVudFdpbmRvdy5PYmplY3Q7XG4gIC8vIGh0bWwucmVtb3ZlQ2hpbGQoaWZyYW1lKTtcbiAgaWZyYW1lRG9jdW1lbnQgPSBpZnJhbWUuY29udGVudFdpbmRvdy5kb2N1bWVudDtcbiAgaWZyYW1lRG9jdW1lbnQub3BlbigpO1xuICBpZnJhbWVEb2N1bWVudC53cml0ZShsdCArICdzY3JpcHQnICsgZ3QgKyAnZG9jdW1lbnQuRj1PYmplY3QnICsgbHQgKyAnL3NjcmlwdCcgKyBndCk7XG4gIGlmcmFtZURvY3VtZW50LmNsb3NlKCk7XG4gIGNyZWF0ZURpY3QgPSBpZnJhbWVEb2N1bWVudC5GO1xuICB3aGlsZSAoaS0tKSBkZWxldGUgY3JlYXRlRGljdFtQUk9UT1RZUEVdW2VudW1CdWdLZXlzW2ldXTtcbiAgcmV0dXJuIGNyZWF0ZURpY3QoKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmNyZWF0ZSB8fCBmdW5jdGlvbiBjcmVhdGUoTywgUHJvcGVydGllcykge1xuICB2YXIgcmVzdWx0O1xuICBpZiAoTyAhPT0gbnVsbCkge1xuICAgIEVtcHR5W1BST1RPVFlQRV0gPSBhbk9iamVjdChPKTtcbiAgICByZXN1bHQgPSBuZXcgRW1wdHkoKTtcbiAgICBFbXB0eVtQUk9UT1RZUEVdID0gbnVsbDtcbiAgICAvLyBhZGQgXCJfX3Byb3RvX19cIiBmb3IgT2JqZWN0LmdldFByb3RvdHlwZU9mIHBvbHlmaWxsXG4gICAgcmVzdWx0W0lFX1BST1RPXSA9IE87XG4gIH0gZWxzZSByZXN1bHQgPSBjcmVhdGVEaWN0KCk7XG4gIHJldHVybiBQcm9wZXJ0aWVzID09PSB1bmRlZmluZWQgPyByZXN1bHQgOiBkUHMocmVzdWx0LCBQcm9wZXJ0aWVzKTtcbn07XG4iLCJ2YXIgZGVmID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZjtcbnZhciBoYXMgPSByZXF1aXJlKCcuL19oYXMnKTtcbnZhciBUQUcgPSByZXF1aXJlKCcuL193a3MnKSgndG9TdHJpbmdUYWcnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQsIHRhZywgc3RhdCkge1xuICBpZiAoaXQgJiYgIWhhcyhpdCA9IHN0YXQgPyBpdCA6IGl0LnByb3RvdHlwZSwgVEFHKSkgZGVmKGl0LCBUQUcsIHsgY29uZmlndXJhYmxlOiB0cnVlLCB2YWx1ZTogdGFnIH0pO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBjcmVhdGUgPSByZXF1aXJlKCcuL19vYmplY3QtY3JlYXRlJyk7XG52YXIgZGVzY3JpcHRvciA9IHJlcXVpcmUoJy4vX3Byb3BlcnR5LWRlc2MnKTtcbnZhciBzZXRUb1N0cmluZ1RhZyA9IHJlcXVpcmUoJy4vX3NldC10by1zdHJpbmctdGFnJyk7XG52YXIgSXRlcmF0b3JQcm90b3R5cGUgPSB7fTtcblxuLy8gMjUuMS4yLjEuMSAlSXRlcmF0b3JQcm90b3R5cGUlW0BAaXRlcmF0b3JdKClcbnJlcXVpcmUoJy4vX2hpZGUnKShJdGVyYXRvclByb3RvdHlwZSwgcmVxdWlyZSgnLi9fd2tzJykoJ2l0ZXJhdG9yJyksIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgTkFNRSwgbmV4dCkge1xuICBDb25zdHJ1Y3Rvci5wcm90b3R5cGUgPSBjcmVhdGUoSXRlcmF0b3JQcm90b3R5cGUsIHsgbmV4dDogZGVzY3JpcHRvcigxLCBuZXh0KSB9KTtcbiAgc2V0VG9TdHJpbmdUYWcoQ29uc3RydWN0b3IsIE5BTUUgKyAnIEl0ZXJhdG9yJyk7XG59O1xuIiwiLy8gNy4xLjEzIFRvT2JqZWN0KGFyZ3VtZW50KVxudmFyIGRlZmluZWQgPSByZXF1aXJlKCcuL19kZWZpbmVkJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gT2JqZWN0KGRlZmluZWQoaXQpKTtcbn07XG4iLCIvLyAxOS4xLjIuOSAvIDE1LjIuMy4yIE9iamVjdC5nZXRQcm90b3R5cGVPZihPKVxudmFyIGhhcyA9IHJlcXVpcmUoJy4vX2hhcycpO1xudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0Jyk7XG52YXIgSUVfUFJPVE8gPSByZXF1aXJlKCcuL19zaGFyZWQta2V5JykoJ0lFX1BST1RPJyk7XG52YXIgT2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5nZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiAoTykge1xuICBPID0gdG9PYmplY3QoTyk7XG4gIGlmIChoYXMoTywgSUVfUFJPVE8pKSByZXR1cm4gT1tJRV9QUk9UT107XG4gIGlmICh0eXBlb2YgTy5jb25zdHJ1Y3RvciA9PSAnZnVuY3Rpb24nICYmIE8gaW5zdGFuY2VvZiBPLmNvbnN0cnVjdG9yKSB7XG4gICAgcmV0dXJuIE8uY29uc3RydWN0b3IucHJvdG90eXBlO1xuICB9IHJldHVybiBPIGluc3RhbmNlb2YgT2JqZWN0ID8gT2JqZWN0UHJvdG8gOiBudWxsO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBMSUJSQVJZID0gcmVxdWlyZSgnLi9fbGlicmFyeScpO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciByZWRlZmluZSA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lJyk7XG52YXIgaGlkZSA9IHJlcXVpcmUoJy4vX2hpZGUnKTtcbnZhciBJdGVyYXRvcnMgPSByZXF1aXJlKCcuL19pdGVyYXRvcnMnKTtcbnZhciAkaXRlckNyZWF0ZSA9IHJlcXVpcmUoJy4vX2l0ZXItY3JlYXRlJyk7XG52YXIgc2V0VG9TdHJpbmdUYWcgPSByZXF1aXJlKCcuL19zZXQtdG8tc3RyaW5nLXRhZycpO1xudmFyIGdldFByb3RvdHlwZU9mID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdwbycpO1xudmFyIElURVJBVE9SID0gcmVxdWlyZSgnLi9fd2tzJykoJ2l0ZXJhdG9yJyk7XG52YXIgQlVHR1kgPSAhKFtdLmtleXMgJiYgJ25leHQnIGluIFtdLmtleXMoKSk7IC8vIFNhZmFyaSBoYXMgYnVnZ3kgaXRlcmF0b3JzIHcvbyBgbmV4dGBcbnZhciBGRl9JVEVSQVRPUiA9ICdAQGl0ZXJhdG9yJztcbnZhciBLRVlTID0gJ2tleXMnO1xudmFyIFZBTFVFUyA9ICd2YWx1ZXMnO1xuXG52YXIgcmV0dXJuVGhpcyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKEJhc2UsIE5BTUUsIENvbnN0cnVjdG9yLCBuZXh0LCBERUZBVUxULCBJU19TRVQsIEZPUkNFRCkge1xuICAkaXRlckNyZWF0ZShDb25zdHJ1Y3RvciwgTkFNRSwgbmV4dCk7XG4gIHZhciBnZXRNZXRob2QgPSBmdW5jdGlvbiAoa2luZCkge1xuICAgIGlmICghQlVHR1kgJiYga2luZCBpbiBwcm90bykgcmV0dXJuIHByb3RvW2tpbmRdO1xuICAgIHN3aXRjaCAoa2luZCkge1xuICAgICAgY2FzZSBLRVlTOiByZXR1cm4gZnVuY3Rpb24ga2V5cygpIHsgcmV0dXJuIG5ldyBDb25zdHJ1Y3Rvcih0aGlzLCBraW5kKTsgfTtcbiAgICAgIGNhc2UgVkFMVUVTOiByZXR1cm4gZnVuY3Rpb24gdmFsdWVzKCkgeyByZXR1cm4gbmV3IENvbnN0cnVjdG9yKHRoaXMsIGtpbmQpOyB9O1xuICAgIH0gcmV0dXJuIGZ1bmN0aW9uIGVudHJpZXMoKSB7IHJldHVybiBuZXcgQ29uc3RydWN0b3IodGhpcywga2luZCk7IH07XG4gIH07XG4gIHZhciBUQUcgPSBOQU1FICsgJyBJdGVyYXRvcic7XG4gIHZhciBERUZfVkFMVUVTID0gREVGQVVMVCA9PSBWQUxVRVM7XG4gIHZhciBWQUxVRVNfQlVHID0gZmFsc2U7XG4gIHZhciBwcm90byA9IEJhc2UucHJvdG90eXBlO1xuICB2YXIgJG5hdGl2ZSA9IHByb3RvW0lURVJBVE9SXSB8fCBwcm90b1tGRl9JVEVSQVRPUl0gfHwgREVGQVVMVCAmJiBwcm90b1tERUZBVUxUXTtcbiAgdmFyICRkZWZhdWx0ID0gJG5hdGl2ZSB8fCBnZXRNZXRob2QoREVGQVVMVCk7XG4gIHZhciAkZW50cmllcyA9IERFRkFVTFQgPyAhREVGX1ZBTFVFUyA/ICRkZWZhdWx0IDogZ2V0TWV0aG9kKCdlbnRyaWVzJykgOiB1bmRlZmluZWQ7XG4gIHZhciAkYW55TmF0aXZlID0gTkFNRSA9PSAnQXJyYXknID8gcHJvdG8uZW50cmllcyB8fCAkbmF0aXZlIDogJG5hdGl2ZTtcbiAgdmFyIG1ldGhvZHMsIGtleSwgSXRlcmF0b3JQcm90b3R5cGU7XG4gIC8vIEZpeCBuYXRpdmVcbiAgaWYgKCRhbnlOYXRpdmUpIHtcbiAgICBJdGVyYXRvclByb3RvdHlwZSA9IGdldFByb3RvdHlwZU9mKCRhbnlOYXRpdmUuY2FsbChuZXcgQmFzZSgpKSk7XG4gICAgaWYgKEl0ZXJhdG9yUHJvdG90eXBlICE9PSBPYmplY3QucHJvdG90eXBlICYmIEl0ZXJhdG9yUHJvdG90eXBlLm5leHQpIHtcbiAgICAgIC8vIFNldCBAQHRvU3RyaW5nVGFnIHRvIG5hdGl2ZSBpdGVyYXRvcnNcbiAgICAgIHNldFRvU3RyaW5nVGFnKEl0ZXJhdG9yUHJvdG90eXBlLCBUQUcsIHRydWUpO1xuICAgICAgLy8gZml4IGZvciBzb21lIG9sZCBlbmdpbmVzXG4gICAgICBpZiAoIUxJQlJBUlkgJiYgdHlwZW9mIEl0ZXJhdG9yUHJvdG90eXBlW0lURVJBVE9SXSAhPSAnZnVuY3Rpb24nKSBoaWRlKEl0ZXJhdG9yUHJvdG90eXBlLCBJVEVSQVRPUiwgcmV0dXJuVGhpcyk7XG4gICAgfVxuICB9XG4gIC8vIGZpeCBBcnJheSN7dmFsdWVzLCBAQGl0ZXJhdG9yfS5uYW1lIGluIFY4IC8gRkZcbiAgaWYgKERFRl9WQUxVRVMgJiYgJG5hdGl2ZSAmJiAkbmF0aXZlLm5hbWUgIT09IFZBTFVFUykge1xuICAgIFZBTFVFU19CVUcgPSB0cnVlO1xuICAgICRkZWZhdWx0ID0gZnVuY3Rpb24gdmFsdWVzKCkgeyByZXR1cm4gJG5hdGl2ZS5jYWxsKHRoaXMpOyB9O1xuICB9XG4gIC8vIERlZmluZSBpdGVyYXRvclxuICBpZiAoKCFMSUJSQVJZIHx8IEZPUkNFRCkgJiYgKEJVR0dZIHx8IFZBTFVFU19CVUcgfHwgIXByb3RvW0lURVJBVE9SXSkpIHtcbiAgICBoaWRlKHByb3RvLCBJVEVSQVRPUiwgJGRlZmF1bHQpO1xuICB9XG4gIC8vIFBsdWcgZm9yIGxpYnJhcnlcbiAgSXRlcmF0b3JzW05BTUVdID0gJGRlZmF1bHQ7XG4gIEl0ZXJhdG9yc1tUQUddID0gcmV0dXJuVGhpcztcbiAgaWYgKERFRkFVTFQpIHtcbiAgICBtZXRob2RzID0ge1xuICAgICAgdmFsdWVzOiBERUZfVkFMVUVTID8gJGRlZmF1bHQgOiBnZXRNZXRob2QoVkFMVUVTKSxcbiAgICAgIGtleXM6IElTX1NFVCA/ICRkZWZhdWx0IDogZ2V0TWV0aG9kKEtFWVMpLFxuICAgICAgZW50cmllczogJGVudHJpZXNcbiAgICB9O1xuICAgIGlmIChGT1JDRUQpIGZvciAoa2V5IGluIG1ldGhvZHMpIHtcbiAgICAgIGlmICghKGtleSBpbiBwcm90bykpIHJlZGVmaW5lKHByb3RvLCBrZXksIG1ldGhvZHNba2V5XSk7XG4gICAgfSBlbHNlICRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogKEJVR0dZIHx8IFZBTFVFU19CVUcpLCBOQU1FLCBtZXRob2RzKTtcbiAgfVxuICByZXR1cm4gbWV0aG9kcztcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgJGF0ID0gcmVxdWlyZSgnLi9fc3RyaW5nLWF0JykodHJ1ZSk7XG5cbi8vIDIxLjEuMy4yNyBTdHJpbmcucHJvdG90eXBlW0BAaXRlcmF0b3JdKClcbnJlcXVpcmUoJy4vX2l0ZXItZGVmaW5lJykoU3RyaW5nLCAnU3RyaW5nJywgZnVuY3Rpb24gKGl0ZXJhdGVkKSB7XG4gIHRoaXMuX3QgPSBTdHJpbmcoaXRlcmF0ZWQpOyAvLyB0YXJnZXRcbiAgdGhpcy5faSA9IDA7ICAgICAgICAgICAgICAgIC8vIG5leHQgaW5kZXhcbi8vIDIxLjEuNS4yLjEgJVN0cmluZ0l0ZXJhdG9yUHJvdG90eXBlJS5uZXh0KClcbn0sIGZ1bmN0aW9uICgpIHtcbiAgdmFyIE8gPSB0aGlzLl90O1xuICB2YXIgaW5kZXggPSB0aGlzLl9pO1xuICB2YXIgcG9pbnQ7XG4gIGlmIChpbmRleCA+PSBPLmxlbmd0aCkgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9O1xuICBwb2ludCA9ICRhdChPLCBpbmRleCk7XG4gIHRoaXMuX2kgKz0gcG9pbnQubGVuZ3RoO1xuICByZXR1cm4geyB2YWx1ZTogcG9pbnQsIGRvbmU6IGZhbHNlIH07XG59KTtcbiIsIi8vIDIyLjEuMy4zMSBBcnJheS5wcm90b3R5cGVbQEB1bnNjb3BhYmxlc11cbnZhciBVTlNDT1BBQkxFUyA9IHJlcXVpcmUoJy4vX3drcycpKCd1bnNjb3BhYmxlcycpO1xudmFyIEFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGU7XG5pZiAoQXJyYXlQcm90b1tVTlNDT1BBQkxFU10gPT0gdW5kZWZpbmVkKSByZXF1aXJlKCcuL19oaWRlJykoQXJyYXlQcm90bywgVU5TQ09QQUJMRVMsIHt9KTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGtleSkge1xuICBBcnJheVByb3RvW1VOU0NPUEFCTEVTXVtrZXldID0gdHJ1ZTtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChkb25lLCB2YWx1ZSkge1xuICByZXR1cm4geyB2YWx1ZTogdmFsdWUsIGRvbmU6ICEhZG9uZSB9O1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBhZGRUb1Vuc2NvcGFibGVzID0gcmVxdWlyZSgnLi9fYWRkLXRvLXVuc2NvcGFibGVzJyk7XG52YXIgc3RlcCA9IHJlcXVpcmUoJy4vX2l0ZXItc3RlcCcpO1xudmFyIEl0ZXJhdG9ycyA9IHJlcXVpcmUoJy4vX2l0ZXJhdG9ycycpO1xudmFyIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKTtcblxuLy8gMjIuMS4zLjQgQXJyYXkucHJvdG90eXBlLmVudHJpZXMoKVxuLy8gMjIuMS4zLjEzIEFycmF5LnByb3RvdHlwZS5rZXlzKClcbi8vIDIyLjEuMy4yOSBBcnJheS5wcm90b3R5cGUudmFsdWVzKClcbi8vIDIyLjEuMy4zMCBBcnJheS5wcm90b3R5cGVbQEBpdGVyYXRvcl0oKVxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19pdGVyLWRlZmluZScpKEFycmF5LCAnQXJyYXknLCBmdW5jdGlvbiAoaXRlcmF0ZWQsIGtpbmQpIHtcbiAgdGhpcy5fdCA9IHRvSU9iamVjdChpdGVyYXRlZCk7IC8vIHRhcmdldFxuICB0aGlzLl9pID0gMDsgICAgICAgICAgICAgICAgICAgLy8gbmV4dCBpbmRleFxuICB0aGlzLl9rID0ga2luZDsgICAgICAgICAgICAgICAgLy8ga2luZFxuLy8gMjIuMS41LjIuMSAlQXJyYXlJdGVyYXRvclByb3RvdHlwZSUubmV4dCgpXG59LCBmdW5jdGlvbiAoKSB7XG4gIHZhciBPID0gdGhpcy5fdDtcbiAgdmFyIGtpbmQgPSB0aGlzLl9rO1xuICB2YXIgaW5kZXggPSB0aGlzLl9pKys7XG4gIGlmICghTyB8fCBpbmRleCA+PSBPLmxlbmd0aCkge1xuICAgIHRoaXMuX3QgPSB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIHN0ZXAoMSk7XG4gIH1cbiAgaWYgKGtpbmQgPT0gJ2tleXMnKSByZXR1cm4gc3RlcCgwLCBpbmRleCk7XG4gIGlmIChraW5kID09ICd2YWx1ZXMnKSByZXR1cm4gc3RlcCgwLCBPW2luZGV4XSk7XG4gIHJldHVybiBzdGVwKDAsIFtpbmRleCwgT1tpbmRleF1dKTtcbn0sICd2YWx1ZXMnKTtcblxuLy8gYXJndW1lbnRzTGlzdFtAQGl0ZXJhdG9yXSBpcyAlQXJyYXlQcm90b192YWx1ZXMlICg5LjQuNC42LCA5LjQuNC43KVxuSXRlcmF0b3JzLkFyZ3VtZW50cyA9IEl0ZXJhdG9ycy5BcnJheTtcblxuYWRkVG9VbnNjb3BhYmxlcygna2V5cycpO1xuYWRkVG9VbnNjb3BhYmxlcygndmFsdWVzJyk7XG5hZGRUb1Vuc2NvcGFibGVzKCdlbnRyaWVzJyk7XG4iLCJ2YXIgJGl0ZXJhdG9ycyA9IHJlcXVpcmUoJy4vZXM2LmFycmF5Lml0ZXJhdG9yJyk7XG52YXIgZ2V0S2V5cyA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzJyk7XG52YXIgcmVkZWZpbmUgPSByZXF1aXJlKCcuL19yZWRlZmluZScpO1xudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIGhpZGUgPSByZXF1aXJlKCcuL19oaWRlJyk7XG52YXIgSXRlcmF0b3JzID0gcmVxdWlyZSgnLi9faXRlcmF0b3JzJyk7XG52YXIgd2tzID0gcmVxdWlyZSgnLi9fd2tzJyk7XG52YXIgSVRFUkFUT1IgPSB3a3MoJ2l0ZXJhdG9yJyk7XG52YXIgVE9fU1RSSU5HX1RBRyA9IHdrcygndG9TdHJpbmdUYWcnKTtcbnZhciBBcnJheVZhbHVlcyA9IEl0ZXJhdG9ycy5BcnJheTtcblxudmFyIERPTUl0ZXJhYmxlcyA9IHtcbiAgQ1NTUnVsZUxpc3Q6IHRydWUsIC8vIFRPRE86IE5vdCBzcGVjIGNvbXBsaWFudCwgc2hvdWxkIGJlIGZhbHNlLlxuICBDU1NTdHlsZURlY2xhcmF0aW9uOiBmYWxzZSxcbiAgQ1NTVmFsdWVMaXN0OiBmYWxzZSxcbiAgQ2xpZW50UmVjdExpc3Q6IGZhbHNlLFxuICBET01SZWN0TGlzdDogZmFsc2UsXG4gIERPTVN0cmluZ0xpc3Q6IGZhbHNlLFxuICBET01Ub2tlbkxpc3Q6IHRydWUsXG4gIERhdGFUcmFuc2Zlckl0ZW1MaXN0OiBmYWxzZSxcbiAgRmlsZUxpc3Q6IGZhbHNlLFxuICBIVE1MQWxsQ29sbGVjdGlvbjogZmFsc2UsXG4gIEhUTUxDb2xsZWN0aW9uOiBmYWxzZSxcbiAgSFRNTEZvcm1FbGVtZW50OiBmYWxzZSxcbiAgSFRNTFNlbGVjdEVsZW1lbnQ6IGZhbHNlLFxuICBNZWRpYUxpc3Q6IHRydWUsIC8vIFRPRE86IE5vdCBzcGVjIGNvbXBsaWFudCwgc2hvdWxkIGJlIGZhbHNlLlxuICBNaW1lVHlwZUFycmF5OiBmYWxzZSxcbiAgTmFtZWROb2RlTWFwOiBmYWxzZSxcbiAgTm9kZUxpc3Q6IHRydWUsXG4gIFBhaW50UmVxdWVzdExpc3Q6IGZhbHNlLFxuICBQbHVnaW46IGZhbHNlLFxuICBQbHVnaW5BcnJheTogZmFsc2UsXG4gIFNWR0xlbmd0aExpc3Q6IGZhbHNlLFxuICBTVkdOdW1iZXJMaXN0OiBmYWxzZSxcbiAgU1ZHUGF0aFNlZ0xpc3Q6IGZhbHNlLFxuICBTVkdQb2ludExpc3Q6IGZhbHNlLFxuICBTVkdTdHJpbmdMaXN0OiBmYWxzZSxcbiAgU1ZHVHJhbnNmb3JtTGlzdDogZmFsc2UsXG4gIFNvdXJjZUJ1ZmZlckxpc3Q6IGZhbHNlLFxuICBTdHlsZVNoZWV0TGlzdDogdHJ1ZSwgLy8gVE9ETzogTm90IHNwZWMgY29tcGxpYW50LCBzaG91bGQgYmUgZmFsc2UuXG4gIFRleHRUcmFja0N1ZUxpc3Q6IGZhbHNlLFxuICBUZXh0VHJhY2tMaXN0OiBmYWxzZSxcbiAgVG91Y2hMaXN0OiBmYWxzZVxufTtcblxuZm9yICh2YXIgY29sbGVjdGlvbnMgPSBnZXRLZXlzKERPTUl0ZXJhYmxlcyksIGkgPSAwOyBpIDwgY29sbGVjdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgdmFyIE5BTUUgPSBjb2xsZWN0aW9uc1tpXTtcbiAgdmFyIGV4cGxpY2l0ID0gRE9NSXRlcmFibGVzW05BTUVdO1xuICB2YXIgQ29sbGVjdGlvbiA9IGdsb2JhbFtOQU1FXTtcbiAgdmFyIHByb3RvID0gQ29sbGVjdGlvbiAmJiBDb2xsZWN0aW9uLnByb3RvdHlwZTtcbiAgdmFyIGtleTtcbiAgaWYgKHByb3RvKSB7XG4gICAgaWYgKCFwcm90b1tJVEVSQVRPUl0pIGhpZGUocHJvdG8sIElURVJBVE9SLCBBcnJheVZhbHVlcyk7XG4gICAgaWYgKCFwcm90b1tUT19TVFJJTkdfVEFHXSkgaGlkZShwcm90bywgVE9fU1RSSU5HX1RBRywgTkFNRSk7XG4gICAgSXRlcmF0b3JzW05BTUVdID0gQXJyYXlWYWx1ZXM7XG4gICAgaWYgKGV4cGxpY2l0KSBmb3IgKGtleSBpbiAkaXRlcmF0b3JzKSBpZiAoIXByb3RvW2tleV0pIHJlZGVmaW5lKHByb3RvLCBrZXksICRpdGVyYXRvcnNba2V5XSwgdHJ1ZSk7XG4gIH1cbn1cbiIsInZhciByZWRlZmluZSA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh0YXJnZXQsIHNyYywgc2FmZSkge1xuICBmb3IgKHZhciBrZXkgaW4gc3JjKSByZWRlZmluZSh0YXJnZXQsIGtleSwgc3JjW2tleV0sIHNhZmUpO1xuICByZXR1cm4gdGFyZ2V0O1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0LCBDb25zdHJ1Y3RvciwgbmFtZSwgZm9yYmlkZGVuRmllbGQpIHtcbiAgaWYgKCEoaXQgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikgfHwgKGZvcmJpZGRlbkZpZWxkICE9PSB1bmRlZmluZWQgJiYgZm9yYmlkZGVuRmllbGQgaW4gaXQpKSB7XG4gICAgdGhyb3cgVHlwZUVycm9yKG5hbWUgKyAnOiBpbmNvcnJlY3QgaW52b2NhdGlvbiEnKTtcbiAgfSByZXR1cm4gaXQ7XG59O1xuIiwiLy8gY2FsbCBzb21ldGhpbmcgb24gaXRlcmF0b3Igc3RlcCB3aXRoIHNhZmUgY2xvc2luZyBvbiBlcnJvclxudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdGVyYXRvciwgZm4sIHZhbHVlLCBlbnRyaWVzKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGVudHJpZXMgPyBmbihhbk9iamVjdCh2YWx1ZSlbMF0sIHZhbHVlWzFdKSA6IGZuKHZhbHVlKTtcbiAgLy8gNy40LjYgSXRlcmF0b3JDbG9zZShpdGVyYXRvciwgY29tcGxldGlvbilcbiAgfSBjYXRjaCAoZSkge1xuICAgIHZhciByZXQgPSBpdGVyYXRvclsncmV0dXJuJ107XG4gICAgaWYgKHJldCAhPT0gdW5kZWZpbmVkKSBhbk9iamVjdChyZXQuY2FsbChpdGVyYXRvcikpO1xuICAgIHRocm93IGU7XG4gIH1cbn07XG4iLCIvLyBjaGVjayBvbiBkZWZhdWx0IEFycmF5IGl0ZXJhdG9yXG52YXIgSXRlcmF0b3JzID0gcmVxdWlyZSgnLi9faXRlcmF0b3JzJyk7XG52YXIgSVRFUkFUT1IgPSByZXF1aXJlKCcuL193a3MnKSgnaXRlcmF0b3InKTtcbnZhciBBcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaXQgIT09IHVuZGVmaW5lZCAmJiAoSXRlcmF0b3JzLkFycmF5ID09PSBpdCB8fCBBcnJheVByb3RvW0lURVJBVE9SXSA9PT0gaXQpO1xufTtcbiIsInZhciBjbGFzc29mID0gcmVxdWlyZSgnLi9fY2xhc3NvZicpO1xudmFyIElURVJBVE9SID0gcmVxdWlyZSgnLi9fd2tzJykoJ2l0ZXJhdG9yJyk7XG52YXIgSXRlcmF0b3JzID0gcmVxdWlyZSgnLi9faXRlcmF0b3JzJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2NvcmUnKS5nZXRJdGVyYXRvck1ldGhvZCA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAoaXQgIT0gdW5kZWZpbmVkKSByZXR1cm4gaXRbSVRFUkFUT1JdXG4gICAgfHwgaXRbJ0BAaXRlcmF0b3InXVxuICAgIHx8IEl0ZXJhdG9yc1tjbGFzc29mKGl0KV07XG59O1xuIiwidmFyIGN0eCA9IHJlcXVpcmUoJy4vX2N0eCcpO1xudmFyIGNhbGwgPSByZXF1aXJlKCcuL19pdGVyLWNhbGwnKTtcbnZhciBpc0FycmF5SXRlciA9IHJlcXVpcmUoJy4vX2lzLWFycmF5LWl0ZXInKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG52YXIgZ2V0SXRlckZuID0gcmVxdWlyZSgnLi9jb3JlLmdldC1pdGVyYXRvci1tZXRob2QnKTtcbnZhciBCUkVBSyA9IHt9O1xudmFyIFJFVFVSTiA9IHt9O1xudmFyIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdGVyYWJsZSwgZW50cmllcywgZm4sIHRoYXQsIElURVJBVE9SKSB7XG4gIHZhciBpdGVyRm4gPSBJVEVSQVRPUiA/IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGl0ZXJhYmxlOyB9IDogZ2V0SXRlckZuKGl0ZXJhYmxlKTtcbiAgdmFyIGYgPSBjdHgoZm4sIHRoYXQsIGVudHJpZXMgPyAyIDogMSk7XG4gIHZhciBpbmRleCA9IDA7XG4gIHZhciBsZW5ndGgsIHN0ZXAsIGl0ZXJhdG9yLCByZXN1bHQ7XG4gIGlmICh0eXBlb2YgaXRlckZuICE9ICdmdW5jdGlvbicpIHRocm93IFR5cGVFcnJvcihpdGVyYWJsZSArICcgaXMgbm90IGl0ZXJhYmxlIScpO1xuICAvLyBmYXN0IGNhc2UgZm9yIGFycmF5cyB3aXRoIGRlZmF1bHQgaXRlcmF0b3JcbiAgaWYgKGlzQXJyYXlJdGVyKGl0ZXJGbikpIGZvciAobGVuZ3RoID0gdG9MZW5ndGgoaXRlcmFibGUubGVuZ3RoKTsgbGVuZ3RoID4gaW5kZXg7IGluZGV4KyspIHtcbiAgICByZXN1bHQgPSBlbnRyaWVzID8gZihhbk9iamVjdChzdGVwID0gaXRlcmFibGVbaW5kZXhdKVswXSwgc3RlcFsxXSkgOiBmKGl0ZXJhYmxlW2luZGV4XSk7XG4gICAgaWYgKHJlc3VsdCA9PT0gQlJFQUsgfHwgcmVzdWx0ID09PSBSRVRVUk4pIHJldHVybiByZXN1bHQ7XG4gIH0gZWxzZSBmb3IgKGl0ZXJhdG9yID0gaXRlckZuLmNhbGwoaXRlcmFibGUpOyAhKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmU7KSB7XG4gICAgcmVzdWx0ID0gY2FsbChpdGVyYXRvciwgZiwgc3RlcC52YWx1ZSwgZW50cmllcyk7XG4gICAgaWYgKHJlc3VsdCA9PT0gQlJFQUsgfHwgcmVzdWx0ID09PSBSRVRVUk4pIHJldHVybiByZXN1bHQ7XG4gIH1cbn07XG5leHBvcnRzLkJSRUFLID0gQlJFQUs7XG5leHBvcnRzLlJFVFVSTiA9IFJFVFVSTjtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbnZhciBkUCA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpO1xudmFyIERFU0NSSVBUT1JTID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKTtcbnZhciBTUEVDSUVTID0gcmVxdWlyZSgnLi9fd2tzJykoJ3NwZWNpZXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoS0VZKSB7XG4gIHZhciBDID0gZ2xvYmFsW0tFWV07XG4gIGlmIChERVNDUklQVE9SUyAmJiBDICYmICFDW1NQRUNJRVNdKSBkUC5mKEMsIFNQRUNJRVMsIHtcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9XG4gIH0pO1xufTtcbiIsInZhciBNRVRBID0gcmVxdWlyZSgnLi9fdWlkJykoJ21ldGEnKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xudmFyIGhhcyA9IHJlcXVpcmUoJy4vX2hhcycpO1xudmFyIHNldERlc2MgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKS5mO1xudmFyIGlkID0gMDtcbnZhciBpc0V4dGVuc2libGUgPSBPYmplY3QuaXNFeHRlbnNpYmxlIHx8IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRydWU7XG59O1xudmFyIEZSRUVaRSA9ICFyZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGlzRXh0ZW5zaWJsZShPYmplY3QucHJldmVudEV4dGVuc2lvbnMoe30pKTtcbn0pO1xudmFyIHNldE1ldGEgPSBmdW5jdGlvbiAoaXQpIHtcbiAgc2V0RGVzYyhpdCwgTUVUQSwgeyB2YWx1ZToge1xuICAgIGk6ICdPJyArICsraWQsIC8vIG9iamVjdCBJRFxuICAgIHc6IHt9ICAgICAgICAgIC8vIHdlYWsgY29sbGVjdGlvbnMgSURzXG4gIH0gfSk7XG59O1xudmFyIGZhc3RLZXkgPSBmdW5jdGlvbiAoaXQsIGNyZWF0ZSkge1xuICAvLyByZXR1cm4gcHJpbWl0aXZlIHdpdGggcHJlZml4XG4gIGlmICghaXNPYmplY3QoaXQpKSByZXR1cm4gdHlwZW9mIGl0ID09ICdzeW1ib2wnID8gaXQgOiAodHlwZW9mIGl0ID09ICdzdHJpbmcnID8gJ1MnIDogJ1AnKSArIGl0O1xuICBpZiAoIWhhcyhpdCwgTUVUQSkpIHtcbiAgICAvLyBjYW4ndCBzZXQgbWV0YWRhdGEgdG8gdW5jYXVnaHQgZnJvemVuIG9iamVjdFxuICAgIGlmICghaXNFeHRlbnNpYmxlKGl0KSkgcmV0dXJuICdGJztcbiAgICAvLyBub3QgbmVjZXNzYXJ5IHRvIGFkZCBtZXRhZGF0YVxuICAgIGlmICghY3JlYXRlKSByZXR1cm4gJ0UnO1xuICAgIC8vIGFkZCBtaXNzaW5nIG1ldGFkYXRhXG4gICAgc2V0TWV0YShpdCk7XG4gIC8vIHJldHVybiBvYmplY3QgSURcbiAgfSByZXR1cm4gaXRbTUVUQV0uaTtcbn07XG52YXIgZ2V0V2VhayA9IGZ1bmN0aW9uIChpdCwgY3JlYXRlKSB7XG4gIGlmICghaGFzKGl0LCBNRVRBKSkge1xuICAgIC8vIGNhbid0IHNldCBtZXRhZGF0YSB0byB1bmNhdWdodCBmcm96ZW4gb2JqZWN0XG4gICAgaWYgKCFpc0V4dGVuc2libGUoaXQpKSByZXR1cm4gdHJ1ZTtcbiAgICAvLyBub3QgbmVjZXNzYXJ5IHRvIGFkZCBtZXRhZGF0YVxuICAgIGlmICghY3JlYXRlKSByZXR1cm4gZmFsc2U7XG4gICAgLy8gYWRkIG1pc3NpbmcgbWV0YWRhdGFcbiAgICBzZXRNZXRhKGl0KTtcbiAgLy8gcmV0dXJuIGhhc2ggd2VhayBjb2xsZWN0aW9ucyBJRHNcbiAgfSByZXR1cm4gaXRbTUVUQV0udztcbn07XG4vLyBhZGQgbWV0YWRhdGEgb24gZnJlZXplLWZhbWlseSBtZXRob2RzIGNhbGxpbmdcbnZhciBvbkZyZWV6ZSA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAoRlJFRVpFICYmIG1ldGEuTkVFRCAmJiBpc0V4dGVuc2libGUoaXQpICYmICFoYXMoaXQsIE1FVEEpKSBzZXRNZXRhKGl0KTtcbiAgcmV0dXJuIGl0O1xufTtcbnZhciBtZXRhID0gbW9kdWxlLmV4cG9ydHMgPSB7XG4gIEtFWTogTUVUQSxcbiAgTkVFRDogZmFsc2UsXG4gIGZhc3RLZXk6IGZhc3RLZXksXG4gIGdldFdlYWs6IGdldFdlYWssXG4gIG9uRnJlZXplOiBvbkZyZWV6ZVxufTtcbiIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQsIFRZUEUpIHtcbiAgaWYgKCFpc09iamVjdChpdCkgfHwgaXQuX3QgIT09IFRZUEUpIHRocm93IFR5cGVFcnJvcignSW5jb21wYXRpYmxlIHJlY2VpdmVyLCAnICsgVFlQRSArICcgcmVxdWlyZWQhJyk7XG4gIHJldHVybiBpdDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgZFAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKS5mO1xudmFyIGNyZWF0ZSA9IHJlcXVpcmUoJy4vX29iamVjdC1jcmVhdGUnKTtcbnZhciByZWRlZmluZUFsbCA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lLWFsbCcpO1xudmFyIGN0eCA9IHJlcXVpcmUoJy4vX2N0eCcpO1xudmFyIGFuSW5zdGFuY2UgPSByZXF1aXJlKCcuL19hbi1pbnN0YW5jZScpO1xudmFyIGZvck9mID0gcmVxdWlyZSgnLi9fZm9yLW9mJyk7XG52YXIgJGl0ZXJEZWZpbmUgPSByZXF1aXJlKCcuL19pdGVyLWRlZmluZScpO1xudmFyIHN0ZXAgPSByZXF1aXJlKCcuL19pdGVyLXN0ZXAnKTtcbnZhciBzZXRTcGVjaWVzID0gcmVxdWlyZSgnLi9fc2V0LXNwZWNpZXMnKTtcbnZhciBERVNDUklQVE9SUyA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJyk7XG52YXIgZmFzdEtleSA9IHJlcXVpcmUoJy4vX21ldGEnKS5mYXN0S2V5O1xudmFyIHZhbGlkYXRlID0gcmVxdWlyZSgnLi9fdmFsaWRhdGUtY29sbGVjdGlvbicpO1xudmFyIFNJWkUgPSBERVNDUklQVE9SUyA/ICdfcycgOiAnc2l6ZSc7XG5cbnZhciBnZXRFbnRyeSA9IGZ1bmN0aW9uICh0aGF0LCBrZXkpIHtcbiAgLy8gZmFzdCBjYXNlXG4gIHZhciBpbmRleCA9IGZhc3RLZXkoa2V5KTtcbiAgdmFyIGVudHJ5O1xuICBpZiAoaW5kZXggIT09ICdGJykgcmV0dXJuIHRoYXQuX2lbaW5kZXhdO1xuICAvLyBmcm96ZW4gb2JqZWN0IGNhc2VcbiAgZm9yIChlbnRyeSA9IHRoYXQuX2Y7IGVudHJ5OyBlbnRyeSA9IGVudHJ5Lm4pIHtcbiAgICBpZiAoZW50cnkuayA9PSBrZXkpIHJldHVybiBlbnRyeTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGdldENvbnN0cnVjdG9yOiBmdW5jdGlvbiAod3JhcHBlciwgTkFNRSwgSVNfTUFQLCBBRERFUikge1xuICAgIHZhciBDID0gd3JhcHBlcihmdW5jdGlvbiAodGhhdCwgaXRlcmFibGUpIHtcbiAgICAgIGFuSW5zdGFuY2UodGhhdCwgQywgTkFNRSwgJ19pJyk7XG4gICAgICB0aGF0Ll90ID0gTkFNRTsgICAgICAgICAvLyBjb2xsZWN0aW9uIHR5cGVcbiAgICAgIHRoYXQuX2kgPSBjcmVhdGUobnVsbCk7IC8vIGluZGV4XG4gICAgICB0aGF0Ll9mID0gdW5kZWZpbmVkOyAgICAvLyBmaXJzdCBlbnRyeVxuICAgICAgdGhhdC5fbCA9IHVuZGVmaW5lZDsgICAgLy8gbGFzdCBlbnRyeVxuICAgICAgdGhhdFtTSVpFXSA9IDA7ICAgICAgICAgLy8gc2l6ZVxuICAgICAgaWYgKGl0ZXJhYmxlICE9IHVuZGVmaW5lZCkgZm9yT2YoaXRlcmFibGUsIElTX01BUCwgdGhhdFtBRERFUl0sIHRoYXQpO1xuICAgIH0pO1xuICAgIHJlZGVmaW5lQWxsKEMucHJvdG90eXBlLCB7XG4gICAgICAvLyAyMy4xLjMuMSBNYXAucHJvdG90eXBlLmNsZWFyKClcbiAgICAgIC8vIDIzLjIuMy4yIFNldC5wcm90b3R5cGUuY2xlYXIoKVxuICAgICAgY2xlYXI6IGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgICAgICBmb3IgKHZhciB0aGF0ID0gdmFsaWRhdGUodGhpcywgTkFNRSksIGRhdGEgPSB0aGF0Ll9pLCBlbnRyeSA9IHRoYXQuX2Y7IGVudHJ5OyBlbnRyeSA9IGVudHJ5Lm4pIHtcbiAgICAgICAgICBlbnRyeS5yID0gdHJ1ZTtcbiAgICAgICAgICBpZiAoZW50cnkucCkgZW50cnkucCA9IGVudHJ5LnAubiA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBkZWxldGUgZGF0YVtlbnRyeS5pXTtcbiAgICAgICAgfVxuICAgICAgICB0aGF0Ll9mID0gdGhhdC5fbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhhdFtTSVpFXSA9IDA7XG4gICAgICB9LFxuICAgICAgLy8gMjMuMS4zLjMgTWFwLnByb3RvdHlwZS5kZWxldGUoa2V5KVxuICAgICAgLy8gMjMuMi4zLjQgU2V0LnByb3RvdHlwZS5kZWxldGUodmFsdWUpXG4gICAgICAnZGVsZXRlJzogZnVuY3Rpb24gKGtleSkge1xuICAgICAgICB2YXIgdGhhdCA9IHZhbGlkYXRlKHRoaXMsIE5BTUUpO1xuICAgICAgICB2YXIgZW50cnkgPSBnZXRFbnRyeSh0aGF0LCBrZXkpO1xuICAgICAgICBpZiAoZW50cnkpIHtcbiAgICAgICAgICB2YXIgbmV4dCA9IGVudHJ5Lm47XG4gICAgICAgICAgdmFyIHByZXYgPSBlbnRyeS5wO1xuICAgICAgICAgIGRlbGV0ZSB0aGF0Ll9pW2VudHJ5LmldO1xuICAgICAgICAgIGVudHJ5LnIgPSB0cnVlO1xuICAgICAgICAgIGlmIChwcmV2KSBwcmV2Lm4gPSBuZXh0O1xuICAgICAgICAgIGlmIChuZXh0KSBuZXh0LnAgPSBwcmV2O1xuICAgICAgICAgIGlmICh0aGF0Ll9mID09IGVudHJ5KSB0aGF0Ll9mID0gbmV4dDtcbiAgICAgICAgICBpZiAodGhhdC5fbCA9PSBlbnRyeSkgdGhhdC5fbCA9IHByZXY7XG4gICAgICAgICAgdGhhdFtTSVpFXS0tO1xuICAgICAgICB9IHJldHVybiAhIWVudHJ5O1xuICAgICAgfSxcbiAgICAgIC8vIDIzLjIuMy42IFNldC5wcm90b3R5cGUuZm9yRWFjaChjYWxsYmFja2ZuLCB0aGlzQXJnID0gdW5kZWZpbmVkKVxuICAgICAgLy8gMjMuMS4zLjUgTWFwLnByb3RvdHlwZS5mb3JFYWNoKGNhbGxiYWNrZm4sIHRoaXNBcmcgPSB1bmRlZmluZWQpXG4gICAgICBmb3JFYWNoOiBmdW5jdGlvbiBmb3JFYWNoKGNhbGxiYWNrZm4gLyogLCB0aGF0ID0gdW5kZWZpbmVkICovKSB7XG4gICAgICAgIHZhbGlkYXRlKHRoaXMsIE5BTUUpO1xuICAgICAgICB2YXIgZiA9IGN0eChjYWxsYmFja2ZuLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCwgMyk7XG4gICAgICAgIHZhciBlbnRyeTtcbiAgICAgICAgd2hpbGUgKGVudHJ5ID0gZW50cnkgPyBlbnRyeS5uIDogdGhpcy5fZikge1xuICAgICAgICAgIGYoZW50cnkudiwgZW50cnkuaywgdGhpcyk7XG4gICAgICAgICAgLy8gcmV2ZXJ0IHRvIHRoZSBsYXN0IGV4aXN0aW5nIGVudHJ5XG4gICAgICAgICAgd2hpbGUgKGVudHJ5ICYmIGVudHJ5LnIpIGVudHJ5ID0gZW50cnkucDtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIC8vIDIzLjEuMy43IE1hcC5wcm90b3R5cGUuaGFzKGtleSlcbiAgICAgIC8vIDIzLjIuMy43IFNldC5wcm90b3R5cGUuaGFzKHZhbHVlKVxuICAgICAgaGFzOiBmdW5jdGlvbiBoYXMoa2V5KSB7XG4gICAgICAgIHJldHVybiAhIWdldEVudHJ5KHZhbGlkYXRlKHRoaXMsIE5BTUUpLCBrZXkpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChERVNDUklQVE9SUykgZFAoQy5wcm90b3R5cGUsICdzaXplJywge1xuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB2YWxpZGF0ZSh0aGlzLCBOQU1FKVtTSVpFXTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gQztcbiAgfSxcbiAgZGVmOiBmdW5jdGlvbiAodGhhdCwga2V5LCB2YWx1ZSkge1xuICAgIHZhciBlbnRyeSA9IGdldEVudHJ5KHRoYXQsIGtleSk7XG4gICAgdmFyIHByZXYsIGluZGV4O1xuICAgIC8vIGNoYW5nZSBleGlzdGluZyBlbnRyeVxuICAgIGlmIChlbnRyeSkge1xuICAgICAgZW50cnkudiA9IHZhbHVlO1xuICAgIC8vIGNyZWF0ZSBuZXcgZW50cnlcbiAgICB9IGVsc2Uge1xuICAgICAgdGhhdC5fbCA9IGVudHJ5ID0ge1xuICAgICAgICBpOiBpbmRleCA9IGZhc3RLZXkoa2V5LCB0cnVlKSwgLy8gPC0gaW5kZXhcbiAgICAgICAgazoga2V5LCAgICAgICAgICAgICAgICAgICAgICAgIC8vIDwtIGtleVxuICAgICAgICB2OiB2YWx1ZSwgICAgICAgICAgICAgICAgICAgICAgLy8gPC0gdmFsdWVcbiAgICAgICAgcDogcHJldiA9IHRoYXQuX2wsICAgICAgICAgICAgIC8vIDwtIHByZXZpb3VzIGVudHJ5XG4gICAgICAgIG46IHVuZGVmaW5lZCwgICAgICAgICAgICAgICAgICAvLyA8LSBuZXh0IGVudHJ5XG4gICAgICAgIHI6IGZhbHNlICAgICAgICAgICAgICAgICAgICAgICAvLyA8LSByZW1vdmVkXG4gICAgICB9O1xuICAgICAgaWYgKCF0aGF0Ll9mKSB0aGF0Ll9mID0gZW50cnk7XG4gICAgICBpZiAocHJldikgcHJldi5uID0gZW50cnk7XG4gICAgICB0aGF0W1NJWkVdKys7XG4gICAgICAvLyBhZGQgdG8gaW5kZXhcbiAgICAgIGlmIChpbmRleCAhPT0gJ0YnKSB0aGF0Ll9pW2luZGV4XSA9IGVudHJ5O1xuICAgIH0gcmV0dXJuIHRoYXQ7XG4gIH0sXG4gIGdldEVudHJ5OiBnZXRFbnRyeSxcbiAgc2V0U3Ryb25nOiBmdW5jdGlvbiAoQywgTkFNRSwgSVNfTUFQKSB7XG4gICAgLy8gYWRkIC5rZXlzLCAudmFsdWVzLCAuZW50cmllcywgW0BAaXRlcmF0b3JdXG4gICAgLy8gMjMuMS4zLjQsIDIzLjEuMy44LCAyMy4xLjMuMTEsIDIzLjEuMy4xMiwgMjMuMi4zLjUsIDIzLjIuMy44LCAyMy4yLjMuMTAsIDIzLjIuMy4xMVxuICAgICRpdGVyRGVmaW5lKEMsIE5BTUUsIGZ1bmN0aW9uIChpdGVyYXRlZCwga2luZCkge1xuICAgICAgdGhpcy5fdCA9IHZhbGlkYXRlKGl0ZXJhdGVkLCBOQU1FKTsgLy8gdGFyZ2V0XG4gICAgICB0aGlzLl9rID0ga2luZDsgICAgICAgICAgICAgICAgICAgICAvLyBraW5kXG4gICAgICB0aGlzLl9sID0gdW5kZWZpbmVkOyAgICAgICAgICAgICAgICAvLyBwcmV2aW91c1xuICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgIHZhciBraW5kID0gdGhhdC5faztcbiAgICAgIHZhciBlbnRyeSA9IHRoYXQuX2w7XG4gICAgICAvLyByZXZlcnQgdG8gdGhlIGxhc3QgZXhpc3RpbmcgZW50cnlcbiAgICAgIHdoaWxlIChlbnRyeSAmJiBlbnRyeS5yKSBlbnRyeSA9IGVudHJ5LnA7XG4gICAgICAvLyBnZXQgbmV4dCBlbnRyeVxuICAgICAgaWYgKCF0aGF0Ll90IHx8ICEodGhhdC5fbCA9IGVudHJ5ID0gZW50cnkgPyBlbnRyeS5uIDogdGhhdC5fdC5fZikpIHtcbiAgICAgICAgLy8gb3IgZmluaXNoIHRoZSBpdGVyYXRpb25cbiAgICAgICAgdGhhdC5fdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIHN0ZXAoMSk7XG4gICAgICB9XG4gICAgICAvLyByZXR1cm4gc3RlcCBieSBraW5kXG4gICAgICBpZiAoa2luZCA9PSAna2V5cycpIHJldHVybiBzdGVwKDAsIGVudHJ5LmspO1xuICAgICAgaWYgKGtpbmQgPT0gJ3ZhbHVlcycpIHJldHVybiBzdGVwKDAsIGVudHJ5LnYpO1xuICAgICAgcmV0dXJuIHN0ZXAoMCwgW2VudHJ5LmssIGVudHJ5LnZdKTtcbiAgICB9LCBJU19NQVAgPyAnZW50cmllcycgOiAndmFsdWVzJywgIUlTX01BUCwgdHJ1ZSk7XG5cbiAgICAvLyBhZGQgW0BAc3BlY2llc10sIDIzLjEuMi4yLCAyMy4yLjIuMlxuICAgIHNldFNwZWNpZXMoTkFNRSk7XG4gIH1cbn07XG4iLCJ2YXIgSVRFUkFUT1IgPSByZXF1aXJlKCcuL193a3MnKSgnaXRlcmF0b3InKTtcbnZhciBTQUZFX0NMT1NJTkcgPSBmYWxzZTtcblxudHJ5IHtcbiAgdmFyIHJpdGVyID0gWzddW0lURVJBVE9SXSgpO1xuICByaXRlclsncmV0dXJuJ10gPSBmdW5jdGlvbiAoKSB7IFNBRkVfQ0xPU0lORyA9IHRydWU7IH07XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby10aHJvdy1saXRlcmFsXG4gIEFycmF5LmZyb20ocml0ZXIsIGZ1bmN0aW9uICgpIHsgdGhyb3cgMjsgfSk7XG59IGNhdGNoIChlKSB7IC8qIGVtcHR5ICovIH1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZXhlYywgc2tpcENsb3NpbmcpIHtcbiAgaWYgKCFza2lwQ2xvc2luZyAmJiAhU0FGRV9DTE9TSU5HKSByZXR1cm4gZmFsc2U7XG4gIHZhciBzYWZlID0gZmFsc2U7XG4gIHRyeSB7XG4gICAgdmFyIGFyciA9IFs3XTtcbiAgICB2YXIgaXRlciA9IGFycltJVEVSQVRPUl0oKTtcbiAgICBpdGVyLm5leHQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB7IGRvbmU6IHNhZmUgPSB0cnVlIH07IH07XG4gICAgYXJyW0lURVJBVE9SXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGl0ZXI7IH07XG4gICAgZXhlYyhhcnIpO1xuICB9IGNhdGNoIChlKSB7IC8qIGVtcHR5ICovIH1cbiAgcmV0dXJuIHNhZmU7XG59O1xuIiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgc2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKCcuL19zZXQtcHJvdG8nKS5zZXQ7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh0aGF0LCB0YXJnZXQsIEMpIHtcbiAgdmFyIFMgPSB0YXJnZXQuY29uc3RydWN0b3I7XG4gIHZhciBQO1xuICBpZiAoUyAhPT0gQyAmJiB0eXBlb2YgUyA9PSAnZnVuY3Rpb24nICYmIChQID0gUy5wcm90b3R5cGUpICE9PSBDLnByb3RvdHlwZSAmJiBpc09iamVjdChQKSAmJiBzZXRQcm90b3R5cGVPZikge1xuICAgIHNldFByb3RvdHlwZU9mKHRoYXQsIFApO1xuICB9IHJldHVybiB0aGF0O1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgcmVkZWZpbmUgPSByZXF1aXJlKCcuL19yZWRlZmluZScpO1xudmFyIHJlZGVmaW5lQWxsID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUtYWxsJyk7XG52YXIgbWV0YSA9IHJlcXVpcmUoJy4vX21ldGEnKTtcbnZhciBmb3JPZiA9IHJlcXVpcmUoJy4vX2Zvci1vZicpO1xudmFyIGFuSW5zdGFuY2UgPSByZXF1aXJlKCcuL19hbi1pbnN0YW5jZScpO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgZmFpbHMgPSByZXF1aXJlKCcuL19mYWlscycpO1xudmFyICRpdGVyRGV0ZWN0ID0gcmVxdWlyZSgnLi9faXRlci1kZXRlY3QnKTtcbnZhciBzZXRUb1N0cmluZ1RhZyA9IHJlcXVpcmUoJy4vX3NldC10by1zdHJpbmctdGFnJyk7XG52YXIgaW5oZXJpdElmUmVxdWlyZWQgPSByZXF1aXJlKCcuL19pbmhlcml0LWlmLXJlcXVpcmVkJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKE5BTUUsIHdyYXBwZXIsIG1ldGhvZHMsIGNvbW1vbiwgSVNfTUFQLCBJU19XRUFLKSB7XG4gIHZhciBCYXNlID0gZ2xvYmFsW05BTUVdO1xuICB2YXIgQyA9IEJhc2U7XG4gIHZhciBBRERFUiA9IElTX01BUCA/ICdzZXQnIDogJ2FkZCc7XG4gIHZhciBwcm90byA9IEMgJiYgQy5wcm90b3R5cGU7XG4gIHZhciBPID0ge307XG4gIHZhciBmaXhNZXRob2QgPSBmdW5jdGlvbiAoS0VZKSB7XG4gICAgdmFyIGZuID0gcHJvdG9bS0VZXTtcbiAgICByZWRlZmluZShwcm90bywgS0VZLFxuICAgICAgS0VZID09ICdkZWxldGUnID8gZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgcmV0dXJuIElTX1dFQUsgJiYgIWlzT2JqZWN0KGEpID8gZmFsc2UgOiBmbi5jYWxsKHRoaXMsIGEgPT09IDAgPyAwIDogYSk7XG4gICAgICB9IDogS0VZID09ICdoYXMnID8gZnVuY3Rpb24gaGFzKGEpIHtcbiAgICAgICAgcmV0dXJuIElTX1dFQUsgJiYgIWlzT2JqZWN0KGEpID8gZmFsc2UgOiBmbi5jYWxsKHRoaXMsIGEgPT09IDAgPyAwIDogYSk7XG4gICAgICB9IDogS0VZID09ICdnZXQnID8gZnVuY3Rpb24gZ2V0KGEpIHtcbiAgICAgICAgcmV0dXJuIElTX1dFQUsgJiYgIWlzT2JqZWN0KGEpID8gdW5kZWZpbmVkIDogZm4uY2FsbCh0aGlzLCBhID09PSAwID8gMCA6IGEpO1xuICAgICAgfSA6IEtFWSA9PSAnYWRkJyA/IGZ1bmN0aW9uIGFkZChhKSB7IGZuLmNhbGwodGhpcywgYSA9PT0gMCA/IDAgOiBhKTsgcmV0dXJuIHRoaXM7IH1cbiAgICAgICAgOiBmdW5jdGlvbiBzZXQoYSwgYikgeyBmbi5jYWxsKHRoaXMsIGEgPT09IDAgPyAwIDogYSwgYik7IHJldHVybiB0aGlzOyB9XG4gICAgKTtcbiAgfTtcbiAgaWYgKHR5cGVvZiBDICE9ICdmdW5jdGlvbicgfHwgIShJU19XRUFLIHx8IHByb3RvLmZvckVhY2ggJiYgIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgICBuZXcgQygpLmVudHJpZXMoKS5uZXh0KCk7XG4gIH0pKSkge1xuICAgIC8vIGNyZWF0ZSBjb2xsZWN0aW9uIGNvbnN0cnVjdG9yXG4gICAgQyA9IGNvbW1vbi5nZXRDb25zdHJ1Y3Rvcih3cmFwcGVyLCBOQU1FLCBJU19NQVAsIEFEREVSKTtcbiAgICByZWRlZmluZUFsbChDLnByb3RvdHlwZSwgbWV0aG9kcyk7XG4gICAgbWV0YS5ORUVEID0gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgaW5zdGFuY2UgPSBuZXcgQygpO1xuICAgIC8vIGVhcmx5IGltcGxlbWVudGF0aW9ucyBub3Qgc3VwcG9ydHMgY2hhaW5pbmdcbiAgICB2YXIgSEFTTlRfQ0hBSU5JTkcgPSBpbnN0YW5jZVtBRERFUl0oSVNfV0VBSyA/IHt9IDogLTAsIDEpICE9IGluc3RhbmNlO1xuICAgIC8vIFY4IH4gIENocm9taXVtIDQwLSB3ZWFrLWNvbGxlY3Rpb25zIHRocm93cyBvbiBwcmltaXRpdmVzLCBidXQgc2hvdWxkIHJldHVybiBmYWxzZVxuICAgIHZhciBUSFJPV1NfT05fUFJJTUlUSVZFUyA9IGZhaWxzKGZ1bmN0aW9uICgpIHsgaW5zdGFuY2UuaGFzKDEpOyB9KTtcbiAgICAvLyBtb3N0IGVhcmx5IGltcGxlbWVudGF0aW9ucyBkb2Vzbid0IHN1cHBvcnRzIGl0ZXJhYmxlcywgbW9zdCBtb2Rlcm4gLSBub3QgY2xvc2UgaXQgY29ycmVjdGx5XG4gICAgdmFyIEFDQ0VQVF9JVEVSQUJMRVMgPSAkaXRlckRldGVjdChmdW5jdGlvbiAoaXRlcikgeyBuZXcgQyhpdGVyKTsgfSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3XG4gICAgLy8gZm9yIGVhcmx5IGltcGxlbWVudGF0aW9ucyAtMCBhbmQgKzAgbm90IHRoZSBzYW1lXG4gICAgdmFyIEJVR0dZX1pFUk8gPSAhSVNfV0VBSyAmJiBmYWlscyhmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBWOCB+IENocm9taXVtIDQyLSBmYWlscyBvbmx5IHdpdGggNSsgZWxlbWVudHNcbiAgICAgIHZhciAkaW5zdGFuY2UgPSBuZXcgQygpO1xuICAgICAgdmFyIGluZGV4ID0gNTtcbiAgICAgIHdoaWxlIChpbmRleC0tKSAkaW5zdGFuY2VbQURERVJdKGluZGV4LCBpbmRleCk7XG4gICAgICByZXR1cm4gISRpbnN0YW5jZS5oYXMoLTApO1xuICAgIH0pO1xuICAgIGlmICghQUNDRVBUX0lURVJBQkxFUykge1xuICAgICAgQyA9IHdyYXBwZXIoZnVuY3Rpb24gKHRhcmdldCwgaXRlcmFibGUpIHtcbiAgICAgICAgYW5JbnN0YW5jZSh0YXJnZXQsIEMsIE5BTUUpO1xuICAgICAgICB2YXIgdGhhdCA9IGluaGVyaXRJZlJlcXVpcmVkKG5ldyBCYXNlKCksIHRhcmdldCwgQyk7XG4gICAgICAgIGlmIChpdGVyYWJsZSAhPSB1bmRlZmluZWQpIGZvck9mKGl0ZXJhYmxlLCBJU19NQVAsIHRoYXRbQURERVJdLCB0aGF0KTtcbiAgICAgICAgcmV0dXJuIHRoYXQ7XG4gICAgICB9KTtcbiAgICAgIEMucHJvdG90eXBlID0gcHJvdG87XG4gICAgICBwcm90by5jb25zdHJ1Y3RvciA9IEM7XG4gICAgfVxuICAgIGlmIChUSFJPV1NfT05fUFJJTUlUSVZFUyB8fCBCVUdHWV9aRVJPKSB7XG4gICAgICBmaXhNZXRob2QoJ2RlbGV0ZScpO1xuICAgICAgZml4TWV0aG9kKCdoYXMnKTtcbiAgICAgIElTX01BUCAmJiBmaXhNZXRob2QoJ2dldCcpO1xuICAgIH1cbiAgICBpZiAoQlVHR1lfWkVSTyB8fCBIQVNOVF9DSEFJTklORykgZml4TWV0aG9kKEFEREVSKTtcbiAgICAvLyB3ZWFrIGNvbGxlY3Rpb25zIHNob3VsZCBub3QgY29udGFpbnMgLmNsZWFyIG1ldGhvZFxuICAgIGlmIChJU19XRUFLICYmIHByb3RvLmNsZWFyKSBkZWxldGUgcHJvdG8uY2xlYXI7XG4gIH1cblxuICBzZXRUb1N0cmluZ1RhZyhDLCBOQU1FKTtcblxuICBPW05BTUVdID0gQztcbiAgJGV4cG9ydCgkZXhwb3J0LkcgKyAkZXhwb3J0LlcgKyAkZXhwb3J0LkYgKiAoQyAhPSBCYXNlKSwgTyk7XG5cbiAgaWYgKCFJU19XRUFLKSBjb21tb24uc2V0U3Ryb25nKEMsIE5BTUUsIElTX01BUCk7XG5cbiAgcmV0dXJuIEM7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIHN0cm9uZyA9IHJlcXVpcmUoJy4vX2NvbGxlY3Rpb24tc3Ryb25nJyk7XG52YXIgdmFsaWRhdGUgPSByZXF1aXJlKCcuL192YWxpZGF0ZS1jb2xsZWN0aW9uJyk7XG52YXIgU0VUID0gJ1NldCc7XG5cbi8vIDIzLjIgU2V0IE9iamVjdHNcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fY29sbGVjdGlvbicpKFNFVCwgZnVuY3Rpb24gKGdldCkge1xuICByZXR1cm4gZnVuY3Rpb24gU2V0KCkgeyByZXR1cm4gZ2V0KHRoaXMsIGFyZ3VtZW50cy5sZW5ndGggPiAwID8gYXJndW1lbnRzWzBdIDogdW5kZWZpbmVkKTsgfTtcbn0sIHtcbiAgLy8gMjMuMi4zLjEgU2V0LnByb3RvdHlwZS5hZGQodmFsdWUpXG4gIGFkZDogZnVuY3Rpb24gYWRkKHZhbHVlKSB7XG4gICAgcmV0dXJuIHN0cm9uZy5kZWYodmFsaWRhdGUodGhpcywgU0VUKSwgdmFsdWUgPSB2YWx1ZSA9PT0gMCA/IDAgOiB2YWx1ZSwgdmFsdWUpO1xuICB9XG59LCBzdHJvbmcpO1xuIiwidmFyIGZvck9mID0gcmVxdWlyZSgnLi9fZm9yLW9mJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0ZXIsIElURVJBVE9SKSB7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgZm9yT2YoaXRlciwgZmFsc2UsIHJlc3VsdC5wdXNoLCByZXN1bHQsIElURVJBVE9SKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG4iLCIvLyBodHRwczovL2dpdGh1Yi5jb20vRGF2aWRCcnVhbnQvTWFwLVNldC5wcm90b3R5cGUudG9KU09OXG52YXIgY2xhc3NvZiA9IHJlcXVpcmUoJy4vX2NsYXNzb2YnKTtcbnZhciBmcm9tID0gcmVxdWlyZSgnLi9fYXJyYXktZnJvbS1pdGVyYWJsZScpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoTkFNRSkge1xuICByZXR1cm4gZnVuY3Rpb24gdG9KU09OKCkge1xuICAgIGlmIChjbGFzc29mKHRoaXMpICE9IE5BTUUpIHRocm93IFR5cGVFcnJvcihOQU1FICsgXCIjdG9KU09OIGlzbid0IGdlbmVyaWNcIik7XG4gICAgcmV0dXJuIGZyb20odGhpcyk7XG4gIH07XG59O1xuIiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL0RhdmlkQnJ1YW50L01hcC1TZXQucHJvdG90eXBlLnRvSlNPTlxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LlIsICdTZXQnLCB7IHRvSlNPTjogcmVxdWlyZSgnLi9fY29sbGVjdGlvbi10by1qc29uJykoJ1NldCcpIH0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9wcm9wb3NhbC1zZXRtYXAtb2Zmcm9tL1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoQ09MTEVDVElPTikge1xuICAkZXhwb3J0KCRleHBvcnQuUywgQ09MTEVDVElPTiwgeyBvZjogZnVuY3Rpb24gb2YoKSB7XG4gICAgdmFyIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgdmFyIEEgPSBuZXcgQXJyYXkobGVuZ3RoKTtcbiAgICB3aGlsZSAobGVuZ3RoLS0pIEFbbGVuZ3RoXSA9IGFyZ3VtZW50c1tsZW5ndGhdO1xuICAgIHJldHVybiBuZXcgdGhpcyhBKTtcbiAgfSB9KTtcbn07XG4iLCIvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL3Byb3Bvc2FsLXNldG1hcC1vZmZyb20vI3NlYy1zZXQub2ZcbnJlcXVpcmUoJy4vX3NldC1jb2xsZWN0aW9uLW9mJykoJ1NldCcpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9wcm9wb3NhbC1zZXRtYXAtb2Zmcm9tL1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJyk7XG52YXIgY3R4ID0gcmVxdWlyZSgnLi9fY3R4Jyk7XG52YXIgZm9yT2YgPSByZXF1aXJlKCcuL19mb3Itb2YnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoQ09MTEVDVElPTikge1xuICAkZXhwb3J0KCRleHBvcnQuUywgQ09MTEVDVElPTiwgeyBmcm9tOiBmdW5jdGlvbiBmcm9tKHNvdXJjZSAvKiAsIG1hcEZuLCB0aGlzQXJnICovKSB7XG4gICAgdmFyIG1hcEZuID0gYXJndW1lbnRzWzFdO1xuICAgIHZhciBtYXBwaW5nLCBBLCBuLCBjYjtcbiAgICBhRnVuY3Rpb24odGhpcyk7XG4gICAgbWFwcGluZyA9IG1hcEZuICE9PSB1bmRlZmluZWQ7XG4gICAgaWYgKG1hcHBpbmcpIGFGdW5jdGlvbihtYXBGbik7XG4gICAgaWYgKHNvdXJjZSA9PSB1bmRlZmluZWQpIHJldHVybiBuZXcgdGhpcygpO1xuICAgIEEgPSBbXTtcbiAgICBpZiAobWFwcGluZykge1xuICAgICAgbiA9IDA7XG4gICAgICBjYiA9IGN0eChtYXBGbiwgYXJndW1lbnRzWzJdLCAyKTtcbiAgICAgIGZvck9mKHNvdXJjZSwgZmFsc2UsIGZ1bmN0aW9uIChuZXh0SXRlbSkge1xuICAgICAgICBBLnB1c2goY2IobmV4dEl0ZW0sIG4rKykpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvck9mKHNvdXJjZSwgZmFsc2UsIEEucHVzaCwgQSk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgdGhpcyhBKTtcbiAgfSB9KTtcbn07XG4iLCIvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL3Byb3Bvc2FsLXNldG1hcC1vZmZyb20vI3NlYy1zZXQuZnJvbVxucmVxdWlyZSgnLi9fc2V0LWNvbGxlY3Rpb24tZnJvbScpKCdTZXQnKTtcbiIsInJlcXVpcmUoJy4uL21vZHVsZXMvZXM2Lm9iamVjdC50by1zdHJpbmcnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM2LnN0cmluZy5pdGVyYXRvcicpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy93ZWIuZG9tLml0ZXJhYmxlJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNi5zZXQnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM3LnNldC50by1qc29uJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNy5zZXQub2YnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM3LnNldC5mcm9tJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uL21vZHVsZXMvX2NvcmUnKS5TZXQ7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgc3Ryb25nID0gcmVxdWlyZSgnLi9fY29sbGVjdGlvbi1zdHJvbmcnKTtcbnZhciB2YWxpZGF0ZSA9IHJlcXVpcmUoJy4vX3ZhbGlkYXRlLWNvbGxlY3Rpb24nKTtcbnZhciBNQVAgPSAnTWFwJztcblxuLy8gMjMuMSBNYXAgT2JqZWN0c1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19jb2xsZWN0aW9uJykoTUFQLCBmdW5jdGlvbiAoZ2V0KSB7XG4gIHJldHVybiBmdW5jdGlvbiBNYXAoKSB7IHJldHVybiBnZXQodGhpcywgYXJndW1lbnRzLmxlbmd0aCA+IDAgPyBhcmd1bWVudHNbMF0gOiB1bmRlZmluZWQpOyB9O1xufSwge1xuICAvLyAyMy4xLjMuNiBNYXAucHJvdG90eXBlLmdldChrZXkpXG4gIGdldDogZnVuY3Rpb24gZ2V0KGtleSkge1xuICAgIHZhciBlbnRyeSA9IHN0cm9uZy5nZXRFbnRyeSh2YWxpZGF0ZSh0aGlzLCBNQVApLCBrZXkpO1xuICAgIHJldHVybiBlbnRyeSAmJiBlbnRyeS52O1xuICB9LFxuICAvLyAyMy4xLjMuOSBNYXAucHJvdG90eXBlLnNldChrZXksIHZhbHVlKVxuICBzZXQ6IGZ1bmN0aW9uIHNldChrZXksIHZhbHVlKSB7XG4gICAgcmV0dXJuIHN0cm9uZy5kZWYodmFsaWRhdGUodGhpcywgTUFQKSwga2V5ID09PSAwID8gMCA6IGtleSwgdmFsdWUpO1xuICB9XG59LCBzdHJvbmcsIHRydWUpO1xuIiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL0RhdmlkQnJ1YW50L01hcC1TZXQucHJvdG90eXBlLnRvSlNPTlxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LlIsICdNYXAnLCB7IHRvSlNPTjogcmVxdWlyZSgnLi9fY29sbGVjdGlvbi10by1qc29uJykoJ01hcCcpIH0pO1xuIiwiLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9wcm9wb3NhbC1zZXRtYXAtb2Zmcm9tLyNzZWMtbWFwLm9mXG5yZXF1aXJlKCcuL19zZXQtY29sbGVjdGlvbi1vZicpKCdNYXAnKTtcbiIsIi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vcHJvcG9zYWwtc2V0bWFwLW9mZnJvbS8jc2VjLW1hcC5mcm9tXG5yZXF1aXJlKCcuL19zZXQtY29sbGVjdGlvbi1mcm9tJykoJ01hcCcpO1xuIiwicmVxdWlyZSgnLi4vbW9kdWxlcy9lczYub2JqZWN0LnRvLXN0cmluZycpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczYuc3RyaW5nLml0ZXJhdG9yJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL3dlYi5kb20uaXRlcmFibGUnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM2Lm1hcCcpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczcubWFwLnRvLWpzb24nKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM3Lm1hcC5vZicpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczcubWFwLmZyb20nKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vbW9kdWxlcy9fY29yZScpLk1hcDtcbiIsIi8vIDcuMi4yIElzQXJyYXkoYXJndW1lbnQpXG52YXIgY29mID0gcmVxdWlyZSgnLi9fY29mJyk7XG5tb2R1bGUuZXhwb3J0cyA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gaXNBcnJheShhcmcpIHtcbiAgcmV0dXJuIGNvZihhcmcpID09ICdBcnJheSc7XG59O1xuIiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgaXNBcnJheSA9IHJlcXVpcmUoJy4vX2lzLWFycmF5Jyk7XG52YXIgU1BFQ0lFUyA9IHJlcXVpcmUoJy4vX3drcycpKCdzcGVjaWVzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9yaWdpbmFsKSB7XG4gIHZhciBDO1xuICBpZiAoaXNBcnJheShvcmlnaW5hbCkpIHtcbiAgICBDID0gb3JpZ2luYWwuY29uc3RydWN0b3I7XG4gICAgLy8gY3Jvc3MtcmVhbG0gZmFsbGJhY2tcbiAgICBpZiAodHlwZW9mIEMgPT0gJ2Z1bmN0aW9uJyAmJiAoQyA9PT0gQXJyYXkgfHwgaXNBcnJheShDLnByb3RvdHlwZSkpKSBDID0gdW5kZWZpbmVkO1xuICAgIGlmIChpc09iamVjdChDKSkge1xuICAgICAgQyA9IENbU1BFQ0lFU107XG4gICAgICBpZiAoQyA9PT0gbnVsbCkgQyA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH0gcmV0dXJuIEMgPT09IHVuZGVmaW5lZCA/IEFycmF5IDogQztcbn07XG4iLCIvLyA5LjQuMi4zIEFycmF5U3BlY2llc0NyZWF0ZShvcmlnaW5hbEFycmF5LCBsZW5ndGgpXG52YXIgc3BlY2llc0NvbnN0cnVjdG9yID0gcmVxdWlyZSgnLi9fYXJyYXktc3BlY2llcy1jb25zdHJ1Y3RvcicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvcmlnaW5hbCwgbGVuZ3RoKSB7XG4gIHJldHVybiBuZXcgKHNwZWNpZXNDb25zdHJ1Y3RvcihvcmlnaW5hbCkpKGxlbmd0aCk7XG59O1xuIiwiLy8gMCAtPiBBcnJheSNmb3JFYWNoXG4vLyAxIC0+IEFycmF5I21hcFxuLy8gMiAtPiBBcnJheSNmaWx0ZXJcbi8vIDMgLT4gQXJyYXkjc29tZVxuLy8gNCAtPiBBcnJheSNldmVyeVxuLy8gNSAtPiBBcnJheSNmaW5kXG4vLyA2IC0+IEFycmF5I2ZpbmRJbmRleFxudmFyIGN0eCA9IHJlcXVpcmUoJy4vX2N0eCcpO1xudmFyIElPYmplY3QgPSByZXF1aXJlKCcuL19pb2JqZWN0Jyk7XG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xudmFyIGFzYyA9IHJlcXVpcmUoJy4vX2FycmF5LXNwZWNpZXMtY3JlYXRlJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChUWVBFLCAkY3JlYXRlKSB7XG4gIHZhciBJU19NQVAgPSBUWVBFID09IDE7XG4gIHZhciBJU19GSUxURVIgPSBUWVBFID09IDI7XG4gIHZhciBJU19TT01FID0gVFlQRSA9PSAzO1xuICB2YXIgSVNfRVZFUlkgPSBUWVBFID09IDQ7XG4gIHZhciBJU19GSU5EX0lOREVYID0gVFlQRSA9PSA2O1xuICB2YXIgTk9fSE9MRVMgPSBUWVBFID09IDUgfHwgSVNfRklORF9JTkRFWDtcbiAgdmFyIGNyZWF0ZSA9ICRjcmVhdGUgfHwgYXNjO1xuICByZXR1cm4gZnVuY3Rpb24gKCR0aGlzLCBjYWxsYmFja2ZuLCB0aGF0KSB7XG4gICAgdmFyIE8gPSB0b09iamVjdCgkdGhpcyk7XG4gICAgdmFyIHNlbGYgPSBJT2JqZWN0KE8pO1xuICAgIHZhciBmID0gY3R4KGNhbGxiYWNrZm4sIHRoYXQsIDMpO1xuICAgIHZhciBsZW5ndGggPSB0b0xlbmd0aChzZWxmLmxlbmd0aCk7XG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICB2YXIgcmVzdWx0ID0gSVNfTUFQID8gY3JlYXRlKCR0aGlzLCBsZW5ndGgpIDogSVNfRklMVEVSID8gY3JlYXRlKCR0aGlzLCAwKSA6IHVuZGVmaW5lZDtcbiAgICB2YXIgdmFsLCByZXM7XG4gICAgZm9yICg7bGVuZ3RoID4gaW5kZXg7IGluZGV4KyspIGlmIChOT19IT0xFUyB8fCBpbmRleCBpbiBzZWxmKSB7XG4gICAgICB2YWwgPSBzZWxmW2luZGV4XTtcbiAgICAgIHJlcyA9IGYodmFsLCBpbmRleCwgTyk7XG4gICAgICBpZiAoVFlQRSkge1xuICAgICAgICBpZiAoSVNfTUFQKSByZXN1bHRbaW5kZXhdID0gcmVzOyAgIC8vIG1hcFxuICAgICAgICBlbHNlIGlmIChyZXMpIHN3aXRjaCAoVFlQRSkge1xuICAgICAgICAgIGNhc2UgMzogcmV0dXJuIHRydWU7ICAgICAgICAgICAgIC8vIHNvbWVcbiAgICAgICAgICBjYXNlIDU6IHJldHVybiB2YWw7ICAgICAgICAgICAgICAvLyBmaW5kXG4gICAgICAgICAgY2FzZSA2OiByZXR1cm4gaW5kZXg7ICAgICAgICAgICAgLy8gZmluZEluZGV4XG4gICAgICAgICAgY2FzZSAyOiByZXN1bHQucHVzaCh2YWwpOyAgICAgICAgLy8gZmlsdGVyXG4gICAgICAgIH0gZWxzZSBpZiAoSVNfRVZFUlkpIHJldHVybiBmYWxzZTsgLy8gZXZlcnlcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIElTX0ZJTkRfSU5ERVggPyAtMSA6IElTX1NPTUUgfHwgSVNfRVZFUlkgPyBJU19FVkVSWSA6IHJlc3VsdDtcbiAgfTtcbn07XG4iLCJleHBvcnRzLmYgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gMTkuMS4yLjEgT2JqZWN0LmFzc2lnbih0YXJnZXQsIHNvdXJjZSwgLi4uKVxudmFyIGdldEtleXMgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cycpO1xudmFyIGdPUFMgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wcycpO1xudmFyIHBJRSA9IHJlcXVpcmUoJy4vX29iamVjdC1waWUnKTtcbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpO1xudmFyIElPYmplY3QgPSByZXF1aXJlKCcuL19pb2JqZWN0Jyk7XG52YXIgJGFzc2lnbiA9IE9iamVjdC5hc3NpZ247XG5cbi8vIHNob3VsZCB3b3JrIHdpdGggc3ltYm9scyBhbmQgc2hvdWxkIGhhdmUgZGV0ZXJtaW5pc3RpYyBwcm9wZXJ0eSBvcmRlciAoVjggYnVnKVxubW9kdWxlLmV4cG9ydHMgPSAhJGFzc2lnbiB8fCByZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uICgpIHtcbiAgdmFyIEEgPSB7fTtcbiAgdmFyIEIgPSB7fTtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG4gIHZhciBTID0gU3ltYm9sKCk7XG4gIHZhciBLID0gJ2FiY2RlZmdoaWprbG1ub3BxcnN0JztcbiAgQVtTXSA9IDc7XG4gIEsuc3BsaXQoJycpLmZvckVhY2goZnVuY3Rpb24gKGspIHsgQltrXSA9IGs7IH0pO1xuICByZXR1cm4gJGFzc2lnbih7fSwgQSlbU10gIT0gNyB8fCBPYmplY3Qua2V5cygkYXNzaWduKHt9LCBCKSkuam9pbignJykgIT0gSztcbn0pID8gZnVuY3Rpb24gYXNzaWduKHRhcmdldCwgc291cmNlKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgdmFyIFQgPSB0b09iamVjdCh0YXJnZXQpO1xuICB2YXIgYUxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gIHZhciBpbmRleCA9IDE7XG4gIHZhciBnZXRTeW1ib2xzID0gZ09QUy5mO1xuICB2YXIgaXNFbnVtID0gcElFLmY7XG4gIHdoaWxlIChhTGVuID4gaW5kZXgpIHtcbiAgICB2YXIgUyA9IElPYmplY3QoYXJndW1lbnRzW2luZGV4KytdKTtcbiAgICB2YXIga2V5cyA9IGdldFN5bWJvbHMgPyBnZXRLZXlzKFMpLmNvbmNhdChnZXRTeW1ib2xzKFMpKSA6IGdldEtleXMoUyk7XG4gICAgdmFyIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICAgIHZhciBqID0gMDtcbiAgICB2YXIga2V5O1xuICAgIHdoaWxlIChsZW5ndGggPiBqKSBpZiAoaXNFbnVtLmNhbGwoUywga2V5ID0ga2V5c1tqKytdKSkgVFtrZXldID0gU1trZXldO1xuICB9IHJldHVybiBUO1xufSA6ICRhc3NpZ247XG4iLCIndXNlIHN0cmljdCc7XG52YXIgcmVkZWZpbmVBbGwgPSByZXF1aXJlKCcuL19yZWRlZmluZS1hbGwnKTtcbnZhciBnZXRXZWFrID0gcmVxdWlyZSgnLi9fbWV0YScpLmdldFdlYWs7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xudmFyIGFuSW5zdGFuY2UgPSByZXF1aXJlKCcuL19hbi1pbnN0YW5jZScpO1xudmFyIGZvck9mID0gcmVxdWlyZSgnLi9fZm9yLW9mJyk7XG52YXIgY3JlYXRlQXJyYXlNZXRob2QgPSByZXF1aXJlKCcuL19hcnJheS1tZXRob2RzJyk7XG52YXIgJGhhcyA9IHJlcXVpcmUoJy4vX2hhcycpO1xudmFyIHZhbGlkYXRlID0gcmVxdWlyZSgnLi9fdmFsaWRhdGUtY29sbGVjdGlvbicpO1xudmFyIGFycmF5RmluZCA9IGNyZWF0ZUFycmF5TWV0aG9kKDUpO1xudmFyIGFycmF5RmluZEluZGV4ID0gY3JlYXRlQXJyYXlNZXRob2QoNik7XG52YXIgaWQgPSAwO1xuXG4vLyBmYWxsYmFjayBmb3IgdW5jYXVnaHQgZnJvemVuIGtleXNcbnZhciB1bmNhdWdodEZyb3plblN0b3JlID0gZnVuY3Rpb24gKHRoYXQpIHtcbiAgcmV0dXJuIHRoYXQuX2wgfHwgKHRoYXQuX2wgPSBuZXcgVW5jYXVnaHRGcm96ZW5TdG9yZSgpKTtcbn07XG52YXIgVW5jYXVnaHRGcm96ZW5TdG9yZSA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5hID0gW107XG59O1xudmFyIGZpbmRVbmNhdWdodEZyb3plbiA9IGZ1bmN0aW9uIChzdG9yZSwga2V5KSB7XG4gIHJldHVybiBhcnJheUZpbmQoc3RvcmUuYSwgZnVuY3Rpb24gKGl0KSB7XG4gICAgcmV0dXJuIGl0WzBdID09PSBrZXk7XG4gIH0pO1xufTtcblVuY2F1Z2h0RnJvemVuU3RvcmUucHJvdG90eXBlID0ge1xuICBnZXQ6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICB2YXIgZW50cnkgPSBmaW5kVW5jYXVnaHRGcm96ZW4odGhpcywga2V5KTtcbiAgICBpZiAoZW50cnkpIHJldHVybiBlbnRyeVsxXTtcbiAgfSxcbiAgaGFzOiBmdW5jdGlvbiAoa2V5KSB7XG4gICAgcmV0dXJuICEhZmluZFVuY2F1Z2h0RnJvemVuKHRoaXMsIGtleSk7XG4gIH0sXG4gIHNldDogZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICB2YXIgZW50cnkgPSBmaW5kVW5jYXVnaHRGcm96ZW4odGhpcywga2V5KTtcbiAgICBpZiAoZW50cnkpIGVudHJ5WzFdID0gdmFsdWU7XG4gICAgZWxzZSB0aGlzLmEucHVzaChba2V5LCB2YWx1ZV0pO1xuICB9LFxuICAnZGVsZXRlJzogZnVuY3Rpb24gKGtleSkge1xuICAgIHZhciBpbmRleCA9IGFycmF5RmluZEluZGV4KHRoaXMuYSwgZnVuY3Rpb24gKGl0KSB7XG4gICAgICByZXR1cm4gaXRbMF0gPT09IGtleTtcbiAgICB9KTtcbiAgICBpZiAofmluZGV4KSB0aGlzLmEuc3BsaWNlKGluZGV4LCAxKTtcbiAgICByZXR1cm4gISF+aW5kZXg7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBnZXRDb25zdHJ1Y3RvcjogZnVuY3Rpb24gKHdyYXBwZXIsIE5BTUUsIElTX01BUCwgQURERVIpIHtcbiAgICB2YXIgQyA9IHdyYXBwZXIoZnVuY3Rpb24gKHRoYXQsIGl0ZXJhYmxlKSB7XG4gICAgICBhbkluc3RhbmNlKHRoYXQsIEMsIE5BTUUsICdfaScpO1xuICAgICAgdGhhdC5fdCA9IE5BTUU7ICAgICAgLy8gY29sbGVjdGlvbiB0eXBlXG4gICAgICB0aGF0Ll9pID0gaWQrKzsgICAgICAvLyBjb2xsZWN0aW9uIGlkXG4gICAgICB0aGF0Ll9sID0gdW5kZWZpbmVkOyAvLyBsZWFrIHN0b3JlIGZvciB1bmNhdWdodCBmcm96ZW4gb2JqZWN0c1xuICAgICAgaWYgKGl0ZXJhYmxlICE9IHVuZGVmaW5lZCkgZm9yT2YoaXRlcmFibGUsIElTX01BUCwgdGhhdFtBRERFUl0sIHRoYXQpO1xuICAgIH0pO1xuICAgIHJlZGVmaW5lQWxsKEMucHJvdG90eXBlLCB7XG4gICAgICAvLyAyMy4zLjMuMiBXZWFrTWFwLnByb3RvdHlwZS5kZWxldGUoa2V5KVxuICAgICAgLy8gMjMuNC4zLjMgV2Vha1NldC5wcm90b3R5cGUuZGVsZXRlKHZhbHVlKVxuICAgICAgJ2RlbGV0ZSc6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgaWYgKCFpc09iamVjdChrZXkpKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIHZhciBkYXRhID0gZ2V0V2VhayhrZXkpO1xuICAgICAgICBpZiAoZGF0YSA9PT0gdHJ1ZSkgcmV0dXJuIHVuY2F1Z2h0RnJvemVuU3RvcmUodmFsaWRhdGUodGhpcywgTkFNRSkpWydkZWxldGUnXShrZXkpO1xuICAgICAgICByZXR1cm4gZGF0YSAmJiAkaGFzKGRhdGEsIHRoaXMuX2kpICYmIGRlbGV0ZSBkYXRhW3RoaXMuX2ldO1xuICAgICAgfSxcbiAgICAgIC8vIDIzLjMuMy40IFdlYWtNYXAucHJvdG90eXBlLmhhcyhrZXkpXG4gICAgICAvLyAyMy40LjMuNCBXZWFrU2V0LnByb3RvdHlwZS5oYXModmFsdWUpXG4gICAgICBoYXM6IGZ1bmN0aW9uIGhhcyhrZXkpIHtcbiAgICAgICAgaWYgKCFpc09iamVjdChrZXkpKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIHZhciBkYXRhID0gZ2V0V2VhayhrZXkpO1xuICAgICAgICBpZiAoZGF0YSA9PT0gdHJ1ZSkgcmV0dXJuIHVuY2F1Z2h0RnJvemVuU3RvcmUodmFsaWRhdGUodGhpcywgTkFNRSkpLmhhcyhrZXkpO1xuICAgICAgICByZXR1cm4gZGF0YSAmJiAkaGFzKGRhdGEsIHRoaXMuX2kpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBDO1xuICB9LFxuICBkZWY6IGZ1bmN0aW9uICh0aGF0LCBrZXksIHZhbHVlKSB7XG4gICAgdmFyIGRhdGEgPSBnZXRXZWFrKGFuT2JqZWN0KGtleSksIHRydWUpO1xuICAgIGlmIChkYXRhID09PSB0cnVlKSB1bmNhdWdodEZyb3plblN0b3JlKHRoYXQpLnNldChrZXksIHZhbHVlKTtcbiAgICBlbHNlIGRhdGFbdGhhdC5faV0gPSB2YWx1ZTtcbiAgICByZXR1cm4gdGhhdDtcbiAgfSxcbiAgdWZzdG9yZTogdW5jYXVnaHRGcm96ZW5TdG9yZVxufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbnZhciBlYWNoID0gcmVxdWlyZSgnLi9fYXJyYXktbWV0aG9kcycpKDApO1xudmFyIHJlZGVmaW5lID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUnKTtcbnZhciBtZXRhID0gcmVxdWlyZSgnLi9fbWV0YScpO1xudmFyIGFzc2lnbiA9IHJlcXVpcmUoJy4vX29iamVjdC1hc3NpZ24nKTtcbnZhciB3ZWFrID0gcmVxdWlyZSgnLi9fY29sbGVjdGlvbi13ZWFrJyk7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciB2YWxpZGF0ZSA9IHJlcXVpcmUoJy4vX3ZhbGlkYXRlLWNvbGxlY3Rpb24nKTtcbnZhciBOQVRJVkVfV0VBS19NQVAgPSByZXF1aXJlKCcuL192YWxpZGF0ZS1jb2xsZWN0aW9uJyk7XG52YXIgSVNfSUUxMSA9ICFnbG9iYWwuQWN0aXZlWE9iamVjdCAmJiAnQWN0aXZlWE9iamVjdCcgaW4gZ2xvYmFsO1xudmFyIFdFQUtfTUFQID0gJ1dlYWtNYXAnO1xudmFyIGdldFdlYWsgPSBtZXRhLmdldFdlYWs7XG52YXIgaXNFeHRlbnNpYmxlID0gT2JqZWN0LmlzRXh0ZW5zaWJsZTtcbnZhciB1bmNhdWdodEZyb3plblN0b3JlID0gd2Vhay51ZnN0b3JlO1xudmFyIEludGVybmFsTWFwO1xuXG52YXIgd3JhcHBlciA9IGZ1bmN0aW9uIChnZXQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIFdlYWtNYXAoKSB7XG4gICAgcmV0dXJuIGdldCh0aGlzLCBhcmd1bWVudHMubGVuZ3RoID4gMCA/IGFyZ3VtZW50c1swXSA6IHVuZGVmaW5lZCk7XG4gIH07XG59O1xuXG52YXIgbWV0aG9kcyA9IHtcbiAgLy8gMjMuMy4zLjMgV2Vha01hcC5wcm90b3R5cGUuZ2V0KGtleSlcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoa2V5KSB7XG4gICAgaWYgKGlzT2JqZWN0KGtleSkpIHtcbiAgICAgIHZhciBkYXRhID0gZ2V0V2VhayhrZXkpO1xuICAgICAgaWYgKGRhdGEgPT09IHRydWUpIHJldHVybiB1bmNhdWdodEZyb3plblN0b3JlKHZhbGlkYXRlKHRoaXMsIFdFQUtfTUFQKSkuZ2V0KGtleSk7XG4gICAgICByZXR1cm4gZGF0YSA/IGRhdGFbdGhpcy5faV0gOiB1bmRlZmluZWQ7XG4gICAgfVxuICB9LFxuICAvLyAyMy4zLjMuNSBXZWFrTWFwLnByb3RvdHlwZS5zZXQoa2V5LCB2YWx1ZSlcbiAgc2V0OiBmdW5jdGlvbiBzZXQoa2V5LCB2YWx1ZSkge1xuICAgIHJldHVybiB3ZWFrLmRlZih2YWxpZGF0ZSh0aGlzLCBXRUFLX01BUCksIGtleSwgdmFsdWUpO1xuICB9XG59O1xuXG4vLyAyMy4zIFdlYWtNYXAgT2JqZWN0c1xudmFyICRXZWFrTWFwID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19jb2xsZWN0aW9uJykoV0VBS19NQVAsIHdyYXBwZXIsIG1ldGhvZHMsIHdlYWssIHRydWUsIHRydWUpO1xuXG4vLyBJRTExIFdlYWtNYXAgZnJvemVuIGtleXMgZml4XG5pZiAoTkFUSVZFX1dFQUtfTUFQICYmIElTX0lFMTEpIHtcbiAgSW50ZXJuYWxNYXAgPSB3ZWFrLmdldENvbnN0cnVjdG9yKHdyYXBwZXIsIFdFQUtfTUFQKTtcbiAgYXNzaWduKEludGVybmFsTWFwLnByb3RvdHlwZSwgbWV0aG9kcyk7XG4gIG1ldGEuTkVFRCA9IHRydWU7XG4gIGVhY2goWydkZWxldGUnLCAnaGFzJywgJ2dldCcsICdzZXQnXSwgZnVuY3Rpb24gKGtleSkge1xuICAgIHZhciBwcm90byA9ICRXZWFrTWFwLnByb3RvdHlwZTtcbiAgICB2YXIgbWV0aG9kID0gcHJvdG9ba2V5XTtcbiAgICByZWRlZmluZShwcm90bywga2V5LCBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgLy8gc3RvcmUgZnJvemVuIG9iamVjdHMgb24gaW50ZXJuYWwgd2Vha21hcCBzaGltXG4gICAgICBpZiAoaXNPYmplY3QoYSkgJiYgIWlzRXh0ZW5zaWJsZShhKSkge1xuICAgICAgICBpZiAoIXRoaXMuX2YpIHRoaXMuX2YgPSBuZXcgSW50ZXJuYWxNYXAoKTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuX2Zba2V5XShhLCBiKTtcbiAgICAgICAgcmV0dXJuIGtleSA9PSAnc2V0JyA/IHRoaXMgOiByZXN1bHQ7XG4gICAgICAvLyBzdG9yZSBhbGwgdGhlIHJlc3Qgb24gbmF0aXZlIHdlYWttYXBcbiAgICAgIH0gcmV0dXJuIG1ldGhvZC5jYWxsKHRoaXMsIGEsIGIpO1xuICAgIH0pO1xuICB9KTtcbn1cbiIsIi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vcHJvcG9zYWwtc2V0bWFwLW9mZnJvbS8jc2VjLXdlYWttYXAub2ZcbnJlcXVpcmUoJy4vX3NldC1jb2xsZWN0aW9uLW9mJykoJ1dlYWtNYXAnKTtcbiIsIi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vcHJvcG9zYWwtc2V0bWFwLW9mZnJvbS8jc2VjLXdlYWttYXAuZnJvbVxucmVxdWlyZSgnLi9fc2V0LWNvbGxlY3Rpb24tZnJvbScpKCdXZWFrTWFwJyk7XG4iLCJyZXF1aXJlKCcuLi9tb2R1bGVzL2VzNi5vYmplY3QudG8tc3RyaW5nJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL3dlYi5kb20uaXRlcmFibGUnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM2LndlYWstbWFwJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNy53ZWFrLW1hcC5vZicpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczcud2Vhay1tYXAuZnJvbScpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi9tb2R1bGVzL19jb3JlJykuV2Vha01hcDtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciAkZGVmaW5lUHJvcGVydHkgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKTtcbnZhciBjcmVhdGVEZXNjID0gcmVxdWlyZSgnLi9fcHJvcGVydHktZGVzYycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvYmplY3QsIGluZGV4LCB2YWx1ZSkge1xuICBpZiAoaW5kZXggaW4gb2JqZWN0KSAkZGVmaW5lUHJvcGVydHkuZihvYmplY3QsIGluZGV4LCBjcmVhdGVEZXNjKDAsIHZhbHVlKSk7XG4gIGVsc2Ugb2JqZWN0W2luZGV4XSA9IHZhbHVlO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBjdHggPSByZXF1aXJlKCcuL19jdHgnKTtcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKTtcbnZhciBjYWxsID0gcmVxdWlyZSgnLi9faXRlci1jYWxsJyk7XG52YXIgaXNBcnJheUl0ZXIgPSByZXF1aXJlKCcuL19pcy1hcnJheS1pdGVyJyk7XG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuL190by1sZW5ndGgnKTtcbnZhciBjcmVhdGVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vX2NyZWF0ZS1wcm9wZXJ0eScpO1xudmFyIGdldEl0ZXJGbiA9IHJlcXVpcmUoJy4vY29yZS5nZXQtaXRlcmF0b3ItbWV0aG9kJyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIXJlcXVpcmUoJy4vX2l0ZXItZGV0ZWN0JykoZnVuY3Rpb24gKGl0ZXIpIHsgQXJyYXkuZnJvbShpdGVyKTsgfSksICdBcnJheScsIHtcbiAgLy8gMjIuMS4yLjEgQXJyYXkuZnJvbShhcnJheUxpa2UsIG1hcGZuID0gdW5kZWZpbmVkLCB0aGlzQXJnID0gdW5kZWZpbmVkKVxuICBmcm9tOiBmdW5jdGlvbiBmcm9tKGFycmF5TGlrZSAvKiAsIG1hcGZuID0gdW5kZWZpbmVkLCB0aGlzQXJnID0gdW5kZWZpbmVkICovKSB7XG4gICAgdmFyIE8gPSB0b09iamVjdChhcnJheUxpa2UpO1xuICAgIHZhciBDID0gdHlwZW9mIHRoaXMgPT0gJ2Z1bmN0aW9uJyA/IHRoaXMgOiBBcnJheTtcbiAgICB2YXIgYUxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgdmFyIG1hcGZuID0gYUxlbiA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQ7XG4gICAgdmFyIG1hcHBpbmcgPSBtYXBmbiAhPT0gdW5kZWZpbmVkO1xuICAgIHZhciBpbmRleCA9IDA7XG4gICAgdmFyIGl0ZXJGbiA9IGdldEl0ZXJGbihPKTtcbiAgICB2YXIgbGVuZ3RoLCByZXN1bHQsIHN0ZXAsIGl0ZXJhdG9yO1xuICAgIGlmIChtYXBwaW5nKSBtYXBmbiA9IGN0eChtYXBmbiwgYUxlbiA+IDIgPyBhcmd1bWVudHNbMl0gOiB1bmRlZmluZWQsIDIpO1xuICAgIC8vIGlmIG9iamVjdCBpc24ndCBpdGVyYWJsZSBvciBpdCdzIGFycmF5IHdpdGggZGVmYXVsdCBpdGVyYXRvciAtIHVzZSBzaW1wbGUgY2FzZVxuICAgIGlmIChpdGVyRm4gIT0gdW5kZWZpbmVkICYmICEoQyA9PSBBcnJheSAmJiBpc0FycmF5SXRlcihpdGVyRm4pKSkge1xuICAgICAgZm9yIChpdGVyYXRvciA9IGl0ZXJGbi5jYWxsKE8pLCByZXN1bHQgPSBuZXcgQygpOyAhKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmU7IGluZGV4KyspIHtcbiAgICAgICAgY3JlYXRlUHJvcGVydHkocmVzdWx0LCBpbmRleCwgbWFwcGluZyA/IGNhbGwoaXRlcmF0b3IsIG1hcGZuLCBbc3RlcC52YWx1ZSwgaW5kZXhdLCB0cnVlKSA6IHN0ZXAudmFsdWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBsZW5ndGggPSB0b0xlbmd0aChPLmxlbmd0aCk7XG4gICAgICBmb3IgKHJlc3VsdCA9IG5ldyBDKGxlbmd0aCk7IGxlbmd0aCA+IGluZGV4OyBpbmRleCsrKSB7XG4gICAgICAgIGNyZWF0ZVByb3BlcnR5KHJlc3VsdCwgaW5kZXgsIG1hcHBpbmcgPyBtYXBmbihPW2luZGV4XSwgaW5kZXgpIDogT1tpbmRleF0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXN1bHQubGVuZ3RoID0gaW5kZXg7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufSk7XG4iLCJyZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNi5zdHJpbmcuaXRlcmF0b3InKTtcbnJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM2LmFycmF5LmZyb20nKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9fY29yZScpLkFycmF5LmZyb207XG4iLCJjb25zdCByZXNlcnZlZFRhZ0xpc3QgPSBuZXcgU2V0KFtcbiAgJ2Fubm90YXRpb24teG1sJyxcbiAgJ2NvbG9yLXByb2ZpbGUnLFxuICAnZm9udC1mYWNlJyxcbiAgJ2ZvbnQtZmFjZS1zcmMnLFxuICAnZm9udC1mYWNlLXVyaScsXG4gICdmb250LWZhY2UtZm9ybWF0JyxcbiAgJ2ZvbnQtZmFjZS1uYW1lJyxcbiAgJ21pc3NpbmctZ2x5cGgnLFxuXSk7XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGxvY2FsTmFtZVxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1ZhbGlkQ3VzdG9tRWxlbWVudE5hbWUobG9jYWxOYW1lKSB7XG4gIGNvbnN0IHJlc2VydmVkID0gcmVzZXJ2ZWRUYWdMaXN0Lmhhcyhsb2NhbE5hbWUpO1xuICBjb25zdCB2YWxpZEZvcm0gPSAvXlthLXpdWy4wLTlfYS16XSotW1xcLS4wLTlfYS16XSokLy50ZXN0KGxvY2FsTmFtZSk7XG4gIHJldHVybiAhcmVzZXJ2ZWQgJiYgdmFsaWRGb3JtO1xufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyFOb2RlfSBub2RlXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNDb25uZWN0ZWQobm9kZSkge1xuICAvLyBVc2UgYE5vZGUjaXNDb25uZWN0ZWRgLCBpZiBkZWZpbmVkLlxuICBjb25zdCBuYXRpdmVWYWx1ZSA9IG5vZGUuaXNDb25uZWN0ZWQ7XG4gIGlmIChuYXRpdmVWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIG5hdGl2ZVZhbHVlO1xuICB9XG5cbiAgLyoqIEB0eXBlIHs/Tm9kZXx1bmRlZmluZWR9ICovXG4gIGxldCBjdXJyZW50ID0gbm9kZTtcbiAgd2hpbGUgKGN1cnJlbnQgJiYgIShjdXJyZW50Ll9fQ0VfaXNJbXBvcnREb2N1bWVudCB8fCBjdXJyZW50IGluc3RhbmNlb2YgRG9jdW1lbnQpKSB7XG4gICAgY3VycmVudCA9IGN1cnJlbnQucGFyZW50Tm9kZSB8fCAod2luZG93LlNoYWRvd1Jvb3QgJiYgY3VycmVudCBpbnN0YW5jZW9mIFNoYWRvd1Jvb3QgPyBjdXJyZW50Lmhvc3QgOiB1bmRlZmluZWQpO1xuICB9XG4gIHJldHVybiAhIShjdXJyZW50ICYmIChjdXJyZW50Ll9fQ0VfaXNJbXBvcnREb2N1bWVudCB8fCBjdXJyZW50IGluc3RhbmNlb2YgRG9jdW1lbnQpKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0geyFOb2RlfSByb290XG4gKiBAcGFyYW0geyFOb2RlfSBzdGFydFxuICogQHJldHVybiB7P05vZGV9XG4gKi9cbmZ1bmN0aW9uIG5leHRTaWJsaW5nT3JBbmNlc3RvclNpYmxpbmcocm9vdCwgc3RhcnQpIHtcbiAgbGV0IG5vZGUgPSBzdGFydDtcbiAgd2hpbGUgKG5vZGUgJiYgbm9kZSAhPT0gcm9vdCAmJiAhbm9kZS5uZXh0U2libGluZykge1xuICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gIH1cbiAgcmV0dXJuICghbm9kZSB8fCBub2RlID09PSByb290KSA/IG51bGwgOiBub2RlLm5leHRTaWJsaW5nO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7IU5vZGV9IHJvb3RcbiAqIEBwYXJhbSB7IU5vZGV9IHN0YXJ0XG4gKiBAcmV0dXJuIHs/Tm9kZX1cbiAqL1xuZnVuY3Rpb24gbmV4dE5vZGUocm9vdCwgc3RhcnQpIHtcbiAgcmV0dXJuIHN0YXJ0LmZpcnN0Q2hpbGQgPyBzdGFydC5maXJzdENoaWxkIDogbmV4dFNpYmxpbmdPckFuY2VzdG9yU2libGluZyhyb290LCBzdGFydCk7XG59XG5cbi8qKlxuICogQHBhcmFtIHshTm9kZX0gcm9vdFxuICogQHBhcmFtIHshZnVuY3Rpb24oIUVsZW1lbnQpfSBjYWxsYmFja1xuICogQHBhcmFtIHshU2V0PE5vZGU+PX0gdmlzaXRlZEltcG9ydHNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHdhbGtEZWVwRGVzY2VuZGFudEVsZW1lbnRzKHJvb3QsIGNhbGxiYWNrLCB2aXNpdGVkSW1wb3J0cyA9IG5ldyBTZXQoKSkge1xuICBsZXQgbm9kZSA9IHJvb3Q7XG4gIHdoaWxlIChub2RlKSB7XG4gICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IE5vZGUuRUxFTUVOVF9OT0RFKSB7XG4gICAgICBjb25zdCBlbGVtZW50ID0gLyoqIEB0eXBlIHshRWxlbWVudH0gKi8obm9kZSk7XG5cbiAgICAgIGNhbGxiYWNrKGVsZW1lbnQpO1xuXG4gICAgICBjb25zdCBsb2NhbE5hbWUgPSBlbGVtZW50LmxvY2FsTmFtZTtcbiAgICAgIGlmIChsb2NhbE5hbWUgPT09ICdsaW5rJyAmJiBlbGVtZW50LmdldEF0dHJpYnV0ZSgncmVsJykgPT09ICdpbXBvcnQnKSB7XG4gICAgICAgIC8vIElmIHRoaXMgaW1wb3J0IChwb2x5ZmlsbGVkIG9yIG5vdCkgaGFzIGl0J3Mgcm9vdCBub2RlIGF2YWlsYWJsZSxcbiAgICAgICAgLy8gd2FsayBpdC5cbiAgICAgICAgY29uc3QgaW1wb3J0Tm9kZSA9IC8qKiBAdHlwZSB7IU5vZGV9ICovIChlbGVtZW50LmltcG9ydCk7XG4gICAgICAgIGlmIChpbXBvcnROb2RlIGluc3RhbmNlb2YgTm9kZSAmJiAhdmlzaXRlZEltcG9ydHMuaGFzKGltcG9ydE5vZGUpKSB7XG4gICAgICAgICAgLy8gUHJldmVudCBtdWx0aXBsZSB3YWxrcyBvZiB0aGUgc2FtZSBpbXBvcnQgcm9vdC5cbiAgICAgICAgICB2aXNpdGVkSW1wb3J0cy5hZGQoaW1wb3J0Tm9kZSk7XG5cbiAgICAgICAgICBmb3IgKGxldCBjaGlsZCA9IGltcG9ydE5vZGUuZmlyc3RDaGlsZDsgY2hpbGQ7IGNoaWxkID0gY2hpbGQubmV4dFNpYmxpbmcpIHtcbiAgICAgICAgICAgIHdhbGtEZWVwRGVzY2VuZGFudEVsZW1lbnRzKGNoaWxkLCBjYWxsYmFjaywgdmlzaXRlZEltcG9ydHMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElnbm9yZSBkZXNjZW5kYW50cyBvZiBpbXBvcnQgbGlua3MgdG8gcHJldmVudCBhdHRlbXB0aW5nIHRvIHdhbGsgdGhlXG4gICAgICAgIC8vIGVsZW1lbnRzIGNyZWF0ZWQgYnkgdGhlIEhUTUwgSW1wb3J0cyBwb2x5ZmlsbCB0aGF0IHdlIGp1c3Qgd2Fsa2VkXG4gICAgICAgIC8vIGFib3ZlLlxuICAgICAgICBub2RlID0gbmV4dFNpYmxpbmdPckFuY2VzdG9yU2libGluZyhyb290LCBlbGVtZW50KTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IGVsc2UgaWYgKGxvY2FsTmFtZSA9PT0gJ3RlbXBsYXRlJykge1xuICAgICAgICAvLyBJZ25vcmUgZGVzY2VuZGFudHMgb2YgdGVtcGxhdGVzLiBUaGVyZSBzaG91bGRuJ3QgYmUgYW55IGRlc2NlbmRhbnRzXG4gICAgICAgIC8vIGJlY2F1c2UgdGhleSB3aWxsIGJlIG1vdmVkIGludG8gYC5jb250ZW50YCBkdXJpbmcgY29uc3RydWN0aW9uIGluXG4gICAgICAgIC8vIGJyb3dzZXJzIHRoYXQgc3VwcG9ydCB0ZW1wbGF0ZSBidXQsIGluIGNhc2UgdGhleSBleGlzdCBhbmQgYXJlIHN0aWxsXG4gICAgICAgIC8vIHdhaXRpbmcgdG8gYmUgbW92ZWQgYnkgYSBwb2x5ZmlsbCwgdGhleSB3aWxsIGJlIGlnbm9yZWQuXG4gICAgICAgIG5vZGUgPSBuZXh0U2libGluZ09yQW5jZXN0b3JTaWJsaW5nKHJvb3QsIGVsZW1lbnQpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLy8gV2FsayBzaGFkb3cgcm9vdHMuXG4gICAgICBjb25zdCBzaGFkb3dSb290ID0gZWxlbWVudC5fX0NFX3NoYWRvd1Jvb3Q7XG4gICAgICBpZiAoc2hhZG93Um9vdCkge1xuICAgICAgICBmb3IgKGxldCBjaGlsZCA9IHNoYWRvd1Jvb3QuZmlyc3RDaGlsZDsgY2hpbGQ7IGNoaWxkID0gY2hpbGQubmV4dFNpYmxpbmcpIHtcbiAgICAgICAgICB3YWxrRGVlcERlc2NlbmRhbnRFbGVtZW50cyhjaGlsZCwgY2FsbGJhY2ssIHZpc2l0ZWRJbXBvcnRzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIG5vZGUgPSBuZXh0Tm9kZShyb290LCBub2RlKTtcbiAgfVxufVxuXG4vKipcbiAqIFVzZWQgdG8gc3VwcHJlc3MgQ2xvc3VyZSdzIFwiTW9kaWZ5aW5nIHRoZSBwcm90b3R5cGUgaXMgb25seSBhbGxvd2VkIGlmIHRoZVxuICogY29uc3RydWN0b3IgaXMgaW4gdGhlIHNhbWUgc2NvcGVcIiB3YXJuaW5nIHdpdGhvdXQgdXNpbmdcbiAqIGBAc3VwcHJlc3Mge25ld0NoZWNrVHlwZXMsIGR1cGxpY2F0ZX1gIGJlY2F1c2UgYG5ld0NoZWNrVHlwZXNgIGlzIHRvbyBicm9hZC5cbiAqXG4gKiBAcGFyYW0geyFPYmplY3R9IGRlc3RpbmF0aW9uXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogQHBhcmFtIHsqfSB2YWx1ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0UHJvcGVydHlVbmNoZWNrZWQoZGVzdGluYXRpb24sIG5hbWUsIHZhbHVlKSB7XG4gIGRlc3RpbmF0aW9uW25hbWVdID0gdmFsdWU7XG59XG4iLCIvKipcbiAqIEBlbnVtIHtudW1iZXJ9XG4gKi9cbmNvbnN0IEN1c3RvbUVsZW1lbnRTdGF0ZSA9IHtcbiAgY3VzdG9tOiAxLFxuICBmYWlsZWQ6IDIsXG59O1xuXG5leHBvcnQgZGVmYXVsdCBDdXN0b21FbGVtZW50U3RhdGU7XG4iLCJpbXBvcnQgKiBhcyBVdGlsaXRpZXMgZnJvbSAnLi9VdGlsaXRpZXMuanMnO1xuaW1wb3J0IENFU3RhdGUgZnJvbSAnLi9DdXN0b21FbGVtZW50U3RhdGUuanMnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDdXN0b21FbGVtZW50SW50ZXJuYWxzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgLyoqIEB0eXBlIHshTWFwPHN0cmluZywgIUN1c3RvbUVsZW1lbnREZWZpbml0aW9uPn0gKi9cbiAgICB0aGlzLl9sb2NhbE5hbWVUb0RlZmluaXRpb24gPSBuZXcgTWFwKCk7XG5cbiAgICAvKiogQHR5cGUgeyFNYXA8IUZ1bmN0aW9uLCAhQ3VzdG9tRWxlbWVudERlZmluaXRpb24+fSAqL1xuICAgIHRoaXMuX2NvbnN0cnVjdG9yVG9EZWZpbml0aW9uID0gbmV3IE1hcCgpO1xuXG4gICAgLyoqIEB0eXBlIHshQXJyYXk8IWZ1bmN0aW9uKCFOb2RlKT59ICovXG4gICAgdGhpcy5fcGF0Y2hlcyA9IFtdO1xuXG4gICAgLyoqIEB0eXBlIHtib29sZWFufSAqL1xuICAgIHRoaXMuX2hhc1BhdGNoZXMgPSBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbG9jYWxOYW1lXG4gICAqIEBwYXJhbSB7IUN1c3RvbUVsZW1lbnREZWZpbml0aW9ufSBkZWZpbml0aW9uXG4gICAqL1xuICBzZXREZWZpbml0aW9uKGxvY2FsTmFtZSwgZGVmaW5pdGlvbikge1xuICAgIHRoaXMuX2xvY2FsTmFtZVRvRGVmaW5pdGlvbi5zZXQobG9jYWxOYW1lLCBkZWZpbml0aW9uKTtcbiAgICB0aGlzLl9jb25zdHJ1Y3RvclRvRGVmaW5pdGlvbi5zZXQoZGVmaW5pdGlvbi5jb25zdHJ1Y3RvciwgZGVmaW5pdGlvbik7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IGxvY2FsTmFtZVxuICAgKiBAcmV0dXJuIHshQ3VzdG9tRWxlbWVudERlZmluaXRpb258dW5kZWZpbmVkfVxuICAgKi9cbiAgbG9jYWxOYW1lVG9EZWZpbml0aW9uKGxvY2FsTmFtZSkge1xuICAgIHJldHVybiB0aGlzLl9sb2NhbE5hbWVUb0RlZmluaXRpb24uZ2V0KGxvY2FsTmFtZSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHshRnVuY3Rpb259IGNvbnN0cnVjdG9yXG4gICAqIEByZXR1cm4geyFDdXN0b21FbGVtZW50RGVmaW5pdGlvbnx1bmRlZmluZWR9XG4gICAqL1xuICBjb25zdHJ1Y3RvclRvRGVmaW5pdGlvbihjb25zdHJ1Y3Rvcikge1xuICAgIHJldHVybiB0aGlzLl9jb25zdHJ1Y3RvclRvRGVmaW5pdGlvbi5nZXQoY29uc3RydWN0b3IpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7IWZ1bmN0aW9uKCFOb2RlKX0gbGlzdGVuZXJcbiAgICovXG4gIGFkZFBhdGNoKGxpc3RlbmVyKSB7XG4gICAgdGhpcy5faGFzUGF0Y2hlcyA9IHRydWU7XG4gICAgdGhpcy5fcGF0Y2hlcy5wdXNoKGxpc3RlbmVyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0geyFOb2RlfSBub2RlXG4gICAqL1xuICBwYXRjaFRyZWUobm9kZSkge1xuICAgIGlmICghdGhpcy5faGFzUGF0Y2hlcykgcmV0dXJuO1xuXG4gICAgVXRpbGl0aWVzLndhbGtEZWVwRGVzY2VuZGFudEVsZW1lbnRzKG5vZGUsIGVsZW1lbnQgPT4gdGhpcy5wYXRjaChlbGVtZW50KSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHshTm9kZX0gbm9kZVxuICAgKi9cbiAgcGF0Y2gobm9kZSkge1xuICAgIGlmICghdGhpcy5faGFzUGF0Y2hlcykgcmV0dXJuO1xuXG4gICAgaWYgKG5vZGUuX19DRV9wYXRjaGVkKSByZXR1cm47XG4gICAgbm9kZS5fX0NFX3BhdGNoZWQgPSB0cnVlO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9wYXRjaGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLl9wYXRjaGVzW2ldKG5vZGUpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0geyFOb2RlfSByb290XG4gICAqL1xuICBjb25uZWN0VHJlZShyb290KSB7XG4gICAgY29uc3QgZWxlbWVudHMgPSBbXTtcblxuICAgIFV0aWxpdGllcy53YWxrRGVlcERlc2NlbmRhbnRFbGVtZW50cyhyb290LCBlbGVtZW50ID0+IGVsZW1lbnRzLnB1c2goZWxlbWVudCkpO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlbGVtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgZWxlbWVudCA9IGVsZW1lbnRzW2ldO1xuICAgICAgaWYgKGVsZW1lbnQuX19DRV9zdGF0ZSA9PT0gQ0VTdGF0ZS5jdXN0b20pIHtcbiAgICAgICAgaWYgKFV0aWxpdGllcy5pc0Nvbm5lY3RlZChlbGVtZW50KSkge1xuICAgICAgICAgIHRoaXMuY29ubmVjdGVkQ2FsbGJhY2soZWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMudXBncmFkZUVsZW1lbnQoZWxlbWVudCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7IU5vZGV9IHJvb3RcbiAgICovXG4gIGRpc2Nvbm5lY3RUcmVlKHJvb3QpIHtcbiAgICBjb25zdCBlbGVtZW50cyA9IFtdO1xuXG4gICAgVXRpbGl0aWVzLndhbGtEZWVwRGVzY2VuZGFudEVsZW1lbnRzKHJvb3QsIGVsZW1lbnQgPT4gZWxlbWVudHMucHVzaChlbGVtZW50KSk7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBlbGVtZW50ID0gZWxlbWVudHNbaV07XG4gICAgICBpZiAoZWxlbWVudC5fX0NFX3N0YXRlID09PSBDRVN0YXRlLmN1c3RvbSkge1xuICAgICAgICB0aGlzLmRpc2Nvbm5lY3RlZENhbGxiYWNrKGVsZW1lbnQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBVcGdyYWRlcyBhbGwgdW5jdXN0b21pemVkIGN1c3RvbSBlbGVtZW50cyBhdCBhbmQgYmVsb3cgYSByb290IG5vZGUgZm9yXG4gICAqIHdoaWNoIHRoZXJlIGlzIGEgZGVmaW5pdGlvbi4gV2hlbiBjdXN0b20gZWxlbWVudCByZWFjdGlvbiBjYWxsYmFja3MgYXJlXG4gICAqIGFzc3VtZWQgdG8gYmUgY2FsbGVkIHN5bmNocm9ub3VzbHkgKHdoaWNoLCBieSB0aGUgY3VycmVudCBET00gLyBIVE1MIHNwZWNcbiAgICogZGVmaW5pdGlvbnMsIHRoZXkgYXJlICpub3QqKSwgY2FsbGJhY2tzIGZvciBib3RoIGVsZW1lbnRzIGN1c3RvbWl6ZWRcbiAgICogc3luY2hyb25vdXNseSBieSB0aGUgcGFyc2VyIGFuZCBlbGVtZW50cyBiZWluZyB1cGdyYWRlZCBvY2N1ciBpbiB0aGUgc2FtZVxuICAgKiByZWxhdGl2ZSBvcmRlci5cbiAgICpcbiAgICogTk9URTogVGhpcyBmdW5jdGlvbiwgd2hlbiB1c2VkIHRvIHNpbXVsYXRlIHRoZSBjb25zdHJ1Y3Rpb24gb2YgYSB0cmVlIHRoYXRcbiAgICogaXMgYWxyZWFkeSBjcmVhdGVkIGJ1dCBub3QgY3VzdG9taXplZCAoaS5lLiBieSB0aGUgcGFyc2VyKSwgZG9lcyAqbm90KlxuICAgKiBwcmV2ZW50IHRoZSBlbGVtZW50IGZyb20gcmVhZGluZyB0aGUgJ2ZpbmFsJyAodHJ1ZSkgc3RhdGUgb2YgdGhlIHRyZWUuIEZvclxuICAgKiBleGFtcGxlLCB0aGUgZWxlbWVudCwgZHVyaW5nIHRydWx5IHN5bmNocm9ub3VzIHBhcnNpbmcgLyBjb25zdHJ1Y3Rpb24gd291bGRcbiAgICogc2VlIHRoYXQgaXQgY29udGFpbnMgbm8gY2hpbGRyZW4gYXMgdGhleSBoYXZlIG5vdCB5ZXQgYmVlbiBpbnNlcnRlZC5cbiAgICogSG93ZXZlciwgdGhpcyBmdW5jdGlvbiBkb2VzIG5vdCBtb2RpZnkgdGhlIHRyZWUsIHRoZSBlbGVtZW50IHdpbGxcbiAgICogKGluY29ycmVjdGx5KSBoYXZlIGNoaWxkcmVuLiBBZGRpdGlvbmFsbHksIHNlbGYtbW9kaWZpY2F0aW9uIHJlc3RyaWN0aW9uc1xuICAgKiBmb3IgY3VzdG9tIGVsZW1lbnQgY29uc3RydWN0b3JzIGltcG9zZWQgYnkgdGhlIERPTSBzcGVjIGFyZSAqbm90KiBlbmZvcmNlZC5cbiAgICpcbiAgICpcbiAgICogVGhlIGZvbGxvd2luZyBuZXN0ZWQgbGlzdCBzaG93cyB0aGUgc3RlcHMgZXh0ZW5kaW5nIGRvd24gZnJvbSB0aGUgSFRNTFxuICAgKiBzcGVjJ3MgcGFyc2luZyBzZWN0aW9uIHRoYXQgY2F1c2UgZWxlbWVudHMgdG8gYmUgc3luY2hyb25vdXNseSBjcmVhdGVkIGFuZFxuICAgKiB1cGdyYWRlZDpcbiAgICpcbiAgICogVGhlIFwiaW4gYm9keVwiIGluc2VydGlvbiBtb2RlOlxuICAgKiBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW5ib2R5XG4gICAqIC0gU3dpdGNoIG9uIHRva2VuOlxuICAgKiAgIC4uIG90aGVyIGNhc2VzIC4uXG4gICAqICAgLT4gQW55IG90aGVyIHN0YXJ0IHRhZ1xuICAgKiAgICAgIC0gW0luc2VydCBhbiBIVE1MIGVsZW1lbnRdKGJlbG93KSBmb3IgdGhlIHRva2VuLlxuICAgKlxuICAgKiBJbnNlcnQgYW4gSFRNTCBlbGVtZW50OlxuICAgKiBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNpbnNlcnQtYW4taHRtbC1lbGVtZW50XG4gICAqIC0gSW5zZXJ0IGEgZm9yZWlnbiBlbGVtZW50IGZvciB0aGUgdG9rZW4gaW4gdGhlIEhUTUwgbmFtZXNwYWNlOlxuICAgKiAgIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI2luc2VydC1hLWZvcmVpZ24tZWxlbWVudFxuICAgKiAgIC0gQ3JlYXRlIGFuIGVsZW1lbnQgZm9yIGEgdG9rZW46XG4gICAqICAgICBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNjcmVhdGUtYW4tZWxlbWVudC1mb3ItdGhlLXRva2VuXG4gICAqICAgICAtIFdpbGwgZXhlY3V0ZSBzY3JpcHQgZmxhZyBpcyB0cnVlP1xuICAgKiAgICAgICAtIChFbGVtZW50IHF1ZXVlIHB1c2hlZCB0byB0aGUgY3VzdG9tIGVsZW1lbnQgcmVhY3Rpb25zIHN0YWNrLilcbiAgICogICAgIC0gQ3JlYXRlIGFuIGVsZW1lbnQ6XG4gICAqICAgICAgIGh0dHBzOi8vZG9tLnNwZWMud2hhdHdnLm9yZy8jY29uY2VwdC1jcmVhdGUtZWxlbWVudFxuICAgKiAgICAgICAtIFN5bmMgQ0UgZmxhZyBpcyB0cnVlP1xuICAgKiAgICAgICAgIC0gQ29uc3RydWN0b3IgY2FsbGVkLlxuICAgKiAgICAgICAgIC0gU2VsZi1tb2RpZmljYXRpb24gcmVzdHJpY3Rpb25zIGVuZm9yY2VkLlxuICAgKiAgICAgICAtIFN5bmMgQ0UgZmxhZyBpcyBmYWxzZT9cbiAgICogICAgICAgICAtIChVcGdyYWRlIHJlYWN0aW9uIGVucXVldWVkLilcbiAgICogICAgIC0gQXR0cmlidXRlcyBhcHBlbmRlZCB0byBlbGVtZW50LlxuICAgKiAgICAgICAoYGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFja2AgcmVhY3Rpb25zIGVucXVldWVkLilcbiAgICogICAgIC0gV2lsbCBleGVjdXRlIHNjcmlwdCBmbGFnIGlzIHRydWU/XG4gICAqICAgICAgIC0gKEVsZW1lbnQgcXVldWUgcG9wcGVkIGZyb20gdGhlIGN1c3RvbSBlbGVtZW50IHJlYWN0aW9ucyBzdGFjay5cbiAgICogICAgICAgICBSZWFjdGlvbnMgaW4gdGhlIHBvcHBlZCBzdGFjayBhcmUgaW52b2tlZC4pXG4gICAqICAgLSAoRWxlbWVudCBxdWV1ZSBwdXNoZWQgdG8gdGhlIGN1c3RvbSBlbGVtZW50IHJlYWN0aW9ucyBzdGFjay4pXG4gICAqICAgLSBJbnNlcnQgdGhlIGVsZW1lbnQ6XG4gICAqICAgICBodHRwczovL2RvbS5zcGVjLndoYXR3Zy5vcmcvI2NvbmNlcHQtbm9kZS1pbnNlcnRcbiAgICogICAgIC0gU2hhZG93LWluY2x1ZGluZyBkZXNjZW5kYW50cyBhcmUgY29ubmVjdGVkLiBEdXJpbmcgcGFyc2luZ1xuICAgKiAgICAgICBjb25zdHJ1Y3Rpb24sIHRoZXJlIGFyZSBubyBzaGFkb3ctKmV4Y2x1ZGluZyogZGVzY2VuZGFudHMuXG4gICAqICAgICAgIEhvd2V2ZXIsIHRoZSBjb25zdHJ1Y3RvciBtYXkgaGF2ZSB2YWxpZGx5IGF0dGFjaGVkIGEgc2hhZG93XG4gICAqICAgICAgIHRyZWUgdG8gaXRzZWxmIGFuZCBhZGRlZCBkZXNjZW5kYW50cyB0byB0aGF0IHNoYWRvdyB0cmVlLlxuICAgKiAgICAgICAoYGNvbm5lY3RlZENhbGxiYWNrYCByZWFjdGlvbnMgZW5xdWV1ZWQuKVxuICAgKiAgIC0gKEVsZW1lbnQgcXVldWUgcG9wcGVkIGZyb20gdGhlIGN1c3RvbSBlbGVtZW50IHJlYWN0aW9ucyBzdGFjay5cbiAgICogICAgIFJlYWN0aW9ucyBpbiB0aGUgcG9wcGVkIHN0YWNrIGFyZSBpbnZva2VkLilcbiAgICpcbiAgICogQHBhcmFtIHshTm9kZX0gcm9vdFxuICAgKiBAcGFyYW0geyFTZXQ8Tm9kZT49fSB2aXNpdGVkSW1wb3J0c1xuICAgKi9cbiAgcGF0Y2hBbmRVcGdyYWRlVHJlZShyb290LCB2aXNpdGVkSW1wb3J0cyA9IG5ldyBTZXQoKSkge1xuICAgIGNvbnN0IGVsZW1lbnRzID0gW107XG5cbiAgICBjb25zdCBnYXRoZXJFbGVtZW50cyA9IGVsZW1lbnQgPT4ge1xuICAgICAgaWYgKGVsZW1lbnQubG9jYWxOYW1lID09PSAnbGluaycgJiYgZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3JlbCcpID09PSAnaW1wb3J0Jykge1xuICAgICAgICAvLyBUaGUgSFRNTCBJbXBvcnRzIHBvbHlmaWxsIHNldHMgYSBkZXNjZW5kYW50IGVsZW1lbnQgb2YgdGhlIGxpbmsgdG9cbiAgICAgICAgLy8gdGhlIGBpbXBvcnRgIHByb3BlcnR5LCBzcGVjaWZpY2FsbHkgdGhpcyBpcyAqbm90KiBhIERvY3VtZW50LlxuICAgICAgICBjb25zdCBpbXBvcnROb2RlID0gLyoqIEB0eXBlIHs/Tm9kZX0gKi8gKGVsZW1lbnQuaW1wb3J0KTtcblxuICAgICAgICBpZiAoaW1wb3J0Tm9kZSBpbnN0YW5jZW9mIE5vZGUgJiYgaW1wb3J0Tm9kZS5yZWFkeVN0YXRlID09PSAnY29tcGxldGUnKSB7XG4gICAgICAgICAgaW1wb3J0Tm9kZS5fX0NFX2lzSW1wb3J0RG9jdW1lbnQgPSB0cnVlO1xuXG4gICAgICAgICAgLy8gQ29ubmVjdGVkIGxpbmtzIGFyZSBhc3NvY2lhdGVkIHdpdGggdGhlIHJlZ2lzdHJ5LlxuICAgICAgICAgIGltcG9ydE5vZGUuX19DRV9oYXNSZWdpc3RyeSA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gSWYgdGhpcyBsaW5rJ3MgaW1wb3J0IHJvb3QgaXMgbm90IGF2YWlsYWJsZSwgaXRzIGNvbnRlbnRzIGNhbid0IGJlXG4gICAgICAgICAgLy8gd2Fsa2VkLiBXYWl0IGZvciAnbG9hZCcgYW5kIHdhbGsgaXQgd2hlbiBpdCdzIHJlYWR5LlxuICAgICAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGltcG9ydE5vZGUgPSAvKiogQHR5cGUgeyFOb2RlfSAqLyAoZWxlbWVudC5pbXBvcnQpO1xuXG4gICAgICAgICAgICBpZiAoaW1wb3J0Tm9kZS5fX0NFX2RvY3VtZW50TG9hZEhhbmRsZWQpIHJldHVybjtcbiAgICAgICAgICAgIGltcG9ydE5vZGUuX19DRV9kb2N1bWVudExvYWRIYW5kbGVkID0gdHJ1ZTtcblxuICAgICAgICAgICAgaW1wb3J0Tm9kZS5fX0NFX2lzSW1wb3J0RG9jdW1lbnQgPSB0cnVlO1xuXG4gICAgICAgICAgICAvLyBDb25uZWN0ZWQgbGlua3MgYXJlIGFzc29jaWF0ZWQgd2l0aCB0aGUgcmVnaXN0cnkuXG4gICAgICAgICAgICBpbXBvcnROb2RlLl9fQ0VfaGFzUmVnaXN0cnkgPSB0cnVlO1xuXG4gICAgICAgICAgICAvLyBDbG9uZSB0aGUgYHZpc2l0ZWRJbXBvcnRzYCBzZXQgdGhhdCB3YXMgcG9wdWxhdGVkIHN5bmMgZHVyaW5nXG4gICAgICAgICAgICAvLyB0aGUgYHBhdGNoQW5kVXBncmFkZVRyZWVgIGNhbGwgdGhhdCBjYXVzZWQgdGhpcyAnbG9hZCcgaGFuZGxlciB0b1xuICAgICAgICAgICAgLy8gYmUgYWRkZWQuIFRoZW4sIHJlbW92ZSAqdGhpcyogbGluaydzIGltcG9ydCBub2RlIHNvIHRoYXQgd2UgY2FuXG4gICAgICAgICAgICAvLyB3YWxrIHRoYXQgaW1wb3J0IGFnYWluLCBldmVuIGlmIGl0IHdhcyBwYXJ0aWFsbHkgd2Fsa2VkIGxhdGVyXG4gICAgICAgICAgICAvLyBkdXJpbmcgdGhlIHNhbWUgYHBhdGNoQW5kVXBncmFkZVRyZWVgIGNhbGwuXG4gICAgICAgICAgICBjb25zdCBjbG9uZWRWaXNpdGVkSW1wb3J0cyA9IG5ldyBTZXQodmlzaXRlZEltcG9ydHMpO1xuICAgICAgICAgICAgdmlzaXRlZEltcG9ydHMuZGVsZXRlKGltcG9ydE5vZGUpO1xuXG4gICAgICAgICAgICB0aGlzLnBhdGNoQW5kVXBncmFkZVRyZWUoaW1wb3J0Tm9kZSwgdmlzaXRlZEltcG9ydHMpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbGVtZW50cy5wdXNoKGVsZW1lbnQpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBgd2Fsa0RlZXBEZXNjZW5kYW50RWxlbWVudHNgIHBvcHVsYXRlcyAoYW5kIGludGVybmFsbHkgY2hlY2tzIGFnYWluc3QpXG4gICAgLy8gYHZpc2l0ZWRJbXBvcnRzYCB3aGVuIHRyYXZlcnNpbmcgYSBsb2FkZWQgaW1wb3J0LlxuICAgIFV0aWxpdGllcy53YWxrRGVlcERlc2NlbmRhbnRFbGVtZW50cyhyb290LCBnYXRoZXJFbGVtZW50cywgdmlzaXRlZEltcG9ydHMpO1xuXG4gICAgaWYgKHRoaXMuX2hhc1BhdGNoZXMpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZWxlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy5wYXRjaChlbGVtZW50c1tpXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlbGVtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy51cGdyYWRlRWxlbWVudChlbGVtZW50c1tpXSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7IUVsZW1lbnR9IGVsZW1lbnRcbiAgICovXG4gIHVwZ3JhZGVFbGVtZW50KGVsZW1lbnQpIHtcbiAgICBjb25zdCBjdXJyZW50U3RhdGUgPSBlbGVtZW50Ll9fQ0Vfc3RhdGU7XG4gICAgaWYgKGN1cnJlbnRTdGF0ZSAhPT0gdW5kZWZpbmVkKSByZXR1cm47XG5cbiAgICBjb25zdCBkZWZpbml0aW9uID0gdGhpcy5sb2NhbE5hbWVUb0RlZmluaXRpb24oZWxlbWVudC5sb2NhbE5hbWUpO1xuICAgIGlmICghZGVmaW5pdGlvbikgcmV0dXJuO1xuXG4gICAgZGVmaW5pdGlvbi5jb25zdHJ1Y3Rpb25TdGFjay5wdXNoKGVsZW1lbnQpO1xuXG4gICAgY29uc3QgY29uc3RydWN0b3IgPSBkZWZpbml0aW9uLmNvbnN0cnVjdG9yO1xuICAgIHRyeSB7XG4gICAgICB0cnkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gbmV3IChjb25zdHJ1Y3RvcikoKTtcbiAgICAgICAgaWYgKHJlc3VsdCAhPT0gZWxlbWVudCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIGN1c3RvbSBlbGVtZW50IGNvbnN0cnVjdG9yIGRpZCBub3QgcHJvZHVjZSB0aGUgZWxlbWVudCBiZWluZyB1cGdyYWRlZC4nKTtcbiAgICAgICAgfVxuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgZGVmaW5pdGlvbi5jb25zdHJ1Y3Rpb25TdGFjay5wb3AoKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBlbGVtZW50Ll9fQ0Vfc3RhdGUgPSBDRVN0YXRlLmZhaWxlZDtcbiAgICAgIHRocm93IGU7XG4gICAgfVxuXG4gICAgZWxlbWVudC5fX0NFX3N0YXRlID0gQ0VTdGF0ZS5jdXN0b207XG4gICAgZWxlbWVudC5fX0NFX2RlZmluaXRpb24gPSBkZWZpbml0aW9uO1xuXG4gICAgaWYgKGRlZmluaXRpb24uYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKSB7XG4gICAgICBjb25zdCBvYnNlcnZlZEF0dHJpYnV0ZXMgPSBkZWZpbml0aW9uLm9ic2VydmVkQXR0cmlidXRlcztcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb2JzZXJ2ZWRBdHRyaWJ1dGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IG5hbWUgPSBvYnNlcnZlZEF0dHJpYnV0ZXNbaV07XG4gICAgICAgIGNvbnN0IHZhbHVlID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUobmFtZSk7XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gbnVsbCkge1xuICAgICAgICAgIHRoaXMuYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKGVsZW1lbnQsIG5hbWUsIG51bGwsIHZhbHVlLCBudWxsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChVdGlsaXRpZXMuaXNDb25uZWN0ZWQoZWxlbWVudCkpIHtcbiAgICAgIHRoaXMuY29ubmVjdGVkQ2FsbGJhY2soZWxlbWVudCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7IUVsZW1lbnR9IGVsZW1lbnRcbiAgICovXG4gIGNvbm5lY3RlZENhbGxiYWNrKGVsZW1lbnQpIHtcbiAgICBjb25zdCBkZWZpbml0aW9uID0gZWxlbWVudC5fX0NFX2RlZmluaXRpb247XG4gICAgaWYgKGRlZmluaXRpb24uY29ubmVjdGVkQ2FsbGJhY2spIHtcbiAgICAgIGRlZmluaXRpb24uY29ubmVjdGVkQ2FsbGJhY2suY2FsbChlbGVtZW50KTtcbiAgICB9XG5cbiAgICBlbGVtZW50Ll9fQ0VfaXNDb25uZWN0ZWRDYWxsYmFja0NhbGxlZCA9IHRydWU7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHshRWxlbWVudH0gZWxlbWVudFxuICAgKi9cbiAgZGlzY29ubmVjdGVkQ2FsbGJhY2soZWxlbWVudCkge1xuICAgIGlmICghZWxlbWVudC5fX0NFX2lzQ29ubmVjdGVkQ2FsbGJhY2tDYWxsZWQpIHtcbiAgICAgIHRoaXMuY29ubmVjdGVkQ2FsbGJhY2soZWxlbWVudCk7XG4gICAgfVxuXG4gICAgY29uc3QgZGVmaW5pdGlvbiA9IGVsZW1lbnQuX19DRV9kZWZpbml0aW9uO1xuICAgIGlmIChkZWZpbml0aW9uLmRpc2Nvbm5lY3RlZENhbGxiYWNrKSB7XG4gICAgICBkZWZpbml0aW9uLmRpc2Nvbm5lY3RlZENhbGxiYWNrLmNhbGwoZWxlbWVudCk7XG4gICAgfVxuXG4gICAgZWxlbWVudC5fX0NFX2lzQ29ubmVjdGVkQ2FsbGJhY2tDYWxsZWQgPSB1bmRlZmluZWQ7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHshRWxlbWVudH0gZWxlbWVudFxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgKiBAcGFyYW0gez9zdHJpbmd9IG9sZFZhbHVlXG4gICAqIEBwYXJhbSB7P3N0cmluZ30gbmV3VmFsdWVcbiAgICogQHBhcmFtIHs/c3RyaW5nfSBuYW1lc3BhY2VcbiAgICovXG4gIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhlbGVtZW50LCBuYW1lLCBvbGRWYWx1ZSwgbmV3VmFsdWUsIG5hbWVzcGFjZSkge1xuICAgIGNvbnN0IGRlZmluaXRpb24gPSBlbGVtZW50Ll9fQ0VfZGVmaW5pdGlvbjtcbiAgICBpZiAoXG4gICAgICBkZWZpbml0aW9uLmF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayAmJlxuICAgICAgZGVmaW5pdGlvbi5vYnNlcnZlZEF0dHJpYnV0ZXMuaW5kZXhPZihuYW1lKSA+IC0xXG4gICAgKSB7XG4gICAgICBkZWZpbml0aW9uLmF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjay5jYWxsKGVsZW1lbnQsIG5hbWUsIG9sZFZhbHVlLCBuZXdWYWx1ZSwgbmFtZXNwYWNlKTtcbiAgICB9XG4gIH1cbn1cbiIsImltcG9ydCBDdXN0b21FbGVtZW50SW50ZXJuYWxzIGZyb20gJy4vQ3VzdG9tRWxlbWVudEludGVybmFscy5qcyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIERvY3VtZW50Q29uc3RydWN0aW9uT2JzZXJ2ZXIge1xuICBjb25zdHJ1Y3RvcihpbnRlcm5hbHMsIGRvYykge1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHshQ3VzdG9tRWxlbWVudEludGVybmFsc31cbiAgICAgKi9cbiAgICB0aGlzLl9pbnRlcm5hbHMgPSBpbnRlcm5hbHM7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7IURvY3VtZW50fVxuICAgICAqL1xuICAgIHRoaXMuX2RvY3VtZW50ID0gZG9jO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge011dGF0aW9uT2JzZXJ2ZXJ8dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIHRoaXMuX29ic2VydmVyID0gdW5kZWZpbmVkO1xuXG5cbiAgICAvLyBTaW11bGF0ZSB0cmVlIGNvbnN0cnVjdGlvbiBmb3IgYWxsIGN1cnJlbnRseSBhY2Nlc3NpYmxlIG5vZGVzIGluIHRoZVxuICAgIC8vIGRvY3VtZW50LlxuICAgIHRoaXMuX2ludGVybmFscy5wYXRjaEFuZFVwZ3JhZGVUcmVlKHRoaXMuX2RvY3VtZW50KTtcblxuICAgIGlmICh0aGlzLl9kb2N1bWVudC5yZWFkeVN0YXRlID09PSAnbG9hZGluZycpIHtcbiAgICAgIHRoaXMuX29ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIodGhpcy5faGFuZGxlTXV0YXRpb25zLmJpbmQodGhpcykpO1xuXG4gICAgICAvLyBOb2RlcyBjcmVhdGVkIGJ5IHRoZSBwYXJzZXIgYXJlIGdpdmVuIHRvIHRoZSBvYnNlcnZlciAqYmVmb3JlKiB0aGUgbmV4dFxuICAgICAgLy8gdGFzayBydW5zLiBJbmxpbmUgc2NyaXB0cyBhcmUgcnVuIGluIGEgbmV3IHRhc2suIFRoaXMgbWVhbnMgdGhhdCB0aGVcbiAgICAgIC8vIG9ic2VydmVyIHdpbGwgYmUgYWJsZSB0byBoYW5kbGUgdGhlIG5ld2x5IHBhcnNlZCBub2RlcyBiZWZvcmUgdGhlIGlubGluZVxuICAgICAgLy8gc2NyaXB0IGlzIHJ1bi5cbiAgICAgIHRoaXMuX29ic2VydmVyLm9ic2VydmUodGhpcy5fZG9jdW1lbnQsIHtcbiAgICAgICAgY2hpbGRMaXN0OiB0cnVlLFxuICAgICAgICBzdWJ0cmVlOiB0cnVlLFxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgZGlzY29ubmVjdCgpIHtcbiAgICBpZiAodGhpcy5fb2JzZXJ2ZXIpIHtcbiAgICAgIHRoaXMuX29ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHshQXJyYXk8IU11dGF0aW9uUmVjb3JkPn0gbXV0YXRpb25zXG4gICAqL1xuICBfaGFuZGxlTXV0YXRpb25zKG11dGF0aW9ucykge1xuICAgIC8vIE9uY2UgdGhlIGRvY3VtZW50J3MgYHJlYWR5U3RhdGVgIGlzICdpbnRlcmFjdGl2ZScgb3IgJ2NvbXBsZXRlJywgYWxsIG5ld1xuICAgIC8vIG5vZGVzIGNyZWF0ZWQgd2l0aGluIHRoYXQgZG9jdW1lbnQgd2lsbCBiZSB0aGUgcmVzdWx0IG9mIHNjcmlwdCBhbmRcbiAgICAvLyBzaG91bGQgYmUgaGFuZGxlZCBieSBwYXRjaGluZy5cbiAgICBjb25zdCByZWFkeVN0YXRlID0gdGhpcy5fZG9jdW1lbnQucmVhZHlTdGF0ZTtcbiAgICBpZiAocmVhZHlTdGF0ZSA9PT0gJ2ludGVyYWN0aXZlJyB8fCByZWFkeVN0YXRlID09PSAnY29tcGxldGUnKSB7XG4gICAgICB0aGlzLmRpc2Nvbm5lY3QoKTtcbiAgICB9XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG11dGF0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgYWRkZWROb2RlcyA9IG11dGF0aW9uc1tpXS5hZGRlZE5vZGVzO1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBhZGRlZE5vZGVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBhZGRlZE5vZGVzW2pdO1xuICAgICAgICB0aGlzLl9pbnRlcm5hbHMucGF0Y2hBbmRVcGdyYWRlVHJlZShub2RlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbiIsIi8qKlxuICogQHRlbXBsYXRlIFRcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRGVmZXJyZWQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtUfHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICB0aGlzLl92YWx1ZSA9IHVuZGVmaW5lZDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge0Z1bmN0aW9ufHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICB0aGlzLl9yZXNvbHZlID0gdW5kZWZpbmVkO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7IVByb21pc2U8VD59XG4gICAgICovXG4gICAgdGhpcy5fcHJvbWlzZSA9IG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgdGhpcy5fcmVzb2x2ZSA9IHJlc29sdmU7XG5cbiAgICAgIGlmICh0aGlzLl92YWx1ZSkge1xuICAgICAgICByZXNvbHZlKHRoaXMuX3ZhbHVlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1R9IHZhbHVlXG4gICAqL1xuICByZXNvbHZlKHZhbHVlKSB7XG4gICAgaWYgKHRoaXMuX3ZhbHVlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FscmVhZHkgcmVzb2x2ZWQuJyk7XG4gICAgfVxuXG4gICAgdGhpcy5fdmFsdWUgPSB2YWx1ZTtcblxuICAgIGlmICh0aGlzLl9yZXNvbHZlKSB7XG4gICAgICB0aGlzLl9yZXNvbHZlKHZhbHVlKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7IVByb21pc2U8VD59XG4gICAqL1xuICB0b1Byb21pc2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Byb21pc2U7XG4gIH1cbn1cbiIsImltcG9ydCBDdXN0b21FbGVtZW50SW50ZXJuYWxzIGZyb20gJy4vQ3VzdG9tRWxlbWVudEludGVybmFscy5qcyc7XG5pbXBvcnQgRG9jdW1lbnRDb25zdHJ1Y3Rpb25PYnNlcnZlciBmcm9tICcuL0RvY3VtZW50Q29uc3RydWN0aW9uT2JzZXJ2ZXIuanMnO1xuaW1wb3J0IERlZmVycmVkIGZyb20gJy4vRGVmZXJyZWQuanMnO1xuaW1wb3J0ICogYXMgVXRpbGl0aWVzIGZyb20gJy4vVXRpbGl0aWVzLmpzJztcblxuLyoqXG4gKiBAdW5yZXN0cmljdGVkXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEN1c3RvbUVsZW1lbnRSZWdpc3RyeSB7XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7IUN1c3RvbUVsZW1lbnRJbnRlcm5hbHN9IGludGVybmFsc1xuICAgKi9cbiAgY29uc3RydWN0b3IoaW50ZXJuYWxzKSB7XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLl9lbGVtZW50RGVmaW5pdGlvbklzUnVubmluZyA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7IUN1c3RvbUVsZW1lbnRJbnRlcm5hbHN9XG4gICAgICovXG4gICAgdGhpcy5faW50ZXJuYWxzID0gaW50ZXJuYWxzO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7IU1hcDxzdHJpbmcsICFEZWZlcnJlZDx1bmRlZmluZWQ+Pn1cbiAgICAgKi9cbiAgICB0aGlzLl93aGVuRGVmaW5lZERlZmVycmVkID0gbmV3IE1hcCgpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGRlZmF1bHQgZmx1c2ggY2FsbGJhY2sgdHJpZ2dlcnMgdGhlIGRvY3VtZW50IHdhbGsgc3luY2hyb25vdXNseS5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHshRnVuY3Rpb259XG4gICAgICovXG4gICAgdGhpcy5fZmx1c2hDYWxsYmFjayA9IGZuID0+IGZuKCk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuX2ZsdXNoUGVuZGluZyA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7IUFycmF5PHN0cmluZz59XG4gICAgICovXG4gICAgdGhpcy5fdW5mbHVzaGVkTG9jYWxOYW1lcyA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7IURvY3VtZW50Q29uc3RydWN0aW9uT2JzZXJ2ZXJ9XG4gICAgICovXG4gICAgdGhpcy5fZG9jdW1lbnRDb25zdHJ1Y3Rpb25PYnNlcnZlciA9IG5ldyBEb2N1bWVudENvbnN0cnVjdGlvbk9ic2VydmVyKGludGVybmFscywgZG9jdW1lbnQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBsb2NhbE5hbWVcbiAgICogQHBhcmFtIHshRnVuY3Rpb259IGNvbnN0cnVjdG9yXG4gICAqL1xuICBkZWZpbmUobG9jYWxOYW1lLCBjb25zdHJ1Y3Rvcikge1xuICAgIGlmICghKGNvbnN0cnVjdG9yIGluc3RhbmNlb2YgRnVuY3Rpb24pKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdDdXN0b20gZWxlbWVudCBjb25zdHJ1Y3RvcnMgbXVzdCBiZSBmdW5jdGlvbnMuJyk7XG4gICAgfVxuXG4gICAgaWYgKCFVdGlsaXRpZXMuaXNWYWxpZEN1c3RvbUVsZW1lbnROYW1lKGxvY2FsTmFtZSkpIHtcbiAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgVGhlIGVsZW1lbnQgbmFtZSAnJHtsb2NhbE5hbWV9JyBpcyBub3QgdmFsaWQuYCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2ludGVybmFscy5sb2NhbE5hbWVUb0RlZmluaXRpb24obG9jYWxOYW1lKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBBIGN1c3RvbSBlbGVtZW50IHdpdGggbmFtZSAnJHtsb2NhbE5hbWV9JyBoYXMgYWxyZWFkeSBiZWVuIGRlZmluZWQuYCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2VsZW1lbnREZWZpbml0aW9uSXNSdW5uaW5nKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0EgY3VzdG9tIGVsZW1lbnQgaXMgYWxyZWFkeSBiZWluZyBkZWZpbmVkLicpO1xuICAgIH1cbiAgICB0aGlzLl9lbGVtZW50RGVmaW5pdGlvbklzUnVubmluZyA9IHRydWU7XG5cbiAgICBsZXQgY29ubmVjdGVkQ2FsbGJhY2s7XG4gICAgbGV0IGRpc2Nvbm5lY3RlZENhbGxiYWNrO1xuICAgIGxldCBhZG9wdGVkQ2FsbGJhY2s7XG4gICAgbGV0IGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjaztcbiAgICBsZXQgb2JzZXJ2ZWRBdHRyaWJ1dGVzO1xuICAgIHRyeSB7XG4gICAgICAvKiogQHR5cGUgeyFPYmplY3R9ICovXG4gICAgICBjb25zdCBwcm90b3R5cGUgPSBjb25zdHJ1Y3Rvci5wcm90b3R5cGU7XG4gICAgICBpZiAoIShwcm90b3R5cGUgaW5zdGFuY2VvZiBPYmplY3QpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBjdXN0b20gZWxlbWVudCBjb25zdHJ1Y3RvclxcJ3MgcHJvdG90eXBlIGlzIG5vdCBhbiBvYmplY3QuJyk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGdldENhbGxiYWNrKG5hbWUpIHtcbiAgICAgICAgY29uc3QgY2FsbGJhY2tWYWx1ZSA9IHByb3RvdHlwZVtuYW1lXTtcbiAgICAgICAgaWYgKGNhbGxiYWNrVmFsdWUgIT09IHVuZGVmaW5lZCAmJiAhKGNhbGxiYWNrVmFsdWUgaW5zdGFuY2VvZiBGdW5jdGlvbikpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSAnJHtuYW1lfScgY2FsbGJhY2sgbXVzdCBiZSBhIGZ1bmN0aW9uLmApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjYWxsYmFja1ZhbHVlO1xuICAgICAgfVxuXG4gICAgICBjb25uZWN0ZWRDYWxsYmFjayA9IGdldENhbGxiYWNrKCdjb25uZWN0ZWRDYWxsYmFjaycpO1xuICAgICAgZGlzY29ubmVjdGVkQ2FsbGJhY2sgPSBnZXRDYWxsYmFjaygnZGlzY29ubmVjdGVkQ2FsbGJhY2snKTtcbiAgICAgIGFkb3B0ZWRDYWxsYmFjayA9IGdldENhbGxiYWNrKCdhZG9wdGVkQ2FsbGJhY2snKTtcbiAgICAgIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayA9IGdldENhbGxiYWNrKCdhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2snKTtcbiAgICAgIG9ic2VydmVkQXR0cmlidXRlcyA9IGNvbnN0cnVjdG9yWydvYnNlcnZlZEF0dHJpYnV0ZXMnXSB8fCBbXTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm47XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRoaXMuX2VsZW1lbnREZWZpbml0aW9uSXNSdW5uaW5nID0gZmFsc2U7XG4gICAgfVxuXG4gICAgY29uc3QgZGVmaW5pdGlvbiA9IHtcbiAgICAgIGxvY2FsTmFtZSxcbiAgICAgIGNvbnN0cnVjdG9yLFxuICAgICAgY29ubmVjdGVkQ2FsbGJhY2ssXG4gICAgICBkaXNjb25uZWN0ZWRDYWxsYmFjayxcbiAgICAgIGFkb3B0ZWRDYWxsYmFjayxcbiAgICAgIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayxcbiAgICAgIG9ic2VydmVkQXR0cmlidXRlcyxcbiAgICAgIGNvbnN0cnVjdGlvblN0YWNrOiBbXSxcbiAgICB9O1xuXG4gICAgdGhpcy5faW50ZXJuYWxzLnNldERlZmluaXRpb24obG9jYWxOYW1lLCBkZWZpbml0aW9uKTtcblxuICAgIHRoaXMuX3VuZmx1c2hlZExvY2FsTmFtZXMucHVzaChsb2NhbE5hbWUpO1xuXG4gICAgLy8gSWYgd2UndmUgYWxyZWFkeSBjYWxsZWQgdGhlIGZsdXNoIGNhbGxiYWNrIGFuZCBpdCBoYXNuJ3QgY2FsbGVkIGJhY2sgeWV0LFxuICAgIC8vIGRvbid0IGNhbGwgaXQgYWdhaW4uXG4gICAgaWYgKCF0aGlzLl9mbHVzaFBlbmRpbmcpIHtcbiAgICAgIHRoaXMuX2ZsdXNoUGVuZGluZyA9IHRydWU7XG4gICAgICB0aGlzLl9mbHVzaENhbGxiYWNrKCgpID0+IHRoaXMuX2ZsdXNoKCkpO1xuICAgIH1cbiAgfVxuXG4gIF9mbHVzaCgpIHtcbiAgICAvLyBJZiBubyBuZXcgZGVmaW5pdGlvbnMgd2VyZSBkZWZpbmVkLCBkb24ndCBhdHRlbXB0IHRvIGZsdXNoLiBUaGlzIGNvdWxkXG4gICAgLy8gaGFwcGVuIGlmIGEgZmx1c2ggY2FsbGJhY2sga2VlcHMgdGhlIGZ1bmN0aW9uIGl0IGlzIGdpdmVuIGFuZCBjYWxscyBpdFxuICAgIC8vIG11bHRpcGxlIHRpbWVzLlxuICAgIGlmICh0aGlzLl9mbHVzaFBlbmRpbmcgPT09IGZhbHNlKSByZXR1cm47XG5cbiAgICB0aGlzLl9mbHVzaFBlbmRpbmcgPSBmYWxzZTtcbiAgICB0aGlzLl9pbnRlcm5hbHMucGF0Y2hBbmRVcGdyYWRlVHJlZShkb2N1bWVudCk7XG5cbiAgICB3aGlsZSAodGhpcy5fdW5mbHVzaGVkTG9jYWxOYW1lcy5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCBsb2NhbE5hbWUgPSB0aGlzLl91bmZsdXNoZWRMb2NhbE5hbWVzLnNoaWZ0KCk7XG4gICAgICBjb25zdCBkZWZlcnJlZCA9IHRoaXMuX3doZW5EZWZpbmVkRGVmZXJyZWQuZ2V0KGxvY2FsTmFtZSk7XG4gICAgICBpZiAoZGVmZXJyZWQpIHtcbiAgICAgICAgZGVmZXJyZWQucmVzb2x2ZSh1bmRlZmluZWQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbG9jYWxOYW1lXG4gICAqIEByZXR1cm4ge0Z1bmN0aW9ufHVuZGVmaW5lZH1cbiAgICovXG4gIGdldChsb2NhbE5hbWUpIHtcbiAgICBjb25zdCBkZWZpbml0aW9uID0gdGhpcy5faW50ZXJuYWxzLmxvY2FsTmFtZVRvRGVmaW5pdGlvbihsb2NhbE5hbWUpO1xuICAgIGlmIChkZWZpbml0aW9uKSB7XG4gICAgICByZXR1cm4gZGVmaW5pdGlvbi5jb25zdHJ1Y3RvcjtcbiAgICB9XG5cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBsb2NhbE5hbWVcbiAgICogQHJldHVybiB7IVByb21pc2U8dW5kZWZpbmVkPn1cbiAgICovXG4gIHdoZW5EZWZpbmVkKGxvY2FsTmFtZSkge1xuICAgIGlmICghVXRpbGl0aWVzLmlzVmFsaWRDdXN0b21FbGVtZW50TmFtZShsb2NhbE5hbWUpKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IFN5bnRheEVycm9yKGAnJHtsb2NhbE5hbWV9JyBpcyBub3QgYSB2YWxpZCBjdXN0b20gZWxlbWVudCBuYW1lLmApKTtcbiAgICB9XG5cbiAgICBjb25zdCBwcmlvciA9IHRoaXMuX3doZW5EZWZpbmVkRGVmZXJyZWQuZ2V0KGxvY2FsTmFtZSk7XG4gICAgaWYgKHByaW9yKSB7XG4gICAgICByZXR1cm4gcHJpb3IudG9Qcm9taXNlKCk7XG4gICAgfVxuXG4gICAgY29uc3QgZGVmZXJyZWQgPSBuZXcgRGVmZXJyZWQoKTtcbiAgICB0aGlzLl93aGVuRGVmaW5lZERlZmVycmVkLnNldChsb2NhbE5hbWUsIGRlZmVycmVkKTtcblxuICAgIGNvbnN0IGRlZmluaXRpb24gPSB0aGlzLl9pbnRlcm5hbHMubG9jYWxOYW1lVG9EZWZpbml0aW9uKGxvY2FsTmFtZSk7XG4gICAgLy8gUmVzb2x2ZSBpbW1lZGlhdGVseSBvbmx5IGlmIHRoZSBnaXZlbiBsb2NhbCBuYW1lIGhhcyBhIGRlZmluaXRpb24gKmFuZCpcbiAgICAvLyB0aGUgZnVsbCBkb2N1bWVudCB3YWxrIHRvIHVwZ3JhZGUgZWxlbWVudHMgd2l0aCB0aGF0IGxvY2FsIG5hbWUgaGFzXG4gICAgLy8gYWxyZWFkeSBoYXBwZW5lZC5cbiAgICBpZiAoZGVmaW5pdGlvbiAmJiB0aGlzLl91bmZsdXNoZWRMb2NhbE5hbWVzLmluZGV4T2YobG9jYWxOYW1lKSA9PT0gLTEpIHtcbiAgICAgIGRlZmVycmVkLnJlc29sdmUodW5kZWZpbmVkKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZGVmZXJyZWQudG9Qcm9taXNlKCk7XG4gIH1cblxuICBwb2x5ZmlsbFdyYXBGbHVzaENhbGxiYWNrKG91dGVyKSB7XG4gICAgdGhpcy5fZG9jdW1lbnRDb25zdHJ1Y3Rpb25PYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgY29uc3QgaW5uZXIgPSB0aGlzLl9mbHVzaENhbGxiYWNrO1xuICAgIHRoaXMuX2ZsdXNoQ2FsbGJhY2sgPSBmbHVzaCA9PiBvdXRlcigoKSA9PiBpbm5lcihmbHVzaCkpO1xuICB9XG59XG5cbi8vIENsb3N1cmUgY29tcGlsZXIgZXhwb3J0cy5cbndpbmRvd1snQ3VzdG9tRWxlbWVudFJlZ2lzdHJ5J10gPSBDdXN0b21FbGVtZW50UmVnaXN0cnk7XG5DdXN0b21FbGVtZW50UmVnaXN0cnkucHJvdG90eXBlWydkZWZpbmUnXSA9IEN1c3RvbUVsZW1lbnRSZWdpc3RyeS5wcm90b3R5cGUuZGVmaW5lO1xuQ3VzdG9tRWxlbWVudFJlZ2lzdHJ5LnByb3RvdHlwZVsnZ2V0J10gPSBDdXN0b21FbGVtZW50UmVnaXN0cnkucHJvdG90eXBlLmdldDtcbkN1c3RvbUVsZW1lbnRSZWdpc3RyeS5wcm90b3R5cGVbJ3doZW5EZWZpbmVkJ10gPSBDdXN0b21FbGVtZW50UmVnaXN0cnkucHJvdG90eXBlLndoZW5EZWZpbmVkO1xuQ3VzdG9tRWxlbWVudFJlZ2lzdHJ5LnByb3RvdHlwZVsncG9seWZpbGxXcmFwRmx1c2hDYWxsYmFjayddID0gQ3VzdG9tRWxlbWVudFJlZ2lzdHJ5LnByb3RvdHlwZS5wb2x5ZmlsbFdyYXBGbHVzaENhbGxiYWNrO1xuIiwiZXhwb3J0IGRlZmF1bHQge1xuICBEb2N1bWVudF9jcmVhdGVFbGVtZW50OiB3aW5kb3cuRG9jdW1lbnQucHJvdG90eXBlLmNyZWF0ZUVsZW1lbnQsXG4gIERvY3VtZW50X2NyZWF0ZUVsZW1lbnROUzogd2luZG93LkRvY3VtZW50LnByb3RvdHlwZS5jcmVhdGVFbGVtZW50TlMsXG4gIERvY3VtZW50X2ltcG9ydE5vZGU6IHdpbmRvdy5Eb2N1bWVudC5wcm90b3R5cGUuaW1wb3J0Tm9kZSxcbiAgRG9jdW1lbnRfcHJlcGVuZDogd2luZG93LkRvY3VtZW50LnByb3RvdHlwZVsncHJlcGVuZCddLFxuICBEb2N1bWVudF9hcHBlbmQ6IHdpbmRvdy5Eb2N1bWVudC5wcm90b3R5cGVbJ2FwcGVuZCddLFxuICBOb2RlX2Nsb25lTm9kZTogd2luZG93Lk5vZGUucHJvdG90eXBlLmNsb25lTm9kZSxcbiAgTm9kZV9hcHBlbmRDaGlsZDogd2luZG93Lk5vZGUucHJvdG90eXBlLmFwcGVuZENoaWxkLFxuICBOb2RlX2luc2VydEJlZm9yZTogd2luZG93Lk5vZGUucHJvdG90eXBlLmluc2VydEJlZm9yZSxcbiAgTm9kZV9yZW1vdmVDaGlsZDogd2luZG93Lk5vZGUucHJvdG90eXBlLnJlbW92ZUNoaWxkLFxuICBOb2RlX3JlcGxhY2VDaGlsZDogd2luZG93Lk5vZGUucHJvdG90eXBlLnJlcGxhY2VDaGlsZCxcbiAgTm9kZV90ZXh0Q29udGVudDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih3aW5kb3cuTm9kZS5wcm90b3R5cGUsICd0ZXh0Q29udGVudCcpLFxuICBFbGVtZW50X2F0dGFjaFNoYWRvdzogd2luZG93LkVsZW1lbnQucHJvdG90eXBlWydhdHRhY2hTaGFkb3cnXSxcbiAgRWxlbWVudF9pbm5lckhUTUw6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iod2luZG93LkVsZW1lbnQucHJvdG90eXBlLCAnaW5uZXJIVE1MJyksXG4gIEVsZW1lbnRfZ2V0QXR0cmlidXRlOiB3aW5kb3cuRWxlbWVudC5wcm90b3R5cGUuZ2V0QXR0cmlidXRlLFxuICBFbGVtZW50X3NldEF0dHJpYnV0ZTogd2luZG93LkVsZW1lbnQucHJvdG90eXBlLnNldEF0dHJpYnV0ZSxcbiAgRWxlbWVudF9yZW1vdmVBdHRyaWJ1dGU6IHdpbmRvdy5FbGVtZW50LnByb3RvdHlwZS5yZW1vdmVBdHRyaWJ1dGUsXG4gIEVsZW1lbnRfZ2V0QXR0cmlidXRlTlM6IHdpbmRvdy5FbGVtZW50LnByb3RvdHlwZS5nZXRBdHRyaWJ1dGVOUyxcbiAgRWxlbWVudF9zZXRBdHRyaWJ1dGVOUzogd2luZG93LkVsZW1lbnQucHJvdG90eXBlLnNldEF0dHJpYnV0ZU5TLFxuICBFbGVtZW50X3JlbW92ZUF0dHJpYnV0ZU5TOiB3aW5kb3cuRWxlbWVudC5wcm90b3R5cGUucmVtb3ZlQXR0cmlidXRlTlMsXG4gIEVsZW1lbnRfaW5zZXJ0QWRqYWNlbnRFbGVtZW50OiB3aW5kb3cuRWxlbWVudC5wcm90b3R5cGVbJ2luc2VydEFkamFjZW50RWxlbWVudCddLFxuICBFbGVtZW50X3ByZXBlbmQ6IHdpbmRvdy5FbGVtZW50LnByb3RvdHlwZVsncHJlcGVuZCddLFxuICBFbGVtZW50X2FwcGVuZDogd2luZG93LkVsZW1lbnQucHJvdG90eXBlWydhcHBlbmQnXSxcbiAgRWxlbWVudF9iZWZvcmU6IHdpbmRvdy5FbGVtZW50LnByb3RvdHlwZVsnYmVmb3JlJ10sXG4gIEVsZW1lbnRfYWZ0ZXI6IHdpbmRvdy5FbGVtZW50LnByb3RvdHlwZVsnYWZ0ZXInXSxcbiAgRWxlbWVudF9yZXBsYWNlV2l0aDogd2luZG93LkVsZW1lbnQucHJvdG90eXBlWydyZXBsYWNlV2l0aCddLFxuICBFbGVtZW50X3JlbW92ZTogd2luZG93LkVsZW1lbnQucHJvdG90eXBlWydyZW1vdmUnXSxcbiAgSFRNTEVsZW1lbnQ6IHdpbmRvdy5IVE1MRWxlbWVudCxcbiAgSFRNTEVsZW1lbnRfaW5uZXJIVE1MOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHdpbmRvdy5IVE1MRWxlbWVudC5wcm90b3R5cGUsICdpbm5lckhUTUwnKSxcbiAgSFRNTEVsZW1lbnRfaW5zZXJ0QWRqYWNlbnRFbGVtZW50OiB3aW5kb3cuSFRNTEVsZW1lbnQucHJvdG90eXBlWydpbnNlcnRBZGphY2VudEVsZW1lbnQnXSxcbn07XG4iLCIvKipcbiAqIFRoaXMgY2xhc3MgZXhpc3RzIG9ubHkgdG8gd29yayBhcm91bmQgQ2xvc3VyZSdzIGxhY2sgb2YgYSB3YXkgdG8gZGVzY3JpYmVcbiAqIHNpbmdsZXRvbnMuIEl0IHJlcHJlc2VudHMgdGhlICdhbHJlYWR5IGNvbnN0cnVjdGVkIG1hcmtlcicgdXNlZCBpbiBjdXN0b21cbiAqIGVsZW1lbnQgY29uc3RydWN0aW9uIHN0YWNrcy5cbiAqXG4gKiBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnLyNjb25jZXB0LWFscmVhZHktY29uc3RydWN0ZWQtbWFya2VyXG4gKi9cbmNsYXNzIEFscmVhZHlDb25zdHJ1Y3RlZE1hcmtlciB7fVxuXG5leHBvcnQgZGVmYXVsdCBuZXcgQWxyZWFkeUNvbnN0cnVjdGVkTWFya2VyKCk7XG4iLCJpbXBvcnQgTmF0aXZlIGZyb20gJy4vTmF0aXZlLmpzJztcbmltcG9ydCBDdXN0b21FbGVtZW50SW50ZXJuYWxzIGZyb20gJy4uL0N1c3RvbUVsZW1lbnRJbnRlcm5hbHMuanMnO1xuaW1wb3J0IENFU3RhdGUgZnJvbSAnLi4vQ3VzdG9tRWxlbWVudFN0YXRlLmpzJztcbmltcG9ydCBBbHJlYWR5Q29uc3RydWN0ZWRNYXJrZXIgZnJvbSAnLi4vQWxyZWFkeUNvbnN0cnVjdGVkTWFya2VyLmpzJztcblxuLyoqXG4gKiBAcGFyYW0geyFDdXN0b21FbGVtZW50SW50ZXJuYWxzfSBpbnRlcm5hbHNcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oaW50ZXJuYWxzKSB7XG4gIHdpbmRvd1snSFRNTEVsZW1lbnQnXSA9IChmdW5jdGlvbigpIHtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7ZnVuY3Rpb24obmV3OiBIVE1MRWxlbWVudCk6ICFIVE1MRWxlbWVudH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBIVE1MRWxlbWVudCgpIHtcbiAgICAgIC8vIFRoaXMgc2hvdWxkIHJlYWxseSBiZSBgbmV3LnRhcmdldGAgYnV0IGBuZXcudGFyZ2V0YCBjYW4ndCBiZSBlbXVsYXRlZFxuICAgICAgLy8gaW4gRVM1LiBBc3N1bWluZyB0aGUgdXNlciBrZWVwcyB0aGUgZGVmYXVsdCB2YWx1ZSBvZiB0aGUgY29uc3RydWN0b3Inc1xuICAgICAgLy8gcHJvdG90eXBlJ3MgYGNvbnN0cnVjdG9yYCBwcm9wZXJ0eSwgdGhpcyBpcyBlcXVpdmFsZW50LlxuICAgICAgLyoqIEB0eXBlIHshRnVuY3Rpb259ICovXG4gICAgICBjb25zdCBjb25zdHJ1Y3RvciA9IHRoaXMuY29uc3RydWN0b3I7XG5cbiAgICAgIGNvbnN0IGRlZmluaXRpb24gPSBpbnRlcm5hbHMuY29uc3RydWN0b3JUb0RlZmluaXRpb24oY29uc3RydWN0b3IpO1xuICAgICAgaWYgKCFkZWZpbml0aW9uKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIGN1c3RvbSBlbGVtZW50IGJlaW5nIGNvbnN0cnVjdGVkIHdhcyBub3QgcmVnaXN0ZXJlZCB3aXRoIGBjdXN0b21FbGVtZW50c2AuJyk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGNvbnN0cnVjdGlvblN0YWNrID0gZGVmaW5pdGlvbi5jb25zdHJ1Y3Rpb25TdGFjaztcblxuICAgICAgaWYgKGNvbnN0cnVjdGlvblN0YWNrLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBjb25zdCBlbGVtZW50ID0gTmF0aXZlLkRvY3VtZW50X2NyZWF0ZUVsZW1lbnQuY2FsbChkb2N1bWVudCwgZGVmaW5pdGlvbi5sb2NhbE5hbWUpO1xuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoZWxlbWVudCwgY29uc3RydWN0b3IucHJvdG90eXBlKTtcbiAgICAgICAgZWxlbWVudC5fX0NFX3N0YXRlID0gQ0VTdGF0ZS5jdXN0b207XG4gICAgICAgIGVsZW1lbnQuX19DRV9kZWZpbml0aW9uID0gZGVmaW5pdGlvbjtcbiAgICAgICAgaW50ZXJuYWxzLnBhdGNoKGVsZW1lbnQpO1xuICAgICAgICByZXR1cm4gZWxlbWVudDtcbiAgICAgIH1cblxuICAgICAgY29uc3QgbGFzdEluZGV4ID0gY29uc3RydWN0aW9uU3RhY2subGVuZ3RoIC0gMTtcbiAgICAgIGNvbnN0IGVsZW1lbnQgPSBjb25zdHJ1Y3Rpb25TdGFja1tsYXN0SW5kZXhdO1xuICAgICAgaWYgKGVsZW1lbnQgPT09IEFscmVhZHlDb25zdHJ1Y3RlZE1hcmtlcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBIVE1MRWxlbWVudCBjb25zdHJ1Y3RvciB3YXMgZWl0aGVyIGNhbGxlZCByZWVudHJhbnRseSBmb3IgdGhpcyBjb25zdHJ1Y3RvciBvciBjYWxsZWQgbXVsdGlwbGUgdGltZXMuJyk7XG4gICAgICB9XG4gICAgICBjb25zdHJ1Y3Rpb25TdGFja1tsYXN0SW5kZXhdID0gQWxyZWFkeUNvbnN0cnVjdGVkTWFya2VyO1xuXG4gICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoZWxlbWVudCwgY29uc3RydWN0b3IucHJvdG90eXBlKTtcbiAgICAgIGludGVybmFscy5wYXRjaCgvKiogQHR5cGUgeyFIVE1MRWxlbWVudH0gKi8gKGVsZW1lbnQpKTtcblxuICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgfVxuXG4gICAgSFRNTEVsZW1lbnQucHJvdG90eXBlID0gTmF0aXZlLkhUTUxFbGVtZW50LnByb3RvdHlwZTtcblxuICAgIHJldHVybiBIVE1MRWxlbWVudDtcbiAgfSkoKTtcbn07XG4iLCJpbXBvcnQgQ3VzdG9tRWxlbWVudEludGVybmFscyBmcm9tICcuLi8uLi9DdXN0b21FbGVtZW50SW50ZXJuYWxzLmpzJztcbmltcG9ydCAqIGFzIFV0aWxpdGllcyBmcm9tICcuLi8uLi9VdGlsaXRpZXMuanMnO1xuXG4vKipcbiAqIEB0eXBlZGVmIHt7XG4gKiAgIHByZXBlbmQ6ICFmdW5jdGlvbiguLi4oIU5vZGV8c3RyaW5nKSksXG4gICogIGFwcGVuZDogIWZ1bmN0aW9uKC4uLighTm9kZXxzdHJpbmcpKSxcbiAqIH19XG4gKi9cbmxldCBQYXJlbnROb2RlTmF0aXZlTWV0aG9kcztcblxuLyoqXG4gKiBAcGFyYW0geyFDdXN0b21FbGVtZW50SW50ZXJuYWxzfSBpbnRlcm5hbHNcbiAqIEBwYXJhbSB7IU9iamVjdH0gZGVzdGluYXRpb25cbiAqIEBwYXJhbSB7IVBhcmVudE5vZGVOYXRpdmVNZXRob2RzfSBidWlsdEluXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGludGVybmFscywgZGVzdGluYXRpb24sIGJ1aWx0SW4pIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7Li4uKCFOb2RlfHN0cmluZyl9IG5vZGVzXG4gICAqL1xuICBkZXN0aW5hdGlvblsncHJlcGVuZCddID0gZnVuY3Rpb24oLi4ubm9kZXMpIHtcbiAgICAvLyBUT0RPOiBGaXggdGhpcyBmb3Igd2hlbiBvbmUgb2YgYG5vZGVzYCBpcyBhIERvY3VtZW50RnJhZ21lbnQhXG4gICAgY29uc3QgY29ubmVjdGVkQmVmb3JlID0gLyoqIEB0eXBlIHshQXJyYXk8IU5vZGU+fSAqLyAobm9kZXMuZmlsdGVyKG5vZGUgPT4ge1xuICAgICAgLy8gRG9jdW1lbnRGcmFnbWVudHMgYXJlIG5vdCBjb25uZWN0ZWQgYW5kIHdpbGwgbm90IGJlIGFkZGVkIHRvIHRoZSBsaXN0LlxuICAgICAgcmV0dXJuIG5vZGUgaW5zdGFuY2VvZiBOb2RlICYmIFV0aWxpdGllcy5pc0Nvbm5lY3RlZChub2RlKTtcbiAgICB9KSk7XG5cbiAgICBidWlsdEluLnByZXBlbmQuYXBwbHkodGhpcywgbm9kZXMpO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb25uZWN0ZWRCZWZvcmUubGVuZ3RoOyBpKyspIHtcbiAgICAgIGludGVybmFscy5kaXNjb25uZWN0VHJlZShjb25uZWN0ZWRCZWZvcmVbaV0pO1xuICAgIH1cblxuICAgIGlmIChVdGlsaXRpZXMuaXNDb25uZWN0ZWQodGhpcykpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEVsZW1lbnQpIHtcbiAgICAgICAgICBpbnRlcm5hbHMuY29ubmVjdFRyZWUobm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Li4uKCFOb2RlfHN0cmluZyl9IG5vZGVzXG4gICAqL1xuICBkZXN0aW5hdGlvblsnYXBwZW5kJ10gPSBmdW5jdGlvbiguLi5ub2Rlcykge1xuICAgIC8vIFRPRE86IEZpeCB0aGlzIGZvciB3aGVuIG9uZSBvZiBgbm9kZXNgIGlzIGEgRG9jdW1lbnRGcmFnbWVudCFcbiAgICBjb25zdCBjb25uZWN0ZWRCZWZvcmUgPSAvKiogQHR5cGUgeyFBcnJheTwhTm9kZT59ICovIChub2Rlcy5maWx0ZXIobm9kZSA9PiB7XG4gICAgICAvLyBEb2N1bWVudEZyYWdtZW50cyBhcmUgbm90IGNvbm5lY3RlZCBhbmQgd2lsbCBub3QgYmUgYWRkZWQgdG8gdGhlIGxpc3QuXG4gICAgICByZXR1cm4gbm9kZSBpbnN0YW5jZW9mIE5vZGUgJiYgVXRpbGl0aWVzLmlzQ29ubmVjdGVkKG5vZGUpO1xuICAgIH0pKTtcblxuICAgIGJ1aWx0SW4uYXBwZW5kLmFwcGx5KHRoaXMsIG5vZGVzKTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29ubmVjdGVkQmVmb3JlLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpbnRlcm5hbHMuZGlzY29ubmVjdFRyZWUoY29ubmVjdGVkQmVmb3JlW2ldKTtcbiAgICB9XG5cbiAgICBpZiAoVXRpbGl0aWVzLmlzQ29ubmVjdGVkKHRoaXMpKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBFbGVtZW50KSB7XG4gICAgICAgICAgaW50ZXJuYWxzLmNvbm5lY3RUcmVlKG5vZGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xufTtcbiIsImltcG9ydCBOYXRpdmUgZnJvbSAnLi9OYXRpdmUuanMnO1xuaW1wb3J0IEN1c3RvbUVsZW1lbnRJbnRlcm5hbHMgZnJvbSAnLi4vQ3VzdG9tRWxlbWVudEludGVybmFscy5qcyc7XG5pbXBvcnQgKiBhcyBVdGlsaXRpZXMgZnJvbSAnLi4vVXRpbGl0aWVzLmpzJztcblxuaW1wb3J0IFBhdGNoUGFyZW50Tm9kZSBmcm9tICcuL0ludGVyZmFjZS9QYXJlbnROb2RlLmpzJztcblxuLyoqXG4gKiBAcGFyYW0geyFDdXN0b21FbGVtZW50SW50ZXJuYWxzfSBpbnRlcm5hbHNcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oaW50ZXJuYWxzKSB7XG4gIFV0aWxpdGllcy5zZXRQcm9wZXJ0eVVuY2hlY2tlZChEb2N1bWVudC5wcm90b3R5cGUsICdjcmVhdGVFbGVtZW50JyxcbiAgICAvKipcbiAgICAgKiBAdGhpcyB7RG9jdW1lbnR9XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGxvY2FsTmFtZVxuICAgICAqIEByZXR1cm4geyFFbGVtZW50fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uKGxvY2FsTmFtZSkge1xuICAgICAgLy8gT25seSBjcmVhdGUgY3VzdG9tIGVsZW1lbnRzIGlmIHRoaXMgZG9jdW1lbnQgaXMgYXNzb2NpYXRlZCB3aXRoIHRoZSByZWdpc3RyeS5cbiAgICAgIGlmICh0aGlzLl9fQ0VfaGFzUmVnaXN0cnkpIHtcbiAgICAgICAgY29uc3QgZGVmaW5pdGlvbiA9IGludGVybmFscy5sb2NhbE5hbWVUb0RlZmluaXRpb24obG9jYWxOYW1lKTtcbiAgICAgICAgaWYgKGRlZmluaXRpb24pIHtcbiAgICAgICAgICByZXR1cm4gbmV3IChkZWZpbml0aW9uLmNvbnN0cnVjdG9yKSgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IC8qKiBAdHlwZSB7IUVsZW1lbnR9ICovXG4gICAgICAgIChOYXRpdmUuRG9jdW1lbnRfY3JlYXRlRWxlbWVudC5jYWxsKHRoaXMsIGxvY2FsTmFtZSkpO1xuICAgICAgaW50ZXJuYWxzLnBhdGNoKHJlc3VsdCk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0pO1xuXG4gIFV0aWxpdGllcy5zZXRQcm9wZXJ0eVVuY2hlY2tlZChEb2N1bWVudC5wcm90b3R5cGUsICdpbXBvcnROb2RlJyxcbiAgICAvKipcbiAgICAgKiBAdGhpcyB7RG9jdW1lbnR9XG4gICAgICogQHBhcmFtIHshTm9kZX0gbm9kZVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IGRlZXBcbiAgICAgKiBAcmV0dXJuIHshTm9kZX1cbiAgICAgKi9cbiAgICBmdW5jdGlvbihub2RlLCBkZWVwKSB7XG4gICAgICBjb25zdCBjbG9uZSA9IE5hdGl2ZS5Eb2N1bWVudF9pbXBvcnROb2RlLmNhbGwodGhpcywgbm9kZSwgZGVlcCk7XG4gICAgICAvLyBPbmx5IGNyZWF0ZSBjdXN0b20gZWxlbWVudHMgaWYgdGhpcyBkb2N1bWVudCBpcyBhc3NvY2lhdGVkIHdpdGggdGhlIHJlZ2lzdHJ5LlxuICAgICAgaWYgKCF0aGlzLl9fQ0VfaGFzUmVnaXN0cnkpIHtcbiAgICAgICAgaW50ZXJuYWxzLnBhdGNoVHJlZShjbG9uZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbnRlcm5hbHMucGF0Y2hBbmRVcGdyYWRlVHJlZShjbG9uZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY2xvbmU7XG4gICAgfSk7XG5cbiAgY29uc3QgTlNfSFRNTCA9IFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbFwiO1xuXG4gIFV0aWxpdGllcy5zZXRQcm9wZXJ0eVVuY2hlY2tlZChEb2N1bWVudC5wcm90b3R5cGUsICdjcmVhdGVFbGVtZW50TlMnLFxuICAgIC8qKlxuICAgICAqIEB0aGlzIHtEb2N1bWVudH1cbiAgICAgKiBAcGFyYW0gez9zdHJpbmd9IG5hbWVzcGFjZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBsb2NhbE5hbWVcbiAgICAgKiBAcmV0dXJuIHshRWxlbWVudH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbihuYW1lc3BhY2UsIGxvY2FsTmFtZSkge1xuICAgICAgLy8gT25seSBjcmVhdGUgY3VzdG9tIGVsZW1lbnRzIGlmIHRoaXMgZG9jdW1lbnQgaXMgYXNzb2NpYXRlZCB3aXRoIHRoZSByZWdpc3RyeS5cbiAgICAgIGlmICh0aGlzLl9fQ0VfaGFzUmVnaXN0cnkgJiYgKG5hbWVzcGFjZSA9PT0gbnVsbCB8fCBuYW1lc3BhY2UgPT09IE5TX0hUTUwpKSB7XG4gICAgICAgIGNvbnN0IGRlZmluaXRpb24gPSBpbnRlcm5hbHMubG9jYWxOYW1lVG9EZWZpbml0aW9uKGxvY2FsTmFtZSk7XG4gICAgICAgIGlmIChkZWZpbml0aW9uKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyAoZGVmaW5pdGlvbi5jb25zdHJ1Y3RvcikoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjb25zdCByZXN1bHQgPSAvKiogQHR5cGUgeyFFbGVtZW50fSAqL1xuICAgICAgICAoTmF0aXZlLkRvY3VtZW50X2NyZWF0ZUVsZW1lbnROUy5jYWxsKHRoaXMsIG5hbWVzcGFjZSwgbG9jYWxOYW1lKSk7XG4gICAgICBpbnRlcm5hbHMucGF0Y2gocmVzdWx0KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSk7XG5cbiAgUGF0Y2hQYXJlbnROb2RlKGludGVybmFscywgRG9jdW1lbnQucHJvdG90eXBlLCB7XG4gICAgcHJlcGVuZDogTmF0aXZlLkRvY3VtZW50X3ByZXBlbmQsXG4gICAgYXBwZW5kOiBOYXRpdmUuRG9jdW1lbnRfYXBwZW5kLFxuICB9KTtcbn07XG4iLCJpbXBvcnQgTmF0aXZlIGZyb20gJy4vTmF0aXZlLmpzJztcbmltcG9ydCBDdXN0b21FbGVtZW50SW50ZXJuYWxzIGZyb20gJy4uL0N1c3RvbUVsZW1lbnRJbnRlcm5hbHMuanMnO1xuaW1wb3J0ICogYXMgVXRpbGl0aWVzIGZyb20gJy4uL1V0aWxpdGllcy5qcyc7XG5cbi8qKlxuICogQHBhcmFtIHshQ3VzdG9tRWxlbWVudEludGVybmFsc30gaW50ZXJuYWxzXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGludGVybmFscykge1xuICAvLyBgTm9kZSNub2RlVmFsdWVgIGlzIGltcGxlbWVudGVkIG9uIGBBdHRyYC5cbiAgLy8gYE5vZGUjdGV4dENvbnRlbnRgIGlzIGltcGxlbWVudGVkIG9uIGBBdHRyYCwgYEVsZW1lbnRgLlxuXG4gIFV0aWxpdGllcy5zZXRQcm9wZXJ0eVVuY2hlY2tlZChOb2RlLnByb3RvdHlwZSwgJ2luc2VydEJlZm9yZScsXG4gICAgLyoqXG4gICAgICogQHRoaXMge05vZGV9XG4gICAgICogQHBhcmFtIHshTm9kZX0gbm9kZVxuICAgICAqIEBwYXJhbSB7P05vZGV9IHJlZk5vZGVcbiAgICAgKiBAcmV0dXJuIHshTm9kZX1cbiAgICAgKi9cbiAgICBmdW5jdGlvbihub2RlLCByZWZOb2RlKSB7XG4gICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIERvY3VtZW50RnJhZ21lbnQpIHtcbiAgICAgICAgY29uc3QgaW5zZXJ0ZWROb2RlcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5hcHBseShub2RlLmNoaWxkTm9kZXMpO1xuICAgICAgICBjb25zdCBuYXRpdmVSZXN1bHQgPSBOYXRpdmUuTm9kZV9pbnNlcnRCZWZvcmUuY2FsbCh0aGlzLCBub2RlLCByZWZOb2RlKTtcblxuICAgICAgICAvLyBEb2N1bWVudEZyYWdtZW50cyBjYW4ndCBiZSBjb25uZWN0ZWQsIHNvIGBkaXNjb25uZWN0VHJlZWAgd2lsbCBuZXZlclxuICAgICAgICAvLyBuZWVkIHRvIGJlIGNhbGxlZCBvbiBhIERvY3VtZW50RnJhZ21lbnQncyBjaGlsZHJlbiBhZnRlciBpbnNlcnRpbmcgaXQuXG5cbiAgICAgICAgaWYgKFV0aWxpdGllcy5pc0Nvbm5lY3RlZCh0aGlzKSkge1xuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5zZXJ0ZWROb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaW50ZXJuYWxzLmNvbm5lY3RUcmVlKGluc2VydGVkTm9kZXNbaV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuYXRpdmVSZXN1bHQ7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG5vZGVXYXNDb25uZWN0ZWQgPSBVdGlsaXRpZXMuaXNDb25uZWN0ZWQobm9kZSk7XG4gICAgICBjb25zdCBuYXRpdmVSZXN1bHQgPSBOYXRpdmUuTm9kZV9pbnNlcnRCZWZvcmUuY2FsbCh0aGlzLCBub2RlLCByZWZOb2RlKTtcblxuICAgICAgaWYgKG5vZGVXYXNDb25uZWN0ZWQpIHtcbiAgICAgICAgaW50ZXJuYWxzLmRpc2Nvbm5lY3RUcmVlKG5vZGUpO1xuICAgICAgfVxuXG4gICAgICBpZiAoVXRpbGl0aWVzLmlzQ29ubmVjdGVkKHRoaXMpKSB7XG4gICAgICAgIGludGVybmFscy5jb25uZWN0VHJlZShub2RlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5hdGl2ZVJlc3VsdDtcbiAgICB9KTtcblxuICBVdGlsaXRpZXMuc2V0UHJvcGVydHlVbmNoZWNrZWQoTm9kZS5wcm90b3R5cGUsICdhcHBlbmRDaGlsZCcsXG4gICAgLyoqXG4gICAgICogQHRoaXMge05vZGV9XG4gICAgICogQHBhcmFtIHshTm9kZX0gbm9kZVxuICAgICAqIEByZXR1cm4geyFOb2RlfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgRG9jdW1lbnRGcmFnbWVudCkge1xuICAgICAgICBjb25zdCBpbnNlcnRlZE5vZGVzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmFwcGx5KG5vZGUuY2hpbGROb2Rlcyk7XG4gICAgICAgIGNvbnN0IG5hdGl2ZVJlc3VsdCA9IE5hdGl2ZS5Ob2RlX2FwcGVuZENoaWxkLmNhbGwodGhpcywgbm9kZSk7XG5cbiAgICAgICAgLy8gRG9jdW1lbnRGcmFnbWVudHMgY2FuJ3QgYmUgY29ubmVjdGVkLCBzbyBgZGlzY29ubmVjdFRyZWVgIHdpbGwgbmV2ZXJcbiAgICAgICAgLy8gbmVlZCB0byBiZSBjYWxsZWQgb24gYSBEb2N1bWVudEZyYWdtZW50J3MgY2hpbGRyZW4gYWZ0ZXIgaW5zZXJ0aW5nIGl0LlxuXG4gICAgICAgIGlmIChVdGlsaXRpZXMuaXNDb25uZWN0ZWQodGhpcykpIHtcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGluc2VydGVkTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGludGVybmFscy5jb25uZWN0VHJlZShpbnNlcnRlZE5vZGVzW2ldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmF0aXZlUmVzdWx0O1xuICAgICAgfVxuXG4gICAgICBjb25zdCBub2RlV2FzQ29ubmVjdGVkID0gVXRpbGl0aWVzLmlzQ29ubmVjdGVkKG5vZGUpO1xuICAgICAgY29uc3QgbmF0aXZlUmVzdWx0ID0gTmF0aXZlLk5vZGVfYXBwZW5kQ2hpbGQuY2FsbCh0aGlzLCBub2RlKTtcblxuICAgICAgaWYgKG5vZGVXYXNDb25uZWN0ZWQpIHtcbiAgICAgICAgaW50ZXJuYWxzLmRpc2Nvbm5lY3RUcmVlKG5vZGUpO1xuICAgICAgfVxuXG4gICAgICBpZiAoVXRpbGl0aWVzLmlzQ29ubmVjdGVkKHRoaXMpKSB7XG4gICAgICAgIGludGVybmFscy5jb25uZWN0VHJlZShub2RlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5hdGl2ZVJlc3VsdDtcbiAgICB9KTtcblxuICBVdGlsaXRpZXMuc2V0UHJvcGVydHlVbmNoZWNrZWQoTm9kZS5wcm90b3R5cGUsICdjbG9uZU5vZGUnLFxuICAgIC8qKlxuICAgICAqIEB0aGlzIHtOb2RlfVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IGRlZXBcbiAgICAgKiBAcmV0dXJuIHshTm9kZX1cbiAgICAgKi9cbiAgICBmdW5jdGlvbihkZWVwKSB7XG4gICAgICBjb25zdCBjbG9uZSA9IE5hdGl2ZS5Ob2RlX2Nsb25lTm9kZS5jYWxsKHRoaXMsIGRlZXApO1xuICAgICAgLy8gT25seSBjcmVhdGUgY3VzdG9tIGVsZW1lbnRzIGlmIHRoaXMgZWxlbWVudCdzIG93bmVyIGRvY3VtZW50IGlzXG4gICAgICAvLyBhc3NvY2lhdGVkIHdpdGggdGhlIHJlZ2lzdHJ5LlxuICAgICAgaWYgKCF0aGlzLm93bmVyRG9jdW1lbnQuX19DRV9oYXNSZWdpc3RyeSkge1xuICAgICAgICBpbnRlcm5hbHMucGF0Y2hUcmVlKGNsb25lKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGludGVybmFscy5wYXRjaEFuZFVwZ3JhZGVUcmVlKGNsb25lKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjbG9uZTtcbiAgICB9KTtcblxuICBVdGlsaXRpZXMuc2V0UHJvcGVydHlVbmNoZWNrZWQoTm9kZS5wcm90b3R5cGUsICdyZW1vdmVDaGlsZCcsXG4gICAgLyoqXG4gICAgICogQHRoaXMge05vZGV9XG4gICAgICogQHBhcmFtIHshTm9kZX0gbm9kZVxuICAgICAqIEByZXR1cm4geyFOb2RlfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIGNvbnN0IG5vZGVXYXNDb25uZWN0ZWQgPSBVdGlsaXRpZXMuaXNDb25uZWN0ZWQobm9kZSk7XG4gICAgICBjb25zdCBuYXRpdmVSZXN1bHQgPSBOYXRpdmUuTm9kZV9yZW1vdmVDaGlsZC5jYWxsKHRoaXMsIG5vZGUpO1xuXG4gICAgICBpZiAobm9kZVdhc0Nvbm5lY3RlZCkge1xuICAgICAgICBpbnRlcm5hbHMuZGlzY29ubmVjdFRyZWUobm9kZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuYXRpdmVSZXN1bHQ7XG4gICAgfSk7XG5cbiAgVXRpbGl0aWVzLnNldFByb3BlcnR5VW5jaGVja2VkKE5vZGUucHJvdG90eXBlLCAncmVwbGFjZUNoaWxkJyxcbiAgICAvKipcbiAgICAgKiBAdGhpcyB7Tm9kZX1cbiAgICAgKiBAcGFyYW0geyFOb2RlfSBub2RlVG9JbnNlcnRcbiAgICAgKiBAcGFyYW0geyFOb2RlfSBub2RlVG9SZW1vdmVcbiAgICAgKiBAcmV0dXJuIHshTm9kZX1cbiAgICAgKi9cbiAgICBmdW5jdGlvbihub2RlVG9JbnNlcnQsIG5vZGVUb1JlbW92ZSkge1xuICAgICAgaWYgKG5vZGVUb0luc2VydCBpbnN0YW5jZW9mIERvY3VtZW50RnJhZ21lbnQpIHtcbiAgICAgICAgY29uc3QgaW5zZXJ0ZWROb2RlcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5hcHBseShub2RlVG9JbnNlcnQuY2hpbGROb2Rlcyk7XG4gICAgICAgIGNvbnN0IG5hdGl2ZVJlc3VsdCA9IE5hdGl2ZS5Ob2RlX3JlcGxhY2VDaGlsZC5jYWxsKHRoaXMsIG5vZGVUb0luc2VydCwgbm9kZVRvUmVtb3ZlKTtcblxuICAgICAgICAvLyBEb2N1bWVudEZyYWdtZW50cyBjYW4ndCBiZSBjb25uZWN0ZWQsIHNvIGBkaXNjb25uZWN0VHJlZWAgd2lsbCBuZXZlclxuICAgICAgICAvLyBuZWVkIHRvIGJlIGNhbGxlZCBvbiBhIERvY3VtZW50RnJhZ21lbnQncyBjaGlsZHJlbiBhZnRlciBpbnNlcnRpbmcgaXQuXG5cbiAgICAgICAgaWYgKFV0aWxpdGllcy5pc0Nvbm5lY3RlZCh0aGlzKSkge1xuICAgICAgICAgIGludGVybmFscy5kaXNjb25uZWN0VHJlZShub2RlVG9SZW1vdmUpO1xuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5zZXJ0ZWROb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaW50ZXJuYWxzLmNvbm5lY3RUcmVlKGluc2VydGVkTm9kZXNbaV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuYXRpdmVSZXN1bHQ7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG5vZGVUb0luc2VydFdhc0Nvbm5lY3RlZCA9IFV0aWxpdGllcy5pc0Nvbm5lY3RlZChub2RlVG9JbnNlcnQpO1xuICAgICAgY29uc3QgbmF0aXZlUmVzdWx0ID0gTmF0aXZlLk5vZGVfcmVwbGFjZUNoaWxkLmNhbGwodGhpcywgbm9kZVRvSW5zZXJ0LCBub2RlVG9SZW1vdmUpO1xuICAgICAgY29uc3QgdGhpc0lzQ29ubmVjdGVkID0gVXRpbGl0aWVzLmlzQ29ubmVjdGVkKHRoaXMpO1xuXG4gICAgICBpZiAodGhpc0lzQ29ubmVjdGVkKSB7XG4gICAgICAgIGludGVybmFscy5kaXNjb25uZWN0VHJlZShub2RlVG9SZW1vdmUpO1xuICAgICAgfVxuXG4gICAgICBpZiAobm9kZVRvSW5zZXJ0V2FzQ29ubmVjdGVkKSB7XG4gICAgICAgIGludGVybmFscy5kaXNjb25uZWN0VHJlZShub2RlVG9JbnNlcnQpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpc0lzQ29ubmVjdGVkKSB7XG4gICAgICAgIGludGVybmFscy5jb25uZWN0VHJlZShub2RlVG9JbnNlcnQpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmF0aXZlUmVzdWx0O1xuICAgIH0pO1xuXG5cbiAgZnVuY3Rpb24gcGF0Y2hfdGV4dENvbnRlbnQoZGVzdGluYXRpb24sIGJhc2VEZXNjcmlwdG9yKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGRlc3RpbmF0aW9uLCAndGV4dENvbnRlbnQnLCB7XG4gICAgICBlbnVtZXJhYmxlOiBiYXNlRGVzY3JpcHRvci5lbnVtZXJhYmxlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgZ2V0OiBiYXNlRGVzY3JpcHRvci5nZXQsXG4gICAgICBzZXQ6IC8qKiBAdGhpcyB7Tm9kZX0gKi8gZnVuY3Rpb24oYXNzaWduZWRWYWx1ZSkge1xuICAgICAgICAvLyBJZiB0aGlzIGlzIGEgdGV4dCBub2RlIHRoZW4gdGhlcmUgYXJlIG5vIG5vZGVzIHRvIGRpc2Nvbm5lY3QuXG4gICAgICAgIGlmICh0aGlzLm5vZGVUeXBlID09PSBOb2RlLlRFWFRfTk9ERSkge1xuICAgICAgICAgIGJhc2VEZXNjcmlwdG9yLnNldC5jYWxsKHRoaXMsIGFzc2lnbmVkVmFsdWUpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCByZW1vdmVkTm9kZXMgPSB1bmRlZmluZWQ7XG4gICAgICAgIC8vIENoZWNraW5nIGZvciBgZmlyc3RDaGlsZGAgaXMgZmFzdGVyIHRoYW4gcmVhZGluZyBgY2hpbGROb2Rlcy5sZW5ndGhgXG4gICAgICAgIC8vIHRvIGNvbXBhcmUgd2l0aCAwLlxuICAgICAgICBpZiAodGhpcy5maXJzdENoaWxkKSB7XG4gICAgICAgICAgLy8gVXNpbmcgYGNoaWxkTm9kZXNgIGlzIGZhc3RlciB0aGFuIGBjaGlsZHJlbmAsIGV2ZW4gdGhvdWdoIHdlIG9ubHlcbiAgICAgICAgICAvLyBjYXJlIGFib3V0IGVsZW1lbnRzLlxuICAgICAgICAgIGNvbnN0IGNoaWxkTm9kZXMgPSB0aGlzLmNoaWxkTm9kZXM7XG4gICAgICAgICAgY29uc3QgY2hpbGROb2Rlc0xlbmd0aCA9IGNoaWxkTm9kZXMubGVuZ3RoO1xuICAgICAgICAgIGlmIChjaGlsZE5vZGVzTGVuZ3RoID4gMCAmJiBVdGlsaXRpZXMuaXNDb25uZWN0ZWQodGhpcykpIHtcbiAgICAgICAgICAgIC8vIENvcHlpbmcgYW4gYXJyYXkgYnkgaXRlcmF0aW5nIGlzIGZhc3RlciB0aGFuIHVzaW5nIHNsaWNlLlxuICAgICAgICAgICAgcmVtb3ZlZE5vZGVzID0gbmV3IEFycmF5KGNoaWxkTm9kZXNMZW5ndGgpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZE5vZGVzTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgcmVtb3ZlZE5vZGVzW2ldID0gY2hpbGROb2Rlc1tpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBiYXNlRGVzY3JpcHRvci5zZXQuY2FsbCh0aGlzLCBhc3NpZ25lZFZhbHVlKTtcblxuICAgICAgICBpZiAocmVtb3ZlZE5vZGVzKSB7XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZW1vdmVkTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGludGVybmFscy5kaXNjb25uZWN0VHJlZShyZW1vdmVkTm9kZXNbaV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICB9KTtcbiAgfVxuXG4gIGlmIChOYXRpdmUuTm9kZV90ZXh0Q29udGVudCAmJiBOYXRpdmUuTm9kZV90ZXh0Q29udGVudC5nZXQpIHtcbiAgICBwYXRjaF90ZXh0Q29udGVudChOb2RlLnByb3RvdHlwZSwgTmF0aXZlLk5vZGVfdGV4dENvbnRlbnQpO1xuICB9IGVsc2Uge1xuICAgIGludGVybmFscy5hZGRQYXRjaChmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICBwYXRjaF90ZXh0Q29udGVudChlbGVtZW50LCB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgLy8gTk9URTogVGhpcyBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgYHRleHRDb250ZW50YCBnZXR0ZXIgYXNzdW1lcyB0aGF0XG4gICAgICAgIC8vIHRleHQgbm9kZXMnIGB0ZXh0Q29udGVudGAgZ2V0dGVyIHdpbGwgbm90IGJlIHBhdGNoZWQuXG4gICAgICAgIGdldDogLyoqIEB0aGlzIHtOb2RlfSAqLyBmdW5jdGlvbigpIHtcbiAgICAgICAgICAvKiogQHR5cGUgeyFBcnJheTxzdHJpbmc+fSAqL1xuICAgICAgICAgIGNvbnN0IHBhcnRzID0gW107XG5cbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuY2hpbGROb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcGFydHMucHVzaCh0aGlzLmNoaWxkTm9kZXNbaV0udGV4dENvbnRlbnQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBwYXJ0cy5qb2luKCcnKTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiAvKiogQHRoaXMge05vZGV9ICovIGZ1bmN0aW9uKGFzc2lnbmVkVmFsdWUpIHtcbiAgICAgICAgICB3aGlsZSAodGhpcy5maXJzdENoaWxkKSB7XG4gICAgICAgICAgICBOYXRpdmUuTm9kZV9yZW1vdmVDaGlsZC5jYWxsKHRoaXMsIHRoaXMuZmlyc3RDaGlsZCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIE5hdGl2ZS5Ob2RlX2FwcGVuZENoaWxkLmNhbGwodGhpcywgZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoYXNzaWduZWRWYWx1ZSkpO1xuICAgICAgICB9LFxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbn07XG4iLCJpbXBvcnQgQ3VzdG9tRWxlbWVudEludGVybmFscyBmcm9tICcuLi8uLi9DdXN0b21FbGVtZW50SW50ZXJuYWxzLmpzJztcbmltcG9ydCAqIGFzIFV0aWxpdGllcyBmcm9tICcuLi8uLi9VdGlsaXRpZXMuanMnO1xuXG4vKipcbiAqIEB0eXBlZGVmIHt7XG4gKiAgIGJlZm9yZTogIWZ1bmN0aW9uKC4uLighTm9kZXxzdHJpbmcpKSxcbiAqICAgYWZ0ZXI6ICFmdW5jdGlvbiguLi4oIU5vZGV8c3RyaW5nKSksXG4gKiAgIHJlcGxhY2VXaXRoOiAhZnVuY3Rpb24oLi4uKCFOb2RlfHN0cmluZykpLFxuICogICByZW1vdmU6ICFmdW5jdGlvbigpLFxuICogfX1cbiAqL1xubGV0IENoaWxkTm9kZU5hdGl2ZU1ldGhvZHM7XG5cbi8qKlxuICogQHBhcmFtIHshQ3VzdG9tRWxlbWVudEludGVybmFsc30gaW50ZXJuYWxzXG4gKiBAcGFyYW0geyFPYmplY3R9IGRlc3RpbmF0aW9uXG4gKiBAcGFyYW0geyFDaGlsZE5vZGVOYXRpdmVNZXRob2RzfSBidWlsdEluXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGludGVybmFscywgZGVzdGluYXRpb24sIGJ1aWx0SW4pIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7Li4uKCFOb2RlfHN0cmluZyl9IG5vZGVzXG4gICAqL1xuICBkZXN0aW5hdGlvblsnYmVmb3JlJ10gPSBmdW5jdGlvbiguLi5ub2Rlcykge1xuICAgIC8vIFRPRE86IEZpeCB0aGlzIGZvciB3aGVuIG9uZSBvZiBgbm9kZXNgIGlzIGEgRG9jdW1lbnRGcmFnbWVudCFcbiAgICBjb25zdCBjb25uZWN0ZWRCZWZvcmUgPSAvKiogQHR5cGUgeyFBcnJheTwhTm9kZT59ICovIChub2Rlcy5maWx0ZXIobm9kZSA9PiB7XG4gICAgICAvLyBEb2N1bWVudEZyYWdtZW50cyBhcmUgbm90IGNvbm5lY3RlZCBhbmQgd2lsbCBub3QgYmUgYWRkZWQgdG8gdGhlIGxpc3QuXG4gICAgICByZXR1cm4gbm9kZSBpbnN0YW5jZW9mIE5vZGUgJiYgVXRpbGl0aWVzLmlzQ29ubmVjdGVkKG5vZGUpO1xuICAgIH0pKTtcblxuICAgIGJ1aWx0SW4uYmVmb3JlLmFwcGx5KHRoaXMsIG5vZGVzKTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29ubmVjdGVkQmVmb3JlLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpbnRlcm5hbHMuZGlzY29ubmVjdFRyZWUoY29ubmVjdGVkQmVmb3JlW2ldKTtcbiAgICB9XG5cbiAgICBpZiAoVXRpbGl0aWVzLmlzQ29ubmVjdGVkKHRoaXMpKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBFbGVtZW50KSB7XG4gICAgICAgICAgaW50ZXJuYWxzLmNvbm5lY3RUcmVlKG5vZGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0gey4uLighTm9kZXxzdHJpbmcpfSBub2Rlc1xuICAgKi9cbiAgZGVzdGluYXRpb25bJ2FmdGVyJ10gPSBmdW5jdGlvbiguLi5ub2Rlcykge1xuICAgIC8vIFRPRE86IEZpeCB0aGlzIGZvciB3aGVuIG9uZSBvZiBgbm9kZXNgIGlzIGEgRG9jdW1lbnRGcmFnbWVudCFcbiAgICBjb25zdCBjb25uZWN0ZWRCZWZvcmUgPSAvKiogQHR5cGUgeyFBcnJheTwhTm9kZT59ICovIChub2Rlcy5maWx0ZXIobm9kZSA9PiB7XG4gICAgICAvLyBEb2N1bWVudEZyYWdtZW50cyBhcmUgbm90IGNvbm5lY3RlZCBhbmQgd2lsbCBub3QgYmUgYWRkZWQgdG8gdGhlIGxpc3QuXG4gICAgICByZXR1cm4gbm9kZSBpbnN0YW5jZW9mIE5vZGUgJiYgVXRpbGl0aWVzLmlzQ29ubmVjdGVkKG5vZGUpO1xuICAgIH0pKTtcblxuICAgIGJ1aWx0SW4uYWZ0ZXIuYXBwbHkodGhpcywgbm9kZXMpO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb25uZWN0ZWRCZWZvcmUubGVuZ3RoOyBpKyspIHtcbiAgICAgIGludGVybmFscy5kaXNjb25uZWN0VHJlZShjb25uZWN0ZWRCZWZvcmVbaV0pO1xuICAgIH1cblxuICAgIGlmIChVdGlsaXRpZXMuaXNDb25uZWN0ZWQodGhpcykpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEVsZW1lbnQpIHtcbiAgICAgICAgICBpbnRlcm5hbHMuY29ubmVjdFRyZWUobm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Li4uKCFOb2RlfHN0cmluZyl9IG5vZGVzXG4gICAqL1xuICBkZXN0aW5hdGlvblsncmVwbGFjZVdpdGgnXSA9IGZ1bmN0aW9uKC4uLm5vZGVzKSB7XG4gICAgLy8gVE9ETzogRml4IHRoaXMgZm9yIHdoZW4gb25lIG9mIGBub2Rlc2AgaXMgYSBEb2N1bWVudEZyYWdtZW50IVxuICAgIGNvbnN0IGNvbm5lY3RlZEJlZm9yZSA9IC8qKiBAdHlwZSB7IUFycmF5PCFOb2RlPn0gKi8gKG5vZGVzLmZpbHRlcihub2RlID0+IHtcbiAgICAgIC8vIERvY3VtZW50RnJhZ21lbnRzIGFyZSBub3QgY29ubmVjdGVkIGFuZCB3aWxsIG5vdCBiZSBhZGRlZCB0byB0aGUgbGlzdC5cbiAgICAgIHJldHVybiBub2RlIGluc3RhbmNlb2YgTm9kZSAmJiBVdGlsaXRpZXMuaXNDb25uZWN0ZWQobm9kZSk7XG4gICAgfSkpO1xuXG4gICAgY29uc3Qgd2FzQ29ubmVjdGVkID0gVXRpbGl0aWVzLmlzQ29ubmVjdGVkKHRoaXMpO1xuXG4gICAgYnVpbHRJbi5yZXBsYWNlV2l0aC5hcHBseSh0aGlzLCBub2Rlcyk7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbm5lY3RlZEJlZm9yZS5sZW5ndGg7IGkrKykge1xuICAgICAgaW50ZXJuYWxzLmRpc2Nvbm5lY3RUcmVlKGNvbm5lY3RlZEJlZm9yZVtpXSk7XG4gICAgfVxuXG4gICAgaWYgKHdhc0Nvbm5lY3RlZCkge1xuICAgICAgaW50ZXJuYWxzLmRpc2Nvbm5lY3RUcmVlKHRoaXMpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBub2RlID0gbm9kZXNbaV07XG4gICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgRWxlbWVudCkge1xuICAgICAgICAgIGludGVybmFscy5jb25uZWN0VHJlZShub2RlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBkZXN0aW5hdGlvblsncmVtb3ZlJ10gPSBmdW5jdGlvbigpIHtcbiAgICBjb25zdCB3YXNDb25uZWN0ZWQgPSBVdGlsaXRpZXMuaXNDb25uZWN0ZWQodGhpcyk7XG5cbiAgICBidWlsdEluLnJlbW92ZS5jYWxsKHRoaXMpO1xuXG4gICAgaWYgKHdhc0Nvbm5lY3RlZCkge1xuICAgICAgaW50ZXJuYWxzLmRpc2Nvbm5lY3RUcmVlKHRoaXMpO1xuICAgIH1cbiAgfTtcbn07XG4iLCJpbXBvcnQgTmF0aXZlIGZyb20gJy4vTmF0aXZlLmpzJztcbmltcG9ydCBDdXN0b21FbGVtZW50SW50ZXJuYWxzIGZyb20gJy4uL0N1c3RvbUVsZW1lbnRJbnRlcm5hbHMuanMnO1xuaW1wb3J0IENFU3RhdGUgZnJvbSAnLi4vQ3VzdG9tRWxlbWVudFN0YXRlLmpzJztcbmltcG9ydCAqIGFzIFV0aWxpdGllcyBmcm9tICcuLi9VdGlsaXRpZXMuanMnO1xuXG5pbXBvcnQgUGF0Y2hQYXJlbnROb2RlIGZyb20gJy4vSW50ZXJmYWNlL1BhcmVudE5vZGUuanMnO1xuaW1wb3J0IFBhdGNoQ2hpbGROb2RlIGZyb20gJy4vSW50ZXJmYWNlL0NoaWxkTm9kZS5qcyc7XG5cbi8qKlxuICogQHBhcmFtIHshQ3VzdG9tRWxlbWVudEludGVybmFsc30gaW50ZXJuYWxzXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGludGVybmFscykge1xuICBpZiAoTmF0aXZlLkVsZW1lbnRfYXR0YWNoU2hhZG93KSB7XG4gICAgVXRpbGl0aWVzLnNldFByb3BlcnR5VW5jaGVja2VkKEVsZW1lbnQucHJvdG90eXBlLCAnYXR0YWNoU2hhZG93JyxcbiAgICAgIC8qKlxuICAgICAgICogQHRoaXMge0VsZW1lbnR9XG4gICAgICAgKiBAcGFyYW0geyF7bW9kZTogc3RyaW5nfX0gaW5pdFxuICAgICAgICogQHJldHVybiB7U2hhZG93Um9vdH1cbiAgICAgICAqL1xuICAgICAgZnVuY3Rpb24oaW5pdCkge1xuICAgICAgICBjb25zdCBzaGFkb3dSb290ID0gTmF0aXZlLkVsZW1lbnRfYXR0YWNoU2hhZG93LmNhbGwodGhpcywgaW5pdCk7XG4gICAgICAgIHRoaXMuX19DRV9zaGFkb3dSb290ID0gc2hhZG93Um9vdDtcbiAgICAgICAgcmV0dXJuIHNoYWRvd1Jvb3Q7XG4gICAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBjb25zb2xlLndhcm4oJ0N1c3RvbSBFbGVtZW50czogYEVsZW1lbnQjYXR0YWNoU2hhZG93YCB3YXMgbm90IHBhdGNoZWQuJyk7XG4gIH1cblxuXG4gIGZ1bmN0aW9uIHBhdGNoX2lubmVySFRNTChkZXN0aW5hdGlvbiwgYmFzZURlc2NyaXB0b3IpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZGVzdGluYXRpb24sICdpbm5lckhUTUwnLCB7XG4gICAgICBlbnVtZXJhYmxlOiBiYXNlRGVzY3JpcHRvci5lbnVtZXJhYmxlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgZ2V0OiBiYXNlRGVzY3JpcHRvci5nZXQsXG4gICAgICBzZXQ6IC8qKiBAdGhpcyB7RWxlbWVudH0gKi8gZnVuY3Rpb24oaHRtbFN0cmluZykge1xuICAgICAgICBjb25zdCBpc0Nvbm5lY3RlZCA9IFV0aWxpdGllcy5pc0Nvbm5lY3RlZCh0aGlzKTtcblxuICAgICAgICAvLyBOT1RFOiBJbiBJRTExLCB3aGVuIHVzaW5nIHRoZSBuYXRpdmUgYGlubmVySFRNTGAgc2V0dGVyLCBhbGwgbm9kZXNcbiAgICAgICAgLy8gdGhhdCB3ZXJlIHByZXZpb3VzbHkgZGVzY2VuZGFudHMgb2YgdGhlIGNvbnRleHQgZWxlbWVudCBoYXZlIGFsbCBvZlxuICAgICAgICAvLyB0aGVpciBjaGlsZHJlbiByZW1vdmVkIGFzIHBhcnQgb2YgdGhlIHNldCAtIHRoZSBlbnRpcmUgc3VidHJlZSBpc1xuICAgICAgICAvLyAnZGlzYXNzZW1ibGVkJy4gVGhpcyB3b3JrIGFyb3VuZCB3YWxrcyB0aGUgc3VidHJlZSAqYmVmb3JlKiB1c2luZyB0aGVcbiAgICAgICAgLy8gbmF0aXZlIHNldHRlci5cbiAgICAgICAgLyoqIEB0eXBlIHshQXJyYXk8IUVsZW1lbnQ+fHVuZGVmaW5lZH0gKi9cbiAgICAgICAgbGV0IHJlbW92ZWRFbGVtZW50cyA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKGlzQ29ubmVjdGVkKSB7XG4gICAgICAgICAgcmVtb3ZlZEVsZW1lbnRzID0gW107XG4gICAgICAgICAgVXRpbGl0aWVzLndhbGtEZWVwRGVzY2VuZGFudEVsZW1lbnRzKHRoaXMsIGVsZW1lbnQgPT4ge1xuICAgICAgICAgICAgaWYgKGVsZW1lbnQgIT09IHRoaXMpIHtcbiAgICAgICAgICAgICAgcmVtb3ZlZEVsZW1lbnRzLnB1c2goZWxlbWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBiYXNlRGVzY3JpcHRvci5zZXQuY2FsbCh0aGlzLCBodG1sU3RyaW5nKTtcblxuICAgICAgICBpZiAocmVtb3ZlZEVsZW1lbnRzKSB7XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZW1vdmVkRWxlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGVsZW1lbnQgPSByZW1vdmVkRWxlbWVudHNbaV07XG4gICAgICAgICAgICBpZiAoZWxlbWVudC5fX0NFX3N0YXRlID09PSBDRVN0YXRlLmN1c3RvbSkge1xuICAgICAgICAgICAgICBpbnRlcm5hbHMuZGlzY29ubmVjdGVkQ2FsbGJhY2soZWxlbWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gT25seSBjcmVhdGUgY3VzdG9tIGVsZW1lbnRzIGlmIHRoaXMgZWxlbWVudCdzIG93bmVyIGRvY3VtZW50IGlzXG4gICAgICAgIC8vIGFzc29jaWF0ZWQgd2l0aCB0aGUgcmVnaXN0cnkuXG4gICAgICAgIGlmICghdGhpcy5vd25lckRvY3VtZW50Ll9fQ0VfaGFzUmVnaXN0cnkpIHtcbiAgICAgICAgICBpbnRlcm5hbHMucGF0Y2hUcmVlKHRoaXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGludGVybmFscy5wYXRjaEFuZFVwZ3JhZGVUcmVlKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBodG1sU3RyaW5nO1xuICAgICAgfSxcbiAgICB9KTtcbiAgfVxuXG4gIGlmIChOYXRpdmUuRWxlbWVudF9pbm5lckhUTUwgJiYgTmF0aXZlLkVsZW1lbnRfaW5uZXJIVE1MLmdldCkge1xuICAgIHBhdGNoX2lubmVySFRNTChFbGVtZW50LnByb3RvdHlwZSwgTmF0aXZlLkVsZW1lbnRfaW5uZXJIVE1MKTtcbiAgfSBlbHNlIGlmIChOYXRpdmUuSFRNTEVsZW1lbnRfaW5uZXJIVE1MICYmIE5hdGl2ZS5IVE1MRWxlbWVudF9pbm5lckhUTUwuZ2V0KSB7XG4gICAgcGF0Y2hfaW5uZXJIVE1MKEhUTUxFbGVtZW50LnByb3RvdHlwZSwgTmF0aXZlLkhUTUxFbGVtZW50X2lubmVySFRNTCk7XG4gIH0gZWxzZSB7XG5cbiAgICAvKiogQHR5cGUge0hUTUxEaXZFbGVtZW50fSAqL1xuICAgIGNvbnN0IHJhd0RpdiA9IE5hdGl2ZS5Eb2N1bWVudF9jcmVhdGVFbGVtZW50LmNhbGwoZG9jdW1lbnQsICdkaXYnKTtcblxuICAgIGludGVybmFscy5hZGRQYXRjaChmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICBwYXRjaF9pbm5lckhUTUwoZWxlbWVudCwge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIC8vIEltcGxlbWVudHMgZ2V0dGluZyBgaW5uZXJIVE1MYCBieSBwZXJmb3JtaW5nIGFuIHVucGF0Y2hlZCBgY2xvbmVOb2RlYFxuICAgICAgICAvLyBvZiB0aGUgZWxlbWVudCBhbmQgcmV0dXJuaW5nIHRoZSByZXN1bHRpbmcgZWxlbWVudCdzIGBpbm5lckhUTUxgLlxuICAgICAgICAvLyBUT0RPOiBJcyB0aGlzIHRvbyBleHBlbnNpdmU/XG4gICAgICAgIGdldDogLyoqIEB0aGlzIHtFbGVtZW50fSAqLyBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gTmF0aXZlLk5vZGVfY2xvbmVOb2RlLmNhbGwodGhpcywgdHJ1ZSkuaW5uZXJIVE1MO1xuICAgICAgICB9LFxuICAgICAgICAvLyBJbXBsZW1lbnRzIHNldHRpbmcgYGlubmVySFRNTGAgYnkgY3JlYXRpbmcgYW4gdW5wYXRjaGVkIGVsZW1lbnQsXG4gICAgICAgIC8vIHNldHRpbmcgYGlubmVySFRNTGAgb2YgdGhhdCBlbGVtZW50IGFuZCByZXBsYWNpbmcgdGhlIHRhcmdldFxuICAgICAgICAvLyBlbGVtZW50J3MgY2hpbGRyZW4gd2l0aCB0aG9zZSBvZiB0aGUgdW5wYXRjaGVkIGVsZW1lbnQuXG4gICAgICAgIHNldDogLyoqIEB0aGlzIHtFbGVtZW50fSAqLyBmdW5jdGlvbihhc3NpZ25lZFZhbHVlKSB7XG4gICAgICAgICAgLy8gTk9URTogcmUtcm91dGUgdG8gYGNvbnRlbnRgIGZvciBgdGVtcGxhdGVgIGVsZW1lbnRzLlxuICAgICAgICAgIC8vIFdlIG5lZWQgdG8gZG8gdGhpcyBiZWNhdXNlIGB0ZW1wbGF0ZS5hcHBlbmRDaGlsZGAgZG9lcyBub3RcbiAgICAgICAgICAvLyByb3V0ZSBpbnRvIGB0ZW1wbGF0ZS5jb250ZW50YC5cbiAgICAgICAgICAvKiogQHR5cGUgeyFOb2RlfSAqL1xuICAgICAgICAgIGNvbnN0IGNvbnRlbnQgPSB0aGlzLmxvY2FsTmFtZSA9PT0gJ3RlbXBsYXRlJyA/ICgvKiogQHR5cGUgeyFIVE1MVGVtcGxhdGVFbGVtZW50fSAqLyAodGhpcykpLmNvbnRlbnQgOiB0aGlzO1xuICAgICAgICAgIHJhd0Rpdi5pbm5lckhUTUwgPSBhc3NpZ25lZFZhbHVlO1xuXG4gICAgICAgICAgd2hpbGUgKGNvbnRlbnQuY2hpbGROb2Rlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBOYXRpdmUuTm9kZV9yZW1vdmVDaGlsZC5jYWxsKGNvbnRlbnQsIGNvbnRlbnQuY2hpbGROb2Rlc1swXSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHdoaWxlIChyYXdEaXYuY2hpbGROb2Rlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBOYXRpdmUuTm9kZV9hcHBlbmRDaGlsZC5jYWxsKGNvbnRlbnQsIHJhd0Rpdi5jaGlsZE5vZGVzWzBdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG5cbiAgVXRpbGl0aWVzLnNldFByb3BlcnR5VW5jaGVja2VkKEVsZW1lbnQucHJvdG90eXBlLCAnc2V0QXR0cmlidXRlJyxcbiAgICAvKipcbiAgICAgKiBAdGhpcyB7RWxlbWVudH1cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuZXdWYWx1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uKG5hbWUsIG5ld1ZhbHVlKSB7XG4gICAgICAvLyBGYXN0IHBhdGggZm9yIG5vbi1jdXN0b20gZWxlbWVudHMuXG4gICAgICBpZiAodGhpcy5fX0NFX3N0YXRlICE9PSBDRVN0YXRlLmN1c3RvbSkge1xuICAgICAgICByZXR1cm4gTmF0aXZlLkVsZW1lbnRfc2V0QXR0cmlidXRlLmNhbGwodGhpcywgbmFtZSwgbmV3VmFsdWUpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBvbGRWYWx1ZSA9IE5hdGl2ZS5FbGVtZW50X2dldEF0dHJpYnV0ZS5jYWxsKHRoaXMsIG5hbWUpO1xuICAgICAgTmF0aXZlLkVsZW1lbnRfc2V0QXR0cmlidXRlLmNhbGwodGhpcywgbmFtZSwgbmV3VmFsdWUpO1xuICAgICAgbmV3VmFsdWUgPSBOYXRpdmUuRWxlbWVudF9nZXRBdHRyaWJ1dGUuY2FsbCh0aGlzLCBuYW1lKTtcbiAgICAgIGludGVybmFscy5hdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sodGhpcywgbmFtZSwgb2xkVmFsdWUsIG5ld1ZhbHVlLCBudWxsKTtcbiAgICB9KTtcblxuICBVdGlsaXRpZXMuc2V0UHJvcGVydHlVbmNoZWNrZWQoRWxlbWVudC5wcm90b3R5cGUsICdzZXRBdHRyaWJ1dGVOUycsXG4gICAgLyoqXG4gICAgICogQHRoaXMge0VsZW1lbnR9XG4gICAgICogQHBhcmFtIHs/c3RyaW5nfSBuYW1lc3BhY2VcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuZXdWYWx1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uKG5hbWVzcGFjZSwgbmFtZSwgbmV3VmFsdWUpIHtcbiAgICAgIC8vIEZhc3QgcGF0aCBmb3Igbm9uLWN1c3RvbSBlbGVtZW50cy5cbiAgICAgIGlmICh0aGlzLl9fQ0Vfc3RhdGUgIT09IENFU3RhdGUuY3VzdG9tKSB7XG4gICAgICAgIHJldHVybiBOYXRpdmUuRWxlbWVudF9zZXRBdHRyaWJ1dGVOUy5jYWxsKHRoaXMsIG5hbWVzcGFjZSwgbmFtZSwgbmV3VmFsdWUpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBvbGRWYWx1ZSA9IE5hdGl2ZS5FbGVtZW50X2dldEF0dHJpYnV0ZU5TLmNhbGwodGhpcywgbmFtZXNwYWNlLCBuYW1lKTtcbiAgICAgIE5hdGl2ZS5FbGVtZW50X3NldEF0dHJpYnV0ZU5TLmNhbGwodGhpcywgbmFtZXNwYWNlLCBuYW1lLCBuZXdWYWx1ZSk7XG4gICAgICBuZXdWYWx1ZSA9IE5hdGl2ZS5FbGVtZW50X2dldEF0dHJpYnV0ZU5TLmNhbGwodGhpcywgbmFtZXNwYWNlLCBuYW1lKTtcbiAgICAgIGludGVybmFscy5hdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sodGhpcywgbmFtZSwgb2xkVmFsdWUsIG5ld1ZhbHVlLCBuYW1lc3BhY2UpO1xuICAgIH0pO1xuXG4gIFV0aWxpdGllcy5zZXRQcm9wZXJ0eVVuY2hlY2tlZChFbGVtZW50LnByb3RvdHlwZSwgJ3JlbW92ZUF0dHJpYnV0ZScsXG4gICAgLyoqXG4gICAgICogQHRoaXMge0VsZW1lbnR9XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbihuYW1lKSB7XG4gICAgICAvLyBGYXN0IHBhdGggZm9yIG5vbi1jdXN0b20gZWxlbWVudHMuXG4gICAgICBpZiAodGhpcy5fX0NFX3N0YXRlICE9PSBDRVN0YXRlLmN1c3RvbSkge1xuICAgICAgICByZXR1cm4gTmF0aXZlLkVsZW1lbnRfcmVtb3ZlQXR0cmlidXRlLmNhbGwodGhpcywgbmFtZSk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG9sZFZhbHVlID0gTmF0aXZlLkVsZW1lbnRfZ2V0QXR0cmlidXRlLmNhbGwodGhpcywgbmFtZSk7XG4gICAgICBOYXRpdmUuRWxlbWVudF9yZW1vdmVBdHRyaWJ1dGUuY2FsbCh0aGlzLCBuYW1lKTtcbiAgICAgIGlmIChvbGRWYWx1ZSAhPT0gbnVsbCkge1xuICAgICAgICBpbnRlcm5hbHMuYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKHRoaXMsIG5hbWUsIG9sZFZhbHVlLCBudWxsLCBudWxsKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICBVdGlsaXRpZXMuc2V0UHJvcGVydHlVbmNoZWNrZWQoRWxlbWVudC5wcm90b3R5cGUsICdyZW1vdmVBdHRyaWJ1dGVOUycsXG4gICAgLyoqXG4gICAgICogQHRoaXMge0VsZW1lbnR9XG4gICAgICogQHBhcmFtIHs/c3RyaW5nfSBuYW1lc3BhY2VcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uKG5hbWVzcGFjZSwgbmFtZSkge1xuICAgICAgLy8gRmFzdCBwYXRoIGZvciBub24tY3VzdG9tIGVsZW1lbnRzLlxuICAgICAgaWYgKHRoaXMuX19DRV9zdGF0ZSAhPT0gQ0VTdGF0ZS5jdXN0b20pIHtcbiAgICAgICAgcmV0dXJuIE5hdGl2ZS5FbGVtZW50X3JlbW92ZUF0dHJpYnV0ZU5TLmNhbGwodGhpcywgbmFtZXNwYWNlLCBuYW1lKTtcbiAgICAgIH1cblxuICAgICAgY29uc3Qgb2xkVmFsdWUgPSBOYXRpdmUuRWxlbWVudF9nZXRBdHRyaWJ1dGVOUy5jYWxsKHRoaXMsIG5hbWVzcGFjZSwgbmFtZSk7XG4gICAgICBOYXRpdmUuRWxlbWVudF9yZW1vdmVBdHRyaWJ1dGVOUy5jYWxsKHRoaXMsIG5hbWVzcGFjZSwgbmFtZSk7XG4gICAgICAvLyBJbiBvbGRlciBicm93c2VycywgYEVsZW1lbnQjZ2V0QXR0cmlidXRlTlNgIG1heSByZXR1cm4gdGhlIGVtcHR5IHN0cmluZ1xuICAgICAgLy8gaW5zdGVhZCBvZiBudWxsIGlmIHRoZSBhdHRyaWJ1dGUgZG9lcyBub3QgZXhpc3QuIEZvciBkZXRhaWxzLCBzZWU7XG4gICAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRWxlbWVudC9nZXRBdHRyaWJ1dGVOUyNOb3Rlc1xuICAgICAgY29uc3QgbmV3VmFsdWUgPSBOYXRpdmUuRWxlbWVudF9nZXRBdHRyaWJ1dGVOUy5jYWxsKHRoaXMsIG5hbWVzcGFjZSwgbmFtZSk7XG4gICAgICBpZiAob2xkVmFsdWUgIT09IG5ld1ZhbHVlKSB7XG4gICAgICAgIGludGVybmFscy5hdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sodGhpcywgbmFtZSwgb2xkVmFsdWUsIG5ld1ZhbHVlLCBuYW1lc3BhY2UpO1xuICAgICAgfVxuICAgIH0pO1xuXG5cbiAgZnVuY3Rpb24gcGF0Y2hfaW5zZXJ0QWRqYWNlbnRFbGVtZW50KGRlc3RpbmF0aW9uLCBiYXNlTWV0aG9kKSB7XG4gICAgVXRpbGl0aWVzLnNldFByb3BlcnR5VW5jaGVja2VkKGRlc3RpbmF0aW9uLCAnaW5zZXJ0QWRqYWNlbnRFbGVtZW50JyxcbiAgICAgIC8qKlxuICAgICAgICogQHRoaXMge0VsZW1lbnR9XG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gd2hlcmVcbiAgICAgICAqIEBwYXJhbSB7IUVsZW1lbnR9IGVsZW1lbnRcbiAgICAgICAqIEByZXR1cm4gez9FbGVtZW50fVxuICAgICAgICovXG4gICAgICBmdW5jdGlvbih3aGVyZSwgZWxlbWVudCkge1xuICAgICAgICBjb25zdCB3YXNDb25uZWN0ZWQgPSBVdGlsaXRpZXMuaXNDb25uZWN0ZWQoZWxlbWVudCk7XG4gICAgICAgIGNvbnN0IGluc2VydGVkRWxlbWVudCA9IC8qKiBAdHlwZSB7IUVsZW1lbnR9ICovXG4gICAgICAgICAgKGJhc2VNZXRob2QuY2FsbCh0aGlzLCB3aGVyZSwgZWxlbWVudCkpO1xuXG4gICAgICAgIGlmICh3YXNDb25uZWN0ZWQpIHtcbiAgICAgICAgICBpbnRlcm5hbHMuZGlzY29ubmVjdFRyZWUoZWxlbWVudCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoVXRpbGl0aWVzLmlzQ29ubmVjdGVkKGluc2VydGVkRWxlbWVudCkpIHtcbiAgICAgICAgICBpbnRlcm5hbHMuY29ubmVjdFRyZWUoZWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGluc2VydGVkRWxlbWVudDtcbiAgICAgIH0pO1xuICB9XG5cbiAgaWYgKE5hdGl2ZS5IVE1MRWxlbWVudF9pbnNlcnRBZGphY2VudEVsZW1lbnQpIHtcbiAgICBwYXRjaF9pbnNlcnRBZGphY2VudEVsZW1lbnQoSFRNTEVsZW1lbnQucHJvdG90eXBlLCBOYXRpdmUuSFRNTEVsZW1lbnRfaW5zZXJ0QWRqYWNlbnRFbGVtZW50KTtcbiAgfSBlbHNlIGlmIChOYXRpdmUuRWxlbWVudF9pbnNlcnRBZGphY2VudEVsZW1lbnQpIHtcbiAgICBwYXRjaF9pbnNlcnRBZGphY2VudEVsZW1lbnQoRWxlbWVudC5wcm90b3R5cGUsIE5hdGl2ZS5FbGVtZW50X2luc2VydEFkamFjZW50RWxlbWVudCk7XG4gIH0gZWxzZSB7XG4gICAgY29uc29sZS53YXJuKCdDdXN0b20gRWxlbWVudHM6IGBFbGVtZW50I2luc2VydEFkamFjZW50RWxlbWVudGAgd2FzIG5vdCBwYXRjaGVkLicpO1xuICB9XG5cblxuICBQYXRjaFBhcmVudE5vZGUoaW50ZXJuYWxzLCBFbGVtZW50LnByb3RvdHlwZSwge1xuICAgIHByZXBlbmQ6IE5hdGl2ZS5FbGVtZW50X3ByZXBlbmQsXG4gICAgYXBwZW5kOiBOYXRpdmUuRWxlbWVudF9hcHBlbmQsXG4gIH0pO1xuXG4gIFBhdGNoQ2hpbGROb2RlKGludGVybmFscywgRWxlbWVudC5wcm90b3R5cGUsIHtcbiAgICBiZWZvcmU6IE5hdGl2ZS5FbGVtZW50X2JlZm9yZSxcbiAgICBhZnRlcjogTmF0aXZlLkVsZW1lbnRfYWZ0ZXIsXG4gICAgcmVwbGFjZVdpdGg6IE5hdGl2ZS5FbGVtZW50X3JlcGxhY2VXaXRoLFxuICAgIHJlbW92ZTogTmF0aXZlLkVsZW1lbnRfcmVtb3ZlLFxuICB9KTtcbn07XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuICogVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcbiAqIFRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuICogQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbiAqIHN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4gKi9cblxuaW1wb3J0IEN1c3RvbUVsZW1lbnRJbnRlcm5hbHMgZnJvbSAnLi9DdXN0b21FbGVtZW50SW50ZXJuYWxzLmpzJztcbmltcG9ydCBDdXN0b21FbGVtZW50UmVnaXN0cnkgZnJvbSAnLi9DdXN0b21FbGVtZW50UmVnaXN0cnkuanMnO1xuXG5pbXBvcnQgUGF0Y2hIVE1MRWxlbWVudCBmcm9tICcuL1BhdGNoL0hUTUxFbGVtZW50LmpzJztcbmltcG9ydCBQYXRjaERvY3VtZW50IGZyb20gJy4vUGF0Y2gvRG9jdW1lbnQuanMnO1xuaW1wb3J0IFBhdGNoTm9kZSBmcm9tICcuL1BhdGNoL05vZGUuanMnO1xuaW1wb3J0IFBhdGNoRWxlbWVudCBmcm9tICcuL1BhdGNoL0VsZW1lbnQuanMnO1xuXG5jb25zdCBwcmlvckN1c3RvbUVsZW1lbnRzID0gd2luZG93WydjdXN0b21FbGVtZW50cyddO1xuXG5pZiAoIXByaW9yQ3VzdG9tRWxlbWVudHMgfHxcbiAgICAgcHJpb3JDdXN0b21FbGVtZW50c1snZm9yY2VQb2x5ZmlsbCddIHx8XG4gICAgICh0eXBlb2YgcHJpb3JDdXN0b21FbGVtZW50c1snZGVmaW5lJ10gIT0gJ2Z1bmN0aW9uJykgfHxcbiAgICAgKHR5cGVvZiBwcmlvckN1c3RvbUVsZW1lbnRzWydnZXQnXSAhPSAnZnVuY3Rpb24nKSkge1xuICAvKiogQHR5cGUgeyFDdXN0b21FbGVtZW50SW50ZXJuYWxzfSAqL1xuICBjb25zdCBpbnRlcm5hbHMgPSBuZXcgQ3VzdG9tRWxlbWVudEludGVybmFscygpO1xuXG4gIFBhdGNoSFRNTEVsZW1lbnQoaW50ZXJuYWxzKTtcbiAgUGF0Y2hEb2N1bWVudChpbnRlcm5hbHMpO1xuICBQYXRjaE5vZGUoaW50ZXJuYWxzKTtcbiAgUGF0Y2hFbGVtZW50KGludGVybmFscyk7XG5cbiAgLy8gVGhlIG1haW4gZG9jdW1lbnQgaXMgYWx3YXlzIGFzc29jaWF0ZWQgd2l0aCB0aGUgcmVnaXN0cnkuXG4gIGRvY3VtZW50Ll9fQ0VfaGFzUmVnaXN0cnkgPSB0cnVlO1xuXG4gIC8qKiBAdHlwZSB7IUN1c3RvbUVsZW1lbnRSZWdpc3RyeX0gKi9cbiAgY29uc3QgY3VzdG9tRWxlbWVudHMgPSBuZXcgQ3VzdG9tRWxlbWVudFJlZ2lzdHJ5KGludGVybmFscyk7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHdpbmRvdywgJ2N1c3RvbUVsZW1lbnRzJywge1xuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIHZhbHVlOiBjdXN0b21FbGVtZW50cyxcbiAgfSk7XG59XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuICogVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcbiAqIFRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuICogQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbiAqIHN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4gKi9cbi8vIEB2ZXJzaW9uIDAuNy4yMlxuXG4oZnVuY3Rpb24oZ2xvYmFsKSB7XG4gIGlmIChnbG9iYWwuSnNNdXRhdGlvbk9ic2VydmVyKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciByZWdpc3RyYXRpb25zVGFibGUgPSBuZXcgV2Vha01hcCgpO1xuICB2YXIgc2V0SW1tZWRpYXRlO1xuICBpZiAoL1RyaWRlbnR8RWRnZS8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSkge1xuICAgIHNldEltbWVkaWF0ZSA9IHNldFRpbWVvdXQ7XG4gIH0gZWxzZSBpZiAod2luZG93LnNldEltbWVkaWF0ZSkge1xuICAgIHNldEltbWVkaWF0ZSA9IHdpbmRvdy5zZXRJbW1lZGlhdGU7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHNldEltbWVkaWF0ZVF1ZXVlID0gW107XG4gICAgdmFyIHNlbnRpbmVsID0gU3RyaW5nKE1hdGgucmFuZG9tKCkpO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBmdW5jdGlvbihlKSB7XG4gICAgICBpZiAoZS5kYXRhID09PSBzZW50aW5lbCkge1xuICAgICAgICB2YXIgcXVldWUgPSBzZXRJbW1lZGlhdGVRdWV1ZTtcbiAgICAgICAgc2V0SW1tZWRpYXRlUXVldWUgPSBbXTtcbiAgICAgICAgcXVldWUuZm9yRWFjaChmdW5jdGlvbihmdW5jKSB7XG4gICAgICAgICAgZnVuYygpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBzZXRJbW1lZGlhdGUgPSBmdW5jdGlvbihmdW5jKSB7XG4gICAgICBzZXRJbW1lZGlhdGVRdWV1ZS5wdXNoKGZ1bmMpO1xuICAgICAgd2luZG93LnBvc3RNZXNzYWdlKHNlbnRpbmVsLCBcIipcIik7XG4gICAgfTtcbiAgfVxuICB2YXIgaXNTY2hlZHVsZWQgPSBmYWxzZTtcbiAgdmFyIHNjaGVkdWxlZE9ic2VydmVycyA9IFtdO1xuICBmdW5jdGlvbiBzY2hlZHVsZUNhbGxiYWNrKG9ic2VydmVyKSB7XG4gICAgc2NoZWR1bGVkT2JzZXJ2ZXJzLnB1c2gob2JzZXJ2ZXIpO1xuICAgIGlmICghaXNTY2hlZHVsZWQpIHtcbiAgICAgIGlzU2NoZWR1bGVkID0gdHJ1ZTtcbiAgICAgIHNldEltbWVkaWF0ZShkaXNwYXRjaENhbGxiYWNrcyk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHdyYXBJZk5lZWRlZChub2RlKSB7XG4gICAgcmV0dXJuIHdpbmRvdy5TaGFkb3dET01Qb2x5ZmlsbCAmJiB3aW5kb3cuU2hhZG93RE9NUG9seWZpbGwud3JhcElmTmVlZGVkKG5vZGUpIHx8IG5vZGU7XG4gIH1cbiAgZnVuY3Rpb24gZGlzcGF0Y2hDYWxsYmFja3MoKSB7XG4gICAgaXNTY2hlZHVsZWQgPSBmYWxzZTtcbiAgICB2YXIgb2JzZXJ2ZXJzID0gc2NoZWR1bGVkT2JzZXJ2ZXJzO1xuICAgIHNjaGVkdWxlZE9ic2VydmVycyA9IFtdO1xuICAgIG9ic2VydmVycy5zb3J0KGZ1bmN0aW9uKG8xLCBvMikge1xuICAgICAgcmV0dXJuIG8xLnVpZF8gLSBvMi51aWRfO1xuICAgIH0pO1xuICAgIHZhciBhbnlOb25FbXB0eSA9IGZhbHNlO1xuICAgIG9ic2VydmVycy5mb3JFYWNoKGZ1bmN0aW9uKG9ic2VydmVyKSB7XG4gICAgICB2YXIgcXVldWUgPSBvYnNlcnZlci50YWtlUmVjb3JkcygpO1xuICAgICAgcmVtb3ZlVHJhbnNpZW50T2JzZXJ2ZXJzRm9yKG9ic2VydmVyKTtcbiAgICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgb2JzZXJ2ZXIuY2FsbGJhY2tfKHF1ZXVlLCBvYnNlcnZlcik7XG4gICAgICAgIGFueU5vbkVtcHR5ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoYW55Tm9uRW1wdHkpIGRpc3BhdGNoQ2FsbGJhY2tzKCk7XG4gIH1cbiAgZnVuY3Rpb24gcmVtb3ZlVHJhbnNpZW50T2JzZXJ2ZXJzRm9yKG9ic2VydmVyKSB7XG4gICAgb2JzZXJ2ZXIubm9kZXNfLmZvckVhY2goZnVuY3Rpb24obm9kZSkge1xuICAgICAgdmFyIHJlZ2lzdHJhdGlvbnMgPSByZWdpc3RyYXRpb25zVGFibGUuZ2V0KG5vZGUpO1xuICAgICAgaWYgKCFyZWdpc3RyYXRpb25zKSByZXR1cm47XG4gICAgICByZWdpc3RyYXRpb25zLmZvckVhY2goZnVuY3Rpb24ocmVnaXN0cmF0aW9uKSB7XG4gICAgICAgIGlmIChyZWdpc3RyYXRpb24ub2JzZXJ2ZXIgPT09IG9ic2VydmVyKSByZWdpc3RyYXRpb24ucmVtb3ZlVHJhbnNpZW50T2JzZXJ2ZXJzKCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiBmb3JFYWNoQW5jZXN0b3JBbmRPYnNlcnZlckVucXVldWVSZWNvcmQodGFyZ2V0LCBjYWxsYmFjaykge1xuICAgIGZvciAodmFyIG5vZGUgPSB0YXJnZXQ7IG5vZGU7IG5vZGUgPSBub2RlLnBhcmVudE5vZGUpIHtcbiAgICAgIHZhciByZWdpc3RyYXRpb25zID0gcmVnaXN0cmF0aW9uc1RhYmxlLmdldChub2RlKTtcbiAgICAgIGlmIChyZWdpc3RyYXRpb25zKSB7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgcmVnaXN0cmF0aW9ucy5sZW5ndGg7IGorKykge1xuICAgICAgICAgIHZhciByZWdpc3RyYXRpb24gPSByZWdpc3RyYXRpb25zW2pdO1xuICAgICAgICAgIHZhciBvcHRpb25zID0gcmVnaXN0cmF0aW9uLm9wdGlvbnM7XG4gICAgICAgICAgaWYgKG5vZGUgIT09IHRhcmdldCAmJiAhb3B0aW9ucy5zdWJ0cmVlKSBjb250aW51ZTtcbiAgICAgICAgICB2YXIgcmVjb3JkID0gY2FsbGJhY2sob3B0aW9ucyk7XG4gICAgICAgICAgaWYgKHJlY29yZCkgcmVnaXN0cmF0aW9uLmVucXVldWUocmVjb3JkKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICB2YXIgdWlkQ291bnRlciA9IDA7XG4gIGZ1bmN0aW9uIEpzTXV0YXRpb25PYnNlcnZlcihjYWxsYmFjaykge1xuICAgIHRoaXMuY2FsbGJhY2tfID0gY2FsbGJhY2s7XG4gICAgdGhpcy5ub2Rlc18gPSBbXTtcbiAgICB0aGlzLnJlY29yZHNfID0gW107XG4gICAgdGhpcy51aWRfID0gKyt1aWRDb3VudGVyO1xuICB9XG4gIEpzTXV0YXRpb25PYnNlcnZlci5wcm90b3R5cGUgPSB7XG4gICAgb2JzZXJ2ZTogZnVuY3Rpb24odGFyZ2V0LCBvcHRpb25zKSB7XG4gICAgICB0YXJnZXQgPSB3cmFwSWZOZWVkZWQodGFyZ2V0KTtcbiAgICAgIGlmICghb3B0aW9ucy5jaGlsZExpc3QgJiYgIW9wdGlvbnMuYXR0cmlidXRlcyAmJiAhb3B0aW9ucy5jaGFyYWN0ZXJEYXRhIHx8IG9wdGlvbnMuYXR0cmlidXRlT2xkVmFsdWUgJiYgIW9wdGlvbnMuYXR0cmlidXRlcyB8fCBvcHRpb25zLmF0dHJpYnV0ZUZpbHRlciAmJiBvcHRpb25zLmF0dHJpYnV0ZUZpbHRlci5sZW5ndGggJiYgIW9wdGlvbnMuYXR0cmlidXRlcyB8fCBvcHRpb25zLmNoYXJhY3RlckRhdGFPbGRWYWx1ZSAmJiAhb3B0aW9ucy5jaGFyYWN0ZXJEYXRhKSB7XG4gICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcigpO1xuICAgICAgfVxuICAgICAgdmFyIHJlZ2lzdHJhdGlvbnMgPSByZWdpc3RyYXRpb25zVGFibGUuZ2V0KHRhcmdldCk7XG4gICAgICBpZiAoIXJlZ2lzdHJhdGlvbnMpIHJlZ2lzdHJhdGlvbnNUYWJsZS5zZXQodGFyZ2V0LCByZWdpc3RyYXRpb25zID0gW10pO1xuICAgICAgdmFyIHJlZ2lzdHJhdGlvbjtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVnaXN0cmF0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAocmVnaXN0cmF0aW9uc1tpXS5vYnNlcnZlciA9PT0gdGhpcykge1xuICAgICAgICAgIHJlZ2lzdHJhdGlvbiA9IHJlZ2lzdHJhdGlvbnNbaV07XG4gICAgICAgICAgcmVnaXN0cmF0aW9uLnJlbW92ZUxpc3RlbmVycygpO1xuICAgICAgICAgIHJlZ2lzdHJhdGlvbi5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCFyZWdpc3RyYXRpb24pIHtcbiAgICAgICAgcmVnaXN0cmF0aW9uID0gbmV3IFJlZ2lzdHJhdGlvbih0aGlzLCB0YXJnZXQsIG9wdGlvbnMpO1xuICAgICAgICByZWdpc3RyYXRpb25zLnB1c2gocmVnaXN0cmF0aW9uKTtcbiAgICAgICAgdGhpcy5ub2Rlc18ucHVzaCh0YXJnZXQpO1xuICAgICAgfVxuICAgICAgcmVnaXN0cmF0aW9uLmFkZExpc3RlbmVycygpO1xuICAgIH0sXG4gICAgZGlzY29ubmVjdDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLm5vZGVzXy5mb3JFYWNoKGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgdmFyIHJlZ2lzdHJhdGlvbnMgPSByZWdpc3RyYXRpb25zVGFibGUuZ2V0KG5vZGUpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlZ2lzdHJhdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgcmVnaXN0cmF0aW9uID0gcmVnaXN0cmF0aW9uc1tpXTtcbiAgICAgICAgICBpZiAocmVnaXN0cmF0aW9uLm9ic2VydmVyID09PSB0aGlzKSB7XG4gICAgICAgICAgICByZWdpc3RyYXRpb24ucmVtb3ZlTGlzdGVuZXJzKCk7XG4gICAgICAgICAgICByZWdpc3RyYXRpb25zLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSwgdGhpcyk7XG4gICAgICB0aGlzLnJlY29yZHNfID0gW107XG4gICAgfSxcbiAgICB0YWtlUmVjb3JkczogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgY29weU9mUmVjb3JkcyA9IHRoaXMucmVjb3Jkc187XG4gICAgICB0aGlzLnJlY29yZHNfID0gW107XG4gICAgICByZXR1cm4gY29weU9mUmVjb3JkcztcbiAgICB9XG4gIH07XG4gIGZ1bmN0aW9uIE11dGF0aW9uUmVjb3JkKHR5cGUsIHRhcmdldCkge1xuICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XG4gICAgdGhpcy5hZGRlZE5vZGVzID0gW107XG4gICAgdGhpcy5yZW1vdmVkTm9kZXMgPSBbXTtcbiAgICB0aGlzLnByZXZpb3VzU2libGluZyA9IG51bGw7XG4gICAgdGhpcy5uZXh0U2libGluZyA9IG51bGw7XG4gICAgdGhpcy5hdHRyaWJ1dGVOYW1lID0gbnVsbDtcbiAgICB0aGlzLmF0dHJpYnV0ZU5hbWVzcGFjZSA9IG51bGw7XG4gICAgdGhpcy5vbGRWYWx1ZSA9IG51bGw7XG4gIH1cbiAgZnVuY3Rpb24gY29weU11dGF0aW9uUmVjb3JkKG9yaWdpbmFsKSB7XG4gICAgdmFyIHJlY29yZCA9IG5ldyBNdXRhdGlvblJlY29yZChvcmlnaW5hbC50eXBlLCBvcmlnaW5hbC50YXJnZXQpO1xuICAgIHJlY29yZC5hZGRlZE5vZGVzID0gb3JpZ2luYWwuYWRkZWROb2Rlcy5zbGljZSgpO1xuICAgIHJlY29yZC5yZW1vdmVkTm9kZXMgPSBvcmlnaW5hbC5yZW1vdmVkTm9kZXMuc2xpY2UoKTtcbiAgICByZWNvcmQucHJldmlvdXNTaWJsaW5nID0gb3JpZ2luYWwucHJldmlvdXNTaWJsaW5nO1xuICAgIHJlY29yZC5uZXh0U2libGluZyA9IG9yaWdpbmFsLm5leHRTaWJsaW5nO1xuICAgIHJlY29yZC5hdHRyaWJ1dGVOYW1lID0gb3JpZ2luYWwuYXR0cmlidXRlTmFtZTtcbiAgICByZWNvcmQuYXR0cmlidXRlTmFtZXNwYWNlID0gb3JpZ2luYWwuYXR0cmlidXRlTmFtZXNwYWNlO1xuICAgIHJlY29yZC5vbGRWYWx1ZSA9IG9yaWdpbmFsLm9sZFZhbHVlO1xuICAgIHJldHVybiByZWNvcmQ7XG4gIH1cbiAgdmFyIGN1cnJlbnRSZWNvcmQsIHJlY29yZFdpdGhPbGRWYWx1ZTtcbiAgZnVuY3Rpb24gZ2V0UmVjb3JkKHR5cGUsIHRhcmdldCkge1xuICAgIHJldHVybiBjdXJyZW50UmVjb3JkID0gbmV3IE11dGF0aW9uUmVjb3JkKHR5cGUsIHRhcmdldCk7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0UmVjb3JkV2l0aE9sZFZhbHVlKG9sZFZhbHVlKSB7XG4gICAgaWYgKHJlY29yZFdpdGhPbGRWYWx1ZSkgcmV0dXJuIHJlY29yZFdpdGhPbGRWYWx1ZTtcbiAgICByZWNvcmRXaXRoT2xkVmFsdWUgPSBjb3B5TXV0YXRpb25SZWNvcmQoY3VycmVudFJlY29yZCk7XG4gICAgcmVjb3JkV2l0aE9sZFZhbHVlLm9sZFZhbHVlID0gb2xkVmFsdWU7XG4gICAgcmV0dXJuIHJlY29yZFdpdGhPbGRWYWx1ZTtcbiAgfVxuICBmdW5jdGlvbiBjbGVhclJlY29yZHMoKSB7XG4gICAgY3VycmVudFJlY29yZCA9IHJlY29yZFdpdGhPbGRWYWx1ZSA9IHVuZGVmaW5lZDtcbiAgfVxuICBmdW5jdGlvbiByZWNvcmRSZXByZXNlbnRzQ3VycmVudE11dGF0aW9uKHJlY29yZCkge1xuICAgIHJldHVybiByZWNvcmQgPT09IHJlY29yZFdpdGhPbGRWYWx1ZSB8fCByZWNvcmQgPT09IGN1cnJlbnRSZWNvcmQ7XG4gIH1cbiAgZnVuY3Rpb24gc2VsZWN0UmVjb3JkKGxhc3RSZWNvcmQsIG5ld1JlY29yZCkge1xuICAgIGlmIChsYXN0UmVjb3JkID09PSBuZXdSZWNvcmQpIHJldHVybiBsYXN0UmVjb3JkO1xuICAgIGlmIChyZWNvcmRXaXRoT2xkVmFsdWUgJiYgcmVjb3JkUmVwcmVzZW50c0N1cnJlbnRNdXRhdGlvbihsYXN0UmVjb3JkKSkgcmV0dXJuIHJlY29yZFdpdGhPbGRWYWx1ZTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBmdW5jdGlvbiBSZWdpc3RyYXRpb24ob2JzZXJ2ZXIsIHRhcmdldCwgb3B0aW9ucykge1xuICAgIHRoaXMub2JzZXJ2ZXIgPSBvYnNlcnZlcjtcbiAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHRoaXMudHJhbnNpZW50T2JzZXJ2ZWROb2RlcyA9IFtdO1xuICB9XG4gIFJlZ2lzdHJhdGlvbi5wcm90b3R5cGUgPSB7XG4gICAgZW5xdWV1ZTogZnVuY3Rpb24ocmVjb3JkKSB7XG4gICAgICB2YXIgcmVjb3JkcyA9IHRoaXMub2JzZXJ2ZXIucmVjb3Jkc187XG4gICAgICB2YXIgbGVuZ3RoID0gcmVjb3Jkcy5sZW5ndGg7XG4gICAgICBpZiAocmVjb3Jkcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHZhciBsYXN0UmVjb3JkID0gcmVjb3Jkc1tsZW5ndGggLSAxXTtcbiAgICAgICAgdmFyIHJlY29yZFRvUmVwbGFjZUxhc3QgPSBzZWxlY3RSZWNvcmQobGFzdFJlY29yZCwgcmVjb3JkKTtcbiAgICAgICAgaWYgKHJlY29yZFRvUmVwbGFjZUxhc3QpIHtcbiAgICAgICAgICByZWNvcmRzW2xlbmd0aCAtIDFdID0gcmVjb3JkVG9SZXBsYWNlTGFzdDtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNjaGVkdWxlQ2FsbGJhY2sodGhpcy5vYnNlcnZlcik7XG4gICAgICB9XG4gICAgICByZWNvcmRzW2xlbmd0aF0gPSByZWNvcmQ7XG4gICAgfSxcbiAgICBhZGRMaXN0ZW5lcnM6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5hZGRMaXN0ZW5lcnNfKHRoaXMudGFyZ2V0KTtcbiAgICB9LFxuICAgIGFkZExpc3RlbmVyc186IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgICAgaWYgKG9wdGlvbnMuYXR0cmlidXRlcykgbm9kZS5hZGRFdmVudExpc3RlbmVyKFwiRE9NQXR0ck1vZGlmaWVkXCIsIHRoaXMsIHRydWUpO1xuICAgICAgaWYgKG9wdGlvbnMuY2hhcmFjdGVyRGF0YSkgbm9kZS5hZGRFdmVudExpc3RlbmVyKFwiRE9NQ2hhcmFjdGVyRGF0YU1vZGlmaWVkXCIsIHRoaXMsIHRydWUpO1xuICAgICAgaWYgKG9wdGlvbnMuY2hpbGRMaXN0KSBub2RlLmFkZEV2ZW50TGlzdGVuZXIoXCJET01Ob2RlSW5zZXJ0ZWRcIiwgdGhpcywgdHJ1ZSk7XG4gICAgICBpZiAob3B0aW9ucy5jaGlsZExpc3QgfHwgb3B0aW9ucy5zdWJ0cmVlKSBub2RlLmFkZEV2ZW50TGlzdGVuZXIoXCJET01Ob2RlUmVtb3ZlZFwiLCB0aGlzLCB0cnVlKTtcbiAgICB9LFxuICAgIHJlbW92ZUxpc3RlbmVyczogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyc18odGhpcy50YXJnZXQpO1xuICAgIH0sXG4gICAgcmVtb3ZlTGlzdGVuZXJzXzogZnVuY3Rpb24obm9kZSkge1xuICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgICBpZiAob3B0aW9ucy5hdHRyaWJ1dGVzKSBub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJET01BdHRyTW9kaWZpZWRcIiwgdGhpcywgdHJ1ZSk7XG4gICAgICBpZiAob3B0aW9ucy5jaGFyYWN0ZXJEYXRhKSBub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJET01DaGFyYWN0ZXJEYXRhTW9kaWZpZWRcIiwgdGhpcywgdHJ1ZSk7XG4gICAgICBpZiAob3B0aW9ucy5jaGlsZExpc3QpIG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIkRPTU5vZGVJbnNlcnRlZFwiLCB0aGlzLCB0cnVlKTtcbiAgICAgIGlmIChvcHRpb25zLmNoaWxkTGlzdCB8fCBvcHRpb25zLnN1YnRyZWUpIG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIkRPTU5vZGVSZW1vdmVkXCIsIHRoaXMsIHRydWUpO1xuICAgIH0sXG4gICAgYWRkVHJhbnNpZW50T2JzZXJ2ZXI6IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIGlmIChub2RlID09PSB0aGlzLnRhcmdldCkgcmV0dXJuO1xuICAgICAgdGhpcy5hZGRMaXN0ZW5lcnNfKG5vZGUpO1xuICAgICAgdGhpcy50cmFuc2llbnRPYnNlcnZlZE5vZGVzLnB1c2gobm9kZSk7XG4gICAgICB2YXIgcmVnaXN0cmF0aW9ucyA9IHJlZ2lzdHJhdGlvbnNUYWJsZS5nZXQobm9kZSk7XG4gICAgICBpZiAoIXJlZ2lzdHJhdGlvbnMpIHJlZ2lzdHJhdGlvbnNUYWJsZS5zZXQobm9kZSwgcmVnaXN0cmF0aW9ucyA9IFtdKTtcbiAgICAgIHJlZ2lzdHJhdGlvbnMucHVzaCh0aGlzKTtcbiAgICB9LFxuICAgIHJlbW92ZVRyYW5zaWVudE9ic2VydmVyczogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgdHJhbnNpZW50T2JzZXJ2ZWROb2RlcyA9IHRoaXMudHJhbnNpZW50T2JzZXJ2ZWROb2RlcztcbiAgICAgIHRoaXMudHJhbnNpZW50T2JzZXJ2ZWROb2RlcyA9IFtdO1xuICAgICAgdHJhbnNpZW50T2JzZXJ2ZWROb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcnNfKG5vZGUpO1xuICAgICAgICB2YXIgcmVnaXN0cmF0aW9ucyA9IHJlZ2lzdHJhdGlvbnNUYWJsZS5nZXQobm9kZSk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVnaXN0cmF0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmIChyZWdpc3RyYXRpb25zW2ldID09PSB0aGlzKSB7XG4gICAgICAgICAgICByZWdpc3RyYXRpb25zLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSwgdGhpcyk7XG4gICAgfSxcbiAgICBoYW5kbGVFdmVudDogZnVuY3Rpb24oZSkge1xuICAgICAgZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgICAgIHN3aXRjaCAoZS50eXBlKSB7XG4gICAgICAgY2FzZSBcIkRPTUF0dHJNb2RpZmllZFwiOlxuICAgICAgICB2YXIgbmFtZSA9IGUuYXR0ck5hbWU7XG4gICAgICAgIHZhciBuYW1lc3BhY2UgPSBlLnJlbGF0ZWROb2RlLm5hbWVzcGFjZVVSSTtcbiAgICAgICAgdmFyIHRhcmdldCA9IGUudGFyZ2V0O1xuICAgICAgICB2YXIgcmVjb3JkID0gbmV3IGdldFJlY29yZChcImF0dHJpYnV0ZXNcIiwgdGFyZ2V0KTtcbiAgICAgICAgcmVjb3JkLmF0dHJpYnV0ZU5hbWUgPSBuYW1lO1xuICAgICAgICByZWNvcmQuYXR0cmlidXRlTmFtZXNwYWNlID0gbmFtZXNwYWNlO1xuICAgICAgICB2YXIgb2xkVmFsdWUgPSBlLmF0dHJDaGFuZ2UgPT09IE11dGF0aW9uRXZlbnQuQURESVRJT04gPyBudWxsIDogZS5wcmV2VmFsdWU7XG4gICAgICAgIGZvckVhY2hBbmNlc3RvckFuZE9ic2VydmVyRW5xdWV1ZVJlY29yZCh0YXJnZXQsIGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgICBpZiAoIW9wdGlvbnMuYXR0cmlidXRlcykgcmV0dXJuO1xuICAgICAgICAgIGlmIChvcHRpb25zLmF0dHJpYnV0ZUZpbHRlciAmJiBvcHRpb25zLmF0dHJpYnV0ZUZpbHRlci5sZW5ndGggJiYgb3B0aW9ucy5hdHRyaWJ1dGVGaWx0ZXIuaW5kZXhPZihuYW1lKSA9PT0gLTEgJiYgb3B0aW9ucy5hdHRyaWJ1dGVGaWx0ZXIuaW5kZXhPZihuYW1lc3BhY2UpID09PSAtMSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAob3B0aW9ucy5hdHRyaWJ1dGVPbGRWYWx1ZSkgcmV0dXJuIGdldFJlY29yZFdpdGhPbGRWYWx1ZShvbGRWYWx1ZSk7XG4gICAgICAgICAgcmV0dXJuIHJlY29yZDtcbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICAgY2FzZSBcIkRPTUNoYXJhY3RlckRhdGFNb2RpZmllZFwiOlxuICAgICAgICB2YXIgdGFyZ2V0ID0gZS50YXJnZXQ7XG4gICAgICAgIHZhciByZWNvcmQgPSBnZXRSZWNvcmQoXCJjaGFyYWN0ZXJEYXRhXCIsIHRhcmdldCk7XG4gICAgICAgIHZhciBvbGRWYWx1ZSA9IGUucHJldlZhbHVlO1xuICAgICAgICBmb3JFYWNoQW5jZXN0b3JBbmRPYnNlcnZlckVucXVldWVSZWNvcmQodGFyZ2V0LCBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgICAgaWYgKCFvcHRpb25zLmNoYXJhY3RlckRhdGEpIHJldHVybjtcbiAgICAgICAgICBpZiAob3B0aW9ucy5jaGFyYWN0ZXJEYXRhT2xkVmFsdWUpIHJldHVybiBnZXRSZWNvcmRXaXRoT2xkVmFsdWUob2xkVmFsdWUpO1xuICAgICAgICAgIHJldHVybiByZWNvcmQ7XG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcblxuICAgICAgIGNhc2UgXCJET01Ob2RlUmVtb3ZlZFwiOlxuICAgICAgICB0aGlzLmFkZFRyYW5zaWVudE9ic2VydmVyKGUudGFyZ2V0KTtcblxuICAgICAgIGNhc2UgXCJET01Ob2RlSW5zZXJ0ZWRcIjpcbiAgICAgICAgdmFyIGNoYW5nZWROb2RlID0gZS50YXJnZXQ7XG4gICAgICAgIHZhciBhZGRlZE5vZGVzLCByZW1vdmVkTm9kZXM7XG4gICAgICAgIGlmIChlLnR5cGUgPT09IFwiRE9NTm9kZUluc2VydGVkXCIpIHtcbiAgICAgICAgICBhZGRlZE5vZGVzID0gWyBjaGFuZ2VkTm9kZSBdO1xuICAgICAgICAgIHJlbW92ZWROb2RlcyA9IFtdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFkZGVkTm9kZXMgPSBbXTtcbiAgICAgICAgICByZW1vdmVkTm9kZXMgPSBbIGNoYW5nZWROb2RlIF07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHByZXZpb3VzU2libGluZyA9IGNoYW5nZWROb2RlLnByZXZpb3VzU2libGluZztcbiAgICAgICAgdmFyIG5leHRTaWJsaW5nID0gY2hhbmdlZE5vZGUubmV4dFNpYmxpbmc7XG4gICAgICAgIHZhciByZWNvcmQgPSBnZXRSZWNvcmQoXCJjaGlsZExpc3RcIiwgZS50YXJnZXQucGFyZW50Tm9kZSk7XG4gICAgICAgIHJlY29yZC5hZGRlZE5vZGVzID0gYWRkZWROb2RlcztcbiAgICAgICAgcmVjb3JkLnJlbW92ZWROb2RlcyA9IHJlbW92ZWROb2RlcztcbiAgICAgICAgcmVjb3JkLnByZXZpb3VzU2libGluZyA9IHByZXZpb3VzU2libGluZztcbiAgICAgICAgcmVjb3JkLm5leHRTaWJsaW5nID0gbmV4dFNpYmxpbmc7XG4gICAgICAgIGZvckVhY2hBbmNlc3RvckFuZE9ic2VydmVyRW5xdWV1ZVJlY29yZChlLnJlbGF0ZWROb2RlLCBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgICAgaWYgKCFvcHRpb25zLmNoaWxkTGlzdCkgcmV0dXJuO1xuICAgICAgICAgIHJldHVybiByZWNvcmQ7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgY2xlYXJSZWNvcmRzKCk7XG4gICAgfVxuICB9O1xuICBnbG9iYWwuSnNNdXRhdGlvbk9ic2VydmVyID0gSnNNdXRhdGlvbk9ic2VydmVyO1xuICBpZiAoIWdsb2JhbC5NdXRhdGlvbk9ic2VydmVyKSB7XG4gICAgZ2xvYmFsLk11dGF0aW9uT2JzZXJ2ZXIgPSBKc011dGF0aW9uT2JzZXJ2ZXI7XG4gICAgSnNNdXRhdGlvbk9ic2VydmVyLl9pc1BvbHlmaWxsZWQgPSB0cnVlO1xuICB9XG59KShzZWxmKTtcbiIsIi8qXG5Db3B5cmlnaHQgKGMpIDIwMTIgQmFybmVzYW5kbm9ibGUuY29tLCBsbGMsIERvbmF2b24gV2VzdCwgYW5kIERvbWVuaWMgRGVuaWNvbGFcblxuUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nXG5hIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcblwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xud2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvXG5wZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG9cbnRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcbmluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG5NRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxuTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRVxuTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTlxuT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OXG5XSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuKi9cbihmdW5jdGlvbiAoZ2xvYmFsLCB1bmRlZmluZWQpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIGlmIChnbG9iYWwuc2V0SW1tZWRpYXRlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgbmV4dEhhbmRsZSA9IDE7IC8vIFNwZWMgc2F5cyBncmVhdGVyIHRoYW4gemVyb1xuICAgIHZhciB0YXNrc0J5SGFuZGxlID0ge307XG4gICAgdmFyIGN1cnJlbnRseVJ1bm5pbmdBVGFzayA9IGZhbHNlO1xuICAgIHZhciBkb2MgPSBnbG9iYWwuZG9jdW1lbnQ7XG4gICAgdmFyIHNldEltbWVkaWF0ZTtcblxuICAgIGZ1bmN0aW9uIGFkZEZyb21TZXRJbW1lZGlhdGVBcmd1bWVudHMoYXJncykge1xuICAgICAgICB0YXNrc0J5SGFuZGxlW25leHRIYW5kbGVdID0gcGFydGlhbGx5QXBwbGllZC5hcHBseSh1bmRlZmluZWQsIGFyZ3MpO1xuICAgICAgICByZXR1cm4gbmV4dEhhbmRsZSsrO1xuICAgIH1cblxuICAgIC8vIFRoaXMgZnVuY3Rpb24gYWNjZXB0cyB0aGUgc2FtZSBhcmd1bWVudHMgYXMgc2V0SW1tZWRpYXRlLCBidXRcbiAgICAvLyByZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCByZXF1aXJlcyBubyBhcmd1bWVudHMuXG4gICAgZnVuY3Rpb24gcGFydGlhbGx5QXBwbGllZChoYW5kbGVyKSB7XG4gICAgICAgIHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGhhbmRsZXIgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIGhhbmRsZXIuYXBwbHkodW5kZWZpbmVkLCBhcmdzKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgKG5ldyBGdW5jdGlvbihcIlwiICsgaGFuZGxlcikpKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcnVuSWZQcmVzZW50KGhhbmRsZSkge1xuICAgICAgICAvLyBGcm9tIHRoZSBzcGVjOiBcIldhaXQgdW50aWwgYW55IGludm9jYXRpb25zIG9mIHRoaXMgYWxnb3JpdGhtIHN0YXJ0ZWQgYmVmb3JlIHRoaXMgb25lIGhhdmUgY29tcGxldGVkLlwiXG4gICAgICAgIC8vIFNvIGlmIHdlJ3JlIGN1cnJlbnRseSBydW5uaW5nIGEgdGFzaywgd2UnbGwgbmVlZCB0byBkZWxheSB0aGlzIGludm9jYXRpb24uXG4gICAgICAgIGlmIChjdXJyZW50bHlSdW5uaW5nQVRhc2spIHtcbiAgICAgICAgICAgIC8vIERlbGF5IGJ5IGRvaW5nIGEgc2V0VGltZW91dC4gc2V0SW1tZWRpYXRlIHdhcyB0cmllZCBpbnN0ZWFkLCBidXQgaW4gRmlyZWZveCA3IGl0IGdlbmVyYXRlZCBhXG4gICAgICAgICAgICAvLyBcInRvbyBtdWNoIHJlY3Vyc2lvblwiIGVycm9yLlxuICAgICAgICAgICAgc2V0VGltZW91dChwYXJ0aWFsbHlBcHBsaWVkKHJ1bklmUHJlc2VudCwgaGFuZGxlKSwgMCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgdGFzayA9IHRhc2tzQnlIYW5kbGVbaGFuZGxlXTtcbiAgICAgICAgICAgIGlmICh0YXNrKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudGx5UnVubmluZ0FUYXNrID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB0YXNrKCk7XG4gICAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJJbW1lZGlhdGUoaGFuZGxlKTtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudGx5UnVubmluZ0FUYXNrID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2xlYXJJbW1lZGlhdGUoaGFuZGxlKSB7XG4gICAgICAgIGRlbGV0ZSB0YXNrc0J5SGFuZGxlW2hhbmRsZV07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbE5leHRUaWNrSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIHNldEltbWVkaWF0ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGhhbmRsZSA9IGFkZEZyb21TZXRJbW1lZGlhdGVBcmd1bWVudHMoYXJndW1lbnRzKTtcbiAgICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2socGFydGlhbGx5QXBwbGllZChydW5JZlByZXNlbnQsIGhhbmRsZSkpO1xuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjYW5Vc2VQb3N0TWVzc2FnZSgpIHtcbiAgICAgICAgLy8gVGhlIHRlc3QgYWdhaW5zdCBgaW1wb3J0U2NyaXB0c2AgcHJldmVudHMgdGhpcyBpbXBsZW1lbnRhdGlvbiBmcm9tIGJlaW5nIGluc3RhbGxlZCBpbnNpZGUgYSB3ZWIgd29ya2VyLFxuICAgICAgICAvLyB3aGVyZSBgZ2xvYmFsLnBvc3RNZXNzYWdlYCBtZWFucyBzb21ldGhpbmcgY29tcGxldGVseSBkaWZmZXJlbnQgYW5kIGNhbid0IGJlIHVzZWQgZm9yIHRoaXMgcHVycG9zZS5cbiAgICAgICAgaWYgKGdsb2JhbC5wb3N0TWVzc2FnZSAmJiAhZ2xvYmFsLmltcG9ydFNjcmlwdHMpIHtcbiAgICAgICAgICAgIHZhciBwb3N0TWVzc2FnZUlzQXN5bmNocm9ub3VzID0gdHJ1ZTtcbiAgICAgICAgICAgIHZhciBvbGRPbk1lc3NhZ2UgPSBnbG9iYWwub25tZXNzYWdlO1xuICAgICAgICAgICAgZ2xvYmFsLm9ubWVzc2FnZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHBvc3RNZXNzYWdlSXNBc3luY2hyb25vdXMgPSBmYWxzZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBnbG9iYWwucG9zdE1lc3NhZ2UoXCJcIiwgXCIqXCIpO1xuICAgICAgICAgICAgZ2xvYmFsLm9ubWVzc2FnZSA9IG9sZE9uTWVzc2FnZTtcbiAgICAgICAgICAgIHJldHVybiBwb3N0TWVzc2FnZUlzQXN5bmNocm9ub3VzO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbFBvc3RNZXNzYWdlSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIC8vIEluc3RhbGxzIGFuIGV2ZW50IGhhbmRsZXIgb24gYGdsb2JhbGAgZm9yIHRoZSBgbWVzc2FnZWAgZXZlbnQ6IHNlZVxuICAgICAgICAvLyAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0RPTS93aW5kb3cucG9zdE1lc3NhZ2VcbiAgICAgICAgLy8gKiBodHRwOi8vd3d3LndoYXR3Zy5vcmcvc3BlY3Mvd2ViLWFwcHMvY3VycmVudC13b3JrL211bHRpcGFnZS9jb21tcy5odG1sI2Nyb3NzRG9jdW1lbnRNZXNzYWdlc1xuXG4gICAgICAgIHZhciBtZXNzYWdlUHJlZml4ID0gXCJzZXRJbW1lZGlhdGUkXCIgKyBNYXRoLnJhbmRvbSgpICsgXCIkXCI7XG4gICAgICAgIHZhciBvbkdsb2JhbE1lc3NhZ2UgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgaWYgKGV2ZW50LnNvdXJjZSA9PT0gZ2xvYmFsICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIGV2ZW50LmRhdGEgPT09IFwic3RyaW5nXCIgJiZcbiAgICAgICAgICAgICAgICBldmVudC5kYXRhLmluZGV4T2YobWVzc2FnZVByZWZpeCkgPT09IDApIHtcbiAgICAgICAgICAgICAgICBydW5JZlByZXNlbnQoK2V2ZW50LmRhdGEuc2xpY2UobWVzc2FnZVByZWZpeC5sZW5ndGgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgICAgICAgIGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBvbkdsb2JhbE1lc3NhZ2UsIGZhbHNlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdsb2JhbC5hdHRhY2hFdmVudChcIm9ubWVzc2FnZVwiLCBvbkdsb2JhbE1lc3NhZ2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgc2V0SW1tZWRpYXRlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgaGFuZGxlID0gYWRkRnJvbVNldEltbWVkaWF0ZUFyZ3VtZW50cyhhcmd1bWVudHMpO1xuICAgICAgICAgICAgZ2xvYmFsLnBvc3RNZXNzYWdlKG1lc3NhZ2VQcmVmaXggKyBoYW5kbGUsIFwiKlwiKTtcbiAgICAgICAgICAgIHJldHVybiBoYW5kbGU7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbE1lc3NhZ2VDaGFubmVsSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIHZhciBjaGFubmVsID0gbmV3IE1lc3NhZ2VDaGFubmVsKCk7XG4gICAgICAgIGNoYW5uZWwucG9ydDEub25tZXNzYWdlID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBoYW5kbGUgPSBldmVudC5kYXRhO1xuICAgICAgICAgICAgcnVuSWZQcmVzZW50KGhhbmRsZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgc2V0SW1tZWRpYXRlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgaGFuZGxlID0gYWRkRnJvbVNldEltbWVkaWF0ZUFyZ3VtZW50cyhhcmd1bWVudHMpO1xuICAgICAgICAgICAgY2hhbm5lbC5wb3J0Mi5wb3N0TWVzc2FnZShoYW5kbGUpO1xuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsUmVhZHlTdGF0ZUNoYW5nZUltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICB2YXIgaHRtbCA9IGRvYy5kb2N1bWVudEVsZW1lbnQ7XG4gICAgICAgIHNldEltbWVkaWF0ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGhhbmRsZSA9IGFkZEZyb21TZXRJbW1lZGlhdGVBcmd1bWVudHMoYXJndW1lbnRzKTtcbiAgICAgICAgICAgIC8vIENyZWF0ZSBhIDxzY3JpcHQ+IGVsZW1lbnQ7IGl0cyByZWFkeXN0YXRlY2hhbmdlIGV2ZW50IHdpbGwgYmUgZmlyZWQgYXN5bmNocm9ub3VzbHkgb25jZSBpdCBpcyBpbnNlcnRlZFxuICAgICAgICAgICAgLy8gaW50byB0aGUgZG9jdW1lbnQuIERvIHNvLCB0aHVzIHF1ZXVpbmcgdXAgdGhlIHRhc2suIFJlbWVtYmVyIHRvIGNsZWFuIHVwIG9uY2UgaXQncyBiZWVuIGNhbGxlZC5cbiAgICAgICAgICAgIHZhciBzY3JpcHQgPSBkb2MuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKTtcbiAgICAgICAgICAgIHNjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcnVuSWZQcmVzZW50KGhhbmRsZSk7XG4gICAgICAgICAgICAgICAgc2NyaXB0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgaHRtbC5yZW1vdmVDaGlsZChzY3JpcHQpO1xuICAgICAgICAgICAgICAgIHNjcmlwdCA9IG51bGw7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaHRtbC5hcHBlbmRDaGlsZChzY3JpcHQpO1xuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsU2V0VGltZW91dEltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICBzZXRJbW1lZGlhdGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBoYW5kbGUgPSBhZGRGcm9tU2V0SW1tZWRpYXRlQXJndW1lbnRzKGFyZ3VtZW50cyk7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KHBhcnRpYWxseUFwcGxpZWQocnVuSWZQcmVzZW50LCBoYW5kbGUpLCAwKTtcbiAgICAgICAgICAgIHJldHVybiBoYW5kbGU7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gSWYgc3VwcG9ydGVkLCB3ZSBzaG91bGQgYXR0YWNoIHRvIHRoZSBwcm90b3R5cGUgb2YgZ2xvYmFsLCBzaW5jZSB0aGF0IGlzIHdoZXJlIHNldFRpbWVvdXQgZXQgYWwuIGxpdmUuXG4gICAgdmFyIGF0dGFjaFRvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mICYmIE9iamVjdC5nZXRQcm90b3R5cGVPZihnbG9iYWwpO1xuICAgIGF0dGFjaFRvID0gYXR0YWNoVG8gJiYgYXR0YWNoVG8uc2V0VGltZW91dCA/IGF0dGFjaFRvIDogZ2xvYmFsO1xuXG4gICAgLy8gRG9uJ3QgZ2V0IGZvb2xlZCBieSBlLmcuIGJyb3dzZXJpZnkgZW52aXJvbm1lbnRzLlxuICAgIGlmICh7fS50b1N0cmluZy5jYWxsKGdsb2JhbC5wcm9jZXNzKSA9PT0gXCJbb2JqZWN0IHByb2Nlc3NdXCIpIHtcbiAgICAgICAgLy8gRm9yIE5vZGUuanMgYmVmb3JlIDAuOVxuICAgICAgICBpbnN0YWxsTmV4dFRpY2tJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgfSBlbHNlIGlmIChjYW5Vc2VQb3N0TWVzc2FnZSgpKSB7XG4gICAgICAgIC8vIEZvciBub24tSUUxMCBtb2Rlcm4gYnJvd3NlcnNcbiAgICAgICAgaW5zdGFsbFBvc3RNZXNzYWdlSW1wbGVtZW50YXRpb24oKTtcblxuICAgIH0gZWxzZSBpZiAoZ2xvYmFsLk1lc3NhZ2VDaGFubmVsKSB7XG4gICAgICAgIC8vIEZvciB3ZWIgd29ya2Vycywgd2hlcmUgc3VwcG9ydGVkXG4gICAgICAgIGluc3RhbGxNZXNzYWdlQ2hhbm5lbEltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2UgaWYgKGRvYyAmJiBcIm9ucmVhZHlzdGF0ZWNoYW5nZVwiIGluIGRvYy5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpKSB7XG4gICAgICAgIC8vIEZvciBJRSA24oCTOFxuICAgICAgICBpbnN0YWxsUmVhZHlTdGF0ZUNoYW5nZUltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBGb3Igb2xkZXIgYnJvd3NlcnNcbiAgICAgICAgaW5zdGFsbFNldFRpbWVvdXRJbXBsZW1lbnRhdGlvbigpO1xuICAgIH1cblxuICAgIGF0dGFjaFRvLnNldEltbWVkaWF0ZSA9IHNldEltbWVkaWF0ZTtcbiAgICBhdHRhY2hUby5jbGVhckltbWVkaWF0ZSA9IGNsZWFySW1tZWRpYXRlO1xufShzZWxmKSk7XG4iLCIvLyBDYXV0aW9uOlxuLy8gRG8gbm90IHJlcGxhY2UgdGhpcyBpbXBvcnQgc3RhdGVtZW50IHdpdGggY29kZXMuXG4vL1xuLy8gSWYgeW91IHJlcGxhY2UgdGhpcyBpbXBvcnQgc3RhdGVtZW50IHdpdGggY29kZXMsXG4vLyB0aGUgY29kZXMgd2lsbCBiZSBleGVjdXRlZCBhZnRlciB0aGUgZm9sbG93aW5nIHBvbHlmaWxscyBhcmUgaW1wb3J0ZWRcbi8vIGJlY2F1c2UgaW1wb3J0IHN0YXRlbWVudHMgYXJlIGhvaXN0ZWQgZHVyaW5nIGNvbXBpbGF0aW9uLlxuaW1wb3J0ICcuL3BvbHlmaWxsLXN3aXRjaGVzJztcblxuLy8gUG9seWZpbGwgRUNNQVNjcmlwdCBzdGFuZGFyZCBmZWF0dXJlcyB3aXRoIGdsb2JhbCBuYW1lc3BhY2UgcG9sbHV0aW9uXG5pbXBvcnQgJ2NvcmUtanMvZm4vb2JqZWN0L3NldC1wcm90b3R5cGUtb2YnO1xuaW1wb3J0ICdjb3JlLWpzL2ZuL3NldCc7XG5pbXBvcnQgJ2NvcmUtanMvZm4vbWFwJztcbmltcG9ydCAnY29yZS1qcy9mbi93ZWFrLW1hcCc7XG5pbXBvcnQgJ2NvcmUtanMvZm4vYXJyYXkvZnJvbSc7XG5cbi8vIFBvbHlmaWxsIEN1c3RvbSBFbGVtZW50cyB2MSB3aXRoIGdsb2JhbCBuYW1lc3BhY2UgcG9sbHV0aW9uXG5pbXBvcnQgJ0BvbnNlbnVpL2N1c3RvbS1lbGVtZW50cy9zcmMvY3VzdG9tLWVsZW1lbnRzJztcblxuLy8gUG9seWZpbGwgTXV0YXRpb25PYnNlcnZlciB3aXRoIGdsb2JhbCBuYW1lc3BhY2UgcG9sbHV0aW9uXG5pbXBvcnQgJy4vTXV0YXRpb25PYnNlcnZlckAwLjcuMjIvTXV0YXRpb25PYnNlcnZlci5qcyc7XG5cbi8vIFBvbHlmaWxsIHNldEltbWVkaWF0ZSB3aXRoIGdsb2JhbCBuYW1lc3BhY2UgcG9sbHV0aW9uXG5pbXBvcnQgJy4vc2V0SW1tZWRpYXRlQDEuMC4yK21vZC9zZXRJbW1lZGlhdGUuanMnO1xuIiwiKGZ1bmN0aW9uKCkge1xuICB2YXIgREVGQVVMVF9WSUVXUE9SVCA9ICd3aWR0aD1kZXZpY2Utd2lkdGgsaW5pdGlhbC1zY2FsZT0xLG1heGltdW0tc2NhbGU9MSxtaW5pbXVtLXNjYWxlPTEsdXNlci1zY2FsYWJsZT1ubyc7XG5cbiAgdmFyIFZpZXdwb3J0ID0geyBcbiAgICBlbnN1cmVWaWV3cG9ydEVsZW1lbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHZpZXdwb3J0RWxlbWVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ21ldGFbbmFtZT12aWV3cG9ydF0nKTtcblxuICAgICAgaWYgKCF2aWV3cG9ydEVsZW1lbnQpIHtcbiAgICAgICAgdmlld3BvcnRFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbWV0YScpO1xuICAgICAgICB2aWV3cG9ydEVsZW1lbnQubmFtZSA9ICd2aWV3cG9ydCc7XG4gICAgICAgIGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQodmlld3BvcnRFbGVtZW50KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHZpZXdwb3J0RWxlbWVudDtcbiAgICB9LFxuXG4gICAgc2V0dXA6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHZpZXdwb3J0RWxlbWVudCA9IFZpZXdwb3J0LmVuc3VyZVZpZXdwb3J0RWxlbWVudCgpO1xuXG4gICAgICBpZiAoIXZpZXdwb3J0RWxlbWVudCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICghdmlld3BvcnRFbGVtZW50Lmhhc0F0dHJpYnV0ZSgnY29udGVudCcpKSB7XG4gICAgICAgIHZpZXdwb3J0RWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2NvbnRlbnQnLCBERUZBVUxUX1ZJRVdQT1JUKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgd2luZG93LlZpZXdwb3J0ID0gVmlld3BvcnQ7XG59KSgpO1xuIiwiaW1wb3J0IHsgRmFzdENsaWNrIH0gZnJvbSAnQG9uc2VudWkvZmFzdGNsaWNrJztcbmltcG9ydCAnLi9vbnMvcGxhdGZvcm0nOyAvLyBUaGlzIGZpbGUgbXVzdCBiZSBsb2FkZWQgYmVmb3JlIEN1c3RvbSBFbGVtZW50cyBwb2x5ZmlsbHMuXG5pbXBvcnQgJy4vcG9seWZpbGxzL2luZGV4LmpzJztcbmltcG9ydCAnLi92ZW5kb3IvaW5kZXguanMnO1xuaW1wb3J0ICcuL29ucy9taWNyb2V2ZW50LmpzJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gc2V0dXAob25zKSB7XG4gIGlmICh3aW5kb3cuX29uc0xvYWRlZCkge1xuICAgIG9ucy5fdXRpbC53YXJuKCdPbnNlbiBVSSBpcyBsb2FkZWQgbW9yZSB0aGFuIG9uY2UuJyk7XG4gIH1cbiAgd2luZG93Ll9vbnNMb2FkZWQgPSB0cnVlO1xuXG4gIC8vIGZhc3RjbGlja1xuICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsICgpID0+IHtcbiAgICBvbnMuZmFzdENsaWNrID0gRmFzdENsaWNrLmF0dGFjaChkb2N1bWVudC5ib2R5KTtcblxuICAgIGNvbnN0IHN1cHBvcnRUb3VjaEFjdGlvbiA9ICd0b3VjaC1hY3Rpb24nIGluIGRvY3VtZW50LmJvZHkuc3R5bGU7XG5cbiAgICBvbnMucGxhdGZvcm0uX3J1bk9uQWN0dWFsUGxhdGZvcm0oKCkgPT4ge1xuICAgICAgaWYgKG9ucy5wbGF0Zm9ybS5pc0FuZHJvaWQoKSkge1xuICAgICAgICAvLyBJbiBBbmRyb2lkNC40KywgY29ycmVjdCB2aWV3cG9ydCBzZXR0aW5ncyBjYW4gcmVtb3ZlIGNsaWNrIGRlbGF5LlxuICAgICAgICAvLyBTbyBkaXNhYmxlIEZhc3RDbGljayBvbiBBbmRyb2lkLlxuICAgICAgICBvbnMuZmFzdENsaWNrLmRlc3Ryb3koKTtcbiAgICAgIH0gZWxzZSBpZiAob25zLnBsYXRmb3JtLmlzSU9TKCkpIHtcbiAgICAgICAgaWYgKHN1cHBvcnRUb3VjaEFjdGlvbiAmJiAob25zLnBsYXRmb3JtLmlzSU9TU2FmYXJpKCkgfHwgb25zLnBsYXRmb3JtLmlzV0tXZWJWaWV3KCkpKSB7XG4gICAgICAgICAgLy8gSWYgJ3RvdWNoLWFjdGlvbicgc3VwcG9ydGVkIGluIGlPUyBTYWZhcmkgb3IgV0tXZWJWaWV3LCBkaXNhYmxlIEZhc3RDbGljay5cbiAgICAgICAgICBvbnMuZmFzdENsaWNrLmRlc3Ryb3koKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBEbyBub3RoaW5nLiAndG91Y2gtYWN0aW9uOiBtYW5pcHVsYXRpb24nIGhhcyBubyBlZmZlY3Qgb24gVUlXZWJWaWV3LlxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH0sIGZhbHNlKTtcblxuICBvbnMucmVhZHkoZnVuY3Rpb24oKSB7XG4gICAgb25zLmVuYWJsZURldmljZUJhY2tCdXR0b25IYW5kbGVyKCk7XG4gICAgb25zLl9kZWZhdWx0RGV2aWNlQmFja0J1dHRvbkhhbmRsZXIgPSBvbnMuX2ludGVybmFsLmRiYkRpc3BhdGNoZXIuY3JlYXRlSGFuZGxlcih3aW5kb3cuZG9jdW1lbnQuYm9keSwgKCkgPT4ge1xuICAgICAgaWYgKE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG5hdmlnYXRvciwgJ2FwcCcpKSB7XG4gICAgICAgIG5hdmlnYXRvci5hcHAuZXhpdEFwcCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdDb3VsZCBub3QgY2xvc2UgdGhlIGFwcC4gSXMgXFwnY29yZG92YS5qc1xcJyBpbmNsdWRlZD9cXG5FcnJvcjogXFwnd2luZG93Lm5hdmlnYXRvci5hcHBcXCcgaXMgdW5kZWZpbmVkLicpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGRvY3VtZW50LmJvZHkuX2dlc3R1cmVEZXRlY3RvciA9IG5ldyBvbnMuR2VzdHVyZURldGVjdG9yKGRvY3VtZW50LmJvZHksIHsgcGFzc2l2ZTogdHJ1ZSB9KTtcblxuICAgIC8vIFNpbXVsYXRlIERldmljZSBCYWNrIEJ1dHRvbiBvbiBFU0MgcHJlc3NcbiAgICBpZiAoIW9ucy5wbGF0Zm9ybS5pc1dlYlZpZXcoKSkge1xuICAgICAgZG9jdW1lbnQuYm9keS5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgaWYgKGV2ZW50LmtleUNvZGUgPT09IDI3KSB7XG4gICAgICAgICAgb25zLmZpcmVEZXZpY2VCYWNrQnV0dG9uRXZlbnQoKTtcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9XG5cbiAgICAvLyBzZXR1cCBsb2FkaW5nIHBsYWNlaG9sZGVyXG4gICAgb25zLl9zZXR1cExvYWRpbmdQbGFjZUhvbGRlcnMoKTtcbiAgfSk7XG5cbiAgLy8gdmlld3BvcnQuanNcbiAgVmlld3BvcnQuc2V0dXAoKTtcbn1cbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmZ1bmN0aW9uIGdldEVsZW1lbnRDbGFzcygpIHtcbiAgaWYgKHR5cGVvZiBIVE1MRWxlbWVudCAhPT0gJ2Z1bmN0aW9uJykgeyAvLyBjYXNlIG9mIFNhZmFyaVxuICAgIGNvbnN0IEJhc2VFbGVtZW50ID0gKCkgPT4ge307XG4gICAgQmFzZUVsZW1lbnQucHJvdG90eXBlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgcmV0dXJuIEJhc2VFbGVtZW50O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBIVE1MRWxlbWVudDtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBCYXNlRWxlbWVudCBleHRlbmRzIGdldEVsZW1lbnRDbGFzcygpIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcbiAgfVxufVxuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IG9uc0VsZW1lbnRzIGZyb20gJy4uL29ucy9lbGVtZW50cyc7XG5pbXBvcnQgdXRpbCBmcm9tICcuLi9vbnMvdXRpbCc7XG5pbXBvcnQgQmFzZUVsZW1lbnQgZnJvbSAnLi9iYXNlL2Jhc2UtZWxlbWVudCc7XG5cbi8qKlxuICogQGVsZW1lbnQgb25zLXRlbXBsYXRlXG4gKiBAY2F0ZWdvcnkgdXRpbFxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1cbiAqICAgICBEZWZpbmUgYSBzZXBhcmF0ZSBIVE1MIGZyYWdtZW50IGFuZCB1c2UgYXMgYSB0ZW1wbGF0ZS4gVGhlc2UgdGVtcGxhdGVzIGNhbiBiZSBsb2FkZWQgYXMgcGFnZXMgaW4gYDxvbnMtbmF2aWdhdG9yPmAsIGA8b25zLXRhYmJhcj5gIGFuZCBgPG9ucy1zcGxpdHRlcj5gLiBUaGV5IGNhbiBhbHNvIGJlIHVzZWQgdG8gZ2VuZXJhdGUgZGlhbG9ncy4gU2luY2UgT25zZW4gVUkgMi40LjAsIHRoZSBuYXRpdmUgYDx0ZW1wbGF0ZT5gIGVsZW1lbnQgY2FuIGJlIHVzZWQgaW5zdGVhZCBvZiBgPG9ucy10ZW1wbGF0ZT5gIGZvciBiZXR0ZXIgcGVyZm9ybWFuY2UgYW5kIGZlYXR1cmVzLiBgPG9ucy10ZW1wbGF0ZT5gIGlzIHN0aWxsIHN1cHBvcnRlZCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eS5cbiAqICAgWy9lbl1cbiAqICAgW2phXeODhuODs+ODl+ODrOODvOODiOOBqOOBl+OBpuS9v+eUqOOBmeOCi+OBn+OCgeOBrkhUTUzjg5Xjg6njgrDjg6Hjg7Pjg4jjgpLlrprnvqnjgZfjgb7jgZnjgILjgZPjga7opoHntKDjgadIVE1M44KS5a6j6KiA44GZ44KL44Go44CBaWTlsZ7mgKfjgavmjIflrprjgZfjgZ/lkI3liY3jgpJwYWdl44GuVVJM44Go44GX44Gmb25zLW5hdmlnYXRvcuOBquOBqeOBruOCs+ODs+ODneODvOODjeODs+ODiOOBi+OCieWPgueFp+OBp+OBjeOBvuOBmeOAglsvamFdXG4gKiBAc2VlYWxzbyBvbnMtbmF2aWdhdG9yXG4gKiAgIFtlbl1UaGUgYDxvbnMtbmF2aWdhdG9yPmAgY29tcG9uZW50IGVuYWJsZXMgc3RhY2sgYmFzZWQgbmF2aWdhdGlvbi5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBzZWVhbHNvIG9ucy10YWJiYXJcbiAqICAgW2VuXVRoZSBgPG9ucy10YWJiYXI+YCBjb21wb25lbnQgaXMgdXNlZCB0byBhZGQgdGFiIG5hdmlnYXRpb24uWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAc2VlYWxzbyBvbnMtc3BsaXR0ZXJcbiAqICAgW2VuXVRoZSBgPG9ucy1zcGxpdHRlcj5gIGNvbXBvbmVudCBjYW4gYmUgdXNlZCB0byBjcmVhdGUgYSBkcmFnZ2FibGUgbWVudSBvciBjb2x1bW4gYmFzZWQgbGF5b3V0LlsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQGV4YW1wbGVcbiAqIDxvbnMtdGVtcGxhdGUgaWQ9XCJmb29iYXIuaHRtbFwiPlxuICogICA8b25zLXBhZ2U+XG4gKiAgICAgUGFnZSBjb250ZW50XG4gKiAgIDwvb25zLXBhZ2U+XG4gKiA8L29ucy10ZW1wbGF0ZT5cbiAqXG4gKiA8b25zLW5hdmlnYXRvciBwYWdlPVwiZm9vYmFyLmh0bWxcIj48L29ucy1uYXZpZ2F0b3I+XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRlbXBsYXRlRWxlbWVudCBleHRlbmRzIEJhc2VFbGVtZW50IHtcblxuICAvKipcbiAgICogQHByb3BlcnR5IHRlbXBsYXRlXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXVRlbXBsYXRlIGNvbnRlbnQuIFRoaXMgcHJvcGVydHkgY2FuIG5vdCBiZSB1c2VkIHdpdGggQW5ndWxhckpTIGJpbmRpbmdzLlsvZW5dXG4gICAqICBbamFdWy9qYV1cbiAgICovXG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIHRoaXMudGVtcGxhdGUgPSB0aGlzLmlubmVySFRNTDtcblxuICAgIHdoaWxlICh0aGlzLmZpcnN0Q2hpbGQpIHtcbiAgICAgIHRoaXMucmVtb3ZlQ2hpbGQodGhpcy5maXJzdENoaWxkKTtcbiAgICB9XG4gIH1cblxuICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICBpZiAodGhpcy5wYXJlbnROb2RlKSB7IC8vIE5vdGU6IHRoaXMucGFyZW50Tm9kZSBpcyBub3Qgc2V0IGluIHNvbWUgQ0UwL0NFMSBwb2x5ZmlsbHMuXG4gICAgICAvLyBTaG93IHdhcm5pbmcgd2hlbiB0aGUgb25zLXRlbXBsYXRlIGlzIG5vdCBsb2NhdGVkIGp1c3QgdW5kZXIgZG9jdW1lbnQuYm9keVxuICAgICAgaWYgKHRoaXMucGFyZW50Tm9kZSAhPT0gZG9jdW1lbnQuYm9keSkgeyAvLyBpZiB0aGUgcGFyZW50IGlzIG5vdCBkb2N1bWVudC5ib2R5XG4gICAgICAgIHV0aWwud2Fybihgb25zLXRlbXBsYXRlIChpZCA9ICR7dGhpcy5nZXRBdHRyaWJ1dGUoJ2lkJyl9KSBtdXN0IGJlIGxvY2F0ZWQganVzdCB1bmRlciBkb2N1bWVudC5ib2R5JHsgdGhpcy5wYXJlbnROb2RlLm91dGVySFRNTCA/IGA6XFxuXFxuJHt0aGlzLnBhcmVudE5vZGUub3V0ZXJIVE1MfWAgOiAnLicgfWApO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBldmVudCA9IG5ldyBDdXN0b21FdmVudCgnX3RlbXBsYXRlbG9hZGVkJywge2J1YmJsZXM6IHRydWUsIGNhbmNlbGFibGU6IHRydWV9KTtcbiAgICBldmVudC50ZW1wbGF0ZSA9IHRoaXMudGVtcGxhdGU7XG4gICAgZXZlbnQudGVtcGxhdGVJZCA9IHRoaXMuZ2V0QXR0cmlidXRlKCdpZCcpO1xuXG4gICAgdGhpcy5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgfVxufVxuXG5vbnNFbGVtZW50cy5UZW1wbGF0ZSA9IFRlbXBsYXRlRWxlbWVudDtcbmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnb25zLXRlbXBsYXRlJywgVGVtcGxhdGVFbGVtZW50KTtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCBvbnNFbGVtZW50cyBmcm9tICcuLi9vbnMvZWxlbWVudHMnO1xuaW1wb3J0IG9yaWVudGF0aW9uIGZyb20gJy4uL29ucy9vcmllbnRhdGlvbic7XG5pbXBvcnQgcGxhdGZvcm0gZnJvbSAnLi4vb25zL3BsYXRmb3JtJztcbmltcG9ydCBCYXNlRWxlbWVudCBmcm9tICcuL2Jhc2UvYmFzZS1lbGVtZW50JztcbmltcG9ydCBjb250ZW50UmVhZHkgZnJvbSAnLi4vb25zL2NvbnRlbnQtcmVhZHknO1xuXG4vKipcbiAqIEBlbGVtZW50IG9ucy1pZlxuICogQGNhdGVnb3J5IGNvbmRpdGlvbmFsXG4gKiBAdHV0b3JpYWwgdmFuaWxsYS9SZWZlcmVuY2UvaWZcbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dXG4gKiAgICAgQ29uZGl0aW9uYWxseSBkaXNwbGF5IGNvbnRlbnQgZGVwZW5kaW5nIG9uIHRoZSBwbGF0Zm9ybSwgZGV2aWNlIG9yaWVudGF0aW9uIG9yIGJvdGguXG4gKlxuICogICAgIFNvbWV0aW1lcyBpdCBpcyB1c2VmdWwgdG8gY29uZGl0aW9uYWxseSBoaWRlIG9yIHNob3cgY2VydGFpbiBjb21wb25lbnRzIGJhc2VkIG9uIHBsYXRmb3JtLiBXaGVuIHJ1bm5pbmcgb24gaU9TIHRoZSBgPG9ucy1pZj5gIGVsZW1lbnQgY2FuIGJlIHVzZWQgdG8gaGlkZSB0aGUgYDxvbnMtZmFiPmAgZWxlbWVudC5cbiAqICAgWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAZ3VpZGUgdGhlbWluZy5odG1sI2Nyb3NzLXBsYXRmb3JtLXN0eWxpbmctYXV0b3N0eWxpbmcgW2VuXUluZm9ybWF0aW9uIGFib3V0IGNyb3NzIHBsYXRmb3JtIHN0eWxpbmdbL2VuXVtqYV1JbmZvcm1hdGlvbiBhYm91dCBjcm9zcyBwbGF0Zm9ybSBzdHlsaW5nWy9qYV1cbiAqIEBleGFtcGxlXG4gKiA8b25zLXBhZ2U+XG4gKiAgIDxvbnMtaWYgb3JpZW50YXRpb249XCJsYW5kc2NhcGVcIj5cbiAqICAgICBMYW5kc2NhcGUgdmlldyFcbiAqICAgPC9vbnMtaWY+XG4gKiAgIDxvbnMtaWYgcGxhdGZvcm09XCJhbmRyb2lkXCI+XG4gKiAgICAgVGhpcyBpcyBBbmRyb2lkLlxuICogICA8L29ucy1pZj5cbiAqICAgPG9ucy1pZiBwbGF0Zm9ybT1cImlvcyBvdGhlclwiPlxuICogICAgIFRoaXMgaXMgbm90IEFuZHJvaWQuXG4gKiAgIDwvb25zLWlmPlxuICogPC9vbnMtcGFnZT5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSWZFbGVtZW50IGV4dGVuZHMgQmFzZUVsZW1lbnQge1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIHBsYXRmb3JtXG4gICAqIEBpbml0b25seVxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFtlbl1TcGFjZS1zZXBhcmF0ZWQgcGxhdGZvcm0gbmFtZXMuIFBvc3NpYmxlIHZhbHVlcyBhcmUgYFwiaW9zXCJgLCBgXCJhbmRyb2lkXCJgLCBgXCJ3aW5kb3dzXCJgIGFuZCBgXCJvdGhlclwiYC5bL2VuXVxuICAgKiAgW2phXVsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIG9yaWVudGF0aW9uXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXUVpdGhlciBgXCJwb3J0cmFpdFwiYCBvciBgXCJsYW5kc2NhcGVcImAuWy9lbl1cbiAgICogIFtqYV1wb3J0cmFpdOOCguOBl+OBj+OBr2xhbmRzY2FwZeOCkuaMh+WumuOBl+OBvuOBmVsvamFdXG4gICAqL1xuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG5cbiAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4ge1xuICAgICAgaWYgKHBsYXRmb3JtLl9nZXRTZWxlY3RlZFBsYXRmb3JtKCkgIT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5fcGxhdGZvcm1VcGRhdGUoKTtcbiAgICAgIH0gZWxzZSBpZiAoIXRoaXMuX2lzQWxsb3dlZFBsYXRmb3JtKCkpIHtcbiAgICAgICAgd2hpbGUgKHRoaXMuY2hpbGROb2Rlc1swXSkge1xuICAgICAgICAgIHRoaXMuY2hpbGROb2Rlc1swXS5yZW1vdmUoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9wbGF0Zm9ybVVwZGF0ZSgpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdGhpcy5fb25PcmllbnRhdGlvbkNoYW5nZSgpO1xuICB9XG5cbiAgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgb3JpZW50YXRpb24ub24oJ2NoYW5nZScsIHRoaXMuX29uT3JpZW50YXRpb25DaGFuZ2UuYmluZCh0aGlzKSk7XG4gIH1cblxuICBzdGF0aWMgZ2V0IG9ic2VydmVkQXR0cmlidXRlcygpIHtcbiAgICByZXR1cm4gWydvcmllbnRhdGlvbiddO1xuICB9XG5cbiAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUpIHtcbiAgICBpZiAobmFtZSA9PT0gJ29yaWVudGF0aW9uJykge1xuICAgICAgdGhpcy5fb25PcmllbnRhdGlvbkNoYW5nZSgpO1xuICAgIH1cbiAgfVxuXG4gIGRpc2Nvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIG9yaWVudGF0aW9uLm9mZignY2hhbmdlJywgdGhpcy5fb25PcmllbnRhdGlvbkNoYW5nZSk7XG4gIH1cblxuICBfcGxhdGZvcm1VcGRhdGUoKSB7XG4gICAgdGhpcy5zdHlsZS5kaXNwbGF5ID0gdGhpcy5faXNBbGxvd2VkUGxhdGZvcm0oKSA/ICcnIDogJ25vbmUnO1xuICB9XG5cbiAgX2lzQWxsb3dlZFBsYXRmb3JtKCkge1xuICAgIHJldHVybiAhdGhpcy5nZXRBdHRyaWJ1dGUoJ3BsYXRmb3JtJykgfHwgdGhpcy5nZXRBdHRyaWJ1dGUoJ3BsYXRmb3JtJykuc3BsaXQoL1xccysvKS5pbmRleE9mKHBsYXRmb3JtLmdldE1vYmlsZU9TKCkpID49IDA7XG4gIH1cblxuICBfb25PcmllbnRhdGlvbkNoYW5nZSgpIHtcbiAgICBpZiAodGhpcy5oYXNBdHRyaWJ1dGUoJ29yaWVudGF0aW9uJykgJiYgdGhpcy5faXNBbGxvd2VkUGxhdGZvcm0oKSkge1xuICAgICAgY29uc3QgY29uZGl0aW9uYWxPcmllbnRhdGlvbiA9IHRoaXMuZ2V0QXR0cmlidXRlKCdvcmllbnRhdGlvbicpLnRvTG93ZXJDYXNlKCk7XG4gICAgICBjb25zdCBjdXJyZW50T3JpZW50YXRpb24gPSBvcmllbnRhdGlvbi5pc1BvcnRyYWl0KCkgPyAncG9ydHJhaXQnIDogJ2xhbmRzY2FwZSc7XG5cbiAgICAgIHRoaXMuc3R5bGUuZGlzcGxheSA9IChjb25kaXRpb25hbE9yaWVudGF0aW9uID09PSBjdXJyZW50T3JpZW50YXRpb24pID8gJycgOiAnbm9uZSc7XG4gICAgfVxuICB9XG59XG5cbm9uc0VsZW1lbnRzLklmID0gSWZFbGVtZW50O1xuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdvbnMtaWYnLCBJZkVsZW1lbnQpO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IHV0aWwgZnJvbSAnLi91dGlsJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQmFzZUFuaW1hdG9yIHtcblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbnMudGltaW5nXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25zLmR1cmF0aW9uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25zLmRlbGF5XG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHtcbiAgICB0aGlzLnRpbWluZyA9IG9wdGlvbnMudGltaW5nIHx8ICdsaW5lYXInO1xuICAgIHRoaXMuZHVyYXRpb24gPSBvcHRpb25zLmR1cmF0aW9uIHx8IDA7XG4gICAgdGhpcy5kZWxheSA9IG9wdGlvbnMuZGVsYXkgfHwgMDtcblxuICAgIHRoaXMuZGVmID0ge1xuICAgICAgdGltaW5nOiB0aGlzLnRpbWluZyxcbiAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgZGVsYXk6IHRoaXMuZGVsYXlcbiAgICB9O1xuICB9XG5cbiAgc3RhdGljIGV4dGVuZChwcm9wZXJ0aWVzID0ge30pIHtcbiAgICBjb25zdCBleHRlbmRlZEFuaW1hdG9yID0gdGhpcztcbiAgICBjb25zdCBuZXdBbmltYXRvciA9IGZ1bmN0aW9uKCkge1xuICAgICAgZXh0ZW5kZWRBbmltYXRvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgdXRpbC5leHRlbmQodGhpcywgcHJvcGVydGllcyk7XG4gICAgfTtcblxuICAgIG5ld0FuaW1hdG9yLnByb3RvdHlwZSA9IHRoaXMucHJvdG90eXBlO1xuICAgIHJldHVybiBuZXdBbmltYXRvcjtcbiAgfVxufVxuXG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG4vLyBUaGlzIG9iamVjdCBzaG91bGQgbm90IGJlIGV4cG9zZWQgdG8gdXNlcnMuIFBsZWFzZSBrZWVwIHRoaXMgcHJpdmF0ZS5cbmNvbnN0IGlQaG9uZVhQYXRjaCA9IHt9O1xuXG5pUGhvbmVYUGF0Y2guaXNJUGhvbmVYUG9ydHJhaXRQYXRjaEFjdGl2ZSA9ICgpID0+IHtcbiAgcmV0dXJuIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5nZXRBdHRyaWJ1dGUoJ29uc2ZsYWctaXBob25leC1wb3J0cmFpdCcpICE9IG51bGwgJiYgd2luZG93LmlubmVyV2lkdGggPCB3aW5kb3cuaW5uZXJIZWlnaHQ7XG59XG5cbmlQaG9uZVhQYXRjaC5pc0lQaG9uZVhMYW5kc2NhcGVQYXRjaEFjdGl2ZSA9ICgpID0+IHtcbiAgLy8gSWYgd2lkdGggPT09IGhlaWdodCwgdHJlYXQgaXQgYXMgbGFuZHNjYXBlXG4gIHJldHVybiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuZ2V0QXR0cmlidXRlKCdvbnNmbGFnLWlwaG9uZXgtbGFuZHNjYXBlJykgIT0gbnVsbCAmJiB3aW5kb3cuaW5uZXJXaWR0aCA+PSB3aW5kb3cuaW5uZXJIZWlnaHQ7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgc2FmZSBhcmVhIGxlbmd0aHMgYmFzZWQgb24gdGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhlIHNhZmUgYXJlYXMuXG4gKi9cbmlQaG9uZVhQYXRjaC5nZXRTYWZlQXJlYUxlbmd0aHMgPSAoKSA9PiB7XG4gIGxldCBzYWZlQXJlYUxlbmd0aHM7XG4gIGlmIChpUGhvbmVYUGF0Y2guaXNJUGhvbmVYUG9ydHJhaXRQYXRjaEFjdGl2ZSgpKSB7XG4gICAgc2FmZUFyZWFMZW5ndGhzID0ge1xuICAgICAgdG9wOiA0NCxcbiAgICAgIHJpZ2h0OiAwLFxuICAgICAgYm90dG9tOiAzNCxcbiAgICAgIGxlZnQ6IDBcbiAgICB9O1xuICB9IGVsc2UgaWYgKGlQaG9uZVhQYXRjaC5pc0lQaG9uZVhMYW5kc2NhcGVQYXRjaEFjdGl2ZSgpKSB7XG4gICAgc2FmZUFyZWFMZW5ndGhzID0ge1xuICAgICAgdG9wOiAwLFxuICAgICAgcmlnaHQ6IDQ0LFxuICAgICAgYm90dG9tOiAyMSxcbiAgICAgIGxlZnQ6IDQ0XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBzYWZlQXJlYUxlbmd0aHMgPSB7XG4gICAgICB0b3A6IDAsXG4gICAgICByaWdodDogMCxcbiAgICAgIGJvdHRvbTogMCxcbiAgICAgIGxlZnQ6IDBcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHNhZmVBcmVhTGVuZ3Rocztcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBzYWZlIGFyZWEgcmVjdCBiYXNlZCBvbiB0aGUgY3VycmVudCBzdGF0ZSBvZiB0aGUgc2FmZSBhcmVhcy5cbiAqL1xuaVBob25lWFBhdGNoLmdldFNhZmVBcmVhRE9NUmVjdCA9ICgpID0+IHtcbiAgbGV0IHNhZmVBcmVhUmVjdDtcbiAgaWYgKGlQaG9uZVhQYXRjaC5pc0lQaG9uZVhQb3J0cmFpdFBhdGNoQWN0aXZlKCkpIHtcbiAgICBzYWZlQXJlYVJlY3QgPSB7XG4gICAgICB4OiAwLFxuICAgICAgeTogNDQsIC8qIDAgKyA0NCAodG9wIHNhZmUgYXJlYSkgKi9cbiAgICAgIHdpZHRoOiB3aW5kb3cuaW5uZXJXaWR0aCxcbiAgICAgIGhlaWdodDogd2luZG93LmlubmVySGVpZ2h0IC0gNzggLyogaGVpZ2h0IC0gNDQgKHRvcCBzYWZlIGFyZWEpIC0gMzQgKGJvdHRvbSBzYWZlIGFyZWEpICovXG4gICAgfTtcbiAgfSBlbHNlIGlmIChpUGhvbmVYUGF0Y2guaXNJUGhvbmVYTGFuZHNjYXBlUGF0Y2hBY3RpdmUoKSkge1xuICAgIHNhZmVBcmVhUmVjdCA9IHtcbiAgICAgIHg6IDQ0LCAvKiAwICsgNDQgKGxlZnQgc2FmZSBhcmVhKSAqL1xuICAgICAgeTogMCxcbiAgICAgIHdpZHRoOiB3aW5kb3cuaW5uZXJXaWR0aCAtIDg4LCAvKiB3aWR0aCAtIDQ0IChsZWZ0IHNhZmUgYXJlYSkgLSAzNCAocmlnaHQgc2FmZSBhcmVhKSAqL1xuICAgICAgaGVpZ2h0OiB3aW5kb3cuaW5uZXJIZWlnaHQgLSAyMSAvKiBoZWlnaHQgLSAyMSAoYm90dG9tIHNhZmUgYXJlYSkgKi9cbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHNhZmVBcmVhUmVjdCA9IHtcbiAgICAgIHg6IDAsXG4gICAgICB5OiAwLFxuICAgICAgd2lkdGg6IHdpbmRvdy5pbm5lcldpZHRoLFxuICAgICAgaGVpZ2h0OiB3aW5kb3cuaW5uZXJIZWlnaHRcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICAuLi5zYWZlQXJlYVJlY3QsXG4gICAgbGVmdDogc2FmZUFyZWFSZWN0LngsXG4gICAgdG9wOiBzYWZlQXJlYVJlY3QueSxcbiAgICByaWdodDogc2FmZUFyZWFSZWN0LnggKyBzYWZlQXJlYVJlY3Qud2lkdGgsXG4gICAgYm90dG9tOiBzYWZlQXJlYVJlY3QueSArIHNhZmVBcmVhUmVjdC5oZWlnaHRcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgaVBob25lWFBhdGNoO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IGFuaW1pdCBmcm9tICcuLi8uLi9vbnMvYW5pbWl0JztcbmltcG9ydCBCYXNlQW5pbWF0b3IgZnJvbSAnLi4vLi4vb25zL2Jhc2UtYW5pbWF0b3InXG5pbXBvcnQgaVBob25lWFBhdGNoIGZyb20gJy4uLy4uL29ucy9pcGhvbmV4LXBhdGNoJztcblxuZXhwb3J0IGNsYXNzIEFjdGlvblNoZWV0QW5pbWF0b3IgZXh0ZW5kcyBCYXNlQW5pbWF0b3Ige1xuXG4gIGNvbnN0cnVjdG9yKHt0aW1pbmcgPSAnbGluZWFyJywgZGVsYXkgPSAwLCBkdXJhdGlvbiA9IDAuMn0gPSB7fSkge1xuICAgIHN1cGVyKHsgdGltaW5nLCBkZWxheSwgZHVyYXRpb24gfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBkaWFsb2dcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZG9uZVxuICAgKi9cbiAgc2hvdyhkaWFsb2csIGRvbmUpIHtcbiAgICBkb25lKCk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZGlhbG9nXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGRvbmVcbiAgICovXG4gIGhpZGUoZGlhbG9nLCBkb25lKSB7XG4gICAgZG9uZSgpO1xuICB9XG59XG5cbi8qKlxuICogQW5kcm9pZCBzdHlsZSBhbmltYXRvciBmb3IgQWN0aW9uIFNoZWV0LlxuICovXG5leHBvcnQgY2xhc3MgTURBY3Rpb25TaGVldEFuaW1hdG9yIGV4dGVuZHMgQWN0aW9uU2hlZXRBbmltYXRvciB7XG5cbiAgY29uc3RydWN0b3IoeyB0aW1pbmcgPSAnZWFzZScsIGRlbGF5ID0gMCwgZHVyYXRpb24gPSAwLjQgfSA9IHt9KSB7XG4gICAgc3VwZXIoe3RpbWluZywgZGVsYXksIGR1cmF0aW9ufSk7XG5cbiAgICB0aGlzLm1hc2tUaW1pbmcgPSAnbGluZWFyJztcbiAgICB0aGlzLm1hc2tEdXJhdGlvbiA9IDAuMjtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gZGlhbG9nXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqL1xuICBzaG93KGRpYWxvZywgY2FsbGJhY2spIHtcblxuICAgIGFuaW1pdC5ydW5BbGwoXG4gICAgICBhbmltaXQoZGlhbG9nLl9tYXNrKVxuICAgICAgICAucXVldWUoeyBvcGFjaXR5OiAwIH0pXG4gICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAgIC5xdWV1ZSh7IG9wYWNpdHk6IDEuMCB9LCB7XG4gICAgICAgICAgZHVyYXRpb246IHRoaXMubWFza0R1cmF0aW9uLFxuICAgICAgICAgIHRpbWluZzogdGhpcy5tYXNrVGltaW5nXG4gICAgICAgIH0pLFxuXG4gICAgICBhbmltaXQoZGlhbG9nLl9zaGVldCwgdGhpcy5kZWYpXG4gICAgICAgIC5kZWZhdWx0KFxuICAgICAgICAgIHsgdHJhbnNmb3JtOiBgdHJhbnNsYXRlM2QoMCwgODAlLCAwKWAsIG9wYWNpdHk6IDAgfSxcbiAgICAgICAgICB7IHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNkKDAsIDAsIDApJywgb3BhY2l0eTogMSB9XG4gICAgICAgIClcbiAgICAgICAgLnF1ZXVlKGRvbmUgPT4ge1xuICAgICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKCk7XG4gICAgICAgICAgZG9uZSgpO1xuICAgICAgICB9KVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IGRpYWxvZ1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKi9cbiAgaGlkZShkaWFsb2csIGNhbGxiYWNrKSB7XG4gICAgYW5pbWl0LnJ1bkFsbChcblxuICAgICAgYW5pbWl0KGRpYWxvZy5fbWFzaylcbiAgICAgICAgLnF1ZXVlKHsgb3BhY2l0eTogMSB9KVxuICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAucXVldWUoeyBvcGFjaXR5OiAwIH0sIHtcbiAgICAgICAgICBkdXJhdGlvbjogdGhpcy5tYXNrRHVyYXRpb24sXG4gICAgICAgICAgdGltaW5nOiB0aGlzLm1hc2tUaW1pbmdcbiAgICAgICAgfSksXG5cbiAgICAgIGFuaW1pdChkaWFsb2cuX3NoZWV0LCB0aGlzLmRlZilcbiAgICAgICAgLmRlZmF1bHQoXG4gICAgICAgICAgeyB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzZCgwLCAwLCAwKScsIG9wYWNpdHk6IDEgfSxcbiAgICAgICAgICB7IHRyYW5zZm9ybTogYHRyYW5zbGF0ZTNkKDAsIDgwJSwgMClgLCBvcGFjaXR5OiAwIH1cbiAgICAgICAgKVxuICAgICAgICAucXVldWUoZG9uZSA9PiB7XG4gICAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soKTtcbiAgICAgICAgICBkb25lKCk7XG4gICAgICAgIH0pXG4gICAgKTtcbiAgfVxufVxuXG4vKipcbiAqIGlPUyBzdHlsZSBhbmltYXRvciBmb3IgZGlhbG9nLlxuICovXG5leHBvcnQgY2xhc3MgSU9TQWN0aW9uU2hlZXRBbmltYXRvciBleHRlbmRzIEFjdGlvblNoZWV0QW5pbWF0b3Ige1xuXG4gIGNvbnN0cnVjdG9yKHsgdGltaW5nID0gJ2Vhc2UnLCBkZWxheSA9IDAsIGR1cmF0aW9uID0gMC4zIH0gPSB7fSkge1xuICAgIHN1cGVyKHt0aW1pbmcsIGRlbGF5LCBkdXJhdGlvbn0pO1xuXG4gICAgdGhpcy5tYXNrVGltaW5nID0gJ2xpbmVhcic7XG4gICAgdGhpcy5tYXNrRHVyYXRpb24gPSAwLjI7XG4gICAgaWYgKGlQaG9uZVhQYXRjaC5pc0lQaG9uZVhQb3J0cmFpdFBhdGNoQWN0aXZlKCkpIHtcbiAgICAgIHRoaXMubGlmdEFtb3VudCA9ICdjYWxjKDEwMCUgKyA0OHB4KSc7XG4gICAgfSBlbHNlIGlmIChpUGhvbmVYUGF0Y2guaXNJUGhvbmVYTGFuZHNjYXBlUGF0Y2hBY3RpdmUoKSkge1xuICAgICAgdGhpcy5saWZ0QW1vdW50ID0gJ2NhbGMoMTAwJSArIDMzcHgpJztcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5saWZ0QW1vdW50ID0gZG9jdW1lbnQuYm9keS5jbGllbnRIZWlnaHQgLyAyLjAgLSAxICsgJ3B4JzsgLy8gYXZvaWQgRm9yY2VkIFN5bmNocm9ub3VzIExheW91dFxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gZGlhbG9nXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqL1xuICBzaG93KGRpYWxvZywgY2FsbGJhY2spIHtcbiAgICBhbmltaXQucnVuQWxsKFxuXG4gICAgICBhbmltaXQoZGlhbG9nLl9tYXNrKVxuICAgICAgLnF1ZXVlKHsgb3BhY2l0eTogMCB9KVxuICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgIC5xdWV1ZSh7IG9wYWNpdHk6IDEgfSwge1xuICAgICAgICBkdXJhdGlvbjogdGhpcy5tYXNrRHVyYXRpb24sXG4gICAgICAgIHRpbWluZzogdGhpcy5tYXNrVGltaW5nXG4gICAgICB9KSxcblxuICAgICAgYW5pbWl0KGRpYWxvZy5fc2hlZXQsIHRoaXMuZGVmKVxuICAgICAgICAuZGVmYXVsdChcbiAgICAgICAgICB7IHRyYW5zZm9ybTogYHRyYW5zbGF0ZTNkKDAsICR7dGhpcy5saWZ0QW1vdW50fSwgMClgIH0sXG4gICAgICAgICAgeyB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzZCgwLCAwLCAwKScgfVxuICAgICAgICApXG4gICAgICAgIC5xdWV1ZShkb25lID0+IHtcbiAgICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjaygpO1xuICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgfSlcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkaWFsb2dcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICovXG4gIGhpZGUoZGlhbG9nLCBjYWxsYmFjaykge1xuICAgIGFuaW1pdC5ydW5BbGwoXG5cbiAgICAgIGFuaW1pdChkaWFsb2cuX21hc2spXG4gICAgICAucXVldWUoeyBvcGFjaXR5OiAxIH0pXG4gICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgLnF1ZXVlKHsgb3BhY2l0eTogMCB9LCB7XG4gICAgICAgIGR1cmF0aW9uOiB0aGlzLm1hc2tEdXJhdGlvbixcbiAgICAgICAgdGltaW5nOiB0aGlzLm1hc2tUaW1pbmdcbiAgICAgIH0pLFxuXG4gICAgICBhbmltaXQoZGlhbG9nLl9zaGVldCwgdGhpcy5kZWYpXG4gICAgICAgIC5kZWZhdWx0KFxuICAgICAgICAgIHsgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoMCwgMCwgMCknIH0sXG4gICAgICAgICAgeyB0cmFuc2Zvcm06IGB0cmFuc2xhdGUzZCgwLCAke3RoaXMubGlmdEFtb3VudH0sIDApYCB9XG4gICAgICAgIClcbiAgICAgICAgLnF1ZXVlKGRvbmUgPT4ge1xuICAgICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKCk7XG4gICAgICAgICAgZG9uZSgpO1xuICAgICAgICB9KVxuICAgICk7XG4gIH1cbn1cbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCB1dGlsIGZyb20gJy4uLy4uL29ucy91dGlsJztcbmltcG9ydCBCYXNlRWxlbWVudCBmcm9tICcuL2Jhc2UtZWxlbWVudCc7XG5pbXBvcnQgTW9kaWZpZXJVdGlsIGZyb20gJy4uLy4uL29ucy9pbnRlcm5hbC9tb2RpZmllci11dGlsJztcbmltcG9ydCBBbmltYXRvckZhY3RvcnkgZnJvbSAnLi4vLi4vb25zL2ludGVybmFsL2FuaW1hdG9yLWZhY3RvcnknO1xuaW1wb3J0IERvb3JMb2NrIGZyb20gJy4uLy4uL29ucy9kb29ybG9jayc7XG5pbXBvcnQgZGV2aWNlQmFja0J1dHRvbkRpc3BhdGNoZXIgZnJvbSAnLi4vLi4vb25zL2ludGVybmFsL2RldmljZS1iYWNrLWJ1dHRvbi1kaXNwYXRjaGVyJztcbmltcG9ydCBjb250ZW50UmVhZHkgZnJvbSAnLi4vLi4vb25zL2NvbnRlbnQtcmVhZHknO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBCYXNlRGlhbG9nRWxlbWVudCBleHRlbmRzIEJhc2VFbGVtZW50IHtcblxuICBnZXQgX3NjaGVtZSgpIHtcbiAgICB1dGlsLnRocm93TWVtYmVyKCk7XG4gIH1cblxuICBfdXBkYXRlQW5pbWF0b3JGYWN0b3J5KCkge1xuICAgIHV0aWwudGhyb3dNZW1iZXIoKTtcbiAgfVxuXG4gIF90b2dnbGVTdHlsZShzaG91bGRTaG93KSB7XG4gICAgdGhpcy5zdHlsZS5kaXNwbGF5ID0gc2hvdWxkU2hvdyA/ICdibG9jaycgOiAnbm9uZSc7XG4gIH1cblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgaWYgKHRoaXMuY29uc3RydWN0b3IgPT09IEJhc2VEaWFsb2dFbGVtZW50KSB7XG4gICAgICB1dGlsLnRocm93QWJzdHJhY3QoKTtcbiAgICB9XG5cbiAgICB0aGlzLl92aXNpYmxlID0gZmFsc2U7XG4gICAgdGhpcy5fZG9vckxvY2sgPSBuZXcgRG9vckxvY2soKTtcbiAgICB0aGlzLl9jYW5jZWwgPSB0aGlzLl9jYW5jZWwuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9zZWxmQ2FtZWxOYW1lID0gdXRpbC5jYW1lbGl6ZSh0aGlzLnRhZ05hbWUuc2xpY2UoNCkpO1xuICAgIHRoaXMuX2RlZmF1bHREQkIgPSBlID0+IHRoaXMuY2FuY2VsYWJsZSA/IHRoaXMuX2NhbmNlbCgpIDogZS5jYWxsUGFyZW50SGFuZGxlcigpO1xuICAgIHRoaXMuX2FuaW1hdG9yRmFjdG9yeSA9IHRoaXMuX3VwZGF0ZUFuaW1hdG9yRmFjdG9yeSgpO1xuICB9XG5cbiAgZ2V0IG9uRGV2aWNlQmFja0J1dHRvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fYmFja0J1dHRvbkhhbmRsZXI7XG4gIH1cblxuICBzZXQgb25EZXZpY2VCYWNrQnV0dG9uKGNhbGxiYWNrKSB7XG4gICAgaWYgKHRoaXMuX2JhY2tCdXR0b25IYW5kbGVyKSB7XG4gICAgICB0aGlzLl9iYWNrQnV0dG9uSGFuZGxlci5kZXN0cm95KCk7XG4gICAgfVxuXG4gICAgdGhpcy5fYmFja0J1dHRvbkhhbmRsZXIgPSBkZXZpY2VCYWNrQnV0dG9uRGlzcGF0Y2hlci5jcmVhdGVIYW5kbGVyKHRoaXMsIGNhbGxiYWNrKTtcbiAgfVxuXG4gIF9jYW5jZWwoKSB7XG4gICAgaWYgKHRoaXMuY2FuY2VsYWJsZSAmJiAhdGhpcy5fcnVubmluZykge1xuICAgICAgdGhpcy5fcnVubmluZyA9IHRydWU7XG4gICAgICB0aGlzLmhpZGUoKVxuICAgICAgICAudGhlbihcbiAgICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9ydW5uaW5nID0gZmFsc2U7XG4gICAgICAgICAgICB1dGlsLnRyaWdnZXJFbGVtZW50RXZlbnQodGhpcywgJ2RpYWxvZy1jYW5jZWwnKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgICgpID0+IHRoaXMuX3J1bm5pbmcgPSBmYWxzZVxuICAgICAgICApO1xuICAgIH1cbiAgfVxuXG4gIHNob3coLi4uYXJncykge1xuICAgIHJldHVybiB0aGlzLl9zZXRWaXNpYmxlKHRydWUsIC4uLmFyZ3MpO1xuICB9XG5cbiAgaGlkZSguLi5hcmdzKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NldFZpc2libGUoZmFsc2UsIC4uLmFyZ3MpO1xuICB9XG5cbiAgdG9nZ2xlKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gdGhpcy5fc2V0VmlzaWJsZSghdGhpcy52aXNpYmxlLCAuLi5hcmdzKTtcbiAgfVxuXG4gIF9zZXRWaXNpYmxlKHNob3VsZFNob3csIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IGFjdGlvbiA9IHNob3VsZFNob3cgPyAnc2hvdycgOiAnaGlkZSc7XG5cbiAgICBvcHRpb25zID0geyAuLi5vcHRpb25zIH07XG4gICAgb3B0aW9ucy5hbmltYXRpb25PcHRpb25zID0gdXRpbC5leHRlbmQoXG4gICAgICBvcHRpb25zLmFuaW1hdGlvbk9wdGlvbnMgfHwge30sXG4gICAgICBBbmltYXRvckZhY3RvcnkucGFyc2VBbmltYXRpb25PcHRpb25zU3RyaW5nKHRoaXMuZ2V0QXR0cmlidXRlKCdhbmltYXRpb24tb3B0aW9ucycpKVxuICAgICk7XG5cbiAgICBsZXQgY2FuY2VsZWQgPSBmYWxzZTtcbiAgICB1dGlsLnRyaWdnZXJFbGVtZW50RXZlbnQodGhpcywgYHByZSR7YWN0aW9ufWAsIHsgLy8gcHJlc2hvdyBwcmVoaWRlXG4gICAgICBbdGhpcy5fc2VsZkNhbWVsTmFtZV06IHRoaXMsXG4gICAgICBjYW5jZWw6ICgpID0+IGNhbmNlbGVkID0gdHJ1ZVxuICAgIH0pO1xuXG4gICAgaWYgKGNhbmNlbGVkKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoYENhbmNlbGVkIGluIHByZSR7YWN0aW9ufSBldmVudC5gKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICB0aGlzLl9kb29yTG9jay53YWl0VW5sb2NrKCgpID0+IHtcbiAgICAgICAgY29uc3QgdW5sb2NrID0gdGhpcy5fZG9vckxvY2subG9jaygpO1xuICAgICAgICBjb25zdCBhbmltYXRvciA9IHRoaXMuX2FuaW1hdG9yRmFjdG9yeS5uZXdBbmltYXRvcihvcHRpb25zKTtcblxuICAgICAgICBzaG91bGRTaG93ICYmIHRoaXMuX3RvZ2dsZVN0eWxlKHRydWUsIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLl92aXNpYmxlID0gc2hvdWxkU2hvdztcbiAgICAgICAgdXRpbC5pb3NQYWdlU2Nyb2xsRml4KHNob3VsZFNob3cpO1xuXG4gICAgICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB7XG4gICAgICAgICAgYW5pbWF0b3JbYWN0aW9uXSh0aGlzLCAoKSA9PiB7XG4gICAgICAgICAgICAhc2hvdWxkU2hvdyAmJiB0aGlzLl90b2dnbGVTdHlsZShmYWxzZSwgb3B0aW9ucyk7XG5cbiAgICAgICAgICAgIHVubG9jaygpO1xuXG4gICAgICAgICAgICB1dGlsLnByb3BhZ2F0ZUFjdGlvbih0aGlzLCAnXycgKyBhY3Rpb24pO1xuICAgICAgICAgICAgdXRpbC50cmlnZ2VyRWxlbWVudEV2ZW50KHRoaXMsICdwb3N0JyArIGFjdGlvbiwge1t0aGlzLl9zZWxmQ2FtZWxOYW1lXTogdGhpc30pOyAvLyBwb3N0c2hvdyBwb3N0aGlkZVxuXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5jYWxsYmFjayBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XG4gICAgICAgICAgICAgIG9wdGlvbnMuY2FsbGJhY2sodGhpcyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJlc29sdmUodGhpcyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIGdldCB2aXNpYmxlKCkge1xuICAgIHJldHVybiB0aGlzLl92aXNpYmxlO1xuICB9XG5cbiAgc2V0IGRpc2FibGVkKHZhbHVlKSB7XG4gICAgcmV0dXJuIHV0aWwudG9nZ2xlQXR0cmlidXRlKHRoaXMsICdkaXNhYmxlZCcsIHZhbHVlKTtcbiAgfVxuXG4gIGdldCBkaXNhYmxlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5oYXNBdHRyaWJ1dGUoJ2Rpc2FibGVkJyk7XG4gIH1cblxuICBzZXQgY2FuY2VsYWJsZSh2YWx1ZSkge1xuICAgIHJldHVybiB1dGlsLnRvZ2dsZUF0dHJpYnV0ZSh0aGlzLCAnY2FuY2VsYWJsZScsIHZhbHVlKTtcbiAgfVxuXG4gIGdldCBjYW5jZWxhYmxlKCkge1xuICAgIHJldHVybiB0aGlzLmhhc0F0dHJpYnV0ZSgnY2FuY2VsYWJsZScpO1xuICB9XG5cbiAgX3VwZGF0ZU1hc2soKSB7XG4gICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHtcbiAgICAgIGlmICh0aGlzLl9tYXNrICYmIHRoaXMuZ2V0QXR0cmlidXRlKCdtYXNrLWNvbG9yJykpIHtcbiAgICAgICAgdGhpcy5fbWFzay5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSB0aGlzLmdldEF0dHJpYnV0ZSgnbWFzay1jb2xvcicpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgaWYgKHR5cGVvZiB0aGlzLl9kZWZhdWx0REJCID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aGlzLm9uRGV2aWNlQmFja0J1dHRvbiA9IHRoaXMuX2RlZmF1bHREQkIuYmluZCh0aGlzKTtcbiAgICB9XG5cbiAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4ge1xuICAgICAgaWYgKHRoaXMuX21hc2spIHtcbiAgICAgICAgdGhpcy5fbWFzay5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuX2NhbmNlbCwgZmFsc2UpO1xuICAgICAgICB1dGlsLmlvc01hc2tTY3JvbGxGaXgodGhpcy5fbWFzaywgdHJ1ZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBkaXNjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICBpZiAodGhpcy5fYmFja0J1dHRvbkhhbmRsZXIpIHtcbiAgICAgIHRoaXMuX2JhY2tCdXR0b25IYW5kbGVyLmRlc3Ryb3koKTtcbiAgICAgIHRoaXMuX2JhY2tCdXR0b25IYW5kbGVyID0gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fbWFzaykge1xuICAgICAgdGhpcy5fbWFzay5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuX2NhbmNlbCwgZmFsc2UpO1xuICAgICAgdXRpbC5pb3NNYXNrU2Nyb2xsRml4KHRoaXMuX21hc2ssIGZhbHNlKTtcbiAgICB9XG4gIH1cblxuICBzdGF0aWMgZ2V0IG9ic2VydmVkQXR0cmlidXRlcygpIHtcbiAgICByZXR1cm4gWydtb2RpZmllcicsICdhbmltYXRpb24nLCAnbWFzay1jb2xvciddO1xuICB9XG5cbiAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIGxhc3QsIGN1cnJlbnQpIHtcbiAgICBzd2l0Y2ggKG5hbWUpIHtcbiAgICAgIGNhc2UgJ21vZGlmaWVyJzpcbiAgICAgICAgTW9kaWZpZXJVdGlsLm9uTW9kaWZpZXJDaGFuZ2VkKGxhc3QsIGN1cnJlbnQsIHRoaXMsIHRoaXMuX3NjaGVtZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnYW5pbWF0aW9uJzpcbiAgICAgICAgdGhpcy5fYW5pbWF0b3JGYWN0b3J5ID0gdGhpcy5fdXBkYXRlQW5pbWF0b3JGYWN0b3J5KCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnbWFzay1jb2xvcic6XG4gICAgICAgIHRoaXMuX3VwZGF0ZU1hc2soKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgc3RhdGljIGdldCBldmVudHMoKSB7XG4gICAgcmV0dXJuIFsncHJlc2hvdycsICdwb3N0c2hvdycsICdwcmVoaWRlJywgJ3Bvc3RoaWRlJywgJ2RpYWxvZy1jYW5jZWwnXTtcbiAgfVxufVxuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IG9uc0VsZW1lbnRzIGZyb20gJy4uLy4uL29ucy9lbGVtZW50cyc7XG5pbXBvcnQgdXRpbCBmcm9tICcuLi8uLi9vbnMvdXRpbCc7XG5pbXBvcnQgYXV0b1N0eWxlIGZyb20gJy4uLy4uL29ucy9hdXRvc3R5bGUnO1xuaW1wb3J0IE1vZGlmaWVyVXRpbCBmcm9tICcuLi8uLi9vbnMvaW50ZXJuYWwvbW9kaWZpZXItdXRpbCc7XG5pbXBvcnQgQW5pbWF0b3JGYWN0b3J5IGZyb20gJy4uLy4uL29ucy9pbnRlcm5hbC9hbmltYXRvci1mYWN0b3J5JztcbmltcG9ydCB7IEFjdGlvblNoZWV0QW5pbWF0b3IsIElPU0FjdGlvblNoZWV0QW5pbWF0b3IsIE1EQWN0aW9uU2hlZXRBbmltYXRvciB9IGZyb20gJy4vYW5pbWF0b3InO1xuaW1wb3J0IHBsYXRmb3JtIGZyb20gJy4uLy4uL29ucy9wbGF0Zm9ybSc7XG5pbXBvcnQgQmFzZURpYWxvZ0VsZW1lbnQgZnJvbSAnLi4vYmFzZS9iYXNlLWRpYWxvZyc7XG5pbXBvcnQgY29udGVudFJlYWR5IGZyb20gJy4uLy4uL29ucy9jb250ZW50LXJlYWR5JztcblxuY29uc3Qgc2NoZW1lID0ge1xuICAnLmFjdGlvbi1zaGVldCc6ICdhY3Rpb24tc2hlZXQtLSonLFxuICAnLmFjdGlvbi1zaGVldC1tYXNrJzogJ2FjdGlvbi1zaGVldC1tYXNrLS0qJyxcbiAgJy5hY3Rpb24tc2hlZXQtdGl0bGUnOiAnYWN0aW9uLXNoZWV0LXRpdGxlLS0qJ1xufTtcblxuY29uc3QgX2FuaW1hdG9yRGljdCA9IHtcbiAgJ2RlZmF1bHQnOiAoKSA9PiBwbGF0Zm9ybS5pc0FuZHJvaWQoKSA/IE1EQWN0aW9uU2hlZXRBbmltYXRvciA6IElPU0FjdGlvblNoZWV0QW5pbWF0b3IsXG4gICdub25lJzogQWN0aW9uU2hlZXRBbmltYXRvclxufTtcblxuLyoqXG4gKiBAZWxlbWVudCBvbnMtYWN0aW9uLXNoZWV0XG4gKiBAY2F0ZWdvcnkgZGlhbG9nXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXVxuICogICAgIEFjdGlvbi9ib3R0b20gc2hlZXQgdGhhdCBpcyBkaXNwbGF5ZWQgb24gdG9wIG9mIGN1cnJlbnQgc2NyZWVuLlxuICpcbiAqICAgICBUaGlzIGVsZW1lbnQgY2FuIGVpdGhlciBiZSBhdHRhY2hlZCBkaXJlY3RseSB0byB0aGUgYDxib2R5PmAgb3IgZHluYW1pY2FsbHkgY3JlYXRlZCBmcm9tIGEgdGVtcGxhdGUgdXNpbmcgdGhlIGBvbnMuY3JlYXRlRWxlbWVudCh0ZW1wbGF0ZSwgeyBhcHBlbmQ6IHRydWUgfSlgIHV0aWxpdHkgZnVuY3Rpb24gYW5kIHRoZSBgPHRlbXBsYXRlPmAgdGFnLlxuICpcbiAqICAgICBUaGUgYWN0aW9uIHNoZWV0IGlzIHVzZWZ1bCBmb3IgZGlzcGxheWluZyBhIGxpc3Qgb2Ygb3B0aW9ucyBhbmQgYXNraW5nIHRoZSB1c2VyIHRvIG1ha2UgYSBkZWNpc2lvbi4gQSBgb25zLWFjdGlvbi1zaGVldC1idXR0b25gIGlzIHByb3ZpZGVkIGZvciB0aGlzIHB1cnBvc2UsIGFsdGhvdWdoIGl0IGNhbiBjb250YWluIGFueSB0eXBlIG9mIGNvbnRlbnQuXG4gKlxuICogICAgIEl0IHdpbGwgYXV0b21hdGljYWxseSBiZSBkaXNwbGF5ZWQgYXMgTWF0ZXJpYWwgRGVzaWduIChib3R0b20gc2hlZXQpIHdoZW4gcnVubmluZyBvbiBhbiBBbmRyb2lkIGRldmljZS5cbiAqICAgWy9lbl1cbiAqICAgW2phXVxuICogICAgIOOCouOCr+OCt+ODp+ODs+OCt+ODvOODiOOAgeOCguOBl+OBj+OBr+ODnOODiOODoOOCt+ODvOODiOOCkuePvuWcqOOBruOCueOCr+ODquODvOODs+S4iuOBq+ihqOekuuOBl+OBvuOBmeOAglxuICpcbiAqICAgICDjgZPjga7opoHntKDjga/jgIFgPGJvZHk+YOimgee0oOOBq+ebtOaOpeOCouOCv+ODg+ODgeOBleOCjOOCi+OBi+OAgeOCguOBl+OBj+OBr2BvbnMuY3JlYXRlRWxlbWVudCh0ZW1wbGF0ZSwgeyBhcHBlbmQ6IHRydWUgfSlg44GoYDx0ZW1wbGF0ZT5g44K/44Kw44KS5L2/44Gj44Gm44OG44Oz44OX44Os44O844OI44GL44KJ5YuV55qE44Gr55Sf5oiQ44GV44KM44G+44GZ44CCXG4gKlxuICogICAgIOOCouOCr+OCt+ODp+ODs+OCt+ODvOODiOOBr+OAgemBuOaKnuiCouOBruODquOCueODiOOCkuihqOekuuOBl+OBpuODpuODvOOCtuODvOOBq+Wwi+OBreOCi+OBruOBq+S+v+WIqeOBp+OBmeOAgmBvbnMtYWN0aW9uLXNoZWV0LWJ1dHRvbmDjga/jgIHjgZPjga7opoHntKDjga7kuK3jgavnva7jgY/jgZ/jgoHjgavmj5DkvpvjgZXjgozjgabjgYTjgb7jgZnjgYzjgIHjgZ3jgozku6XlpJbjgavjgoLku5bjga7jganjga7jgojjgYbjgaropoHntKDjgpLlkKvjgoDjgZPjgajjgYzjgafjgY3jgb7jgZnjgIJcbiAqXG4gKiAgICAgQW5kcm9pZOODh+ODkOOCpOOCueOBp+Wun+ihjOOBleOCjOOCi+OBqOOBjeOBq+OBr+OAgeiHquWLleeahOOBq+ODnuODhuODquOCouODq+ODh+OCtuOCpOODsyjjg5zjg4jjg6Djgrfjg7zjg4gp44Go44GX44Gm6KGo56S644GV44KM44G+44GZ44CCXG4gKiAgIFsvamFdXG4gKiBAbW9kaWZpZXIgbWF0ZXJpYWxcbiAqICAgW2VuXURpc3BsYXkgYSBNYXRlcmlhbCBEZXNpZ24gYm90dG9tIHNoZWV0LlsvZW5dXG4gKiAgIFtqYV3jg57jg4bjg6rjgqLjg6vjg4fjgrbjgqTjg7Pjga7jg5zjg4jjg6Djgrfjg7zjg4jjgpLooajnpLrjgZfjgb7jgZnjgIJbL2phXVxuICogQHR1dG9yaWFsIHZhbmlsbGEvcmVmZXJlbmNlL2FjdGlvbi1zaGVldFxuICogQGd1aWRlIHRoZW1pbmcuaHRtbCNtb2RpZmllcnMgW2VuXU1vcmUgZGV0YWlscyBhYm91dCB0aGUgYG1vZGlmaWVyYCBhdHRyaWJ1dGVbL2VuXVtqYV1tb2RpZmllcuWxnuaAp+OBruS9v+OBhOaWuVsvamFdXG4gKiBAc2VlYWxzbyBvbnMtcG9wb3ZlclxuICogICBbZW5dYDxvbnMtcG9wb3Zlcj5gIGNvbXBvbmVudFsvZW5dXG4gKiAgIFtqYV1vbnMtcG9wb3ZlcuOCs+ODs+ODneODvOODjeODs+ODiFsvamFdXG4gKiBAc2VlYWxzbyBvbnMtbW9kYWxcbiAqICAgW2VuXWA8b25zLW1vZGFsPmAgY29tcG9uZW50Wy9lbl1cbiAqICAgW2phXW9ucy1tb2RhbOOCs+ODs+ODneODvOODjeODs+ODiFsvamFdXG4gKiBAZXhhbXBsZVxuICogPG9ucy1hY3Rpb24tc2hlZXQgaWQ9XCJzaGVldFwiPlxuICogICA8b25zLWFjdGlvbi1zaGVldC1idXR0b24+TGFiZWw8L29ucy1hY3Rpb24tc2hlZXQtYnV0dG9uPlxuICogICA8b25zLWFjdGlvbi1zaGVldC1idXR0b24+TGFiZWw8L29ucy1hY3Rpb24tc2hlZXQtYnV0dG9uPlxuICogPC9vbnMtYWN0aW9uLXNoZWV0PlxuICpcbiAqIDxzY3JpcHQ+XG4gKiAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdzaGVldCcpLnNob3coKTtcbiAqIDwvc2NyaXB0PlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBY3Rpb25TaGVldEVsZW1lbnQgZXh0ZW5kcyBCYXNlRGlhbG9nRWxlbWVudCB7XG5cbiAgLyoqXG4gICAqIEBldmVudCBwcmVzaG93XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBbZW5dRmlyZWQganVzdCBiZWZvcmUgdGhlIGFjdGlvbiBzaGVldCBpcyBkaXNwbGF5ZWQuWy9lbl1cbiAgICogW2phXeODgOOCpOOCouODreOCsOOBjOihqOekuuOBleOCjOOCi+ebtOWJjeOBq+eZuueBq+OBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCBbZW5dRXZlbnQgb2JqZWN0LlsvZW5dXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5hY3Rpb25TaGVldFxuICAgKiAgIFtlbl1Db21wb25lbnQgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCs+ODs+ODneODvOODjeODs+ODiOOBruOCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGV2ZW50LmNhbmNlbFxuICAgKiAgIFtlbl1FeGVjdXRlIHRoaXMgZnVuY3Rpb24gdG8gc3RvcCB0aGUgYWN0aW9uIHNoZWV0IGZyb20gYmVpbmcgc2hvd24uWy9lbl1cbiAgICogICBbamFd44GT44Gu6Zai5pWw44KS5a6f6KGM44GZ44KL44Go44CB44OA44Kk44Ki44Ot44Kw44Gu6KGo56S644GM44Kt44Oj44Oz44K744Or44GV44KM44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBldmVudCBwb3N0c2hvd1xuICAgKiBAZGVzY3JpcHRpb25cbiAgICogW2VuXUZpcmVkIGp1c3QgYWZ0ZXIgdGhlIGFjdGlvbiBzaGVldCBpcyBkaXNwbGF5ZWQuWy9lbl1cbiAgICogW2phXeODgOOCpOOCouODreOCsOOBjOihqOekuuOBleOCjOOBn+ebtOW+jOOBq+eZuueBq+OBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCBbZW5dRXZlbnQgb2JqZWN0LlsvZW5dXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5hY3Rpb25TaGVldFxuICAgKiAgIFtlbl1Db21wb25lbnQgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCs+ODs+ODneODvOODjeODs+ODiOOBruOCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAZXZlbnQgcHJlaGlkZVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogW2VuXUZpcmVkIGp1c3QgYmVmb3JlIHRoZSBhY3Rpb24gc2hlZXQgaXMgaGlkZGVuLlsvZW5dXG4gICAqIFtqYV3jg4DjgqTjgqLjg63jgrDjgYzpmqDjgozjgovnm7TliY3jgavnmbrngavjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgW2VuXUV2ZW50IG9iamVjdC5bL2VuXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQuYWN0aW9uU2hlZXRcbiAgICogICBbZW5dQ29tcG9uZW50IG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgrPjg7Pjg53jg7zjg43jg7Pjg4jjga7jgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBldmVudC5jYW5jZWxcbiAgICogICBbZW5dRXhlY3V0ZSB0aGlzIGZ1bmN0aW9uIHRvIHN0b3AgdGhlIGFjdGlvbiBzaGVldCBmcm9tIGJlaW5nIGhpZGRlbi5bL2VuXVxuICAgKiAgIFtqYV3jgZPjga7plqLmlbDjgpLlrp/ooYzjgZnjgovjgajjgIHjg4DjgqTjgqLjg63jgrDjga7pnZ7ooajnpLrjgYzjgq3jg6Pjg7Pjgrvjg6vjgZXjgozjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGV2ZW50IHBvc3RoaWRlXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBbZW5dRmlyZWQganVzdCBhZnRlciB0aGUgYWN0aW9uIHNoZWV0IGlzIGhpZGRlbi5bL2VuXVxuICAgKiBbamFd44OA44Kk44Ki44Ot44Kw44GM6Zqg44KM44Gf5b6M44Gr55m654Gr44GX44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IFtlbl1FdmVudCBvYmplY3QuWy9lbl1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50LmFjdGlvblNoZWV0XG4gICAqICAgW2VuXUNvbXBvbmVudCBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Kz44Oz44Od44O844ON44Oz44OI44Gu44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgdGl0bGVcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dT3B0aW9uYWwgdGl0bGUgb2YgdGhlIGFjdGlvbiBzaGVldC4gQSBuZXcgZWxlbWVudCB3aWxsIGJlIGNyZWF0ZWQgY29udGFpbmluZyB0aGlzIHN0cmluZy5bL2VuXVxuICAgKiAgW2phXeOCouOCr+OCt+ODp+ODs+OCt+ODvOODiOOBruOCv+OCpOODiOODq+OCkuaMh+WumuOBl+OBvuOBmeOAguOBk+OBk+OBp+aMh+WumuOBl+OBn+aWh+Wtl+WIl+OCkuWQq+OCgOaWsOOBl+OBhOimgee0oOOBjOS9nOaIkOOBleOCjOOBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIG1vZGlmaWVyXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXVRoZSBhcHBlYXJhbmNlIG9mIHRoZSBhY3Rpb24gc2hlZXQuWy9lbl1cbiAgICogIFtqYV3jg4DjgqTjgqLjg63jgrDjga7ooajnj77jgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBjYW5jZWxhYmxlXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXUlmIHRoaXMgYXR0cmlidXRlIGlzIHNldCB0aGUgYWN0aW9uIHNoZWV0IGNhbiBiZSBjbG9zZWQgYnkgdGFwcGluZyB0aGUgYmFja2dyb3VuZCBvciBieSBwcmVzc2luZyB0aGUgYmFjayBidXR0b24gb24gQW5kcm9pZCBkZXZpY2VzLlsvZW5dXG4gICAqICBbamFd44GT44Gu5bGe5oCn44GM6Kit5a6a44GV44KM44KL44Go44CB44Ki44Kv44K344On44Oz44K344O844OI44Gu6IOM5pmv44KEQW5kcm9pZOODh+ODkOOCpOOCueOBruODkOODg+OCr+ODnOOCv+ODs+OCkuaOqOOBmeOBk+OBqOOBp+OCouOCr+OCt+ODp+ODs+OCt+ODvOODiOOBjOmWieOBmOOCi+OCiOOBhuOBq+OBquOCiuOBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGRpc2FibGVkXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXUlmIHRoaXMgYXR0cmlidXRlIGlzIHNldCB0aGUgYWN0aW9uIHNoZWV0IGlzIGRpc2FibGVkLlsvZW5dXG4gICAqICBbamFd44GT44Gu5bGe5oCn44GM44GC44KL5pmC44CB44OA44Kk44Ki44Ot44Kw44GvZGlzYWJsZWTnirbmhYvjgavjgarjgorjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBhbmltYXRpb25cbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlZmF1bHQgZGVmYXVsdFxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFtlbl1UaGUgYW5pbWF0aW9uIHVzZWQgd2hlbiBzaG93aW5nIGFuZCBoaWRpbmcgdGhlIGFjdGlvbiBzaGVldC4gQ2FuIGJlIGVpdGhlciBgXCJub25lXCJgIG9yIGBcImRlZmF1bHRcImAuWy9lbl1cbiAgICogIFtqYV3jg4DjgqTjgqLjg63jgrDjgpLooajnpLrjgZnjgovpmpvjga7jgqLjg4vjg6Hjg7zjgrfjg6fjg7PlkI3jgpLmjIflrprjgZfjgb7jgZnjgIJcIm5vbmVcIuOCguOBl+OBj+OBr1wiZGVmYXVsdFwi44KS5oyH5a6a44Gn44GN44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgYW5pbWF0aW9uLW9wdGlvbnNcbiAgICogQHR5cGUge0V4cHJlc3Npb259XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXVNwZWNpZnkgdGhlIGFuaW1hdGlvbidzIGR1cmF0aW9uLCB0aW1pbmcgYW5kIGRlbGF5IHdpdGggYW4gb2JqZWN0IGxpdGVyYWwuIEUuZy4gYHtkdXJhdGlvbjogMC4yLCBkZWxheTogMSwgdGltaW5nOiAnZWFzZS1pbid9YC5bL2VuXVxuICAgKiAgW2phXeOCouODi+ODoeODvOOCt+ODp+ODs+aZguOBrmR1cmF0aW9uLCB0aW1pbmcsIGRlbGF544KS44Kq44OW44K444Kn44Kv44OI44Oq44OG44Op44Or44Gn5oyH5a6a44GX44G+44GZ44CCZS5nLiBge2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAxLCB0aW1pbmc6ICdlYXNlLWluJ31gWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgbWFzay1jb2xvclxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVmYXVsdCByZ2JhKDAsIDAsIDAsIDAuMilcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dQ29sb3Igb2YgdGhlIGJhY2tncm91bmQgbWFzay4gRGVmYXVsdCBpcyBgXCJyZ2JhKDAsIDAsIDAsIDAuMilcImAuWy9lbl1cbiAgICogIFtqYV3og4zmma/jga7jg57jgrnjgq/jga7oibLjgpLmjIflrprjgZfjgb7jgZnjgIJcInJnYmEoMCwgMCwgMCwgMC4yKVwi44GM44OH44OV44Kp44Or44OI5YCk44Gn44GZ44CCWy9qYV1cbiAgICovXG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB0aGlzLl9jb21waWxlKCkpO1xuICB9XG5cbiAgZ2V0IF9zY2hlbWUoKSB7XG4gICAgcmV0dXJuIHNjaGVtZTtcbiAgfVxuXG4gIGdldCBfbWFzaygpIHtcbiAgICByZXR1cm4gdXRpbC5maW5kQ2hpbGQodGhpcywgJy5hY3Rpb24tc2hlZXQtbWFzaycpO1xuICB9XG5cbiAgZ2V0IF9zaGVldCgpIHtcbiAgICByZXR1cm4gdXRpbC5maW5kQ2hpbGQodGhpcywgJy5hY3Rpb24tc2hlZXQnKTtcbiAgfVxuXG4gIGdldCBfdGl0bGUoKSB7XG4gICAgcmV0dXJuIHRoaXMucXVlcnlTZWxlY3RvcignLmFjdGlvbi1zaGVldC10aXRsZScpO1xuICB9XG5cbiAgX3VwZGF0ZUFuaW1hdG9yRmFjdG9yeSgpIHtcbiAgICByZXR1cm4gbmV3IEFuaW1hdG9yRmFjdG9yeSh7XG4gICAgICBhbmltYXRvcnM6IF9hbmltYXRvckRpY3QsXG4gICAgICBiYXNlQ2xhc3M6IEFjdGlvblNoZWV0QW5pbWF0b3IsXG4gICAgICBiYXNlQ2xhc3NOYW1lOiAnQWN0aW9uU2hlZXRBbmltYXRvcicsXG4gICAgICBkZWZhdWx0QW5pbWF0aW9uOiB0aGlzLmdldEF0dHJpYnV0ZSgnYW5pbWF0aW9uJylcbiAgICB9KTtcbiAgfVxuXG4gIF9jb21waWxlKCkge1xuICAgIGF1dG9TdHlsZS5wcmVwYXJlKHRoaXMpO1xuXG4gICAgdGhpcy5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgIHRoaXMuc3R5bGUuekluZGV4ID0gMTAwMDE7XG5cbiAgICAvKiBFeHBlY3RlZCByZXN1bHQ6XG4gICAgICogICA8b25zLWFjdGlvbi1zaGVldD5cbiAgICAgKiAgICAgPGRpdiBjbGFzcz1cImFjdGlvbi1zaGVldC1tYXNrXCI+PC9kaXY+XG4gICAgICogICAgIDxkaXYgY2xhc3M9XCJhY3Rpb24tc2hlZXRcIj5cbiAgICAgKiAgICAgICA8ZGl2IGNsYXNzPVwiYWN0aW9uLXNoZWV0LXRpdGxlPjwvZGl2PlxuICAgICAqICAgICAgIC4uLlxuICAgICAqICAgICA8L2Rpdj5cbiAgICAgKiAgIDwvb25zLWFjdGlvbi1zaGVldD5cbiAgICAgKi9cblxuICAgIGlmICghdGhpcy5fc2hlZXQpIHtcbiAgICAgIGNvbnN0IHNoZWV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICBzaGVldC5jbGFzc0xpc3QuYWRkKCdhY3Rpb24tc2hlZXQnKTtcblxuICAgICAgd2hpbGUgKHRoaXMuZmlyc3RDaGlsZCkge1xuICAgICAgICBzaGVldC5hcHBlbmRDaGlsZCh0aGlzLmZpcnN0Q2hpbGQpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmFwcGVuZENoaWxkKHNoZWV0KTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuX3RpdGxlICYmIHRoaXMuaGFzQXR0cmlidXRlKCd0aXRsZScpKSB7XG4gICAgICBjb25zdCB0aXRsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgdGl0bGUuaW5uZXJIVE1MID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ3RpdGxlJyk7XG4gICAgICB0aXRsZS5jbGFzc0xpc3QuYWRkKCdhY3Rpb24tc2hlZXQtdGl0bGUnKTtcbiAgICAgIHRoaXMuX3NoZWV0Lmluc2VydEJlZm9yZSh0aXRsZSwgdGhpcy5fc2hlZXQuZmlyc3RDaGlsZCk7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLl9tYXNrKSB7XG4gICAgICBjb25zdCBtYXNrID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICBtYXNrLmNsYXNzTGlzdC5hZGQoJ2FjdGlvbi1zaGVldC1tYXNrJyk7XG4gICAgICB0aGlzLmluc2VydEJlZm9yZShtYXNrLCB0aGlzLmZpcnN0Q2hpbGQpO1xuICAgIH1cblxuICAgIHRoaXMuX3NoZWV0LnN0eWxlLnpJbmRleCA9IDIwMDAxO1xuICAgIHRoaXMuX21hc2suc3R5bGUuekluZGV4ID0gMjAwMDA7XG5cbiAgICBNb2RpZmllclV0aWwuaW5pdE1vZGlmaWVyKHRoaXMsIHRoaXMuX3NjaGVtZSk7XG4gIH1cblxuICBfdXBkYXRlVGl0bGUoKSB7XG4gICAgaWYgKHRoaXMuX3RpdGxlKSB7XG4gICAgICB0aGlzLl90aXRsZS5pbm5lckhUTUwgPSB0aGlzLmdldEF0dHJpYnV0ZSgndGl0bGUnKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IG9uRGV2aWNlQmFja0J1dHRvblxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dQmFjay1idXR0b24gaGFuZGxlci5bL2VuXVxuICAgKiAgIFtqYV3jg5Djg4Pjgq/jg5zjgr/jg7Pjg4/jg7Pjg4njg6njgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQG1ldGhvZCBzaG93XG4gICAqIEBzaWduYXR1cmUgc2hvdyhbb3B0aW9uc10pXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogICBbZW5dUGFyYW1ldGVyIG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgqrjg5fjgrfjg6fjg7PjgpLmjIflrprjgZnjgovjgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuYW5pbWF0aW9uXVxuICAgKiAgIFtlbl1BbmltYXRpb24gbmFtZS4gQXZhaWxhYmxlIGFuaW1hdGlvbnMgYXJlIGBcIm5vbmVcImAgYW5kIGBcInNsaWRlXCJgLlsvZW5dXG4gICAqICAgW2phXeOCouODi+ODoeODvOOCt+ODp+ODs+WQjeOCkuaMh+WumuOBl+OBvuOBmeOAglwibm9uZVwiLCBcInNsaWRlXCLjga7jgYTjgZrjgozjgYvjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuYW5pbWF0aW9uT3B0aW9uc11cbiAgICogICBbZW5dU3BlY2lmeSB0aGUgYW5pbWF0aW9uJ3MgZHVyYXRpb24sIGRlbGF5IGFuZCB0aW1pbmcuIEUuZy4gYHtkdXJhdGlvbjogMC4yLCBkZWxheTogMC40LCB0aW1pbmc6ICdlYXNlLWluJ31gLlsvZW5dXG4gICAqICAgW2phXeOCouODi+ODoeODvOOCt+ODp+ODs+aZguOBrmR1cmF0aW9uLCBkZWxheSwgdGltaW5n44KS5oyH5a6a44GX44G+44GZ44CCZS5nLiBge2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAwLjQsIHRpbWluZzogJ2Vhc2UtaW4nfWAgWy9qYV1cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuY2FsbGJhY2tdXG4gICAqICAgW2VuXVRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIGFmdGVyIHRoZSBhY3Rpb24gc2hlZXQgaGFzIGJlZW4gcmV2ZWFsZWQuWy9lbl1cbiAgICogICBbamFd44OA44Kk44Ki44Ot44Kw44GM6KGo56S644GV44KM57WC44KP44Gj44Gf5b6M44Gr5ZG844Gz5Ye644GV44KM44KL6Zai5pWw44Kq44OW44K444Kn44Kv44OI44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dU2hvdyB0aGUgYWN0aW9uIHNoZWV0LlsvZW5dXG4gICAqICBbamFd44OA44Kk44Ki44Ot44Kw44KS6ZaL44GN44G+44GZ44CCWy9qYV1cbiAgICogQHJldHVybiB7UHJvbWlzZX0gUmVzb2x2ZXMgdG8gdGhlIGRpc3BsYXllZCBlbGVtZW50LlxuICAgKi9cblxuICAvKipcbiAgICogQG1ldGhvZCBoaWRlXG4gICAqIEBzaWduYXR1cmUgaGlkZShbb3B0aW9uc10pXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogICBbZW5dUGFyYW1ldGVyIG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgqrjg5fjgrfjg6fjg7PjgpLmjIflrprjgZnjgovjgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuYW5pbWF0aW9uXVxuICAgKiAgIFtlbl1BbmltYXRpb24gbmFtZS4gQXZhaWxhYmxlIGFuaW1hdGlvbnMgYXJlIGBcIm5vbmVcImAgYW5kIGBcInNsaWRlXCJgLlsvZW5dXG4gICAqICAgW2phXeOCouODi+ODoeODvOOCt+ODp+ODs+WQjeOCkuaMh+WumuOBl+OBvuOBmeOAglwibm9uZVwiLCBcInNsaWRlXCLjga7jgYTjgZrjgozjgYvjgpLmjIflrprjgafjgY3jgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuYW5pbWF0aW9uT3B0aW9uc11cbiAgICogICBbZW5dU3BlY2lmeSB0aGUgYW5pbWF0aW9uJ3MgZHVyYXRpb24sIGRlbGF5IGFuZCB0aW1pbmcuIEUuZy4gYHtkdXJhdGlvbjogMC4yLCBkZWxheTogMC40LCB0aW1pbmc6ICdlYXNlLWluJ31gLlsvZW5dXG4gICAqICAgW2phXeOCouODi+ODoeODvOOCt+ODp+ODs+aZguOBrmR1cmF0aW9uLCBkZWxheSwgdGltaW5n44KS5oyH5a6a44GX44G+44GZ44CCZS5nLiBge2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAwLjQsIHRpbWluZzogJ2Vhc2UtaW4nfWBbL2phXVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5jYWxsYmFja11cbiAgICogICBbZW5dVGhpcyBmdW5jdGlvbnMgaXMgY2FsbGVkIGFmdGVyIHRoZSBhY3Rpb24gc2hlZXQgaGFzIGJlZW4gaGlkZGVuLlsvZW5dXG4gICAqICAgW2phXeODgOOCpOOCouODreOCsOOBjOmaoOOCjOOBn+W+jOOBq+WRvOOBs+WHuuOBleOCjOOCi+mWouaVsOOCquODluOCuOOCp+OCr+ODiOOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1IaWRlIHRoZSBhY3Rpb24gc2hlZXQuWy9lbl1cbiAgICogICBbamFd44OA44Kk44Ki44Ot44Kw44KS6ZaJ44GY44G+44GZ44CCWy9qYV1cbiAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICogICBbZW5dUmVzb2x2ZXMgdG8gdGhlIGhpZGRlbiBlbGVtZW50Wy9lbl1cbiAgICogICBbamFd6Zqg44KM44Gf6KaB57Sg44KS6Kej5rG644GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSB2aXNpYmxlXG4gICAqIEByZWFkb25seVxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVdoZXRoZXIgdGhlIGFjdGlvbiBzaGVldCBpcyB2aXNpYmxlIG9yIG5vdC5bL2VuXVxuICAgKiAgIFtqYV3opoHntKDjgYzopovjgYjjgovloLTlkIjjgatgdHJ1ZWDjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQHByb3BlcnR5IGRpc2FibGVkXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dV2hldGhlciB0aGUgYWN0aW9uIHNoZWV0IGlzIGRpc2FibGVkIG9yIG5vdC5bL2VuXVxuICAgKiAgIFtqYV3nhKHlirnljJbjgZXjgozjgabjgYTjgovloLTlkIjjgatgdHJ1ZWDjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQHByb3BlcnR5IGNhbmNlbGFibGVcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1XaGV0aGVyIHRoZSBhY3Rpb24gc2hlZXQgaXMgY2FuY2VsYWJsZSBvciBub3QuIEEgY2FuY2VsYWJsZSBhY3Rpb24gc2hlZXQgY2FuIGJlIGNsb3NlZCBieSB0YXBwaW5nIHRoZSBiYWNrZ3JvdW5kIG9yIGJ5IHByZXNzaW5nIHRoZSBiYWNrIGJ1dHRvbiBvbiBBbmRyb2lkIGRldmljZXMuWy9lbl1cbiAgICogICBbamFd44Ki44Kv44K344On44Oz44K344O844OI44GM44Kt44Oj44Oz44K744Or5Y+v6IO944GL44Gp44GG44GL44KS6Kit5a6a44GX44G+44GZ44CC44Kt44Oj44Oz44K744Or5Y+v6IO944Gq44Ki44Kv44K344On44Oz44K344O844OI44Gv44CB6IOM5pmv44KS44K/44OD44OX44GX44Gf44KKQW5kcm9pZOODh+ODkOOCpOOCueOBruODkOODg+OCr+ODnOOCv+ODs+OCkuaOqOOBmeOBk+OBqOOBp+mWieOBmOOCi+OCiOOBhuOBq+OBquOCiuOBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIHN0YXRpYyBnZXQgb2JzZXJ2ZWRBdHRyaWJ1dGVzKCkge1xuICAgIHJldHVybiBbLi4uc3VwZXIub2JzZXJ2ZWRBdHRyaWJ1dGVzLCAndGl0bGUnXTtcbiAgfVxuXG4gIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBsYXN0LCBjdXJyZW50KSB7XG4gICAgaWYgKG5hbWUgPT09ICd0aXRsZScpIHtcbiAgICAgIHRoaXMuX3VwZGF0ZVRpdGxlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN1cGVyLmF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBsYXN0LCBjdXJyZW50KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAgICogQHBhcmFtIHtBY3Rpb25TaGVldEFuaW1hdG9yfSBBbmltYXRvclxuICAgKi9cbiAgc3RhdGljIHJlZ2lzdGVyQW5pbWF0b3IobmFtZSwgQW5pbWF0b3IpIHtcbiAgICBpZiAoIShBbmltYXRvci5wcm90b3R5cGUgaW5zdGFuY2VvZiBBY3Rpb25TaGVldEFuaW1hdG9yKSkge1xuICAgICAgdXRpbC50aHJvd0FuaW1hdG9yKCdBY3Rpb25TaGVldCcpO1xuICAgIH1cbiAgICBfYW5pbWF0b3JEaWN0W25hbWVdID0gQW5pbWF0b3I7XG4gIH1cblxuICBzdGF0aWMgZ2V0IGFuaW1hdG9ycygpIHtcbiAgICByZXR1cm4gX2FuaW1hdG9yRGljdDtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgQWN0aW9uU2hlZXRBbmltYXRvcigpIHtcbiAgICByZXR1cm4gQWN0aW9uU2hlZXRBbmltYXRvcjtcbiAgfVxufVxuXG5vbnNFbGVtZW50cy5BY3Rpb25TaGVldCA9IEFjdGlvblNoZWV0RWxlbWVudDtcbmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnb25zLWFjdGlvbi1zaGVldCcsIEFjdGlvblNoZWV0RWxlbWVudCk7XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgb25zRWxlbWVudHMgZnJvbSAnLi4vLi4vb25zL2VsZW1lbnRzJztcbmltcG9ydCB1dGlsIGZyb20gJy4uLy4uL29ucy91dGlsJztcbmltcG9ydCBhdXRvU3R5bGUgZnJvbSAnLi4vLi4vb25zL2F1dG9zdHlsZSc7XG5pbXBvcnQgY29udGVudFJlYWR5IGZyb20gJy4uLy4uL29ucy9jb250ZW50LXJlYWR5JztcbmltcG9ydCBNb2RpZmllclV0aWwgZnJvbSAnLi4vLi4vb25zL2ludGVybmFsL21vZGlmaWVyLXV0aWwnO1xuaW1wb3J0IEJhc2VFbGVtZW50IGZyb20gJy4vYmFzZS1lbGVtZW50JztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQmFzZUJ1dHRvbkVsZW1lbnQgZXh0ZW5kcyBCYXNlRWxlbWVudCB7XG5cbiAgZ2V0IF9zY2hlbWUoKSB7XG4gICAgdXRpbC50aHJvd01lbWJlcigpO1xuICB9XG5cbiAgZ2V0IF9kZWZhdWx0Q2xhc3NOYW1lKCkge1xuICAgIHV0aWwudGhyb3dNZW1iZXIoKTtcbiAgfVxuXG4gIGdldCBfcmlwcGxlT3B0KCkge1xuICAgIHJldHVybiBbdGhpc107XG4gIH1cblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgaWYgKHRoaXMuY29uc3RydWN0b3IgPT09IEJhc2VCdXR0b25FbGVtZW50KSB7XG4gICAgICB1dGlsLnRocm93QWJzdHJhY3QoKTtcbiAgICB9XG5cbiAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4gdGhpcy5fY29tcGlsZSgpKTtcbiAgfVxuXG4gIHNldCBkaXNhYmxlZCh2YWx1ZSkge1xuICAgIHJldHVybiB1dGlsLnRvZ2dsZUF0dHJpYnV0ZSh0aGlzLCAnZGlzYWJsZWQnLCB2YWx1ZSk7XG4gIH1cblxuICBnZXQgZGlzYWJsZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaGFzQXR0cmlidXRlKCdkaXNhYmxlZCcpO1xuICB9XG5cbiAgZ2V0IF9pY29uKCkge1xuICAgIHJldHVybiB1dGlsLmZpbmRDaGlsZCh0aGlzLCAnb25zLWljb24nKTtcbiAgfVxuXG4gIF9jb21waWxlKCkge1xuICAgIGF1dG9TdHlsZS5wcmVwYXJlKHRoaXMpO1xuXG4gICAgdGhpcy5jbGFzc0xpc3QuYWRkKHRoaXMuX2RlZmF1bHRDbGFzc05hbWUpO1xuXG4gICAgaWYgKCF0aGlzLl9pY29uICYmIHRoaXMuaGFzQXR0cmlidXRlKCdpY29uJykpIHtcbiAgICAgIHV0aWwuY2hlY2tNaXNzaW5nSW1wb3J0KCdJY29uJyk7XG4gICAgICBjb25zdCBpY29uID0gdXRpbC5jcmVhdGVFbGVtZW50KGA8b25zLWljb24gaWNvbj1cIiR7dGhpcy5nZXRBdHRyaWJ1dGUoJ2ljb24nKX1cIj48L29ucy1pY29uPmApO1xuICAgICAgaWNvbi5jbGFzc0xpc3QuYWRkKHRoaXMuX2RlZmF1bHRDbGFzc05hbWUucmVwbGFjZSgnYnV0dG9uJywgJ2ljb24nKSk7XG4gICAgICB0aGlzLmluc2VydEJlZm9yZShpY29uLCB0aGlzLmZpcnN0Q2hpbGQpO1xuICAgIH1cblxuICAgIHRoaXMuX3VwZGF0ZVJpcHBsZSgpO1xuXG4gICAgTW9kaWZpZXJVdGlsLmluaXRNb2RpZmllcih0aGlzLCB0aGlzLl9zY2hlbWUpO1xuICB9XG5cbiAgX3VwZGF0ZUljb24oKSB7XG4gICAgaWYgKHRoaXMuX2ljb24pIHtcbiAgICAgIHRoaXMuX2ljb24uc2V0QXR0cmlidXRlKCdpY29uJywgdGhpcy5nZXRBdHRyaWJ1dGUoJ2ljb24nKSk7XG4gICAgfVxuICB9XG5cbiAgX3VwZGF0ZVJpcHBsZSgpIHtcbiAgICB0aGlzLl9yaXBwbGVPcHQgJiYgdXRpbC51cGRhdGVSaXBwbGUoLi4udGhpcy5fcmlwcGxlT3B0KTtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgb2JzZXJ2ZWRBdHRyaWJ1dGVzKCkge1xuICAgIHJldHVybiBbJ21vZGlmaWVyJywgJ2NsYXNzJywgJ2ljb24nLCAncmlwcGxlJ107XG4gIH1cblxuICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgbGFzdCwgY3VycmVudCkge1xuICAgIHN3aXRjaCAobmFtZSkge1xuICAgICAgY2FzZSAnY2xhc3MnOlxuICAgICAgICB1dGlsLnJlc3RvcmVDbGFzcyh0aGlzLCB0aGlzLl9kZWZhdWx0Q2xhc3NOYW1lLCB0aGlzLl9zY2hlbWUpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ21vZGlmaWVyJzpcbiAgICAgICAgTW9kaWZpZXJVdGlsLm9uTW9kaWZpZXJDaGFuZ2VkKGxhc3QsIGN1cnJlbnQsIHRoaXMsIHRoaXMuX3NjaGVtZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnaWNvbic6XG4gICAgICAgIHRoaXMuX3VwZGF0ZUljb24oKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdyaXBwbGUnOlxuICAgICAgICB0aGlzLmNsYXNzTGlzdC5jb250YWlucyh0aGlzLl9kZWZhdWx0Q2xhc3NOYW1lKSAmJiB0aGlzLl91cGRhdGVSaXBwbGUoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG59XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgb25zRWxlbWVudHMgZnJvbSAnLi4vb25zL2VsZW1lbnRzJztcbmltcG9ydCBCYXNlQnV0dG9uRWxlbWVudCBmcm9tICcuL2Jhc2UvYmFzZS1idXR0b24nO1xuXG4vKipcbiAqIEBlbGVtZW50IG9ucy1hY3Rpb24tc2hlZXQtYnV0dG9uXG4gKiBAY2F0ZWdvcnkgZGlhbG9nXG4gKiBAbW9kaWZpZXIgZGVzdHJ1Y3RpdmVcbiAqICAgW2VuXVNob3dzIGEgXCJkZXN0cnVjdGl2ZVwiIGJ1dHRvbiAob25seSBmb3IgaU9TKS5bL2VuXVxuICogICBbamFdXCJkZXN0cnVjdGl2ZVwi44Gq44Oc44K/44Oz44KS6KGo56S644GX44G+44GZKGlPU+OBp+OBruOBv+acieWKuSnjgIJbL2phXVxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1Db21wb25lbnQgdGhhdCByZXByZXNlbnQgZWFjaCBidXR0b24gb2YgdGhlIGFjdGlvbiBzaGVldC5bL2VuXVxuICogICBbamFd44Ki44Kv44K344On44Oz44K344O844OI44Gr6KGo56S644GV44KM44KL5ZCE44Oc44K/44Oz44KS6KGo54++44GZ44KL44Kz44Oz44Od44O844ON44Oz44OI44Gn44GZ44CCWy9qYV1cbiAqIEBzZWVhbHNvIG9ucy1hY3Rpb24tc2hlZXRcbiAqICAgW2VuXVRoZSBgPG9ucy1hY3Rpb24tc2hlZXQ+YCBjb21wb25lbnRbL2VuXVxuICogICBbamFdb25zLWFjdGlvbi1zaGVldOOCs+ODs+ODneODvOODjeODs+ODiFsvamFdXG4gKiBAc2VlYWxzbyBvbnMtbGlzdC1pdGVtXG4gKiAgIFtlbl1UaGUgYDxvbnMtbGlzdC1pdGVtPmAgY29tcG9uZW50Wy9lbl1cbiAqICAgW2phXW9ucy1saXN0LWl0ZW3jgrPjg7Pjg53jg7zjg43jg7Pjg4hbL2phXVxuICogQHNlZWFsc28gb25zLWljb25cbiAqICAgW2VuXVRoZSBgPG9ucy1pY29uPmAgY29tcG9uZW50Wy9lbl1cbiAqICAgW2phXW9ucy1pY29u44Kz44Oz44Od44O844ON44Oz44OIWy9qYV1cbiAqIEB0dXRvcmlhbCB2YW5pbGxhL1JlZmVyZW5jZS9hY3Rpb24tc2hlZXRcbiAqIEBndWlkZSBhcHBzaXplLmh0bWwjcmVtb3ZpbmctaWNvbi1wYWNrcyBbZW5dUmVtb3ZpbmcgaWNvbiBwYWNrcy5bL2VuXVtqYV1bL2phXVxuICogQGd1aWRlIGZhcS5odG1sI2hvdy1jYW4taS11c2UtY3VzdG9tLWljb24tcGFja3MgW2VuXUFkZGluZyBjdXN0b20gaWNvbiBwYWNrcy5bL2VuXVtqYV1bL2phXVxuICogQG1vZGlmaWVyIG1hdGVyaWFsXG4gKiAgIFtlbl1EaXNwbGF5IGEgTWF0ZXJpYWwgRGVzaWduIGFjdGlvbiBzaGVldCBidXR0b24uWy9lbl1cbiAqICAgW2phXeODnuODhuODquOCouODq+ODh+OCtuOCpOODs+OBruOCouOCr+OCt+ODp+ODs+OCt+ODvOODiOeUqOOBruODnOOCv+ODs+OCkuihqOekuuOBl+OBvuOBmeOAglsvamFdXG4gKiBAZXhhbXBsZVxuICogPG9ucy1hY3Rpb24tc2hlZXQgaWQ9XCJzaGVldFwiPlxuICogICA8b25zLWFjdGlvbi1zaGVldC1idXR0b24+TGFiZWw8L29ucy1hY3Rpb24tc2hlZXQtYnV0dG9uPlxuICogICA8b25zLWFjdGlvbi1zaGVldC1idXR0b24+TGFiZWw8L29ucy1hY3Rpb24tc2hlZXQtYnV0dG9uPlxuICogPC9vbnMtYWN0aW9uLXNoZWV0PlxuICpcbiAqIDxzY3JpcHQ+XG4gKiAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdzaGVldCcpLnNob3coKTtcbiAqIDwvc2NyaXB0PlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBY3Rpb25TaGVldEJ1dHRvbkVsZW1lbnQgZXh0ZW5kcyBCYXNlQnV0dG9uRWxlbWVudCB7XG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgaWNvblxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFtlbl1DcmVhdGVzIGFuIGBvbnMtaWNvbmAgY29tcG9uZW50IHdpdGggdGhpcyBzdHJpbmcuIE9ubHkgdmlzaWJsZSBvbiBBbmRyb2lkLiBDaGVjayBbU2VlIGFsc29dKCNzZWVhbHNvKSBzZWN0aW9uIGZvciBtb3JlIGluZm9ybWF0aW9uLlsvZW5dXG4gICAqICBbamFdYG9ucy1pY29uYOOCs+ODs+ODneODvOODjeODs+ODiOOCkuaCquaAp+OBl+OBvuOBmeOAgkFuZHJvaWTjgafjga7jgb/ooajnpLrjgZXjgozjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBtb2RpZmllclxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dVGhlIGFwcGVhcmFuY2Ugb2YgdGhlIGFjdGlvbiBzaGVldCBidXR0b24uWy9lbl1cbiAgICogICBbamFd44Ki44Kv44K344On44Oz44K344O844OI44Oc44K/44Oz44Gu6KaL44Gf55uu44KS6Kit5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgZ2V0IF9zY2hlbWUoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICcnOiAnYWN0aW9uLXNoZWV0LWJ1dHRvbi0tKicsXG4gICAgICAnLmFjdGlvbi1zaGVldC1pY29uJzogJ2FjdGlvbi1zaGVldC1pY29uLS0qJ1xuICAgIH07XG4gIH1cblxuICBnZXQgX2RlZmF1bHRDbGFzc05hbWUoKSB7XG4gICAgcmV0dXJuICdhY3Rpb24tc2hlZXQtYnV0dG9uJztcbiAgfVxuXG4gIGdldCBfcmlwcGxlT3B0KCkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbn1cblxub25zRWxlbWVudHMuQWN0aW9uU2hlZXRCdXR0b24gPSBBY3Rpb25TaGVldEJ1dHRvbkVsZW1lbnQ7XG5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ29ucy1hY3Rpb24tc2hlZXQtYnV0dG9uJywgQWN0aW9uU2hlZXRCdXR0b25FbGVtZW50KTtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCBhbmltaXQgZnJvbSAnLi4vLi4vb25zL2FuaW1pdCc7XG5pbXBvcnQgQmFzZUFuaW1hdG9yIGZyb20gJy4uLy4uL29ucy9iYXNlLWFuaW1hdG9yJztcblxuZXhwb3J0IGNsYXNzIEFsZXJ0RGlhbG9nQW5pbWF0b3IgZXh0ZW5kcyBCYXNlQW5pbWF0b3Ige1xuXG4gIGNvbnN0cnVjdG9yKHt0aW1pbmcgPSAnbGluZWFyJywgZGVsYXkgPSAwLCBkdXJhdGlvbiA9IDAuMn0gPSB7fSkge1xuICAgIHN1cGVyKHsgdGltaW5nLCBkZWxheSwgZHVyYXRpb24gfSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZGlhbG9nXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGRvbmVcbiAgICovXG4gIHNob3coZGlhbG9nLCBkb25lKSB7XG4gICAgZG9uZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGRpYWxvZ1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBkb25lXG4gICAqL1xuICBoaWRlKGRpYWxvZywgZG9uZSkge1xuICAgIGRvbmUoKTtcbiAgfVxufVxuXG4vKipcbiAqIEFuZHJvaWQgc3R5bGUgYW5pbWF0b3IgZm9yIGFsZXJ0IGRpYWxvZy5cbiAqL1xuZXhwb3J0IGNsYXNzIEFuZHJvaWRBbGVydERpYWxvZ0FuaW1hdG9yIGV4dGVuZHMgQWxlcnREaWFsb2dBbmltYXRvciB7XG5cbiAgY29uc3RydWN0b3Ioe3RpbWluZyA9ICdjdWJpYy1iZXppZXIoLjEsIC43LCAuNCwgMSknLCBkdXJhdGlvbiA9IDAuMiwgZGVsYXkgPSAwfSA9IHt9KSB7XG4gICAgc3VwZXIoe2R1cmF0aW9uLCB0aW1pbmcsIGRlbGF5fSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IGRpYWxvZ1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKi9cbiAgc2hvdyhkaWFsb2csIGNhbGxiYWNrKSB7XG4gICAgY2FsbGJhY2sgPSBjYWxsYmFjayA/IGNhbGxiYWNrIDogZnVuY3Rpb24oKSB7fTtcblxuICAgIGFuaW1pdC5ydW5BbGwoXG5cbiAgICAgIGFuaW1pdChkaWFsb2cuX21hc2ssIHRoaXMuZGVmKVxuICAgICAgICAuZGVmYXVsdCh7IG9wYWNpdHk6IDAgfSwgeyBvcGFjaXR5OiAxIH0pLFxuXG4gICAgICBhbmltaXQoZGlhbG9nLl9kaWFsb2csIHRoaXMuZGVmKVxuICAgICAgICAuZGVmYXVsdChcbiAgICAgICAgICB7IHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNkKC01MCUsIC01MCUsIDApIHNjYWxlM2QoLjksIC45LCAxKScsIG9wYWNpdHk6IDAgfSxcbiAgICAgICAgICB7IHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNkKC01MCUsIC01MCUsIDApIHNjYWxlM2QoMSwgMSwgMSknLCBvcGFjaXR5OiAxIH1cbiAgICAgICAgKVxuICAgICAgICAucXVldWUoZG9uZSA9PiB7XG4gICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICBkb25lKCk7XG4gICAgICAgIH0pXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gZGlhbG9nXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqL1xuICBoaWRlKGRpYWxvZywgY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjayA9IGNhbGxiYWNrID8gY2FsbGJhY2sgOiBmdW5jdGlvbigpIHt9O1xuXG4gICAgYW5pbWl0LnJ1bkFsbChcblxuICAgICAgYW5pbWl0KGRpYWxvZy5fbWFzaywgdGhpcy5kZWYpXG4gICAgICAgIC5kZWZhdWx0KHsgb3BhY2l0eTogMSB9LCB7IG9wYWNpdHk6IDAgfSksXG5cbiAgICAgIGFuaW1pdChkaWFsb2cuX2RpYWxvZywgdGhpcy5kZWYpXG4gICAgICAgIC5kZWZhdWx0KFxuICAgICAgICAgIHsgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoLTUwJSwgLTUwJSwgMCkgc2NhbGUzZCgxLCAxLCAxKScsIG9wYWNpdHk6IDEgfSxcbiAgICAgICAgICB7IHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNkKC01MCUsIC01MCUsIDApIHNjYWxlM2QoLjksIC45LCAxKScsIG9wYWNpdHk6IDAgfVxuICAgICAgICApXG4gICAgICAgIC5xdWV1ZShkb25lID0+IHtcbiAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgfSlcbiAgICApO1xuICB9XG59XG5cbi8qKlxuICogaU9TIHN0eWxlIGFuaW1hdG9yIGZvciBhbGVydCBkaWFsb2cuXG4gKi9cbmV4cG9ydCBjbGFzcyBJT1NBbGVydERpYWxvZ0FuaW1hdG9yIGV4dGVuZHMgQWxlcnREaWFsb2dBbmltYXRvciB7XG5cbiAgY29uc3RydWN0b3Ioe3RpbWluZyA9ICdjdWJpYy1iZXppZXIoLjEsIC43LCAuNCwgMSknLCBkdXJhdGlvbiA9IDAuMiwgZGVsYXkgPSAwfSA9IHt9KSB7XG4gICAgc3VwZXIoe2R1cmF0aW9uLCB0aW1pbmcsIGRlbGF5fSk7XG4gIH1cblxuICAvKlxuICAgKiBAcGFyYW0ge09iamVjdH0gZGlhbG9nXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqL1xuICBzaG93KGRpYWxvZywgY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjayA9IGNhbGxiYWNrID8gY2FsbGJhY2sgOiBmdW5jdGlvbigpIHt9O1xuXG4gICAgYW5pbWl0LnJ1bkFsbChcblxuICAgICAgYW5pbWl0KGRpYWxvZy5fbWFzaywgdGhpcy5kZWYpXG4gICAgICAgIC5kZWZhdWx0KHsgb3BhY2l0eTogMCB9LCB7IG9wYWNpdHk6IDEgfSksXG5cbiAgICAgIGFuaW1pdChkaWFsb2cuX2RpYWxvZywgdGhpcy5kZWYpXG4gICAgICAgIC5kZWZhdWx0KFxuICAgICAgICAgIHsgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoLTUwJSwgLTUwJSwgMCkgc2NhbGUzZCgxLjMsIDEuMywgMSknLCBvcGFjaXR5OiAwIH0sXG4gICAgICAgICAgeyB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzZCgtNTAlLCAtNTAlLCAwKSBzY2FsZTNkKDEsIDEsIDEpJywgb3BhY2l0eTogMSB9XG4gICAgICAgIClcbiAgICAgICAgLnF1ZXVlKGRvbmUgPT4ge1xuICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgZG9uZSgpO1xuICAgICAgICB9KVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IGRpYWxvZ1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKi9cbiAgaGlkZShkaWFsb2csIGNhbGxiYWNrKSB7XG4gICAgY2FsbGJhY2sgPSBjYWxsYmFjayA/IGNhbGxiYWNrIDogZnVuY3Rpb24oKSB7fTtcblxuICAgIGFuaW1pdC5ydW5BbGwoXG5cbiAgICAgIGFuaW1pdChkaWFsb2cuX21hc2ssIHRoaXMuZGVmKVxuICAgICAgICAuZGVmYXVsdCh7IG9wYWNpdHk6IDEgfSwgeyBvcGFjaXR5OiAwIH0pLFxuXG4gICAgICBhbmltaXQoZGlhbG9nLl9kaWFsb2csIHRoaXMuZGVmKVxuICAgICAgICAuZGVmYXVsdCh7IG9wYWNpdHk6IDEgfSwgeyBvcGFjaXR5OiAwIH0pXG4gICAgICAgIC5xdWV1ZShkb25lID0+IHtcbiAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgfSlcbiAgICApO1xuICB9XG59XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgb25zRWxlbWVudHMgZnJvbSAnLi4vLi4vb25zL2VsZW1lbnRzJztcbmltcG9ydCB1dGlsIGZyb20gJy4uLy4uL29ucy91dGlsJztcbmltcG9ydCBhdXRvU3R5bGUgZnJvbSAnLi4vLi4vb25zL2F1dG9zdHlsZSc7XG5pbXBvcnQgTW9kaWZpZXJVdGlsIGZyb20gJy4uLy4uL29ucy9pbnRlcm5hbC9tb2RpZmllci11dGlsJztcbmltcG9ydCBBbmltYXRvckZhY3RvcnkgZnJvbSAnLi4vLi4vb25zL2ludGVybmFsL2FuaW1hdG9yLWZhY3RvcnknO1xuaW1wb3J0IHsgQWxlcnREaWFsb2dBbmltYXRvciwgSU9TQWxlcnREaWFsb2dBbmltYXRvciwgQW5kcm9pZEFsZXJ0RGlhbG9nQW5pbWF0b3IgfSBmcm9tICcuL2FuaW1hdG9yJztcbmltcG9ydCBwbGF0Zm9ybSBmcm9tICcuLi8uLi9vbnMvcGxhdGZvcm0nO1xuaW1wb3J0IEJhc2VEaWFsb2dFbGVtZW50IGZyb20gJy4uL2Jhc2UvYmFzZS1kaWFsb2cnO1xuaW1wb3J0IGNvbnRlbnRSZWFkeSBmcm9tICcuLi8uLi9vbnMvY29udGVudC1yZWFkeSc7XG5cbmNvbnN0IHNjaGVtZSA9IHtcbiAgJy5hbGVydC1kaWFsb2cnOiAnYWxlcnQtZGlhbG9nLS0qJyxcbiAgJy5hbGVydC1kaWFsb2ctY29udGFpbmVyJzogJ2FsZXJ0LWRpYWxvZy1jb250YWluZXItLSonLFxuICAnLmFsZXJ0LWRpYWxvZy10aXRsZSc6ICdhbGVydC1kaWFsb2ctdGl0bGUtLSonLFxuICAnLmFsZXJ0LWRpYWxvZy1jb250ZW50JzogJ2FsZXJ0LWRpYWxvZy1jb250ZW50LS0qJyxcbiAgJy5hbGVydC1kaWFsb2ctZm9vdGVyJzogJ2FsZXJ0LWRpYWxvZy1mb290ZXItLSonLFxuICAnLmFsZXJ0LWRpYWxvZy1mb290ZXItLXJvd2Zvb3Rlcic6ICdhbGVydC1kaWFsb2ctZm9vdGVyLS1yb3dmb290ZXItLSonLFxuICAnLmFsZXJ0LWRpYWxvZy1idXR0b24tLXJvd2Zvb3Rlcic6ICdhbGVydC1kaWFsb2ctYnV0dG9uLS1yb3dmb290ZXItLSonLFxuICAnLmFsZXJ0LWRpYWxvZy1idXR0b24tLXByaW1hbCc6ICdhbGVydC1kaWFsb2ctYnV0dG9uLS1wcmltYWwtLSonLFxuICAnLmFsZXJ0LWRpYWxvZy1idXR0b24nOiAnYWxlcnQtZGlhbG9nLWJ1dHRvbi0tKicsXG4gICdvbnMtYWxlcnQtZGlhbG9nLWJ1dHRvbic6ICdhbGVydC1kaWFsb2ctYnV0dG9uLS0qJyxcbiAgJy5hbGVydC1kaWFsb2ctbWFzayc6ICdhbGVydC1kaWFsb2ctbWFzay0tKicsXG4gICcudGV4dC1pbnB1dCc6ICd0ZXh0LWlucHV0LS0qJ1xufTtcblxuY29uc3QgX2FuaW1hdG9yRGljdCA9IHtcbiAgJ25vbmUnOiBBbGVydERpYWxvZ0FuaW1hdG9yLFxuICAnZGVmYXVsdCc6ICgpID0+IHBsYXRmb3JtLmlzQW5kcm9pZCgpID8gQW5kcm9pZEFsZXJ0RGlhbG9nQW5pbWF0b3IgOiBJT1NBbGVydERpYWxvZ0FuaW1hdG9yLFxuICAnZmFkZSc6ICgpID0+IHBsYXRmb3JtLmlzQW5kcm9pZCgpID8gQW5kcm9pZEFsZXJ0RGlhbG9nQW5pbWF0b3IgOiBJT1NBbGVydERpYWxvZ0FuaW1hdG9yXG59O1xuXG4vKipcbiAqIEBlbGVtZW50IG9ucy1hbGVydC1kaWFsb2dcbiAqIEBjYXRlZ29yeSBkaWFsb2dcbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dXG4gKiAgICAgQWxlcnQgZGlhbG9nIHRoYXQgaXMgZGlzcGxheWVkIG9uIHRvcCBvZiB0aGUgY3VycmVudCBzY3JlZW4uIFVzZWZ1bCBmb3IgZGlzcGxheWluZyBxdWVzdGlvbnMsIHdhcm5pbmdzIG9yIGVycm9yIG1lc3NhZ2VzIHRvIHRoZSB1c2VyLiBUaGUgdGl0bGUsIGNvbnRlbnQgYW5kIGJ1dHRvbnMgY2FuIGJlIGVhc2lseSBjdXN0b21pemVkIGFuZCBpdCB3aWxsIGF1dG9tYXRpY2FsbHkgc3dpdGNoIHN0eWxlIGJhc2VkIG9uIHRoZSBwbGF0Zm9ybS5cbiAqXG4gKiAgICAgVG8gdXNlIHRoZSBlbGVtZW50IGl0IGNhbiBlaXRoZXIgYmUgYXR0YWNoZWQgZGlyZWN0bHkgdG8gdGhlIGA8Ym9keT5gIGVsZW1lbnQgb3IgZHluYW1pY2FsbHkgY3JlYXRlZCBmcm9tIGEgdGVtcGxhdGUgdXNpbmcgdGhlIGBvbnMuY3JlYXRlQWxlcnREaWFsb2codGVtcGxhdGUpYCB1dGlsaXR5IGZ1bmN0aW9uIGFuZCB0aGUgYDx0ZW1wbGF0ZT5gIHRhZy5cbiAqICAgWy9lbl1cbiAqICAgW2phXVxuICogICAgIOePvuWcqOOBruOCueOCr+ODquODvOODs+OBruS4iuOBq+ihqOekuuOBmeOCi+OCouODqeODvOODiOODgOOCpOOCouODreOCsOOBp+OBmeOAguODpuODvOOCtuOBq+WvvuOBmeOCi+WVj+OBhOOBi+OBkeOAgeitpuWRiuOAgeOCqOODqeODvOODoeODg+OCu+ODvOOCuOOCkuihqOekuuOBmeOCi+OBruOBq+WIqeeUqOOBp+OBjeOBvuOBmeOAguOCv+OCpOODiOODq+OChOOCs+ODs+ODhuODs+ODhOOChOODnOOCv+ODs+OBr+ewoeWNmOOBq+OCq+OCueOCv+ODnuOCpOOCuuOBp+OBjeOAgeWun+ihjOOBl+OBpuOBhOOCi+ODl+ODqeODg+ODiOODleOCqeODvOODoOOBq+S9teOBm+OBpuOCueOCv+OCpOODq+OBjOiHquWLleeahOOBq+WIh+OCiuabv+OCj+OCiuOBvuOBmeOAglxuICogICBbL2phXVxuICogQGNvZGVwZW4gUXd3eHlwXG4gKiBAdHV0b3JpYWwgdmFuaWxsYS9SZWZlcmVuY2UvYWxlcnQtZGlhbG9nXG4gKiBAbW9kaWZpZXIgbWF0ZXJpYWxcbiAqICAgW2VuXU1hdGVyaWFsIERlc2lnbiBzdHlsZVsvZW5dXG4gKiAgIFtqYV3jg57jg4bjg6rjgqLjg6vjg4fjgrbjgqTjg7Pjga7jgrnjgr/jgqTjg6tbL2phXVxuICogQG1vZGlmaWVyIHJvd2Zvb3RlclxuICogICBbZW5dSG9yaXpvbnRhbGx5IGFsaWducyB0aGUgZm9vdGVyIGJ1dHRvbnMuWy9lbl1cbiAqICAgW2phXeODleODg+OCv+ODvOOBruikh+aVsOOBruODnOOCv+ODs+OCkuawtOW5s+OBq+mFjee9rlsvamFdXG4gKiBAc2VlYWxzbyBvbnMtZGlhbG9nXG4gKiAgIFtlbl1vbnMtZGlhbG9nIGNvbXBvbmVudFsvZW5dXG4gKiAgIFtqYV1vbnMtZGlhbG9n44Kz44Oz44Od44O844ON44Oz44OIWy9qYV1cbiAqIEBzZWVhbHNvIG9ucy1wb3BvdmVyXG4gKiAgIFtlbl1vbnMtcG9wb3ZlciBjb21wb25lbnRbL2VuXVxuICogICBbamFdb25zLWRpYWxvZ+OCs+ODs+ODneODvOODjeODs+ODiFsvamFdXG4gKiBAc2VlYWxzbyBvbnMubm90aWZpY2F0aW9uXG4gKiAgIFtlbl1Vc2luZyBvbnMubm90aWZpY2F0aW9uIHV0aWxpdHkgZnVuY3Rpb25zLlsvZW5dXG4gKiAgIFtqYV3jgqLjg6njg7zjg4jjg4DjgqTjgqLjg63jgrDjgpLooajnpLrjgZnjgovjgavjga/jgIFvbnMubm90aWZpY2F0aW9u44Kq44OW44K444Kn44Kv44OI44Gu44Oh44K944OD44OJ44KS5L2/44GG44GT44Go44KC44Gn44GN44G+44GZ44CCWy9qYV1cbiAqIEBleGFtcGxlXG4gKiA8b25zLWFsZXJ0LWRpYWxvZyBpZD1cImFsZXJ0LWRpYWxvZ1wiPlxuICogICA8ZGl2IGNsYXNzPVwiYWxlcnQtZGlhbG9nLXRpdGxlXCI+V2FybmluZyE8L2Rpdj5cbiAqICAgPGRpdiBjbGFzcz1cImFsZXJ0LWRpYWxvZy1jb250ZW50XCI+XG4gKiAgICAgQW4gZXJyb3IgaGFzIG9jY3VycmVkIVxuICogICA8L2Rpdj5cbiAqICAgPGRpdiBjbGFzcz1cImFsZXJ0LWRpYWxvZy1mb290ZXJcIj5cbiAqICAgICA8YnV0dG9uIGlkPVwiYWxlcnQtZGlhbG9nLWJ1dHRvblwiIGNsYXNzPVwiYWxlcnQtZGlhbG9nLWJ1dHRvblwiPk9LPC9idXR0b24+XG4gKiAgIDwvZGl2PlxuICogPC9vbnMtYWxlcnQtZGlhbG9nPlxuICogPHNjcmlwdD5cbiAqICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2FsZXJ0LWRpYWxvZycpLnNob3coKTtcbiAqIDwvc2NyaXB0PlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBbGVydERpYWxvZ0VsZW1lbnQgZXh0ZW5kcyBCYXNlRGlhbG9nRWxlbWVudCB7XG5cbiAgLyoqXG4gICAqIEBldmVudCBwcmVzaG93XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1GaXJlZCBqdXN0IGJlZm9yZSB0aGUgYWxlcnQgZGlhbG9nIGlzIGRpc3BsYXllZC5bL2VuXVxuICAgKiAgIFtqYV3jgqLjg6njg7zjg4jjg4DjgqTjgqLjg63jgrDjgYzooajnpLrjgZXjgozjgovnm7TliY3jgavnmbrngavjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgW2VuXUV2ZW50IG9iamVjdC5bL2VuXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQuYWxlcnREaWFsb2dcbiAgICogICBbZW5dQWxlcnQgZGlhbG9nIG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgqLjg6njg7zjg4jjg4DjgqTjgqLjg63jgrDjga7jgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBldmVudC5jYW5jZWxcbiAgICogICBbZW5dRXhlY3V0ZSB0byBzdG9wIHRoZSBkaWFsb2cgZnJvbSBzaG93aW5nLlsvZW5dXG4gICAqICAgW2phXeOBk+OBrumWouaVsOOCkuWun+ihjOOBmeOCi+OBqOOAgeOCouODqeODvOODiOODgOOCpOOCouODreOCsOOBruihqOekuuOCkuatouOCgeOBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAZXZlbnQgcG9zdHNob3dcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUZpcmVkIGp1c3QgYWZ0ZXIgdGhlIGFsZXJ0IGRpYWxvZyBpcyBkaXNwbGF5ZWQuWy9lbl1cbiAgICogICBbamFd44Ki44Op44O844OI44OA44Kk44Ki44Ot44Kw44GM6KGo56S644GV44KM44Gf55u05b6M44Gr55m654Gr44GX44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IFtlbl1FdmVudCBvYmplY3QuWy9lbl1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50LmFsZXJ0RGlhbG9nXG4gICAqICAgW2VuXUFsZXJ0IGRpYWxvZyBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Ki44Op44O844OI44OA44Kk44Ki44Ot44Kw44Gu44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBldmVudCBwcmVoaWRlXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1GaXJlZCBqdXN0IGJlZm9yZSB0aGUgYWxlcnQgZGlhbG9nIGlzIGhpZGRlbi5bL2VuXVxuICAgKiAgIFtqYV3jgqLjg6njg7zjg4jjg4DjgqTjgqLjg63jgrDjgYzpmqDjgozjgovnm7TliY3jgavnmbrngavjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgW2VuXUV2ZW50IG9iamVjdC5bL2VuXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQuYWxlcnREaWFsb2dcbiAgICogICBbZW5dQWxlcnQgZGlhbG9nIG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgqLjg6njg7zjg4jjg4DjgqTjgqLjg63jgrDjga7jgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBldmVudC5jYW5jZWxcbiAgICogICBbZW5dRXhlY3V0ZSB0byBzdG9wIHRoZSBkaWFsb2cgZnJvbSBoaWRpbmcuWy9lbl1cbiAgICogICBbamFd44GT44Gu6Zai5pWw44KS5a6f6KGM44GZ44KL44Go44CB44Ki44Op44O844OI44OA44Kk44Ki44Ot44Kw44GM6ZaJ44GY44KI44GG44Go44GZ44KL44Gu44KS5q2i44KB44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBldmVudCBwb3N0aGlkZVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogW2VuXUZpcmVkIGp1c3QgYWZ0ZXIgdGhlIGFsZXJ0IGRpYWxvZyBpcyBoaWRkZW4uWy9lbl1cbiAgICogW2phXeOCouODqeODvOODiOODgOOCpOOCouODreOCsOOBjOmaoOOCjOOBn+W+jOOBq+eZuueBq+OBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCBbZW5dRXZlbnQgb2JqZWN0LlsvZW5dXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5hbGVydERpYWxvZ1xuICAgKiAgIFtlbl1BbGVydCBkaWFsb2cgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCouODqeODvOODiOODgOOCpOOCouODreOCsOOBruOCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIG1vZGlmaWVyXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXVRoZSBhcHBlYXJhbmNlIG9mIHRoZSBkaWFsb2cuWy9lbl1cbiAgICogIFtqYV3jg4DjgqTjgqLjg63jgrDjga7opovjgZ/nm67jgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBjYW5jZWxhYmxlXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXUlmIHRoaXMgYXR0cmlidXRlIGlzIHNldCB0aGUgZGlhbG9nIGNhbiBiZSBjbG9zZWQgYnkgdGFwcGluZyB0aGUgYmFja2dyb3VuZCBvciBieSBwcmVzc2luZyB0aGUgYmFjayBidXR0b24gb24gQW5kcm9pZCBkZXZpY2VzLlsvZW5dXG4gICAqICBbamFd44GT44Gu5bGe5oCn44KS6Kit5a6a44GZ44KL44Go44CB44OA44Kk44Ki44Ot44Kw44Gu6IOM5pmv44KS44K/44OD44OX44GX44Gf44KKQW5kcm9pZOODh+ODkOOCpOOCueOBruODkOODg+OCr+ODnOOCv+ODs+OCkuaKvOOBmeOBqOODgOOCpOOCouODreOCsOOBjOmWieOBmOOCi+OCiOOBhuOBq+OBquOCiuOBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGRpc2FibGVkXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXUlmIHRoaXMgYXR0cmlidXRlIGlzIHNldCB0aGUgZGlhbG9nIGlzIGRpc2FibGVkLlsvZW5dXG4gICAqICBbamFd44GT44Gu5bGe5oCn44GM44GC44KL5pmC44CB44Ki44Op44O844OI44OA44Kk44Ki44Ot44Kw44GvZGlzYWJsZWTnirbmhYvjgavjgarjgorjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBhbmltYXRpb25cbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlZmF1bHQgZGVmYXVsdFxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFtlbl1UaGUgYW5pbWF0aW9uIHVzZWQgd2hlbiBzaG93aW5nIGFuZCBoaWRpbmcgdGhlIGRpYWxvZy4gQ2FuIGJlIGVpdGhlciBgXCJub25lXCJgIG9yIGBcImRlZmF1bHRcImAuWy9lbl1cbiAgICogIFtqYV3jg4DjgqTjgqLjg63jgrDjgpLooajnpLrjgZnjgovpmpvjga7jgqLjg4vjg6Hjg7zjgrfjg6fjg7PlkI3jgpLmjIflrprjgZfjgb7jgZnjgILjg4fjg5Xjgqnjg6vjg4jjgafjga9cIm5vbmVcIuOBi1wiZGVmYXVsdFwi44GM5oyH5a6a44Gn44GN44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgYW5pbWF0aW9uLW9wdGlvbnNcbiAgICogQHR5cGUge0V4cHJlc3Npb259XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXVNwZWNpZnkgdGhlIGFuaW1hdGlvbidzIGR1cmF0aW9uLCB0aW1pbmcgYW5kIGRlbGF5IHdpdGggYW4gb2JqZWN0IGxpdGVyYWwuIEUuZy4gYHtkdXJhdGlvbjogMC4yLCBkZWxheTogMSwgdGltaW5nOiAnZWFzZS1pbid9YC5bL2VuXVxuICAgKiAgW2phXeOCouODi+ODoeODvOOCt+ODp+ODs+aZguOBrmR1cmF0aW9uLCB0aW1pbmcsIGRlbGF544KS44Kq44OW44K444Kn44Kv44OI44Oq44OG44Op44Or44Gn5oyH5a6a44GX44G+44GZ44CC5L6L77yae2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAxLCB0aW1pbmc6ICdlYXNlLWluJ31bL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBtYXNrLWNvbG9yXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZWZhdWx0IHJnYmEoMCwgMCwgMCwgMC4yKVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFtlbl1Db2xvciBvZiB0aGUgYmFja2dyb3VuZCBtYXNrLiBEZWZhdWx0IGlzIFwicmdiYSgwLCAwLCAwLCAwLjIpXCIuWy9lbl1cbiAgICogIFtqYV3og4zmma/jga7jg57jgrnjgq/jga7oibLjgpLmjIflrprjgZfjgb7jgZnjgIJcInJnYmEoMCwgMCwgMCwgMC4yKVwi44GM44OH44OV44Kp44Or44OI5YCk44Gn44GZ44CCWy9qYV1cbiAgICovXG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB0aGlzLl9jb21waWxlKCkpO1xuICB9XG5cbiAgZ2V0IF9zY2hlbWUoKSB7XG4gICAgcmV0dXJuIHNjaGVtZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtFbGVtZW50fVxuICAgKi9cbiAgZ2V0IF9tYXNrKCkge1xuICAgIHJldHVybiB1dGlsLmZpbmRDaGlsZCh0aGlzLCAnLmFsZXJ0LWRpYWxvZy1tYXNrJyk7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7RWxlbWVudH1cbiAgICovXG4gIGdldCBfZGlhbG9nKCkge1xuICAgIHJldHVybiB1dGlsLmZpbmRDaGlsZCh0aGlzLCAnLmFsZXJ0LWRpYWxvZycpO1xuXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7RWxlbWVudH1cbiAgICovXG4gIGdldCBfdGl0bGVFbGVtZW50KCkge1xuICAgIHJldHVybiB1dGlsLmZpbmRDaGlsZCh0aGlzLl9kaWFsb2cuY2hpbGRyZW5bMF0sICcuYWxlcnQtZGlhbG9nLXRpdGxlJyk7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7RWxlbWVudH1cbiAgICovXG4gIGdldCBfY29udGVudEVsZW1lbnQoKSB7XG4gICAgcmV0dXJuIHV0aWwuZmluZENoaWxkKHRoaXMuX2RpYWxvZy5jaGlsZHJlblswXSwgJy5hbGVydC1kaWFsb2ctY29udGVudCcpO1xuICB9XG5cbiAgX3VwZGF0ZUFuaW1hdG9yRmFjdG9yeSgpIHtcbiAgICByZXR1cm4gbmV3IEFuaW1hdG9yRmFjdG9yeSh7XG4gICAgICBhbmltYXRvcnM6IF9hbmltYXRvckRpY3QsXG4gICAgICBiYXNlQ2xhc3M6IEFsZXJ0RGlhbG9nQW5pbWF0b3IsXG4gICAgICBiYXNlQ2xhc3NOYW1lOiAnQWxlcnREaWFsb2dBbmltYXRvcicsXG4gICAgICBkZWZhdWx0QW5pbWF0aW9uOiB0aGlzLmdldEF0dHJpYnV0ZSgnYW5pbWF0aW9uJylcbiAgICB9KTtcbiAgfVxuXG4gIF9jb21waWxlKCkge1xuICAgIGF1dG9TdHlsZS5wcmVwYXJlKHRoaXMpO1xuXG4gICAgdGhpcy5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgIHRoaXMuc3R5bGUuekluZGV4ID0gMTAwMDE7XG5cbiAgICAvKipcbiAgICAgKiBFeHBlY3RlZCByZXN1bHQgYWZ0ZXIgY29tcGlsZTpcbiAgICAgKlxuICAgICAqIDxvbnMtYWxlcnQtZGlhbG9nIHN0eWxlPVwibm9uZVwiPlxuICAgICAqICAgPGRpdiBjbGFzcz1cImFsZXJ0LWRpYWxvZy1tYXNrXCI+PC9kaXY+XG4gICAgICogICA8ZGl2IGNsYXNzPVwiYWxlcnQtZGlhbG9nXCI+XG4gICAgICogICAgIDxkaXYgY2xhc3M9XCJhbGVydC1kaWFsb2ctY29udGFpbmVyXCI+Li4uPC9kaXY+XG4gICAgICogICA8L2Rpdj5cbiAgICAgKiA8L29ucy1hbGVydC1kaWFsb2c+XG4gICAgICovXG5cbiAgICBjb25zdCBjb250ZW50ID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuXG4gICAgaWYgKCF0aGlzLl9tYXNrICYmICF0aGlzLl9kaWFsb2cpIHtcbiAgICAgIHdoaWxlICh0aGlzLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgY29udGVudC5hcHBlbmRDaGlsZCh0aGlzLmZpcnN0Q2hpbGQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghdGhpcy5fbWFzaykge1xuICAgICAgY29uc3QgbWFzayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgbWFzay5jbGFzc0xpc3QuYWRkKCdhbGVydC1kaWFsb2ctbWFzaycpO1xuICAgICAgdGhpcy5pbnNlcnRCZWZvcmUobWFzaywgdGhpcy5jaGlsZHJlblswXSk7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLl9kaWFsb2cpIHtcbiAgICAgIGNvbnN0IGRpYWxvZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgZGlhbG9nLmNsYXNzTGlzdC5hZGQoJ2FsZXJ0LWRpYWxvZycpO1xuICAgICAgdGhpcy5pbnNlcnRCZWZvcmUoZGlhbG9nLCBudWxsKTtcbiAgICB9XG5cbiAgICBpZiAoIXV0aWwuZmluZENoaWxkKHRoaXMuX2RpYWxvZywgJy5hbGVydC1kaWFsb2ctY29udGFpbmVyJykpIHtcbiAgICAgIGNvbnN0IGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoJ2FsZXJ0LWRpYWxvZy1jb250YWluZXInKTtcbiAgICAgIHRoaXMuX2RpYWxvZy5hcHBlbmRDaGlsZChjb250YWluZXIpO1xuICAgIH1cblxuICAgIHRoaXMuX2RpYWxvZy5jaGlsZHJlblswXS5hcHBlbmRDaGlsZChjb250ZW50KTtcblxuICAgIHRoaXMuX2RpYWxvZy5zdHlsZS56SW5kZXggPSAyMDAwMTtcbiAgICB0aGlzLl9tYXNrLnN0eWxlLnpJbmRleCA9IDIwMDAwO1xuXG4gICAgTW9kaWZpZXJVdGlsLmluaXRNb2RpZmllcih0aGlzLCB0aGlzLl9zY2hlbWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBkaXNhYmxlZFxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgZGlzYWJsZWQgb3Igbm90LlsvZW5dXG4gICAqICAgW2phXeeEoeWKueWMluOBleOCjOOBpuOBhOOCi+WgtOWQiOOBq2B0cnVlYOOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgY2FuY2VsYWJsZVxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVdoZXRoZXIgdGhlIGRpYWxvZyBpcyBjYW5jZWxhYmxlIG9yIG5vdC4gQSBjYW5jZWxhYmxlIGRpYWxvZyBjYW4gYmUgY2xvc2VkIGJ5IHRhcHBpbmcgdGhlIGJhY2tncm91bmQgb3IgYnkgcHJlc3NpbmcgdGhlIGJhY2sgYnV0dG9uIG9uIEFuZHJvaWQgZGV2aWNlcy5bL2VuXVxuICAgKiAgIFtqYV3jgZ3jga7jg4DjgqTjgqLjg63jgrDjgYzjgq3jg6Pjg7Pjgrvjg6vlj6/og73jgYvjganjgYbjgYvjgpLooajjgZfjgb7jgZnjgILjgq3jg6Pjg7Pjgrvjg6vlj6/og73jgarjg4DjgqTjgqLjg63jgrDjga/jgIHog4zmma/jgpLjgr/jg4Pjg5fjgZnjgovjgYtBbmRyb2lk44OH44OQ44Kk44K544Gu44OQ44OD44Kv44Oc44K/44Oz44KS5oq844GZ44GT44Go44Gn6ZaJ44GY44KL44GT44Go44GM5Ye65p2l44KL44KI44GG44Gr44Gq44KK44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBtZXRob2Qgc2hvd1xuICAgKiBAc2lnbmF0dXJlIHNob3coW29wdGlvbnNdKVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqICAgW2VuXVBhcmFtZXRlciBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Kq44OX44K344On44Oz44KS5oyH5a6a44GZ44KL44Kq44OW44K444Kn44Kv44OI44Gn44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmFuaW1hdGlvbl1cbiAgICogICBbZW5dQW5pbWF0aW9uIG5hbWUuIEF2YWlsYWJsZSBhbmltYXRpb25zIGFyZSBgXCJmYWRlXCJgIGFuZCBgXCJub25lXCJgLlsvZW5dXG4gICAqICAgW2phXeOCouODi+ODoeODvOOCt+ODp+ODs+WQjeOCkuaMh+WumuOBl+OBvuOBmeOAguaMh+WumuOBp+OBjeOCi+OBruOBr+OAgVwiZmFkZVwiLCBcIm5vbmVcIuOBruOBhOOBmuOCjOOBi+OBp+OBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5hbmltYXRpb25PcHRpb25zXVxuICAgKiAgIFtlbl1TcGVjaWZ5IHRoZSBhbmltYXRpb24ncyBkdXJhdGlvbiwgZGVsYXkgYW5kIHRpbWluZy4gRS5nLiAgYHtkdXJhdGlvbjogMC4yLCBkZWxheTogMC40LCB0aW1pbmc6ICdlYXNlLWluJ31gLlsvZW5dXG4gICAqICAgW2phXeOCouODi+ODoeODvOOCt+ODp+ODs+aZguOBrmR1cmF0aW9uLCBkZWxheSwgdGltaW5n44KS5oyH5a6a44GX44G+44GZ44CCZS5nLiA8Y29kZT57ZHVyYXRpb246IDAuMiwgZGVsYXk6IDAuNCwgdGltaW5nOiAnZWFzZS1pbid9PC9jb2RlPiBbL2phXVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5jYWxsYmFja11cbiAgICogICBbZW5dRnVuY3Rpb24gdG8gZXhlY3V0ZSBhZnRlciB0aGUgZGlhbG9nIGhhcyBiZWVuIHJldmVhbGVkLlsvZW5dXG4gICAqICAgW2phXeODgOOCpOOCouODreOCsOOBjOihqOekuuOBleOCjOe1guOCj+OBo+OBn+aZguOBq+WRvOOBs+WHuuOBleOCjOOCi+OCs+ODvOODq+ODkOODg+OCr+OCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1TaG93IHRoZSBhbGVydCBkaWFsb2cuWy9lbl1cbiAgICogICBbamFd44OA44Kk44Ki44Ot44Kw44KS6KGo56S644GX44G+44GZ44CCWy9qYV1cbiAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICogICBbZW5dQSBgUHJvbWlzZWAgb2JqZWN0IHRoYXQgcmVzb2x2ZXMgdG8gdGhlIGRpc3BsYXllZCBlbGVtZW50LlsvZW5dXG4gICAqICAgW2phXeihqOekuuOBleOCjOOCi+imgee0oOOCkuino+axuuOBmeOCi2BQcm9taXNlYOOCquODluOCuOOCp+OCr+ODiOOCkui/lOOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAbWV0aG9kIGhpZGVcbiAgICogQHNpZ25hdHVyZSBoaWRlKFtvcHRpb25zXSlcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiAgIFtlbl1QYXJhbWV0ZXIgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCquODl+OCt+ODp+ODs+OCkuaMh+WumuOBmeOCi+OCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5hbmltYXRpb25dXG4gICAqICAgW2VuXUFuaW1hdGlvbiBuYW1lLiBBdmFpbGFibGUgYW5pbWF0aW9ucyBhcmUgYFwiZmFkZVwiYCBhbmQgYFwibm9uZVwiYC5bL2VuXVxuICAgKiAgIFtqYV3jgqLjg4vjg6Hjg7zjgrfjg6fjg7PlkI3jgpLmjIflrprjgZfjgb7jgZnjgIJcImZhZGVcIiwgXCJub25lXCLjga7jgYTjgZrjgozjgYvjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuYW5pbWF0aW9uT3B0aW9uc11cbiAgICogICBbZW5dU3BlY2lmeSB0aGUgYW5pbWF0aW9uJ3MgZHVyYXRpb24sIGRlbGF5IGFuZCB0aW1pbmcuIEUuZy4gIDxjb2RlPntkdXJhdGlvbjogMC4yLCBkZWxheTogMC40LCB0aW1pbmc6ICdlYXNlLWluJ308L2NvZGU+Wy9lbl1cbiAgICogICBbamFd44Ki44OL44Oh44O844K344On44Oz5pmC44GuZHVyYXRpb24sIGRlbGF5LCB0aW1pbmfjgpLmjIflrprjgZfjgb7jgZnjgIJlLmcuIDxjb2RlPntkdXJhdGlvbjogMC4yLCBkZWxheTogMC40LCB0aW1pbmc6ICdlYXNlLWluJ308L2NvZGU+IFsvamFdXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmNhbGxiYWNrXVxuICAgKiAgIFtlbl1GdW5jdGlvbiB0byBleGVjdXRlIGFmdGVyIHRoZSBkaWFsb2cgaGFzIGJlZW4gaGlkZGVuLlsvZW5dXG4gICAqICAgW2phXeOBk+OBruODgOOCpOOCouODreOCsOOBjOmWieOBmOOBn+aZguOBq+WRvOOBs+WHuuOBleOCjOOCi+OCs+ODvOODq+ODkOODg+OCr+OCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1IaWRlIHRoZSBhbGVydCBkaWFsb2cuWy9lbl1cbiAgICogICBbamFd44OA44Kk44Ki44Ot44Kw44KS6ZaJ44GY44G+44GZ44CCWy9qYV1cbiAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICogICBbZW5dUmVzb2x2ZXMgdG8gdGhlIGhpZGRlbiBlbGVtZW50Wy9lbl1cbiAgICogICBbamFd6Zqg44KM44Gf6KaB57Sg44KS6Kej5rG644GZ44KLYFByb21pc2Vg44Kq44OW44K444Kn44Kv44OI44KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSB2aXNpYmxlXG4gICAqIEByZWFkb25seVxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVdoZXRoZXIgdGhlIGRpYWxvZyBpcyB2aXNpYmxlIG9yIG5vdC5bL2VuXVxuICAgKiAgIFtqYV3opoHntKDjgYzopovjgYjjgovloLTlkIjjgatgdHJ1ZWDjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQHByb3BlcnR5IG9uRGV2aWNlQmFja0J1dHRvblxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dQmFjay1idXR0b24gaGFuZGxlci5bL2VuXVxuICAgKiAgIFtqYV3jg5Djg4Pjgq/jg5zjgr/jg7Pjg4/jg7Pjg4njg6njgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAgICogQHBhcmFtIHtEaWFsb2dBbmltYXRvcn0gQW5pbWF0b3JcbiAgICovXG4gIHN0YXRpYyByZWdpc3RlckFuaW1hdG9yKG5hbWUsIEFuaW1hdG9yKSB7XG4gICAgaWYgKCEoQW5pbWF0b3IucHJvdG90eXBlIGluc3RhbmNlb2YgQWxlcnREaWFsb2dBbmltYXRvcikpIHtcbiAgICAgIHV0aWwudGhyb3dBbmltYXRvcignQWxlcnREaWFsb2cnKTtcbiAgICB9XG4gICAgX2FuaW1hdG9yRGljdFtuYW1lXSA9IEFuaW1hdG9yO1xuICB9XG5cbiAgc3RhdGljIGdldCBhbmltYXRvcnMoKSB7XG4gICAgcmV0dXJuIF9hbmltYXRvckRpY3Q7XG4gIH1cblxuICBzdGF0aWMgZ2V0IEFsZXJ0RGlhbG9nQW5pbWF0b3IoKSB7XG4gICAgcmV0dXJuIEFsZXJ0RGlhbG9nQW5pbWF0b3I7XG4gIH1cbn1cblxub25zRWxlbWVudHMuQWxlcnREaWFsb2cgPSBBbGVydERpYWxvZ0VsZW1lbnQ7XG5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ29ucy1hbGVydC1kaWFsb2cnLCBBbGVydERpYWxvZ0VsZW1lbnQpO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IG9uc0VsZW1lbnRzIGZyb20gJy4uL29ucy9lbGVtZW50cyc7XG5pbXBvcnQgQmFzZUJ1dHRvbkVsZW1lbnQgZnJvbSAnLi9iYXNlL2Jhc2UtYnV0dG9uJztcblxuLyoqXG4gKiBAZWxlbWVudCBvbnMtYWxlcnQtZGlhbG9nLWJ1dHRvblxuICogQG1vZGlmaWVyIG1hdGVyaWFsXG4gKiAgIFtlbl1NYXRlcmlhbCBEZXNpZ24gYWxlcnQtZGlhbG9nIGJ1dHRvbi5bL2VuXVxuICogICBbamFd44Oe44OG44Oq44Ki44Or44OH44K244Kk44Oz44Gu44Oc44K/44Oz44KS6KGo56S644GX44G+44GZ44CCWy9qYV1cbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAc2VlYWxzbyBvbnMtYWxlcnQtZGlhbG9nXG4gKiAgIFtlbl1UaGUgYDxvbnMtYWxlcnQtZGlhbG9nPmAgY29tcG9uZW50IGRpc3BsYXlzIGEgYWxlcnQgZGlhbG9nLlsvZW5dXG4gKiAgIFtqYV1vbnMtYWxlcnQtZGlhbG9n44Kz44Oz44Od44O844ON44Oz44OIWy9qYV1cbiAqIEBleGFtcGxlXG4gKiAgPG9ucy1hbGVydC1kaWFsb2c+XG4gKiAgICA8ZGl2IGNsYXNzPVwiYWxlcnQtZGlhbG9nLXRpdGxlXCI+V2FybmluZyE8L2Rpdj5cbiAqICAgIDxkaXYgY2xhc3M9XCJhbGVydC1kaWFsb2ctY29udGVudFwiPlxuICogICAgICBBbiBlcnJvciBoYXMgb2NjdXJyZWQhXG4gKiAgICA8L2Rpdj5cbiAqICAgIDxkaXYgY2xhc3M9XCJhbGVydC1kaWFsb2ctZm9vdGVyXCI+XG4gKiAgICAgIDxhbGVydC1kaWFsb2ctYnV0dG9uIG9uY2xpY2s9XCJhcHAuY2xvc2UoKVwiPkNhbmNlbDwvYWxlcnQtZGlhbG9nLWJ1dHRvbj5cbiAqICAgICAgPGFsZXJ0LWRpYWxvZy1idXR0b24gY2xhc3M9XCJhbGVydC1kaWFsb2ctYnV0dG9uXCIgb25jbGljaz1cImFwcC5jbG9zZSgpXCI+T0s8L2FsZXJ0LWRpYWxvZy1idXR0b24+XG4gKiAgICA8L2Rpdj5cbiAqICA8L29ucy1hbGVydC1kaWFsb2c+XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEFsZXJ0RGlhbG9nQnV0dG9uRWxlbWVudCBleHRlbmRzIEJhc2VCdXR0b25FbGVtZW50IHtcblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBtb2RpZmllclxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dVGhlIGFwcGVhcmFuY2Ugb2YgdGhlIGJ1dHRvbi5bL2VuXVxuICAgKiAgIFtqYV3jg5zjgr/jg7Pjga7ooajnj77jgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBkaXNhYmxlZFxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dU3BlY2lmeSBpZiBidXR0b24gc2hvdWxkIGJlIGRpc2FibGVkLlsvZW5dXG4gICAqICAgW2phXeODnOOCv+ODs+OCkueEoeWKueWMluOBmeOCi+WgtOWQiOOBr+aMh+WumuOBl+OBpuOBj+OBoOOBleOBhOOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgZGlzYWJsZWRcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1XaGV0aGVyIHRoZSBlbGVtZW50IGlzIGRpc2FibGVkIG9yIG5vdC5bL2VuXVxuICAgKiAgIFtqYV3nhKHlirnljJbjgZXjgozjgabjgYTjgovloLTlkIjjgatgdHJ1ZWDjgIJbL2phXVxuICAgKi9cblxuICBnZXQgX3NjaGVtZSgpIHtcbiAgICByZXR1cm4geyAnJzogJ2FsZXJ0LWRpYWxvZy1idXR0b24tLSonIH07XG4gIH1cblxuICBnZXQgX2RlZmF1bHRDbGFzc05hbWUoKSB7XG4gICAgcmV0dXJuICdhbGVydC1kaWFsb2ctYnV0dG9uJztcbiAgfVxuXG4gIGdldCBfcmlwcGxlT3B0KCkge1xuICAgIHJldHVybiBbdGhpcywgdW5kZWZpbmVkLCB7ICdtb2RpZmllcic6ICdsaWdodC1ncmF5JyB9XTtcbiAgfVxufVxuXG5vbnNFbGVtZW50cy5BbGVydERpYWxvZ0J1dHRvbiA9IEFsZXJ0RGlhbG9nQnV0dG9uRWxlbWVudDtcbmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnb25zLWFsZXJ0LWRpYWxvZy1idXR0b24nLCBBbGVydERpYWxvZ0J1dHRvbkVsZW1lbnQpO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IG9uc0VsZW1lbnRzIGZyb20gJy4uL29ucy9lbGVtZW50cyc7XG5pbXBvcnQgdXRpbCBmcm9tICcuLi9vbnMvdXRpbCc7XG5pbXBvcnQgYXV0b1N0eWxlIGZyb20gJy4uL29ucy9hdXRvc3R5bGUnO1xuaW1wb3J0IE1vZGlmaWVyVXRpbCBmcm9tICcuLi9vbnMvaW50ZXJuYWwvbW9kaWZpZXItdXRpbCc7XG5pbXBvcnQgQmFzZUVsZW1lbnQgZnJvbSAnLi9iYXNlL2Jhc2UtZWxlbWVudCc7XG5pbXBvcnQgY29udGVudFJlYWR5IGZyb20gJy4uL29ucy9jb250ZW50LXJlYWR5JztcbmltcG9ydCBpb3NCYWNrQnV0dG9uSWNvbiBmcm9tICcuLi8uLi9pbWFnZXMvaW9zLWJhY2stYnV0dG9uLWljb24uc3ZnJztcbmltcG9ydCBtZEJhY2tCdXR0b25JY29uIGZyb20gJy4uLy4uL2ltYWdlcy9tZC1iYWNrLWJ1dHRvbi1pY29uLnN2Zyc7XG5cbmNvbnN0IGRlZmF1bHRDbGFzc05hbWUgPSAnYmFjay1idXR0b24nO1xuXG5jb25zdCBzY2hlbWUgPSB7XG4gICcnOiAnYmFjay1idXR0b24tLSonLFxuICAnLmJhY2stYnV0dG9uX19pY29uJzogJ2JhY2stYnV0dG9uLS0qX19pY29uJyxcbiAgJy5iYWNrLWJ1dHRvbl9fbGFiZWwnOiAnYmFjay1idXR0b24tLSpfX2xhYmVsJ1xufTtcblxuLyoqXG4gKiBAZWxlbWVudCBvbnMtYmFjay1idXR0b25cbiAqIEBjYXRlZ29yeSBuYXZpZ2F0aW9uXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXVxuICogICAgIEJhY2sgYnV0dG9uIGNvbXBvbmVudCBmb3IgYDxvbnMtdG9vbGJhcj5gLiBQdXQgaXQgaW4gdGhlIGxlZnQgcGFydCBvZiB0aGUgYDxvbnMtdG9vbGJhcj5gLlxuICpcbiAqICAgICBJdCB3aWxsIGZpbmQgdGhlIHBhcmVudCBgPG9ucy1uYXZpZ2F0b3I+YCBlbGVtZW50IGFuZCBwb3AgYSBwYWdlIHdoZW4gY2xpY2tlZC4gVGhpcyBiZWhhdmlvciBjYW4gYmUgb3ZlcnJpZGVuIGJ5IHNwZWNpZnlpbmcgdGhlIGBvbkNsaWNrYCBwcm9wZXJ0eS5cbiAqICAgWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAY29kZXBlbiBhSG1HTFxuICogQHR1dG9yaWFsIHZhbmlsbGEvUmVmZXJlbmNlL2JhY2stYnV0dG9uXG4gKiBAbW9kaWZpZXIgbWF0ZXJpYWxcbiAqICAgW2VuXU1hdGVyaWFsIERlc2lnbiBzdHlsZVsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQHNlZWFsc28gb25zLXRvb2xiYXJcbiAqICAgW2VuXW9ucy10b29sYmFyIGNvbXBvbmVudFsvZW5dXG4gKiAgIFtqYV1vbnMtdG9vbGJhcuOCs+ODs+ODneODvOODjeODs+ODiFsvamFdXG4gKiBAc2VlYWxzbyBvbnMtbmF2aWdhdG9yXG4gKiAgIFtlbl1vbnMtbmF2aWdhdG9yIGNvbXBvbmVudFsvZW5dXG4gKiAgIFtqYV1vbnMtbmF2aWdhdG9y44Kz44Oz44Od44O844ON44Oz44OIWy9qYV1cbiAqIEBleGFtcGxlXG4gKiA8b25zLXRvb2xiYXI+XG4gKiAgIDxkaXYgY2xhc3M9XCJsZWZ0XCI+XG4gKiAgICAgPG9ucy1iYWNrLWJ1dHRvbj5CYWNrPC9vbnMtYmFjay1idXR0b24+XG4gKiAgIDwvZGl2PlxuICogICA8ZGl2IGNsYXNzPVwiY2VudGVyXCI+XG4gKiAgICAgVGl0bGVcbiAqICAgPGRpdj5cbiAqIDwvb25zLXRvb2xiYXI+XG4gKi9cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQmFja0J1dHRvbkVsZW1lbnQgZXh0ZW5kcyBCYXNlRWxlbWVudCB7XG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIG1vZGlmaWVyXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXVRoZSBhcHBlYXJhbmNlIG9mIHRoZSBiYWNrIGJ1dHRvbi5bL2VuXVxuICAgKiAgW2phXeODkOODg+OCr+ODnOOCv+ODs+OBruimi+OBn+ebruOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG5cbiAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4ge1xuICAgICAgdGhpcy5fY29tcGlsZSgpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5fb3B0aW9ucyA9IHt9O1xuICAgIHRoaXMuX2JvdW5kT25DbGljayA9IHRoaXMuX29uQ2xpY2suYmluZCh0aGlzKTtcbiAgfVxuXG4gIF91cGRhdGVJY29uKGljb24gPSB1dGlsLmZpbmRDaGlsZCh0aGlzLCAnLmJhY2stYnV0dG9uX19pY29uJykpIHtcbiAgICBpY29uLmlubmVySFRNTCA9IGF1dG9TdHlsZS5nZXRQbGF0Zm9ybSh0aGlzKSA9PT0gJ2FuZHJvaWQnIHx8IHV0aWwuaGFzTW9kaWZpZXIodGhpcywgJ21hdGVyaWFsJykgPyBtZEJhY2tCdXR0b25JY29uIDogaW9zQmFja0J1dHRvbkljb247XG4gIH1cblxuICBfY29tcGlsZSgpIHtcbiAgICBhdXRvU3R5bGUucHJlcGFyZSh0aGlzKTtcblxuICAgIHRoaXMuY2xhc3NMaXN0LmFkZChkZWZhdWx0Q2xhc3NOYW1lKTtcblxuICAgIGlmICghdXRpbC5maW5kQ2hpbGQodGhpcywgJy5iYWNrLWJ1dHRvbl9fbGFiZWwnKSkge1xuICAgICAgY29uc3QgbGFiZWwgPSB1dGlsLmNyZWF0ZSgnc3Bhbi5iYWNrLWJ1dHRvbl9fbGFiZWwnKTtcblxuICAgICAgd2hpbGUgKHRoaXMuY2hpbGROb2Rlc1swXSkge1xuICAgICAgICBsYWJlbC5hcHBlbmRDaGlsZCh0aGlzLmNoaWxkTm9kZXNbMF0pO1xuICAgICAgfVxuICAgICAgdGhpcy5hcHBlbmRDaGlsZChsYWJlbCk7XG4gICAgfVxuXG4gICAgaWYgKCF1dGlsLmZpbmRDaGlsZCh0aGlzLCAnLmJhY2stYnV0dG9uX19pY29uJykpIHtcbiAgICAgIGNvbnN0IGljb24gPSB1dGlsLmNyZWF0ZSgnc3Bhbi5iYWNrLWJ1dHRvbl9faWNvbicpO1xuICAgICAgdGhpcy5fdXBkYXRlSWNvbihpY29uKTtcblxuICAgICAgdGhpcy5pbnNlcnRCZWZvcmUoaWNvbiwgdGhpcy5jaGlsZHJlblswXSk7XG4gICAgfVxuXG4gICAgdXRpbC51cGRhdGVSaXBwbGUodGhpcywgdW5kZWZpbmVkLCB7Y2VudGVyOiAnJywgJ3NpemUnOiAnY29udGFpbicsICdiYWNrZ3JvdW5kJzogJ3RyYW5zcGFyZW50J30pO1xuXG4gICAgTW9kaWZpZXJVdGlsLmluaXRNb2RpZmllcih0aGlzLCBzY2hlbWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBvcHRpb25zXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1PcHRpb25zIG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgqrjg5fjgrfjg6fjg7PjgpLmjIflrprjgZnjgovjgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQHByb3BlcnR5IG9wdGlvbnMuYW5pbWF0aW9uXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1BbmltYXRpb24gbmFtZS4gQXZhaWxhYmxlIGFuaW1hdGlvbnMgYXJlIFwic2xpZGVcIiwgXCJsaWZ0XCIsIFwiZmFkZVwiIGFuZCBcIm5vbmVcIi5cbiAgICogICAgIFRoZXNlIGFyZSBwbGF0Zm9ybSBiYXNlZCBhbmltYXRpb25zLiBGb3IgZml4ZWQgYW5pbWF0aW9ucywgYWRkIFwiLWlvc1wiIG9yIFwiLW1kXCJcbiAgICogICAgIHN1ZmZpeCB0byB0aGUgYW5pbWF0aW9uIG5hbWUuIEUuZy4gXCJsaWZ0LWlvc1wiLCBcImxpZnQtbWRcIi4gRGVmYXVsdHMgdmFsdWVzIGFyZSBcInNsaWRlLWlvc1wiIGFuZCBcImZhZGUtbWRcIi5cbiAgICogICBbL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQHByb3BlcnR5IG9wdGlvbnMuYW5pbWF0aW9uT3B0aW9uc1xuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dU3BlY2lmeSB0aGUgYW5pbWF0aW9uJ3MgZHVyYXRpb24sIGRlbGF5IGFuZCB0aW1pbmcuIEUuZy4gIGB7ZHVyYXRpb246IDAuMiwgZGVsYXk6IDAuNCwgdGltaW5nOiAnZWFzZS1pbid9YFsvZW5dXG4gICAqICAgW2phXeOCouODi+ODoeODvOOCt+ODp+ODs+aZguOBrmR1cmF0aW9uLCBkZWxheSwgdGltaW5n44KS5oyH5a6a44GX44G+44GZ44CCZS5nLiBge2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAwLjQsIHRpbWluZzogJ2Vhc2UtaW4nfWAgWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBvcHRpb25zLmNhbGxiYWNrXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1GdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCB3aGVuIHRoZSB0cmFuc2l0aW9uIGhhcyBlbmRlZC5bL2VuXVxuICAgKiAgIFtqYV3jgZPjga7jg6Hjgr3jg4Pjg4njgavjgojjgovnlLvpnaLpgbfnp7vjgYzntYLkuobjgZfjgZ/pmpvjgavlkbzjgbPlh7rjgZXjgozjgovplqLmlbDjgqrjg5bjgrjjgqfjgq/jg4jjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICBnZXQgb3B0aW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy5fb3B0aW9ucztcbiAgfVxuXG4gIHNldCBvcHRpb25zKG9iamVjdCkge1xuICAgIHRoaXMuX29wdGlvbnMgPSBvYmplY3Q7XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IG9uQ2xpY2tcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dVXNlZCB0byBvdmVycmlkZSB0aGUgZGVmYXVsdCBiYWNrIGJ1dHRvbiBiZWhhdmlvci5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cbiAgX29uQ2xpY2soKSB7XG4gICAgaWYgKHRoaXMub25DbGljaykge1xuICAgICAgdGhpcy5vbkNsaWNrLmFwcGx5KHRoaXMpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGNvbnN0IG5hdmlnYXRvciA9IHV0aWwuZmluZFBhcmVudCh0aGlzLCAnb25zLW5hdmlnYXRvcicpO1xuICAgICAgaWYgKG5hdmlnYXRvcikge1xuICAgICAgICBuYXZpZ2F0b3IucG9wUGFnZSh0aGlzLm9wdGlvbnMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGNvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLl9ib3VuZE9uQ2xpY2ssIGZhbHNlKTtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgb2JzZXJ2ZWRBdHRyaWJ1dGVzKCkge1xuICAgIHJldHVybiBbJ21vZGlmaWVyJywgJ2NsYXNzJ107XG4gIH1cblxuICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgbGFzdCwgY3VycmVudCkge1xuICAgIHN3aXRjaCAobmFtZSkge1xuICAgICAgY2FzZSAnY2xhc3MnOlxuICAgICAgICB1dGlsLnJlc3RvcmVDbGFzcyh0aGlzLCBkZWZhdWx0Q2xhc3NOYW1lLCBzY2hlbWUpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnbW9kaWZpZXInOiB7XG4gICAgICAgIE1vZGlmaWVyVXRpbC5vbk1vZGlmaWVyQ2hhbmdlZChsYXN0LCBjdXJyZW50LCB0aGlzLCBzY2hlbWUpICYmIHRoaXMuX3VwZGF0ZUljb24oKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZGlzY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuX2JvdW5kT25DbGljaywgZmFsc2UpO1xuICB9XG5cbiAgc2hvdygpIHtcbiAgICB0aGlzLnN0eWxlLmRpc3BsYXkgPSAnaW5saW5lLWJsb2NrJztcbiAgfVxuXG4gIGhpZGUoKSB7XG4gICAgdGhpcy5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICB9XG59XG5cbm9uc0VsZW1lbnRzLkJhY2tCdXR0b24gPSBCYWNrQnV0dG9uRWxlbWVudDtcbmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnb25zLWJhY2stYnV0dG9uJywgQmFja0J1dHRvbkVsZW1lbnQpO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IG9uc0VsZW1lbnRzIGZyb20gJy4uL29ucy9lbGVtZW50cyc7XG5pbXBvcnQgdXRpbCBmcm9tICcuLi9vbnMvdXRpbCc7XG5pbXBvcnQgYXV0b1N0eWxlIGZyb20gJy4uL29ucy9hdXRvc3R5bGUnO1xuaW1wb3J0IE1vZGlmaWVyVXRpbCBmcm9tICcuLi9vbnMvaW50ZXJuYWwvbW9kaWZpZXItdXRpbCc7XG5pbXBvcnQgQmFzZUVsZW1lbnQgZnJvbSAnLi9iYXNlL2Jhc2UtZWxlbWVudCc7XG5cbmNvbnN0IGRlZmF1bHRDbGFzc05hbWUgPSAnYm90dG9tLWJhcic7XG5jb25zdCBzY2hlbWUgPSB7Jyc6ICdib3R0b20tYmFyLS0qJ307XG5cbi8qKlxuICogQGVsZW1lbnQgb25zLWJvdHRvbS10b29sYmFyXG4gKiBAY2F0ZWdvcnkgcGFnZVxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1Ub29sYmFyIGNvbXBvbmVudCB0aGF0IGlzIHBvc2l0aW9uZWQgYXQgdGhlIGJvdHRvbSBvZiB0aGUgcGFnZS4gU2luY2UgYm90dG9tIHRvb2xiYXJzIGFyZSB2ZXJ5IHZlcnNhdGlsZSBlbGVtZW50cywgYG9ucy1ib3R0b20tdG9vbGJhcmAgZG9lcyBub3QgcHJvdmlkZSBhbnkgc3BlY2lmaWMgbGF5b3V0IHN5bnRheCBmb3IgaXRzIGNoaWxkcmVuLiBNb2RpZmllcnMgb3IgY3VzdG9tIENTUyBtdXN0IGJlIHVzZWQuWy9lbl1cbiAqICAgW2phXeODmuODvOOCuOS4i+mDqOOBq+mFjee9ruOBleOCjOOCi+ODhOODvOODq+ODkOODvOeUqOOCs+ODs+ODneODvOODjeODs+ODiOOBp+OBmeOAglsvamFdXG4gKiBAbW9kaWZpZXIgdHJhbnNwYXJlbnRcbiAqICAgW2VuXU1ha2UgdGhlIHRvb2xiYXIgdHJhbnNwYXJlbnQuWy9lbl1cbiAqICAgW2phXeODhOODvOODq+ODkOODvOOBruiDjOaZr+OCkumAj+aYjuOBq+OBl+OBpuihqOekuuOBl+OBvuOBmeOAglsvamFdXG4gKiBAbW9kaWZpZXIgYWxpZ25lZFxuICogICBbZW5dVmVydGljYWxseSBhbGlnbnMgaXRzIGNoaWxkcmVuIGFuZCBhcHBsaWVzIGZsZXhib3ggZm9yIGJsb2NrIGVsZW1lbnRzLiBganVzdGlmeS1jb250ZW50YCBDU1MgcnVsZSBjYW4gYmUgdXNlZCB0byBjaGFuZ2UgaG9yaXpvbnRhbCBhbGlnbi5bL2VuXVxuICogICBbamFd44OE44O844Or44OQ44O844Gu6IOM5pmv44KS6YCP5piO44Gr44GX44Gm6KGo56S644GX44G+44GZ44CCWy9qYV1cbiAqIEBzZWVhbHNvIG9ucy10b29sYmFyIFtlbl1vbnMtdG9vbGJhciBjb21wb25lbnRbL2VuXVtqYV1vbnMtdG9vbGJhcuOCs+ODs+ODneODvOODjeODs+ODiFsvamFdXG4gKiBAZXhhbXBsZVxuICogPG9ucy1ib3R0b20tdG9vbGJhcj5cbiAqICAgQ29udGVudFxuICogPC9vbnMtYm90dG9tLXRvb2xiYXI+XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEJvdHRvbVRvb2xiYXJFbGVtZW50IGV4dGVuZHMgQmFzZUVsZW1lbnQge1xuICAvKipcbiAgICogQGF0dHJpYnV0ZSBtb2RpZmllclxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dVGhlIGFwcGVhcmFuY2Ugb2YgdGhlIHRvb2xiYXIuWy9lbl1cbiAgICogICBbamFd44OE44O844Or44OQ44O844Gu6KaL44Gf55uu44Gu6KGo54++44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIHRoaXMuY2xhc3NMaXN0LmFkZChkZWZhdWx0Q2xhc3NOYW1lKTtcbiAgICBNb2RpZmllclV0aWwuaW5pdE1vZGlmaWVyKHRoaXMsIHNjaGVtZSk7XG4gIH1cblxuICBzdGF0aWMgZ2V0IG9ic2VydmVkQXR0cmlidXRlcygpIHtcbiAgICByZXR1cm4gWydtb2RpZmllcicsICdjbGFzcyddO1xuICB9XG5cbiAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIGxhc3QsIGN1cnJlbnQpIHtcbiAgICBzd2l0Y2ggKG5hbWUpIHtcbiAgICAgIGNhc2UgJ2NsYXNzJzpcbiAgICAgICAgdXRpbC5yZXN0b3JlQ2xhc3ModGhpcywgZGVmYXVsdENsYXNzTmFtZSwgc2NoZW1lKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdtb2RpZmllcic6XG4gICAgICAgIE1vZGlmaWVyVXRpbC5vbk1vZGlmaWVyQ2hhbmdlZChsYXN0LCBjdXJyZW50LCB0aGlzLCBzY2hlbWUpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cblxufVxuXG5vbnNFbGVtZW50cy5Cb3R0b21Ub29sYmFyID0gQm90dG9tVG9vbGJhckVsZW1lbnQ7XG5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ29ucy1ib3R0b20tdG9vbGJhcicsIEJvdHRvbVRvb2xiYXJFbGVtZW50KTtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCBvbnNFbGVtZW50cyBmcm9tICcuLi9vbnMvZWxlbWVudHMnO1xuaW1wb3J0IEJhc2VCdXR0b25FbGVtZW50IGZyb20gJy4vYmFzZS9iYXNlLWJ1dHRvbic7XG5cbi8qKlxuICogQGVsZW1lbnQgb25zLWJ1dHRvblxuICogQGNhdGVnb3J5IGZvcm1cbiAqIEBtb2RpZmllciBvdXRsaW5lXG4gKiAgIFtlbl1CdXR0b24gd2l0aCBvdXRsaW5lIGFuZCB0cmFuc3BhcmVudCBiYWNrZ3JvdW5kWy9lbl1cbiAqICAgW2phXeOCouOCpuODiOODqeOCpOODs+OCkuaMgeOBo+OBn+ODnOOCv+ODs+OCkuihqOekuuOBl+OBvuOBmeOAglsvamFdXG4gKiBAbW9kaWZpZXIgbGlnaHRcbiAqICAgW2VuXUJ1dHRvbiB0aGF0IGRvZXNuJ3Qgc3RhbmQgb3V0LlsvZW5dXG4gKiAgIFtqYV3nm67nq4vjgZ/jgarjgYTjg5zjgr/jg7PjgpLooajnpLrjgZfjgb7jgZnjgIJbL2phXVxuICogQG1vZGlmaWVyIHF1aWV0XG4gKiAgIFtlbl1CdXR0b24gd2l0aCBubyBvdXRsaW5lIGFuZCBvciBiYWNrZ3JvdW5kLi5bL2VuXVxuICogICBbamFd5p6g57ea44KE6IOM5pmv44GM54Sh44GE5paH5a2X44Gg44GR44Gu44Oc44K/44Oz44KS6KGo56S644GX44G+44GZ44CCWy9qYV1cbiAqIEBtb2RpZmllciBjdGFcbiAqICAgW2VuXUJ1dHRvbiB0aGF0IHJlYWxseSBzdGFuZHMgb3V0LlsvZW5dXG4gKiAgIFtqYV3nm67nq4vjgaTjg5zjgr/jg7PjgpLooajnpLrjgZfjgb7jgZnjgIJbL2phXVxuICogQG1vZGlmaWVyIGxhcmdlXG4gKiAgIFtlbl1MYXJnZSBidXR0b24gdGhhdCBjb3ZlcnMgdGhlIHdpZHRoIG9mIHRoZSBzY3JlZW4uWy9lbl1cbiAqICAgW2phXeaoquOBhOOBo+OBseOBhOOBq+W6g+OBjOOCi+Wkp+OBjeOBquODnOOCv+ODs+OCkuihqOekuuOBl+OBvuOBmeOAglsvamFdXG4gKiBAbW9kaWZpZXIgbGFyZ2UtLXF1aWV0XG4gKiAgIFtlbl1MYXJnZSBxdWlldCBidXR0b24uWy9lbl1cbiAqICAgW2phXeaoquOBhOOBo+OBseOBhOOBq+W6g+OBjOOCi3F1aWV044Oc44K/44Oz44KS6KGo56S644GX44G+44GZ44CCWy9qYV1cbiAqIEBtb2RpZmllciBsYXJnZS0tY3RhXG4gKiAgIFtlbl1MYXJnZSBjYWxsIHRvIGFjdGlvbiBidXR0b24uWy9lbl1cbiAqICAgW2phXeaoquOBhOOBo+OBseOBhOOBq+W6g+OBjOOCi2N0YeODnOOCv+ODs+OCkuihqOekuuOBl+OBvuOBmeOAglsvamFdXG4gKiBAbW9kaWZpZXIgbWF0ZXJpYWxcbiAqICAgW2VuXU1hdGVyaWFsIERlc2lnbiBidXR0b25bL2VuXVxuICogICBbamFd44Oe44OG44Oq44Ki44Or44OH44K244Kk44Oz44Gu44Oc44K/44OzWy9qYV1cbiAqIEBtb2RpZmllciBtYXRlcmlhbC0tZmxhdFxuICogICBbZW5dTWF0ZXJpYWwgRGVzaWduIGZsYXQgYnV0dG9uWy9lbl1cbiAqICAgW2phXeODnuODhuODquOCouODq+ODh+OCtuOCpOODs+OBruODleODqeODg+ODiOODnOOCv+ODs1svamFdXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXVxuICogICAgIEJ1dHRvbiBjb21wb25lbnQuIElmIHlvdSB3YW50IHRvIHBsYWNlIGEgYnV0dG9uIGluIGEgdG9vbGJhciwgdXNlIGA8b25zLXRvb2xiYXItYnV0dG9uPmAgb3IgYDxvbnMtYmFjay1idXR0b24+YCBpbnN0ZWFkLlxuICpcbiAqICAgICBXaWxsIGF1dG9tYXRpY2FsbHkgZGlzcGxheSBhcyBhIE1hdGVyaWFsIERlc2lnbiBidXR0b24gd2l0aCBhIHJpcHBsZSBlZmZlY3Qgb24gQW5kcm9pZC5cbiAqICAgWy9lbl1cbiAqICAgW2phXeODnOOCv+ODs+eUqOOCs+ODs+ODneODvOODjeODs+ODiOOAguODhOODvOODq+ODkOODvOOBq+ODnOOCv+ODs+OCkuioree9ruOBmeOCi+WgtOWQiOOBr+OAgW9ucy10b29sYmFyLWJ1dHRvbuOCguOBl+OBj+OBr29ucy1iYWNrLWJ1dHRvbuOCs+ODs+ODneODvOODjeODs+ODiOOCkuS9v+eUqOOBl+OBvuOBmeOAglsvamFdXG4gKiBAY29kZXBlbiBoTGF5eFxuICogQHR1dG9yaWFsIHZhbmlsbGEvUmVmZXJlbmNlL2J1dHRvblxuICogQGd1aWRlIHRoZW1pbmcuaHRtbCNtb2RpZmllcnMgW2VuXU1vcmUgZGV0YWlscyBhYm91dCB0aGUgYG1vZGlmaWVyYCBhdHRyaWJ1dGVbL2VuXVtqYV1tb2RpZmllcuWxnuaAp+OBruS9v+OBhOaWuVsvamFdXG4gKiBAZ3VpZGUgdGhlbWluZy5odG1sI2Nyb3NzLXBsYXRmb3JtLXN0eWxpbmctYXV0b3N0eWxpbmcgW2VuXUluZm9ybWF0aW9uIGFib3V0IGNyb3NzIHBsYXRmb3JtIHN0eWxpbmdbL2VuXVtqYV1JbmZvcm1hdGlvbiBhYm91dCBjcm9zcyBwbGF0Zm9ybSBzdHlsaW5nWy9qYV1cbiAqIEBleGFtcGxlXG4gKiA8b25zLWJ1dHRvbiBtb2RpZmllcj1cImxhcmdlLS1jdGFcIj5cbiAqICAgVGFwIE1lXG4gKiA8L29ucy1idXR0b24+XG4gKi9cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQnV0dG9uRWxlbWVudCBleHRlbmRzIEJhc2VCdXR0b25FbGVtZW50IHtcblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBtb2RpZmllclxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFtlbl1UaGUgYXBwZWFyYW5jZSBvZiB0aGUgYnV0dG9uLlsvZW5dXG4gICAqICBbamFd44Oc44K/44Oz44Gu6KGo54++44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgcmlwcGxlXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXUlmIHRoaXMgYXR0cmlidXRlIGlzIGRlZmluZWQsIHRoZSBidXR0b24gd2lsbCBoYXZlIGEgcmlwcGxlIGVmZmVjdC5bL2VuXVxuICAgKiAgW2phXVsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGRpc2FibGVkXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1TcGVjaWZ5IGlmIGJ1dHRvbiBzaG91bGQgYmUgZGlzYWJsZWQuWy9lbl1cbiAgICogICBbamFd44Oc44K/44Oz44KS54Sh5Yq55YyW44GZ44KL5aC05ZCI44Gv5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBkaXNhYmxlZFxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVdoZXRoZXIgdGhlIGJ1dHRvbiBpcyBkaXNhYmxlZCBvciBub3QuWy9lbl1cbiAgICogICBbamFd54Sh5Yq55YyW44GV44KM44Gm44GE44KL5aC05ZCI44GrYHRydWVg44CCWy9qYV1cbiAgICovXG5cbiAgZ2V0IF9zY2hlbWUoKSB7XG4gICAgcmV0dXJuIHsgJyc6ICdidXR0b24tLSonIH07XG4gIH1cblxuICBnZXQgX2RlZmF1bHRDbGFzc05hbWUoKSB7XG4gICAgcmV0dXJuICdidXR0b24nO1xuICB9XG59XG5cbm9uc0VsZW1lbnRzLkJ1dHRvbiA9IEJ1dHRvbkVsZW1lbnQ7XG5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ29ucy1idXR0b24nLCBCdXR0b25FbGVtZW50KTtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCBvbnNFbGVtZW50cyBmcm9tICcuLi9vbnMvZWxlbWVudHMnO1xuaW1wb3J0IHV0aWwgZnJvbSAnLi4vb25zL3V0aWwnO1xuaW1wb3J0IGF1dG9TdHlsZSBmcm9tICcuLi9vbnMvYXV0b3N0eWxlJztcbmltcG9ydCBNb2RpZmllclV0aWwgZnJvbSAnLi4vb25zL2ludGVybmFsL21vZGlmaWVyLXV0aWwnO1xuaW1wb3J0IEJhc2VFbGVtZW50IGZyb20gJy4vYmFzZS9iYXNlLWVsZW1lbnQnO1xuaW1wb3J0IGNvbnRlbnRSZWFkeSBmcm9tICcuLi9vbnMvY29udGVudC1yZWFkeSc7XG5cbmNvbnN0IGRlZmF1bHRDbGFzc05hbWUgPSAnY2FyZCc7XG5jb25zdCBzY2hlbWUgPSB7XG4gICcnOiAnY2FyZC0tKicsXG4gICcuY2FyZF9fdGl0bGUnOiAnY2FyZC0tKl9fdGl0bGUnLFxuICAnLmNhcmRfX2NvbnRlbnQnOiAnY2FyZC0tKl9fY29udGVudCdcbn07XG5cbi8qKlxuICogQGVsZW1lbnQgb25zLWNhcmRcbiAqIEBjYXRlZ29yeSB2aXN1YWxcbiAqIEBtb2RpZmllciBtYXRlcmlhbFxuICogICBbZW5dQSBjYXJkIHdpdGggbWF0ZXJpYWwgZGVzaWduLlsvZW5dXG4gKiAgIFtqYV3jg6rjgrnjg4jjga7kuIrkuIvjga7jg5zjg7zjg4Djg7zjgYznhKHjgYTjg6rjgrnjg4jjgpLooajnpLrjgZfjgb7jgZnjgIJbL2phXVxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1cbiAqICAgIENvbXBvbmVudCB0byBjcmVhdGUgYSBjYXJkIHRoYXQgZGlzcGxheXMgc29tZSBpbmZvcm1hdGlvbi5cbiAqXG4gKiAgICBUaGUgY2FyZCBtYXkgYmUgY29tcG9zZWQgYnkgZGl2cyB3aXRoIHNwZWNpYWxseSBwcmVwYXJlZCBjbGFzc2VzIGB0aXRsZWAgYW5kL29yIGBjb250ZW50YC4gWW91IGNhbiBhbHNvIGFkZCB5b3VyIG93biBjb250ZW50IGFzIHlvdSBwbGVhc2UuWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAdHV0b3JpYWwgdmFuaWxsYS9SZWZlcmVuY2UvY2FyZFxuICogQGV4YW1wbGVcbiAqIDxvbnMtY2FyZD5cbiAqICAgPHA+U29tZSBjb250ZW50PC9wPlxuICogPC9vbnMtY2FyZD5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ2FyZEVsZW1lbnQgZXh0ZW5kcyBCYXNlRWxlbWVudCB7XG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgbW9kaWZpZXJcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVRoZSBhcHBlYXJhbmNlIG9mIHRoZSBjYXJkLlsvZW5dXG4gICAqICAgW2phXeODquOCueODiOOBruihqOePvuOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG5cbiAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4ge1xuICAgICAgdGhpcy5fY29tcGlsZSgpO1xuICAgIH0pO1xuICB9XG5cbiAgX2NvbXBpbGUoKSB7XG4gICAgbGV0IHRpdGxlLCBjb250ZW50O1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBlbCA9IHRoaXMuY2hpbGRyZW5baV07XG5cbiAgICAgIGlmIChlbC5jbGFzc0xpc3QuY29udGFpbnMoJ3RpdGxlJykpIHtcbiAgICAgICAgZWwuY2xhc3NMaXN0LmFkZCgnY2FyZF9fdGl0bGUnKTtcbiAgICAgICAgdGl0bGUgPSBlbDtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGVsLmNsYXNzTGlzdC5jb250YWlucygnY29udGVudCcpKSB7XG4gICAgICAgIGVsLmNsYXNzTGlzdC5hZGQoJ2NhcmRfX2NvbnRlbnQnKTtcbiAgICAgICAgY29udGVudCA9IGVsO1xuICAgICAgfVxuICAgIH1cblxuICAgIGF1dG9TdHlsZS5wcmVwYXJlKHRoaXMpO1xuICAgIHRoaXMuY2xhc3NMaXN0LmFkZChkZWZhdWx0Q2xhc3NOYW1lKTtcbiAgICBNb2RpZmllclV0aWwuaW5pdE1vZGlmaWVyKHRoaXMsIHNjaGVtZSk7XG4gIH1cblxuICBzdGF0aWMgZ2V0IG9ic2VydmVkQXR0cmlidXRlcygpIHtcbiAgICByZXR1cm4gWydtb2RpZmllcicsICdjbGFzcyddO1xuICB9XG5cbiAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIGxhc3QsIGN1cnJlbnQpIHtcbiAgICBzd2l0Y2ggKG5hbWUpIHtcbiAgICAgIGNhc2UgJ2NsYXNzJzpcbiAgICAgICAgdXRpbC5yZXN0b3JlQ2xhc3ModGhpcywgZGVmYXVsdENsYXNzTmFtZSwgc2NoZW1lKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdtb2RpZmllcic6XG4gICAgICAgIE1vZGlmaWVyVXRpbC5vbk1vZGlmaWVyQ2hhbmdlZChsYXN0LCBjdXJyZW50LCB0aGlzLCBzY2hlbWUpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cbn1cblxub25zRWxlbWVudHMuQ2FyZCA9IENhcmRFbGVtZW50O1xuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdvbnMtY2FyZCcsIENhcmRFbGVtZW50KTtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCBvbnNFbGVtZW50cyBmcm9tICcuLi9vbnMvZWxlbWVudHMnO1xuaW1wb3J0IHV0aWwgZnJvbSAnLi4vb25zL3V0aWwnO1xuaW1wb3J0IEJhc2VFbGVtZW50IGZyb20gJy4vYmFzZS9iYXNlLWVsZW1lbnQnO1xuaW1wb3J0IE1vZGlmaWVyVXRpbCBmcm9tICcuLi9vbnMvaW50ZXJuYWwvbW9kaWZpZXItdXRpbCc7XG5jb25zdCBzY2hlbWUgPSB7Jyc6ICdjYXJvdXNlbC1pdGVtLS0qJ307XG5cbi8qKlxuICogQGVsZW1lbnQgb25zLWNhcm91c2VsLWl0ZW1cbiAqIEBjYXRlZ29yeSBjYXJvdXNlbFxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1cbiAqICAgICBDYXJvdXNlbCBpdGVtIGNvbXBvbmVudC4gVXNlZCBhcyBhIGNoaWxkIG9mIHRoZSBgPG9ucy1jYXJvdXNlbD5gIGVsZW1lbnQuXG4gKiAgIFsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQGNvZGVwZW4geGJiek9RXG4gKiBAdHV0b3JpYWwgdmFuaWxsYS9SZWZlcmVuY2UvY2Fyb3VzZWxcbiAqIEBzZWVhbHNvIG9ucy1jYXJvdXNlbFxuICogICBbZW5dYDxvbnMtY2Fyb3VzZWw+YCBjb21wb25lbnRzWy9lbl1cbiAqICAgW2phXTxvbnMtY2Fyb3VzZWw+44Kz44Oz44Od44O844ON44Oz44OIWy9qYV1cbiAqIEBleGFtcGxlXG4gKiA8b25zLWNhcm91c2VsIHN0eWxlPVwid2lkdGg6IDEwMCU7IGhlaWdodDogMjAwcHhcIj5cbiAqICAgPG9ucy1jYXJvdXNlbC1pdGVtPlxuICogICAgLi4uXG4gKiAgIDwvb25zLWNhcm91c2VsLWl0ZW0+XG4gKiAgIDxvbnMtY2Fyb3VzZWwtaXRlbT5cbiAqICAgIC4uLlxuICogICA8L29ucy1jYXJvdXNlbC1pdGVtPlxuICogPC9vbnMtY2Fyb3VzZWw+XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENhcm91c2VsSXRlbUVsZW1lbnQgZXh0ZW5kcyBCYXNlRWxlbWVudCB7XG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIHRoaXMuc3R5bGUud2lkdGggPSAnMTAwJSc7XG4gICAgTW9kaWZpZXJVdGlsLmluaXRNb2RpZmllcih0aGlzLCBzY2hlbWUpO1xuICB9XG5cbiAgc3RhdGljIGdldCBvYnNlcnZlZEF0dHJpYnV0ZXMoKSB7XG4gICAgcmV0dXJuIFsnbW9kaWZpZXInXVxuICB9XG5cbiAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIGxhc3QsIGN1cnJlbnQpIHtcbiAgICBpZiAobmFtZSA9PT0gJ21vZGlmaWVyJykge1xuICAgICAgcmV0dXJuIE1vZGlmaWVyVXRpbC5vbk1vZGlmaWVyQ2hhbmdlZChsYXN0LCBjdXJyZW50LCB0aGlzLCBzY2hlbWUpO1xuICAgIH1cbiAgfVxufVxuXG5vbnNFbGVtZW50cy5DYXJvdXNlbEl0ZW0gPSBDYXJvdXNlbEl0ZW1FbGVtZW50O1xuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdvbnMtY2Fyb3VzZWwtaXRlbScsIENhcm91c2VsSXRlbUVsZW1lbnQpO1xuIiwiaW1wb3J0IHV0aWwgZnJvbSAnLi4vdXRpbCc7XG5pbXBvcnQgcGxhdGZvcm0gZnJvbSAnLi4vcGxhdGZvcm0nO1xuaW1wb3J0IGFuaW1pdCBmcm9tICcuLi9hbmltaXQnO1xuaW1wb3J0IEdlc3R1cmVEZXRlY3RvciBmcm9tICcuLi9nZXN0dXJlLWRldGVjdG9yJztcblxuY29uc3QgZGlyZWN0aW9uTWFwID0ge1xuICB2ZXJ0aWNhbDoge1xuICAgIGF4aXM6ICdZJyxcbiAgICBzaXplOiAnSGVpZ2h0JyxcbiAgICBkaXI6IFsndXAnLCAnZG93biddLFxuICAgIHQzZDogWycwcHgsICcsICdweCwgMHB4J11cbiAgfSxcbiAgaG9yaXpvbnRhbDoge1xuICAgIGF4aXM6ICdYJyxcbiAgICBzaXplOiAnV2lkdGgnLFxuICAgIGRpcjogWydsZWZ0JywgJ3JpZ2h0J10sXG4gICAgdDNkOiBbJycsICdweCwgMHB4LCAwcHgnXVxuICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTd2lwZXIge1xuICBjb25zdHJ1Y3RvcihwYXJhbXMpIHtcbiAgICAvLyBQYXJhbWV0ZXJzXG4gICAgY29uc3QgRkFMU0UgPSAoKCkgPT4gZmFsc2UpO1xuICAgIGBnZXRJbml0aWFsSW5kZXggZ2V0QnViYmxlV2lkdGggaXNWZXJ0aWNhbCBpc092ZXJTY3JvbGxhYmxlIGlzQ2VudGVyZWRcbiAgICBpc0F1dG9TY3JvbGxhYmxlIHJlZnJlc2hIb29rIHByZUNoYW5nZUhvb2sgcG9zdENoYW5nZUhvb2sgb3ZlclNjcm9sbEhvb2tgXG4gICAgICAuc3BsaXQoL1xccysvKVxuICAgICAgLmZvckVhY2goa2V5ID0+IHRoaXNba2V5XSA9IHBhcmFtc1trZXldIHx8IEZBTFNFKTtcblxuICAgIHRoaXMuZ2V0RWxlbWVudCA9IHBhcmFtcy5nZXRFbGVtZW50OyAvLyBSZXF1aXJlZFxuICAgIHRoaXMuc2Nyb2xsSG9vayA9IHBhcmFtcy5zY3JvbGxIb29rOyAvLyBPcHRpb25hbFxuICAgIHRoaXMuaXRlbVNpemUgPSBwYXJhbXMuaXRlbVNpemUgfHwgJzEwMCUnO1xuXG4gICAgdGhpcy5nZXRBdXRvU2Nyb2xsUmF0aW8gPSAoLi4uYXJncykgPT4ge1xuICAgICAgbGV0IHJhdGlvID0gcGFyYW1zLmdldEF1dG9TY3JvbGxSYXRpbyAmJiBwYXJhbXMuZ2V0QXV0b1Njcm9sbFJhdGlvKC4uLmFyZ3MpO1xuICAgICAgcmF0aW8gPSB0eXBlb2YgcmF0aW8gPT09ICdudW1iZXInICYmIHJhdGlvID09PSByYXRpbyA/IHJhdGlvIDogLjU7XG4gICAgICBpZiAocmF0aW8gPCAwLjAgfHwgcmF0aW8gPiAxLjApIHtcbiAgICAgICAgdXRpbC50aHJvdygnSW52YWxpZCBhdXRvLXNjcm9sbC1yYXRpbyAnICsgcmF0aW8gKyAnLiBNdXN0IGJlIGJldHdlZW4gMCBhbmQgMScpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJhdGlvO1xuICAgIH07XG5cbiAgICAvLyBQcmV2ZW50IGNsaWNrcyBvbmx5IG9uIGRlc2t0b3BcbiAgICB0aGlzLnNob3VsZEJsb2NrID0gdXRpbC5nbG9iYWxzLmFjdHVhbE1vYmlsZU9TID09PSAnb3RoZXInO1xuXG4gICAgLy8gQmluZCBoYW5kbGVyc1xuICAgIHRoaXMub25EcmFnU3RhcnQgPSB0aGlzLm9uRHJhZ1N0YXJ0LmJpbmQodGhpcyk7XG4gICAgdGhpcy5vbkRyYWcgPSB0aGlzLm9uRHJhZy5iaW5kKHRoaXMpO1xuICAgIHRoaXMub25EcmFnRW5kID0gdGhpcy5vbkRyYWdFbmQuYmluZCh0aGlzKTtcbiAgICB0aGlzLm9uUmVzaXplID0gdGhpcy5vblJlc2l6ZS5iaW5kKHRoaXMpO1xuXG4gICAgdGhpcy5fc2hvdWxkRml4U2Nyb2xsID0gdXRpbC5nbG9iYWxzLmFjdHVhbE1vYmlsZU9TID09PSAnaW9zJztcbiAgfVxuXG4gIGluaXQoeyBzd2lwZWFibGUsIGF1dG9SZWZyZXNoIH0gPSB7fSkge1xuICAgIHRoaXMuaW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgIHRoaXMudGFyZ2V0ID0gdGhpcy5nZXRFbGVtZW50KCkuY2hpbGRyZW5bMF07XG4gICAgdGhpcy5ibG9ja2VyID0gdGhpcy5nZXRFbGVtZW50KCkuY2hpbGRyZW5bMV07XG4gICAgaWYgKCF0aGlzLnRhcmdldCB8fCAhdGhpcy5ibG9ja2VyKSB7XG4gICAgICB1dGlsLnRocm93KCdFeHBlY3RlZCBcInRhcmdldFwiIGFuZCBcImJsb2NrZXJcIiBlbGVtZW50cyB0byBleGlzdCBiZWZvcmUgaW5pdGlhbGl6aW5nIFN3aXBlcicpO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5zaG91bGRCbG9jaykge1xuICAgICAgdGhpcy5ibG9ja2VyLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgfVxuXG4gICAgLy8gQWRkIGNsYXNzZXNcbiAgICB0aGlzLmdldEVsZW1lbnQoKS5jbGFzc0xpc3QuYWRkKCdvbnMtc3dpcGVyJyk7XG4gICAgdGhpcy50YXJnZXQuY2xhc3NMaXN0LmFkZCgnb25zLXN3aXBlci10YXJnZXQnKTtcbiAgICB0aGlzLmJsb2NrZXIuY2xhc3NMaXN0LmFkZCgnb25zLXN3aXBlci1ibG9ja2VyJyk7XG5cbiAgICAvLyBTZXR1cCBsaXN0ZW5lcnNcbiAgICB0aGlzLl9nZXN0dXJlRGV0ZWN0b3IgPSBuZXcgR2VzdHVyZURldGVjdG9yKHRoaXMuZ2V0RWxlbWVudCgpLFxuICAgICAgeyBkcmFnTWluRGlzdGFuY2U6IDEsIGRyYWdMb2NrVG9BeGlzOiB0cnVlLCBwYXNzaXZlOiAhdGhpcy5fc2hvdWxkRml4U2Nyb2xsIH1cbiAgICApO1xuICAgIHRoaXMuX211dGF0aW9uT2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcigoKSA9PiB0aGlzLnJlZnJlc2goKSk7XG4gICAgdGhpcy51cGRhdGVTd2lwZWFibGUoc3dpcGVhYmxlKTtcbiAgICB0aGlzLnVwZGF0ZUF1dG9SZWZyZXNoKGF1dG9SZWZyZXNoKTtcblxuICAgIC8vIFNldHVwIGluaXRpYWwgbGF5b3V0XG4gICAgdGhpcy5fc2Nyb2xsID0gdGhpcy5fb2Zmc2V0ID0gdGhpcy5fbGFzdEFjdGl2ZUluZGV4ID0gMDtcbiAgICB0aGlzLl91cGRhdGVMYXlvdXQoKTtcbiAgICB0aGlzLl9zZXR1cEluaXRpYWxJbmRleCgpO1xuICAgIHNldEltbWVkaWF0ZSgoKSA9PiB0aGlzLmluaXRpYWxpemVkICYmIHRoaXMuX3NldHVwSW5pdGlhbEluZGV4KCkpO1xuXG4gICAgLy8gRml4IHJlbmRlcmluZyBnbGl0Y2ggb24gQW5kcm9pZCA0LjFcbiAgICAvLyBGaXggZm9yIGlmcmFtZXMgd2hlcmUgdGhlIHdpZHRoIGlzIGluY29uc2lzdGVudCBhdCB0aGUgYmVnaW5uaW5nXG4gICAgaWYgKHdpbmRvdyAhPT0gd2luZG93LnBhcmVudCB8fCB0aGlzLm9mZnNldEhlaWdodCA9PT0gMCkge1xuICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB0aGlzLmluaXRpYWxpemVkICYmIHRoaXMub25SZXNpemUoKSk7XG4gICAgfVxuICB9XG5cbiAgZGlzcG9zZSgpIHtcbiAgICB0aGlzLmluaXRpYWxpemVkID0gZmFsc2U7XG4gICAgdGhpcy51cGRhdGVTd2lwZWFibGUoZmFsc2UpO1xuICAgIHRoaXMudXBkYXRlQXV0b1JlZnJlc2goZmFsc2UpO1xuXG4gICAgdGhpcy5fZ2VzdHVyZURldGVjdG9yICYmIHRoaXMuX2dlc3R1cmVEZXRlY3Rvci5kaXNwb3NlKCk7XG4gICAgdGhpcy50YXJnZXQgPSB0aGlzLmJsb2NrZXIgPSB0aGlzLl9nZXN0dXJlRGV0ZWN0b3IgPSB0aGlzLl9tdXRhdGlvbk9ic2VydmVyID0gbnVsbDtcblxuICAgIHRoaXMuc2V0dXBSZXNpemUoZmFsc2UpO1xuICB9XG5cbiAgb25SZXNpemUoKSB7XG4gICAgY29uc3QgaSA9IHRoaXMuX3Njcm9sbCAvIHRoaXMudGFyZ2V0U2l6ZTtcbiAgICB0aGlzLl9yZXNldCgpO1xuICAgIHRoaXMuc2V0QWN0aXZlSW5kZXgoaSk7XG4gICAgdGhpcy5yZWZyZXNoKCk7XG4gIH1cblxuICBnZXQgaXRlbUNvdW50KCkge1xuICAgIHJldHVybiB0aGlzLnRhcmdldC5jaGlsZHJlbi5sZW5ndGg7XG4gIH1cblxuICBnZXQgaXRlbU51bVNpemUoKSB7XG4gICAgaWYgKHR5cGVvZiB0aGlzLl9pdGVtTnVtU2l6ZSAhPT0gJ251bWJlcicgfHwgdGhpcy5faXRlbU51bVNpemUgIT09IHRoaXMuX2l0ZW1OdW1TaXplKSB7XG4gICAgICB0aGlzLl9pdGVtTnVtU2l6ZSA9IHRoaXMuX2NhbGN1bGF0ZUl0ZW1TaXplKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9pdGVtTnVtU2l6ZTtcbiAgfVxuXG4gIGdldCBtYXhTY3JvbGwoKSB7XG4gICAgY29uc3QgbWF4ID0gdGhpcy5pdGVtQ291bnQgKiB0aGlzLml0ZW1OdW1TaXplIC0gdGhpcy50YXJnZXRTaXplO1xuICAgIHJldHVybiBNYXRoLmNlaWwobWF4IDwgMCA/IDAgOiBtYXgpOyAvLyBOZWVkIHRvIHJldHVybiBhbiBpbnRlZ2VyIHZhbHVlLlxuICB9XG5cbiAgX2NhbGN1bGF0ZUl0ZW1TaXplKCkge1xuICAgIGNvbnN0IG1hdGNoZXMgPSB0aGlzLml0ZW1TaXplLm1hdGNoKC9eKFxcZCspKHB4fCUpLyk7XG5cbiAgICBpZiAoIW1hdGNoZXMpIHtcbiAgICAgIHV0aWwudGhyb3coYEludmFsaWQgc3RhdGU6IHN3aXBlcidzIHNpemUgdW5pdCBtdXN0IGJlICclJyBvciAncHgnYCk7XG4gICAgfVxuXG4gICAgY29uc3QgdmFsdWUgPSBwYXJzZUludChtYXRjaGVzWzFdLCAxMCk7XG4gICAgcmV0dXJuIG1hdGNoZXNbMl0gPT09ICclJyA/IE1hdGgucm91bmQodmFsdWUgLyAxMDAgKiB0aGlzLnRhcmdldFNpemUpIDogdmFsdWU7XG4gIH1cblxuICBfc2V0dXBJbml0aWFsSW5kZXgoKSB7XG4gICAgdGhpcy5fcmVzZXQoKTtcbiAgICB0aGlzLl9sYXN0QWN0aXZlSW5kZXggPSBNYXRoLm1heChNYXRoLm1pbihOdW1iZXIodGhpcy5nZXRJbml0aWFsSW5kZXgoKSksIHRoaXMuaXRlbUNvdW50KSwgMCk7XG4gICAgdGhpcy5fc2Nyb2xsID0gdGhpcy5fb2Zmc2V0ICsgdGhpcy5pdGVtTnVtU2l6ZSAqIHRoaXMuX2xhc3RBY3RpdmVJbmRleDtcbiAgICB0aGlzLl9zY3JvbGxUbyh0aGlzLl9zY3JvbGwpO1xuICB9XG5cbiAgX3NldFN3aXBpbmcodG9nZ2xlKSB7XG4gICAgdGhpcy50YXJnZXQuY2xhc3NMaXN0LnRvZ2dsZSgnc3dpcGluZycsIHRvZ2dsZSk7IC8vIEhpZGVzIGV2ZXJ5dGhpbmcgZXhjZXB0IHNob3duIHBhZ2VzXG4gIH1cblxuICBzZXRBY3RpdmVJbmRleChpbmRleCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgdGhpcy5fc2V0U3dpcGluZyh0cnVlKTtcbiAgICBpbmRleCA9IE1hdGgubWF4KDAsIE1hdGgubWluKGluZGV4LCB0aGlzLml0ZW1Db3VudCAtIDEpKTtcbiAgICBjb25zdCBzY3JvbGwgPSBNYXRoLm1heCgwLCBNYXRoLm1pbih0aGlzLm1heFNjcm9sbCwgdGhpcy5fb2Zmc2V0ICsgdGhpcy5pdGVtTnVtU2l6ZSAqIGluZGV4KSk7XG5cbiAgICBpZiAocGxhdGZvcm0uaXNVSVdlYlZpZXcoKSkge1xuICAgICAgLyogRGlydHkgZml4IGZvciAjMjIzMShodHRwczovL2dpdGh1Yi5jb20vT25zZW5VSS9PbnNlblVJL2lzc3Vlcy8yMjMxKS4gYmVnaW4gKi9cbiAgICAgIGNvbnN0IGNvbmNhdCA9IGFycmF5T2ZBcnJheSA9PiBBcnJheS5wcm90b3R5cGUuY29uY2F0LmFwcGx5KFtdLCBhcnJheU9mQXJyYXkpO1xuICAgICAgY29uc3QgY29udGVudHMgPSBjb25jYXQoXG4gICAgICAgIHV0aWwuYXJyYXlGcm9tKHRoaXMudGFyZ2V0LmNoaWxkcmVuKS5tYXAocGFnZSA9PiB7XG4gICAgICAgICAgcmV0dXJuIHV0aWwuYXJyYXlGcm9tKHBhZ2UuY2hpbGRyZW4pXG4gICAgICAgICAgICAuZmlsdGVyKGNoaWxkID0+IGNoaWxkLmNsYXNzTGlzdC5jb250YWlucygncGFnZV9fY29udGVudCcpKTtcbiAgICAgICAgfSlcbiAgICAgICk7XG5cbiAgICAgIGNvbnN0IG1hcCA9IG5ldyBNYXAoKTtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgICAgIGNvbnRlbnRzLmZvckVhY2goY29udGVudCA9PiB7XG4gICAgICAgICAgICBtYXAuc2V0KGNvbnRlbnQsIGNvbnRlbnQuZ2V0QXR0cmlidXRlKCdjbGFzcycpKTtcbiAgICAgICAgICAgIGNvbnRlbnQuY2xhc3NMaXN0LmFkZCgncGFnZV9fY29udGVudC0tc3VwcHJlc3MtbGF5ZXItY3JlYXRpb24nKVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShyZXNvbHZlKTtcbiAgICAgICAgfSlcbiAgICAgICAgLnRoZW4oKCkgPT4gdGhpcy5fY2hhbmdlVG8oc2Nyb2xsLCBvcHRpb25zKSlcbiAgICAgICAgLnRoZW4oKCkgPT4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgICAgY29udGVudHMuZm9yRWFjaChjb250ZW50ID0+IHtcbiAgICAgICAgICAgIGNvbnRlbnQuc2V0QXR0cmlidXRlKCdjbGFzcycsIG1hcC5nZXQoY29udGVudCkpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShyZXNvbHZlKTtcbiAgICAgICAgfSkpXG4gICAgICApO1xuICAgICAgLyogZW5kICovXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLl9jaGFuZ2VUbyhzY3JvbGwsIG9wdGlvbnMpO1xuICAgIH1cbiAgfVxuXG4gIGdldEFjdGl2ZUluZGV4KHNjcm9sbCA9IHRoaXMuX3Njcm9sbCkge1xuICAgIHNjcm9sbCAtPSB0aGlzLl9vZmZzZXQ7XG4gICAgY29uc3QgY291bnQgPSB0aGlzLml0ZW1Db3VudCxcbiAgICAgIHNpemUgPSB0aGlzLml0ZW1OdW1TaXplO1xuXG4gICAgaWYgKHRoaXMuaXRlbU51bVNpemUgPT09IDAgfHwgIXV0aWwuaXNJbnRlZ2VyKHNjcm9sbCkpIHtcbiAgICAgIHJldHVybiB0aGlzLl9sYXN0QWN0aXZlSW5kZXg7XG4gICAgfVxuXG4gICAgaWYgKHNjcm9sbCA8PSAwKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgIGlmIChzaXplICogaSA8PSBzY3JvbGwgJiYgc2l6ZSAqIChpICsgMSkgPiBzY3JvbGwpIHtcbiAgICAgICAgcmV0dXJuIGk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvdW50IC0gMTtcbiAgfVxuXG4gIHNldHVwUmVzaXplKGFkZCkge1xuICAgIHdpbmRvd1soYWRkID8gJ2FkZCcgOiAncmVtb3ZlJykgKyAnRXZlbnRMaXN0ZW5lciddKCdyZXNpemUnLCB0aGlzLm9uUmVzaXplLCB0cnVlKTtcbiAgfVxuXG4gIHNob3coKSB7XG4gICAgdGhpcy5zZXR1cFJlc2l6ZSh0cnVlKTtcbiAgICB0aGlzLm9uUmVzaXplKCk7XG4gICAgc2V0VGltZW91dCgoKSA9PiB0aGlzLnRhcmdldCAmJiB0aGlzLnRhcmdldC5jbGFzc0xpc3QuYWRkKCdhY3RpdmUnKSwgMTAwMC82MCk7IC8vIEhpZGUgZWxlbWVudHMgYWZ0ZXIgYW5pbWF0aW9uc1xuICB9XG5cbiAgaGlkZSgpIHtcbiAgICB0aGlzLnNldHVwUmVzaXplKGZhbHNlKTtcbiAgICB0aGlzLnRhcmdldC5jbGFzc0xpc3QucmVtb3ZlKCdhY3RpdmUnKTsgLy8gU2hvdyBlbGVtZW50cyBiZWZvcmUgYW5pbWF0aW9uc1xuICB9XG5cbiAgdXBkYXRlU3dpcGVhYmxlKHNob3VsZFVwZGF0ZSkge1xuICAgIGlmICh0aGlzLl9nZXN0dXJlRGV0ZWN0b3IpIHtcbiAgICAgIGNvbnN0IGFjdGlvbiA9IHNob3VsZFVwZGF0ZSA/ICdvbicgOiAnb2ZmJztcbiAgICAgIHRoaXMuX2dlc3R1cmVEZXRlY3RvclthY3Rpb25dKCdkcmFnJywgdGhpcy5vbkRyYWcpO1xuICAgICAgdGhpcy5fZ2VzdHVyZURldGVjdG9yW2FjdGlvbl0oJ2RyYWdzdGFydCcsIHRoaXMub25EcmFnU3RhcnQpO1xuICAgICAgdGhpcy5fZ2VzdHVyZURldGVjdG9yW2FjdGlvbl0oJ2RyYWdlbmQnLCB0aGlzLm9uRHJhZ0VuZCk7XG4gICAgfVxuICB9XG5cbiAgdXBkYXRlQXV0b1JlZnJlc2goc2hvdWxkV2F0Y2gpIHtcbiAgICBpZiAodGhpcy5fbXV0YXRpb25PYnNlcnZlcikge1xuICAgICAgc2hvdWxkV2F0Y2hcbiAgICAgICAgPyB0aGlzLl9tdXRhdGlvbk9ic2VydmVyLm9ic2VydmUodGhpcy50YXJnZXQsIHsgY2hpbGRMaXN0OiB0cnVlIH0pXG4gICAgICAgIDogdGhpcy5fbXV0YXRpb25PYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgfVxuICB9XG5cbiAgdXBkYXRlSXRlbVNpemUobmV3U2l6ZSkge1xuICAgIHRoaXMuaXRlbVNpemUgPSBuZXdTaXplIHx8ICcxMDAlJztcbiAgICB0aGlzLnJlZnJlc2goKTtcbiAgfVxuXG4gIHRvZ2dsZUJsb2NrZXIoYmxvY2spIHtcbiAgICB0aGlzLmJsb2NrZXIuc3R5bGUucG9pbnRlckV2ZW50cyA9IGJsb2NrID8gJ2F1dG8nIDogJ25vbmUnO1xuICB9XG5cbiAgX2NhbkNvbnN1bWVHZXN0dXJlKGdlc3R1cmUpIHtcbiAgICBjb25zdCBkID0gZ2VzdHVyZS5kaXJlY3Rpb247XG4gICAgY29uc3QgaXNGaXJzdCA9IHRoaXMuX3Njcm9sbCA9PT0gMCAmJiAhdGhpcy5pc092ZXJTY3JvbGxhYmxlKCk7XG4gICAgY29uc3QgaXNMYXN0ID0gdGhpcy5fc2Nyb2xsID09PSB0aGlzLm1heFNjcm9sbCAmJiAhdGhpcy5pc092ZXJTY3JvbGxhYmxlKCk7XG5cbiAgICByZXR1cm4gdGhpcy5pc1ZlcnRpY2FsKClcbiAgICAgID8gKChkID09PSAnZG93bicgJiYgIWlzRmlyc3QpIHx8IChkID09PSAndXAnICYmICFpc0xhc3QpKVxuICAgICAgOiAoKGQgPT09ICdyaWdodCcgJiYgIWlzRmlyc3QpIHx8IChkID09PSAnbGVmdCcgJiYgIWlzTGFzdCkpO1xuICB9XG5cbiAgb25EcmFnU3RhcnQoZXZlbnQpIHtcbiAgICB0aGlzLl9pZ25vcmVEcmFnID0gZXZlbnQuY29uc3VtZWQgfHwgIXV0aWwuaXNWYWxpZEdlc3R1cmUoZXZlbnQpO1xuXG4gICAgaWYgKCF0aGlzLl9pZ25vcmVEcmFnKSB7XG4gICAgICBjb25zdCBjb25zdW1lID0gZXZlbnQuY29uc3VtZTtcbiAgICAgIGV2ZW50LmNvbnN1bWUgPSAoKSA9PiB7IGNvbnN1bWUgJiYgY29uc3VtZSgpOyB0aGlzLl9pZ25vcmVEcmFnID0gdHJ1ZTsgfTtcblxuICAgICAgaWYgKHRoaXMuX2NhbkNvbnN1bWVHZXN0dXJlKGV2ZW50Lmdlc3R1cmUpKSB7XG4gICAgICAgIGNvbnN0IHN0YXJ0WCA9IGV2ZW50Lmdlc3R1cmUuY2VudGVyICYmIGV2ZW50Lmdlc3R1cmUuY2VudGVyLmNsaWVudFggfHwgMCxcbiAgICAgICAgICBkaXN0RnJvbUVkZ2UgPSB0aGlzLmdldEJ1YmJsZVdpZHRoKCkgfHwgMCxcbiAgICAgICAgICBzdGFydCA9ICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN1bWUgJiYgY29uc3VtZSgpO1xuICAgICAgICAgICAgZXZlbnQuY29uc3VtZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5fc3RhcnRlZCA9IHRydWU7IC8vIEF2b2lkIHN0YXJ0aW5nIGRyYWcgZnJvbSBvdXRzaWRlXG4gICAgICAgICAgICB0aGlzLnNob3VsZEJsb2NrICYmIHRoaXMudG9nZ2xlQmxvY2tlcih0cnVlKTtcbiAgICAgICAgICAgIHRoaXMuX3NldFN3aXBpbmcodHJ1ZSk7XG4gICAgICAgICAgICB1dGlsLmlvc1ByZXZlbnRTY3JvbGwodGhpcy5fZ2VzdHVyZURldGVjdG9yKTtcbiAgICAgICAgICB9O1xuXG4gICAgICAgIC8vIExldCBwYXJlbnQgZWxlbWVudHMgY29uc3VtZSB0aGUgZ2VzdHVyZSBvciBjb25zdW1lIGl0IHJpZ2h0IGF3YXlcbiAgICAgICAgc3RhcnRYIDwgZGlzdEZyb21FZGdlIHx8IHN0YXJ0WCA+ICh0aGlzLnRhcmdldFNpemUgLSBkaXN0RnJvbUVkZ2UpXG4gICAgICAgICAgPyBzZXRJbW1lZGlhdGUoKCkgPT4gIXRoaXMuX2lnbm9yZURyYWcgJiYgc3RhcnQoKSlcbiAgICAgICAgICA6IHN0YXJ0KCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgb25EcmFnKGV2ZW50KSB7XG4gICAgaWYgKCFldmVudC5nZXN0dXJlIHx8IHRoaXMuX2lnbm9yZURyYWcgfHwgIXRoaXMuX3N0YXJ0ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLl9jb250aW51ZWQgPSB0cnVlOyAvLyBGaXggZm9yIHJhbmRvbSAnZHJhZ2VuZCcgd2l0aG91dCAnZHJhZydcbiAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblxuICAgIHRoaXMuX3Njcm9sbFRvKHRoaXMuX3Njcm9sbCAtIHRoaXMuX2dldERlbHRhKGV2ZW50KSwgeyB0aHJvdHRsZTogdHJ1ZSB9KTtcbiAgfVxuXG4gIG9uRHJhZ0VuZChldmVudCkge1xuICAgIHRoaXMuX3N0YXJ0ZWQgPSBmYWxzZTtcbiAgICBpZiAoIWV2ZW50Lmdlc3R1cmUgfHwgdGhpcy5faWdub3JlRHJhZyB8fCAhdGhpcy5fY29udGludWVkKSB7XG4gICAgICB0aGlzLl9pZ25vcmVEcmFnID0gdHJ1ZTsgLy8gb25EcmFnRW5kIG1pZ2h0IGZpcmUgYmVmb3JlIG9uRHJhZ1N0YXJ0J3Mgc2V0SW1tZWRpYXRlXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5fY29udGludWVkID0gZmFsc2U7XG4gICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG5cbiAgICBjb25zdCBzY3JvbGwgPSB0aGlzLl9zY3JvbGwgLSB0aGlzLl9nZXREZWx0YShldmVudCk7XG4gICAgY29uc3Qgbm9ybWFsaXplZFNjcm9sbCA9IHRoaXMuX25vcm1hbGl6ZVNjcm9sbChzY3JvbGwpO1xuICAgIHNjcm9sbCA9PT0gbm9ybWFsaXplZFNjcm9sbCA/IHRoaXMuX3N0YXJ0TW9tZW50dW1TY3JvbGwoc2Nyb2xsLCBldmVudCkgOiB0aGlzLl9raWxsT3ZlclNjcm9sbChub3JtYWxpemVkU2Nyb2xsKTtcbiAgICB0aGlzLnNob3VsZEJsb2NrICYmIHRoaXMudG9nZ2xlQmxvY2tlcihmYWxzZSk7XG4gIH1cblxuICBfc3RhcnRNb21lbnR1bVNjcm9sbChzY3JvbGwsIGV2ZW50KSB7XG4gICAgY29uc3QgdmVsb2NpdHkgPSB0aGlzLl9nZXRWZWxvY2l0eShldmVudCksXG4gICAgICBtYXRjaGVzRGlyZWN0aW9uID0gZXZlbnQuZ2VzdHVyZS5pbnRlcmltRGlyZWN0aW9uID09PSB0aGlzLmRNLmRpclt0aGlzLl9nZXREZWx0YShldmVudCkgPCAwID8gMCA6IDFdO1xuXG4gICAgY29uc3QgbmV4dFNjcm9sbCA9IHRoaXMuX2dldEF1dG9TY3JvbGwoc2Nyb2xsLCB2ZWxvY2l0eSwgbWF0Y2hlc0RpcmVjdGlvbik7XG4gICAgbGV0IGR1cmF0aW9uID0gTWF0aC5hYnMobmV4dFNjcm9sbCAtIHNjcm9sbCkgLyAodmVsb2NpdHkgKyAwLjAxKSAvIDEwMDA7XG4gICAgZHVyYXRpb24gPSBNYXRoLm1pbiguMjUsIE1hdGgubWF4KC4xLCBkdXJhdGlvbikpO1xuXG4gICAgdGhpcy5fY2hhbmdlVG8obmV4dFNjcm9sbCwgeyBzd2lwZTogdHJ1ZSwgYW5pbWF0aW9uT3B0aW9uczogeyBkdXJhdGlvbiwgdGltaW5nOiAnY3ViaWMtYmV6aWVyKC40LCAuNywgLjUsIDEpJyB9IH0pO1xuICB9XG5cbiAgX2tpbGxPdmVyU2Nyb2xsKHNjcm9sbCkge1xuICAgIHRoaXMuX3Njcm9sbCA9IHNjcm9sbDtcbiAgICBjb25zdCBkaXJlY3Rpb24gPSB0aGlzLmRNLmRpcltOdW1iZXIoc2Nyb2xsID4gMCldO1xuICAgIGNvbnN0IGtpbGxPdmVyU2Nyb2xsID0gKCkgPT4gdGhpcy5fY2hhbmdlVG8oc2Nyb2xsLCB7IGFuaW1hdGlvbk9wdGlvbnM6IHsgZHVyYXRpb246IC40LCB0aW1pbmc6ICdjdWJpYy1iZXppZXIoLjEsIC40LCAuMSwgMSknIH0gfSk7XG4gICAgdGhpcy5vdmVyU2Nyb2xsSG9vayh7IGRpcmVjdGlvbiwga2lsbE92ZXJTY3JvbGwgfSkgfHwga2lsbE92ZXJTY3JvbGwoKTtcbiAgfVxuXG4gIF9jaGFuZ2VUbyhzY3JvbGwsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IGUgPSB7IGFjdGl2ZUluZGV4OiB0aGlzLmdldEFjdGl2ZUluZGV4KHNjcm9sbCksIGxhc3RBY3RpdmVJbmRleDogdGhpcy5fbGFzdEFjdGl2ZUluZGV4LCBzd2lwZTogb3B0aW9ucy5zd2lwZSB8fCBmYWxzZSB9O1xuICAgIGNvbnN0IGNoYW5nZSA9IGUuYWN0aXZlSW5kZXggIT09IGUubGFzdEFjdGl2ZUluZGV4O1xuICAgIGNvbnN0IGNhbmNlbGVkID0gY2hhbmdlID8gdGhpcy5wcmVDaGFuZ2VIb29rKGUpIDogZmFsc2U7XG5cbiAgICB0aGlzLl9zY3JvbGwgPSBjYW5jZWxlZCA/IHRoaXMuX29mZnNldCArIGUubGFzdEFjdGl2ZUluZGV4ICogdGhpcy5pdGVtTnVtU2l6ZSA6IHNjcm9sbDtcbiAgICB0aGlzLl9sYXN0QWN0aXZlSW5kZXggPSBjYW5jZWxlZCA/IGUubGFzdEFjdGl2ZUluZGV4IDogZS5hY3RpdmVJbmRleDtcblxuICAgIHJldHVybiB0aGlzLl9zY3JvbGxUbyh0aGlzLl9zY3JvbGwsIG9wdGlvbnMpLnRoZW4oKCkgPT4ge1xuICAgICAgaWYgKHNjcm9sbCA9PT0gdGhpcy5fc2Nyb2xsICYmICFjYW5jZWxlZCkge1xuICAgICAgICB0aGlzLl9zZXRTd2lwaW5nKGZhbHNlKTtcbiAgICAgICAgY2hhbmdlICYmIHRoaXMucG9zdENoYW5nZUhvb2soZSk7XG4gICAgICB9IGVsc2UgaWYgKG9wdGlvbnMucmVqZWN0KSB7XG4gICAgICAgIHRoaXMuX3NldFN3aXBpbmcoZmFsc2UpO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoJ0NhbmNlbGVkJyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBfc2Nyb2xsVG8oc2Nyb2xsLCBvcHRpb25zID0ge30pIHtcbiAgICBpZiAob3B0aW9ucy50aHJvdHRsZSkge1xuICAgICAgY29uc3QgcmF0aW8gPSAwLjM1O1xuICAgICAgaWYgKHNjcm9sbCA8IDApIHtcbiAgICAgICAgc2Nyb2xsID0gdGhpcy5pc092ZXJTY3JvbGxhYmxlKCkgPyBNYXRoLnJvdW5kKHNjcm9sbCAqIHJhdGlvKSA6IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBtYXhTY3JvbGwgPSB0aGlzLm1heFNjcm9sbDtcbiAgICAgICAgaWYgKG1heFNjcm9sbCA8IHNjcm9sbCkge1xuICAgICAgICAgIHNjcm9sbCA9IHRoaXMuaXNPdmVyU2Nyb2xsYWJsZSgpID8gbWF4U2Nyb2xsICsgTWF0aC5yb3VuZCgoc2Nyb2xsIC0gbWF4U2Nyb2xsKSAqIHJhdGlvKSA6IG1heFNjcm9sbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IG9wdCA9IG9wdGlvbnMuYW5pbWF0aW9uICA9PT0gJ25vbmUnID8ge30gOiBvcHRpb25zLmFuaW1hdGlvbk9wdGlvbnM7XG4gICAgdGhpcy5zY3JvbGxIb29rICYmIHRoaXMuaXRlbU51bVNpemUgPiAwICYmIHRoaXMuc2Nyb2xsSG9vaygoc2Nyb2xsIC8gdGhpcy5pdGVtTnVtU2l6ZSkudG9GaXhlZCgyKSwgb3B0aW9ucy5hbmltYXRpb25PcHRpb25zIHx8IHt9KTtcblxuICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+XG4gICAgICBhbmltaXQodGhpcy50YXJnZXQpXG4gICAgICAgIC5xdWV1ZSh7IHRyYW5zZm9ybTogdGhpcy5fZ2V0VHJhbnNmb3JtKHNjcm9sbCkgfSwgb3B0KVxuICAgICAgICAucGxheShyZXNvbHZlKVxuICAgICk7XG4gIH1cblxuICBfZ2V0QXV0b1Njcm9sbChzY3JvbGwsIHZlbG9jaXR5LCBtYXRjaGVzRGlyZWN0aW9uKSB7XG4gICAgY29uc3QgbWF4ID0gdGhpcy5tYXhTY3JvbGwsXG4gICAgICBvZmZzZXQgPSB0aGlzLl9vZmZzZXQsXG4gICAgICBzaXplID0gdGhpcy5pdGVtTnVtU2l6ZTtcblxuICAgIGlmICghdGhpcy5pc0F1dG9TY3JvbGxhYmxlKCkpIHtcbiAgICAgIHJldHVybiBNYXRoLm1heCgwLCBNYXRoLm1pbihtYXgsIHNjcm9sbCkpO1xuICAgIH1cblxuICAgIGxldCBhcnIgPSBbXTtcbiAgICBmb3IgKGxldCBzID0gb2Zmc2V0OyBzIDwgbWF4OyBzICs9IHNpemUpIHtcbiAgICAgIGFyci5wdXNoKHMpO1xuICAgIH1cbiAgICBhcnIucHVzaChtYXgpO1xuXG4gICAgYXJyID0gYXJyXG4gICAgICAuc29ydCgobGVmdCwgcmlnaHQpID0+IE1hdGguYWJzKGxlZnQgLSBzY3JvbGwpIC0gTWF0aC5hYnMocmlnaHQgLSBzY3JvbGwpKVxuICAgICAgLmZpbHRlcigoaXRlbSwgcG9zKSA9PiAhcG9zIHx8IGl0ZW0gIT09IGFycltwb3MgLSAxXSk7XG5cbiAgICBsZXQgcmVzdWx0ID0gYXJyWzBdO1xuICAgIGNvbnN0IGxhc3RTY3JvbGwgPSB0aGlzLl9sYXN0QWN0aXZlSW5kZXggKiBzaXplICsgb2Zmc2V0O1xuICAgIGNvbnN0IHNjcm9sbFJhdGlvID0gTWF0aC5hYnMoc2Nyb2xsIC0gbGFzdFNjcm9sbCkgLyBzaXplO1xuXG4gICAgaWYgKHNjcm9sbFJhdGlvIDw9IHRoaXMuZ2V0QXV0b1Njcm9sbFJhdGlvKG1hdGNoZXNEaXJlY3Rpb24sIHZlbG9jaXR5LCBzaXplKSkge1xuICAgICAgcmVzdWx0ID0gbGFzdFNjcm9sbDtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHNjcm9sbFJhdGlvIDwgMS4wICYmIGFyclswXSA9PT0gbGFzdFNjcm9sbCAmJiBhcnIubGVuZ3RoID4gMSkge1xuICAgICAgICByZXN1bHQgPSBhcnJbMV07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBNYXRoLm1heCgwLCBNYXRoLm1pbihtYXgsIHJlc3VsdCkpO1xuICB9XG5cbiAgX3Jlc2V0KCkge1xuICAgIHRoaXMuX3RhcmdldFNpemUgPSB0aGlzLl9pdGVtTnVtU2l6ZSA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIF9ub3JtYWxpemVTY3JvbGwoc2Nyb2xsKSB7XG4gICAgcmV0dXJuIE1hdGgubWF4KCBNYXRoLm1pbihzY3JvbGwsIHRoaXMubWF4U2Nyb2xsKSwgMClcbiAgfVxuXG4gIHJlZnJlc2goKSB7XG4gICAgdGhpcy5fcmVzZXQoKTtcbiAgICB0aGlzLl91cGRhdGVMYXlvdXQoKTtcblxuICAgIGlmICh1dGlsLmlzSW50ZWdlcih0aGlzLl9zY3JvbGwpKSB7XG4gICAgICBjb25zdCBzY3JvbGwgPSB0aGlzLl9ub3JtYWxpemVTY3JvbGwodGhpcy5fc2Nyb2xsKTtcbiAgICAgIHNjcm9sbCAhPT0gdGhpcy5fc2Nyb2xsID8gdGhpcy5fa2lsbE92ZXJTY3JvbGwoc2Nyb2xsKSA6IHRoaXMuX2NoYW5nZVRvKHNjcm9sbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3NldHVwSW5pdGlhbEluZGV4KCk7XG4gICAgfVxuXG4gICAgdGhpcy5yZWZyZXNoSG9vaygpO1xuICB9XG5cbiAgZ2V0IHRhcmdldFNpemUoKSB7XG4gICAgaWYgKCF0aGlzLl90YXJnZXRTaXplKSB7XG4gICAgICB0aGlzLl90YXJnZXRTaXplID0gdGhpcy50YXJnZXRbYG9mZnNldCR7dGhpcy5kTS5zaXplfWBdO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fdGFyZ2V0U2l6ZTtcbiAgfVxuXG4gIF9nZXREZWx0YShldmVudCkge1xuICAgIHJldHVybiBldmVudC5nZXN0dXJlW2BkZWx0YSR7dGhpcy5kTS5heGlzfWBdO1xuICB9XG5cbiAgX2dldFZlbG9jaXR5KGV2ZW50KSB7XG4gICAgcmV0dXJuIGV2ZW50Lmdlc3R1cmVbYHZlbG9jaXR5JHt0aGlzLmRNLmF4aXN9YF07XG4gIH1cblxuICBfZ2V0VHJhbnNmb3JtKHNjcm9sbCkge1xuICAgIHJldHVybiBgdHJhbnNsYXRlM2QoJHt0aGlzLmRNLnQzZFswXX0key1zY3JvbGx9JHt0aGlzLmRNLnQzZFsxXX0pYDtcbiAgfVxuXG4gIF91cGRhdGVMYXlvdXQoKSB7XG4gICAgdGhpcy5kTSA9IGRpcmVjdGlvbk1hcFt0aGlzLmlzVmVydGljYWwoKSA/ICd2ZXJ0aWNhbCcgOiAnaG9yaXpvbnRhbCddO1xuICAgIHRoaXMudGFyZ2V0LmNsYXNzTGlzdC50b2dnbGUoJ29ucy1zd2lwZXItdGFyZ2V0LS12ZXJ0aWNhbCcsIHRoaXMuaXNWZXJ0aWNhbCgpKTtcblxuICAgIGZvciAobGV0IGMgPSB0aGlzLnRhcmdldC5jaGlsZHJlblswXTsgYzsgYyA9IGMubmV4dEVsZW1lbnRTaWJsaW5nKSB7XG4gICAgICBjLnN0eWxlW3RoaXMuZE0uc2l6ZS50b0xvd2VyQ2FzZSgpXSA9IHRoaXMuaXRlbVNpemU7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaXNDZW50ZXJlZCgpKSB7XG4gICAgICB0aGlzLl9vZmZzZXQgPSAodGhpcy50YXJnZXRTaXplIC0gdGhpcy5pdGVtTnVtU2l6ZSkgLyAtMiB8fCAwO1xuICAgIH1cbiAgfVxufVxuXG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgb25zRWxlbWVudHMgZnJvbSAnLi4vb25zL2VsZW1lbnRzJztcbmltcG9ydCB1dGlsIGZyb20gJy4uL29ucy91dGlsJztcbmltcG9ydCBCYXNlRWxlbWVudCBmcm9tICcuL2Jhc2UvYmFzZS1lbGVtZW50JztcbmltcG9ydCBjb250ZW50UmVhZHkgZnJvbSAnLi4vb25zL2NvbnRlbnQtcmVhZHknO1xuaW1wb3J0IFN3aXBlciBmcm9tICcuLi9vbnMvaW50ZXJuYWwvc3dpcGVyJztcblxuLyoqXG4gKiBAZWxlbWVudCBvbnMtY2Fyb3VzZWxcbiAqIEBjYXRlZ29yeSBjYXJvdXNlbFxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1cbiAqICAgICBDYXJvdXNlbCBjb21wb25lbnQuIEEgY2Fyb3VzZWwgY2FuIGJlIHVzZWQgdG8gZGlzcGxheSBzZXZlcmFsIGl0ZW1zIGluIHRoZSBzYW1lIHNwYWNlLlxuICpcbiAqICAgICBUaGUgY29tcG9uZW50IHN1cHBvcnRzIGRpc3BsYXlpbmcgY29udGVudCBib3RoIGhvcml6b250YWxseSBhbmQgdmVydGljYWxseS4gVGhlIHVzZXIgY2FuIHNjcm9sbCB0aHJvdWdoIHRoZSBpdGVtcyBieSBkcmFnZ2luZyBhbmQgaXQgY2FuIGFsc28gYmUgY29udHJvbGxlciBwcm9ncmFtbWF0aWNhbGx5LlxuICogICBbL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBjb2RlcGVuIHhiYnpPUVxuICogQHR1dG9yaWFsIHZhbmlsbGEvUmVmZXJlbmNlL2Nhcm91c2VsXG4gKiBAc2VlYWxzbyBvbnMtY2Fyb3VzZWwtaXRlbVxuICogICBbZW5dYDxvbnMtY2Fyb3VzZWwtaXRlbT5gIGNvbXBvbmVudFsvZW5dXG4gKiAgIFtqYV1vbnMtY2Fyb3VzZWwtaXRlbeOCs+ODs+ODneODvOODjeODs+ODiFsvamFdXG4gKiBAZXhhbXBsZVxuICogPG9ucy1jYXJvdXNlbCBzdHlsZT1cIndpZHRoOiAxMDAlOyBoZWlnaHQ6IDIwMHB4XCI+XG4gKiAgIDxvbnMtY2Fyb3VzZWwtaXRlbT5cbiAqICAgIC4uLlxuICogICA8L29ucy1jYXJvdXNlbC1pdGVtPlxuICogICA8b25zLWNhcm91c2VsLWl0ZW0+XG4gKiAgICAuLi5cbiAqICAgPC9vbnMtY2Fyb3VzZWwtaXRlbT5cbiAqIDwvb25zLWNhcm91c2VsPlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDYXJvdXNlbEVsZW1lbnQgZXh0ZW5kcyBCYXNlRWxlbWVudCB7XG5cbiAgLyoqXG4gICAqIEBldmVudCBwb3N0Y2hhbmdlXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1GaXJlZCBqdXN0IGFmdGVyIHRoZSBjdXJyZW50IGNhcm91c2VsIGl0ZW0gaGFzIGNoYW5nZWQuWy9lbl1cbiAgICogICBbamFd54++5Zyo6KGo56S644GX44Gm44GE44KL44Kr44Or44O844K744Or44Gu6KaB57Sg44GM5aSJ44KP44Gj44Gf5pmC44Gr55m654Gr44GX44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50XG4gICAqICAgW2VuXUV2ZW50IG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgqTjg5njg7Pjg4jjgqrjg5bjgrjjgqfjgq/jg4jjgafjgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQuY2Fyb3VzZWxcbiAgICogICBbZW5dQ2Fyb3VzZWwgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCpOODmeODs+ODiOOBjOeZuueBq+OBl+OBn0Nhcm91c2Vs44Kq44OW44K444Kn44Kv44OI44Gn44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGV2ZW50LmFjdGl2ZUluZGV4XG4gICAqICAgW2VuXUN1cnJlbnQgYWN0aXZlIGluZGV4LlsvZW5dXG4gICAqICAgW2phXeePvuWcqOOCouOCr+ODhuOCo+ODluOBq+OBquOBo+OBpuOBhOOCi+imgee0oOOBruOCpOODs+ODh+ODg+OCr+OCueOAglsvamFdXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBldmVudC5sYXN0QWN0aXZlSW5kZXhcbiAgICogICBbZW5dUHJldmlvdXMgYWN0aXZlIGluZGV4LlsvZW5dXG4gICAqICAgW2phXeS7peWJjeOCouOCr+ODhuOCo+ODluOBoOOBo+OBn+imgee0oOOBruOCpOODs+ODh+ODg+OCr+OCueOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAZXZlbnQgcmVmcmVzaFxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dRmlyZWQgd2hlbiB0aGUgY2Fyb3VzZWwgaGFzIGJlZW4gcmVmcmVzaGVkLlsvZW5dXG4gICAqICAgW2phXeOCq+ODq+ODvOOCu+ODq+OBjOabtOaWsOOBleOCjOOBn+aZguOBq+eZuueBq+OBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudFxuICAgKiAgIFtlbl1FdmVudCBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Kk44OZ44Oz44OI44Kq44OW44K444Kn44Kv44OI44Gn44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50LmNhcm91c2VsXG4gICAqICAgW2VuXUNhcm91c2VsIG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgqTjg5njg7Pjg4jjgYznmbrngavjgZfjgZ9DYXJvdXNlbOOCquODluOCuOOCp+OCr+ODiOOBp+OBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAZXZlbnQgb3ZlcnNjcm9sbFxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dRmlyZWQgd2hlbiB0aGUgY2Fyb3VzZWwgaGFzIGJlZW4gb3ZlcnNjcm9sbGVkLlsvZW5dXG4gICAqICAgW2phXeOCq+ODq+ODvOOCu+ODq+OBjOOCquODvOODkOODvOOCueOCr+ODreODvOODq+OBl+OBn+aZguOBq+eZuueBq+OBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudFxuICAgKiAgIFtlbl1FdmVudCBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Kk44OZ44Oz44OI44Kq44OW44K444Kn44Kv44OI44Gn44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50LmNhcm91c2VsXG4gICAqICAgW2VuXUZpcmVkIHdoZW4gdGhlIGNhcm91c2VsIGhhcyBiZWVuIHJlZnJlc2hlZC5bL2VuXVxuICAgKiAgIFtqYV3jgqvjg6vjg7zjgrvjg6vjgYzmm7TmlrDjgZXjgozjgZ/mmYLjgavnmbrngavjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge051bWJlcn0gZXZlbnQuYWN0aXZlSW5kZXhcbiAgICogICBbZW5dQ3VycmVudCBhY3RpdmUgaW5kZXguWy9lbl1cbiAgICogICBbamFd54++5Zyo44Ki44Kv44OG44Kj44OW44Gr44Gq44Gj44Gm44GE44KL6KaB57Sg44Gu44Kk44Oz44OH44OD44Kv44K544CCWy9qYV1cbiAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50LmRpcmVjdGlvblxuICAgKiAgIFtlbl1DYW4gYmUgb25lIG9mIGVpdGhlciBcInVwXCIsIFwiZG93blwiLCBcImxlZnRcIiBvciBcInJpZ2h0XCIuWy9lbl1cbiAgICogICBbamFd44Kq44O844OQ44O844K544Kv44Ot44O844Or44GV44KM44Gf5pa55ZCR44GM5b6X44KJ44KM44G+44GZ44CCXCJ1cFwiLCBcImRvd25cIiwgXCJsZWZ0XCIsIFwicmlnaHRcIuOBruOBhOOBmuOCjOOBi+OBruaWueWQkeOBjOa4oeOBleOCjOOBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGV2ZW50LndhaXRUb1JldHVyblxuICAgKiAgIFtlbl1UYWtlcyBhIDxjb2RlPlByb21pc2U8L2NvZGU+IG9iamVjdCBhcyBhbiBhcmd1bWVudC4gVGhlIGNhcm91c2VsIHdpbGwgbm90IHNjcm9sbCBiYWNrIHVudGlsIHRoZSBwcm9taXNlIGhhcyBiZWVuIHJlc29sdmVkIG9yIHJlamVjdGVkLlsvZW5dXG4gICAqICAgW2phXeOBk+OBrumWouaVsOOBr1Byb21pc2Xjgqrjg5bjgrjjgqfjgq/jg4jjgpLlvJXmlbDjgajjgZfjgablj5fjgZHlj5bjgorjgb7jgZnjgILmuKHjgZfjgZ9Qcm9taXNl44Kq44OW44K444Kn44Kv44OI44GMcmVzb2x2ZeOBleOCjOOCi+OBi3JlamVjdOOBleOCjOOCi+OBvuOBp+OAgeOCq+ODq+ODvOOCu+ODq+OBr+OCueOCr+ODreODvOODq+ODkOODg+OCr+OBl+OBvuOBm+OCk+OAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGRpcmVjdGlvblxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dVGhlIGRpcmVjdGlvbiBvZiB0aGUgY2Fyb3VzZWwuIENhbiBiZSBlaXRoZXIgXCJob3Jpem9udGFsXCIgb3IgXCJ2ZXJ0aWNhbFwiLiBEZWZhdWx0IGlzIFwiaG9yaXpvbnRhbFwiLlsvZW5dXG4gICAqICAgW2phXeOCq+ODq+ODvOOCu+ODq+OBruaWueWQkeOCkuaMh+WumuOBl+OBvuOBmeOAglwiaG9yaXpvbnRhbFwi44GLXCJ2ZXJ0aWNhbFwi44KS5oyH5a6a44Gn44GN44G+44GZ44CCXCJob3Jpem9udGFsXCLjgYzjg4fjg5Xjgqnjg6vjg4jlgKTjgafjgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBmdWxsc2NyZWVuXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1JZiB0aGlzIGF0dHJpYnV0ZSBpcyBzZXQgdGhlIGNhcm91c2VsIHdpbGwgY292ZXIgdGhlIHdob2xlIHNjcmVlbi5bL2VuXVxuICAgKiAgIFtqYV3jgZPjga7lsZ7mgKfjgYzjgYLjgovjgajjgIFhYnNvbHV0ZeODneOCuOOCt+ODp+ODs+OCkuS9v+OBo+OBpuOCq+ODq+ODvOOCu+ODq+OBjOiHquWLleeahOOBq+eUu+mdouOBhOOBo+OBseOBhOOBq+W6g+OBjOOCiuOBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIG92ZXJzY3JvbGxhYmxlXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1JZiB0aGlzIGF0dHJpYnV0ZSBpcyBzZXQgdGhlIGNhcm91c2VsIHdpbGwgYmUgc2Nyb2xsYWJsZSBvdmVyIHRoZSBlZGdlLiBJdCB3aWxsIGJvdW5jZSBiYWNrIHdoZW4gcmVsZWFzZWQuWy9lbl1cbiAgICogICBbamFd44GT44Gu5bGe5oCn44GM44GC44KL5pmC44CB44K/44OD44OB44KE44OJ44Op44OD44Kw44Gn56uv44G+44Gn44K544Kv44Ot44O844Or44GX44Gf5pmC44Gr44CB44OQ44Km44Oz44OJ44GZ44KL44KI44GG44Gq5Yq55p6c44GM5b2T44Gf44KK44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgY2VudGVyZWRcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUlmIHRoaXMgYXR0cmlidXRlIGlzIHNldCB0aGUgY2Fyb3VzZWwgdGhlbiB0aGUgc2VsZWN0ZWQgaXRlbSB3aWxsIGJlIGluIHRoZSBjZW50ZXIgb2YgdGhlIGNhcm91c2VsIGluc3RlYWQgb2YgdGhlIGJlZ2lubmluZy4gVXNlZnVsIG9ubHkgd2hlbiB0aGUgaXRlbXMgYXJlIHNtYWxsZXIgdGhhbiB0aGUgY2Fyb3VzZWwuIFsvZW5dXG4gICAqICAgW2phXeOBk+OBruWxnuaAp+OBjOOBguOCi+aZguOAgemBuOOCk+OBp+OBhOOCi29ucy1jYXJvdXNlbC1pdGVt44Gv44Kr44Or44O844K744Or44Gu55yf44KT5Lit44G46KGM44GN44G+44GZ44CC6aCF55uu44GM44Kr44Or44O844K744Or44KI44KK44KC5bCP44GV44GE5aC05ZCI44Gr44Gu44G/44CB44GT44KM44Gv5L6/5Yip44Gn44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgaXRlbS13aWR0aFxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICAgW2VuXW9ucy1jYXJvdXNlbC1pdGVtJ3Mgd2lkdGguIE9ubHkgd29ya3Mgd2hlbiB0aGUgZGlyZWN0aW9uIGlzIHNldCB0byBcImhvcml6b250YWxcIi5bL2VuXVxuICAgKiAgICBbamFdb25zLWNhcm91c2VsLWl0ZW3jga7luYXjgpLmjIflrprjgZfjgb7jgZnjgILjgZPjga7lsZ7mgKfjga/jgIFkaXJlY3Rpb27lsZ7mgKfjgatcImhvcml6b250YWxcIuOCkuaMh+WumuOBl+OBn+aZguOBruOBv+acieWKueOBq+OBquOCiuOBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGl0ZW0taGVpZ2h0XG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1vbnMtY2Fyb3VzZWwtaXRlbSdzIGhlaWdodC4gT25seSB3b3JrcyB3aGVuIHRoZSBkaXJlY3Rpb24gaXMgc2V0IHRvIFwidmVydGljYWxcIi5bL2VuXVxuICAgKiAgIFtqYV1vbnMtY2Fyb3VzZWwtaXRlbeOBrumrmOOBleOCkuaMh+WumuOBl+OBvuOBmeOAguOBk+OBruWxnuaAp+OBr+OAgWRpcmVjdGlvbuWxnuaAp+OBq1widmVydGljYWxcIuOCkuaMh+WumuOBl+OBn+aZguOBruOBv+acieWKueOBq+OBquOCiuOBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGF1dG8tc2Nyb2xsXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1JZiB0aGlzIGF0dHJpYnV0ZSBpcyBzZXQgdGhlIGNhcm91c2VsIHdpbGwgYmUgYXV0b21hdGljYWxseSBzY3JvbGxlZCB0byB0aGUgY2xvc2VzdCBpdGVtIGJvcmRlciB3aGVuIHJlbGVhc2VkLlsvZW5dXG4gICAqICAgW2phXeOBk+OBruWxnuaAp+OBjOOBguOCi+aZguOAgeS4gOeVqui/keOBhGNhcm91c2VsLWl0ZW3jga7looPnlYzjgb7jgafoh6rli5XnmoTjgavjgrnjgq/jg63jg7zjg6vjgZnjgovjgojjgYbjgavjgarjgorjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBhdXRvLXNjcm9sbC1yYXRpb1xuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICAgW2VuXUEgbnVtYmVyIGJldHdlZW4gMC4wIGFuZCAxLjAgdGhhdCBzcGVjaWZpZXMgaG93IG11Y2ggdGhlIHVzZXIgbXVzdCBkcmFnIHRoZSBjYXJvdXNlbCBpbiBvcmRlciBmb3IgaXQgdG8gYXV0byBzY3JvbGwgdG8gdGhlIG5leHQgaXRlbS5bL2VuXVxuICAgKiAgICBbamFdMC4w44GL44KJMS4w44G+44Gn44Gu5YCk44KS5oyH5a6a44GX44G+44GZ44CC44Kr44Or44O844K744Or44Gu6KaB57Sg44KS44Gp44KM44GQ44KJ44GE44Gu5Ymy5ZCI44G+44Gn44OJ44Op44OD44Kw44GZ44KL44Go5qyh44Gu6KaB57Sg44Gr6Ieq5YuV55qE44Gr44K544Kv44Ot44O844Or44GZ44KL44GL44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgc3dpcGVhYmxlXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1JZiB0aGlzIGF0dHJpYnV0ZSBpcyBzZXQgdGhlIGNhcm91c2VsIGNhbiBiZSBzY3JvbGxlZCBieSBkcmFnIG9yIHN3aXBlLlsvZW5dXG4gICAqICAgW2phXeOBk+OBruWxnuaAp+OBjOOBguOCi+aZguOAgeOCq+ODq+ODvOOCu+ODq+OCkuOCueODr+OCpOODl+OChOODieODqeODg+OCsOOBp+enu+WLleOBp+OBjeOCi+OCiOOBhuOBq+OBquOCiuOBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGRpc2FibGVkXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1JZiB0aGlzIGF0dHJpYnV0ZSBpcyBzZXQgdGhlIGNhcm91c2VsIGlzIGRpc2FibGVkLlsvZW5dXG4gICAqICAgW2phXeOBk+OBruWxnuaAp+OBjOOBguOCi+aZguOAgWRyYWfjgoR0b3VjaOOChHN3aXBl44KS5Y+X44GR5LuY44GR44Gq44GP44Gq44KK44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgaW5pdGlhbC1pbmRleFxuICAgKiBAaW5pdG9ubHlcbiAgICogQGRlZmF1bHQgMFxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dU3BlY2lmeSB0aGUgaW5kZXggb2YgdGhlIG9ucy1jYXJvdXNlbC1pdGVtIHRvIHNob3cgaW5pdGlhbGx5LiBEZWZhdWx0IGlzIDAuWy9lbl1cbiAgICogICBbamFd5pyA5Yid44Gr6KGo56S644GZ44KLb25zLWNhcm91c2VsLWl0ZW3jgpIw5aeL44G+44KK44Gu44Kk44Oz44OH44OD44Kv44K544Gn5oyH5a6a44GX44G+44GZ44CC44OH44OV44Kp44Or44OI5YCk44GvIDAg44Gn44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgYXV0by1yZWZyZXNoXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1XaGVuIHRoaXMgYXR0cmlidXRlIGlzIHNldCB0aGUgY2Fyb3VzZWwgd2lsbCBhdXRvbWF0aWNhbGx5IHJlZnJlc2ggd2hlbiB0aGUgbnVtYmVyIG9mIGNoaWxkIG5vZGVzIGNoYW5nZS5bL2VuXVxuICAgKiAgIFtqYV3jgZPjga7lsZ7mgKfjgYzjgYLjgovmmYLjgIHlrZDopoHntKDjga7mlbDjgYzlpInjgo/jgovjgajjgqvjg6vjg7zjgrvjg6vjga/oh6rli5XnmoTjgavmm7TmlrDjgZXjgozjgovjgojjgYbjgavjgarjgorjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBhbmltYXRpb25cbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUlmIHRoaXMgYXR0cmlidXRlIGlzIHNldCB0byBgXCJub25lXCJgIHRoZSB0cmFuc2l0aW9ucyB3aWxsIG5vdCBiZSBhbmltYXRlZC5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBhbmltYXRpb24tb3B0aW9uc1xuICAgKiBAdHlwZSB7RXhwcmVzc2lvbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVNwZWNpZnkgdGhlIGFuaW1hdGlvbidzIGR1cmF0aW9uLCB0aW1pbmcgYW5kIGRlbGF5IHdpdGggYW4gb2JqZWN0IGxpdGVyYWwuIEUuZy4gYHtkdXJhdGlvbjogMC4yLCBkZWxheTogMSwgdGltaW5nOiAnZWFzZS1pbid9YC5bL2VuXVxuICAgKiAgIFtqYV3jgqLjg4vjg6Hjg7zjgrfjg6fjg7PmmYLjga5kdXJhdGlvbiwgdGltaW5nLCBkZWxheeOCkuOCquODluOCuOOCp+OCr+ODiOODquODhuODqeODq+OBp+aMh+WumuOBl+OBvuOBmeOAguS+i++8mntkdXJhdGlvbjogMC4yLCBkZWxheTogMSwgdGltaW5nOiAnZWFzZS1pbid9Wy9qYV1cbiAgICovXG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB0aGlzLl9jb21waWxlKCkpO1xuICB9XG5cbiAgX2NvbXBpbGUoKSB7XG4gICAgY29uc3QgdGFyZ2V0ID0gdGhpcy5jaGlsZHJlblswXSAmJiB0aGlzLmNoaWxkcmVuWzBdLnRhZ05hbWUgIT09ICdPTlMtQ0FST1VTRUwtSVRFTScgJiYgdGhpcy5jaGlsZHJlblswXSB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBpZiAoIXRhcmdldC5wYXJlbnROb2RlKSB7XG4gICAgICB3aGlsZSAodGhpcy5maXJzdENoaWxkKSB7XG4gICAgICAgIHRhcmdldC5hcHBlbmRDaGlsZCh0aGlzLmZpcnN0Q2hpbGQpO1xuICAgICAgfVxuICAgICAgdGhpcy5hcHBlbmRDaGlsZCh0YXJnZXQpO1xuICAgIH1cblxuICAgICF0aGlzLmNoaWxkcmVuWzFdICYmIHRoaXMuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JykpO1xuXG4gICAgdGhpcy5hcHBlbmRDaGlsZCA9IHRoaXMuYXBwZW5kQ2hpbGQuYmluZCh0YXJnZXQpO1xuICAgIHRoaXMuaW5zZXJ0QmVmb3JlID0gdGhpcy5pbnNlcnRCZWZvcmUuYmluZCh0YXJnZXQpO1xuICB9XG5cbiAgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgaWYgKCF0aGlzLl9zd2lwZXIpIHtcbiAgICAgIHRoaXMuX3N3aXBlciA9IG5ldyBTd2lwZXIoe1xuICAgICAgICBnZXRFbGVtZW50OiAoKSA9PiB0aGlzLFxuICAgICAgICBnZXRJbml0aWFsSW5kZXg6ICgpID0+IHRoaXMuZ2V0QXR0cmlidXRlKCdpbml0aWFsLWluZGV4JyksXG4gICAgICAgIGdldEF1dG9TY3JvbGxSYXRpbzogKCkgPT4gdGhpcy5hdXRvU2Nyb2xsUmF0aW8sXG4gICAgICAgIGlzVmVydGljYWw6ICgpID0+IHRoaXMudmVydGljYWwsXG4gICAgICAgIGlzT3ZlclNjcm9sbGFibGU6ICgpID0+IHRoaXMub3ZlcnNjcm9sbGFibGUsXG4gICAgICAgIGlzQ2VudGVyZWQ6ICgpID0+IHRoaXMuY2VudGVyZWQsXG4gICAgICAgIGlzQXV0b1Njcm9sbGFibGU6ICgpID0+IHRoaXMuYXV0b1Njcm9sbCxcbiAgICAgICAgaXRlbVNpemU6IHRoaXMuaXRlbVNpemUsXG4gICAgICAgIG92ZXJTY3JvbGxIb29rOiB0aGlzLl9vbk92ZXJTY3JvbGwuYmluZCh0aGlzKSxcbiAgICAgICAgcHJlQ2hhbmdlSG9vazogdGhpcy5fb25DaGFuZ2UuYmluZCh0aGlzLCAncHJlY2hhbmdlJyksXG4gICAgICAgIHBvc3RDaGFuZ2VIb29rOiB0aGlzLl9vbkNoYW5nZS5iaW5kKHRoaXMsICdwb3N0Y2hhbmdlJyksXG4gICAgICAgIHJlZnJlc2hIb29rOiB0aGlzLl9vblJlZnJlc2guYmluZCh0aGlzKSxcbiAgICAgICAgc2Nyb2xsSG9vazogKC4uLmFyZ3MpID0+IHRoaXMuX29uU3dpcGUgJiYgdGhpcy5fb25Td2lwZSguLi5hcmdzKVxuICAgICAgfSk7XG5cbiAgICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB0aGlzLl9zd2lwZXIuaW5pdCh7XG4gICAgICAgIHN3aXBlYWJsZTogdGhpcy5oYXNBdHRyaWJ1dGUoJ3N3aXBlYWJsZScpLFxuICAgICAgICBhdXRvUmVmcmVzaDogdGhpcy5oYXNBdHRyaWJ1dGUoJ2F1dG8tcmVmcmVzaCcpXG4gICAgICB9KSk7XG4gICAgfVxuICB9XG5cbiAgZGlzY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgaWYgKHRoaXMuX3N3aXBlciAmJiB0aGlzLl9zd2lwZXIuaW5pdGlhbGl6ZWQpIHtcbiAgICAgIHRoaXMuX3N3aXBlci5kaXNwb3NlKCk7XG4gICAgICB0aGlzLl9zd2lwZXIgPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIHN0YXRpYyBnZXQgb2JzZXJ2ZWRBdHRyaWJ1dGVzKCkge1xuICAgIHJldHVybiBbJ3N3aXBlYWJsZScsICdhdXRvLXJlZnJlc2gnLCAnZGlyZWN0aW9uJywgJ2l0ZW0taGVpZ2h0JywgJ2l0ZW0td2lkdGgnXTtcbiAgfVxuXG4gIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBsYXN0LCBjdXJyZW50KSB7XG4gICAgaWYgKCF0aGlzLl9zd2lwZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBzd2l0Y2ggKG5hbWUpIHtcbiAgICAgIGNhc2UgJ3N3aXBlYWJsZSc6XG4gICAgICAgIHRoaXMuX3N3aXBlci51cGRhdGVTd2lwZWFibGUodGhpcy5oYXNBdHRyaWJ1dGUoJ3N3aXBlYWJsZScpKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdhdXRvLXJlZnJlc2gnOlxuICAgICAgICB0aGlzLl9zd2lwZXIudXBkYXRlQXV0b1JlZnJlc2godGhpcy5oYXNBdHRyaWJ1dGUoJ2F1dG8tcmVmcmVzaCcpKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdpdGVtLWhlaWdodCc6XG4gICAgICAgIHRoaXMudmVydGljYWwgJiYgdGhpcy5fc3dpcGVyLnVwZGF0ZUl0ZW1TaXplKHRoaXMuaXRlbVNpemUpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2l0ZW0td2lkdGgnOlxuICAgICAgICB0aGlzLnZlcnRpY2FsIHx8IHRoaXMuX3N3aXBlci51cGRhdGVJdGVtU2l6ZSh0aGlzLml0ZW1TaXplKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdkaXJlY3Rpb24nOlxuICAgICAgICB0aGlzLl9zd2lwZXIucmVmcmVzaCgpO1xuICAgIH1cbiAgfVxuXG4gIF9zaG93KCkge1xuICAgIHRoaXMuX3N3aXBlci5zaG93KCk7XG4gIH1cblxuICBfaGlkZSgpIHtcbiAgICB0aGlzLl9zd2lwZXIuaGlkZSgpO1xuICB9XG5cbiAgX29uT3ZlclNjcm9sbCh7IGRpcmVjdGlvbiwga2lsbE92ZXJTY3JvbGwgfSkge1xuICAgIGxldCB3YWl0Rm9yQWN0aW9uID0gZmFsc2U7XG4gICAgdXRpbC50cmlnZ2VyRWxlbWVudEV2ZW50KHRoaXMsICdvdmVyc2Nyb2xsJywge1xuICAgICAgY2Fyb3VzZWw6IHRoaXMsXG4gICAgICBhY3RpdmVJbmRleDogdGhpcy5nZXRBY3RpdmVJbmRleCgpLFxuICAgICAgZGlyZWN0aW9uLFxuICAgICAgd2FpdFRvUmV0dXJuOiBwcm9taXNlID0+IHtcbiAgICAgICAgd2FpdEZvckFjdGlvbiA9IHRydWU7XG4gICAgICAgIHByb21pc2UudGhlbihraWxsT3ZlclNjcm9sbCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gd2FpdEZvckFjdGlvbjtcbiAgfVxuXG4gIF9vbkNoYW5nZShldmVudE5hbWUsIHsgYWN0aXZlSW5kZXgsIGxhc3RBY3RpdmVJbmRleCB9KSB7XG4gICAgdXRpbC50cmlnZ2VyRWxlbWVudEV2ZW50KHRoaXMsIGV2ZW50TmFtZSwgeyBjYXJvdXNlbDogdGhpcywgYWN0aXZlSW5kZXgsIGxhc3RBY3RpdmVJbmRleCB9KTtcbiAgfVxuXG4gIF9vblJlZnJlc2goKSB7XG4gICAgdXRpbC50cmlnZ2VyRWxlbWVudEV2ZW50KHRoaXMsICdyZWZyZXNoJywgeyBjYXJvdXNlbDogdGhpcyB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIHNldEFjdGl2ZUluZGV4XG4gICAqIEBzaWduYXR1cmUgc2V0QWN0aXZlSW5kZXgoaW5kZXgsIFtvcHRpb25zXSlcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4XG4gICAqICAgW2VuXVRoZSBpbmRleCB0aGF0IHRoZSBjYXJvdXNlbCBzaG91bGQgYmUgc2V0IHRvLlsvZW5dXG4gICAqICAgW2phXWNhcm91c2Vs6KaB57Sg44Gu44Kk44Oz44OH44OD44Kv44K544KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiAgIFtlbl1QYXJhbWV0ZXIgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmNhbGxiYWNrXVxuICAgKiAgIFtlbl1BIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBjYWxsZWQgYWZ0ZXIgdGhlIGFuaW1hdGlvbiBpcyBmaW5pc2hlZC5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuYW5pbWF0aW9uXVxuICAgKiAgIFtlbl1JZiB0aGlzIGF0dHJpYnV0ZSBpcyBzZXQgdG8gYFwibm9uZVwiYCB0aGUgdHJhbnNpdGlvbnMgd2lsbCBub3QgYmUgYW5pbWF0ZWQuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLmFuaW1hdGlvbk9wdGlvbnNdXG4gICAqICAgW2VuXUFuIG9iamVjdCB0aGF0IGNhbiBiZSB1c2VkIHRvIHNwZWNpZnkgZHVyYXRpb24sIGRlbGF5IGFuZCB0aW1pbmcgZnVuY3Rpb24gb2YgdGhlIGFuaW1hdGlvbi5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dU3BlY2lmeSB0aGUgaW5kZXggb2YgdGhlIGA8b25zLWNhcm91c2VsLWl0ZW0+YCB0byBzaG93LlsvZW5dXG4gICAqICAgW2phXeihqOekuuOBmeOCi29ucy1jYXJvdXNlbC1pdGVt44KSaW5kZXjjgafmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKiAgIFtlbl1SZXNvbHZlcyB0byB0aGUgY2Fyb3VzZWwgZWxlbWVudC5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cbiAgc2V0QWN0aXZlSW5kZXgoaW5kZXgsIG9wdGlvbnMgPSB7fSkge1xuICAgIG9wdGlvbnMgPSB7XG4gICAgICBhbmltYXRpb246IHRoaXMuZ2V0QXR0cmlidXRlKCdhbmltYXRpb24nKSxcbiAgICAgIGFuaW1hdGlvbk9wdGlvbnM6IHRoaXMuaGFzQXR0cmlidXRlKCdhbmltYXRpb24tb3B0aW9ucycpXG4gICAgICAgID8gdXRpbC5hbmltYXRpb25PcHRpb25zUGFyc2UodGhpcy5nZXRBdHRyaWJ1dGUoJ2FuaW1hdGlvbi1vcHRpb25zJykpXG4gICAgICAgIDogeyBkdXJhdGlvbjogLjMsIHRpbWluZzogJ2N1YmljLWJlemllciguNCwgLjcsIC41LCAxKScgfSxcbiAgICAgIC4uLm9wdGlvbnNcbiAgICB9O1xuXG4gICAgcmV0dXJuIHRoaXMuX3N3aXBlci5zZXRBY3RpdmVJbmRleChpbmRleCwgb3B0aW9ucylcbiAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgb3B0aW9ucy5jYWxsYmFjayBpbnN0YW5jZW9mIEZ1bmN0aW9uICYmIG9wdGlvbnMuY2FsbGJhY2sodGhpcyk7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcyk7XG4gICAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIGdldEFjdGl2ZUluZGV4XG4gICAqIEBzaWduYXR1cmUgZ2V0QWN0aXZlSW5kZXgoKVxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAqICAgW2VuXVRoZSBjdXJyZW50IGNhcm91c2VsIGl0ZW0gaW5kZXguWy9lbl1cbiAgICogICBbamFd54++5Zyo6KGo56S644GX44Gm44GE44KL44Kr44Or44O844K744Or6KaB57Sg44Gu44Kk44Oz44OH44OD44Kv44K544GM6L+U44GV44KM44G+44GZ44CCWy9qYV1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBjdXJyZW50bHkgdmlzaWJsZSBgPG9ucy1jYXJvdXNlbC1pdGVtPmAuWy9lbl1cbiAgICogICBbamFd54++5Zyo6KGo56S644GV44KM44Gm44GE44KLb25zLWNhcm91c2VsLWl0ZW3opoHntKDjga7jgqTjg7Pjg4fjg4Pjgq/jgrnjgpLov5TjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cbiAgZ2V0QWN0aXZlSW5kZXgoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N3aXBlci5nZXRBY3RpdmVJbmRleCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgbmV4dFxuICAgKiBAc2lnbmF0dXJlIG5leHQoW29wdGlvbnNdKVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqICAgW2VuXVBhcmFtZXRlciBvYmplY3QuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuY2FsbGJhY2tdXG4gICAqICAgW2VuXUEgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGV4ZWN1dGVkIGFmdGVyIHRoZSBhbmltYXRpb24gaGFzIGZpbmlzaGVkLlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5hbmltYXRpb25dXG4gICAqICAgW2VuXUlmIHRoaXMgYXR0cmlidXRlIGlzIHNldCB0byBgXCJub25lXCJgIHRoZSB0cmFuc2l0aW9ucyB3aWxsIG5vdCBiZSBhbmltYXRlZC5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuYW5pbWF0aW9uT3B0aW9uc11cbiAgICogICBbZW5dQW4gb2JqZWN0IHRoYXQgY2FuIGJlIHVzZWQgdG8gc3BlY2lmeSB0aGUgZHVyYXRpb24sIGRlbGF5IGFuZCB0aW1pbmcgZnVuY3Rpb24gb2YgdGhlIGFuaW1hdGlvbi5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKiAgIFtlbl1SZXNvbHZlcyB0byB0aGUgY2Fyb3VzZWwgZWxlbWVudFsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1TaG93IG5leHQgYDxvbnMtY2Fyb3VzZWwtaXRlbT5gLlsvZW5dXG4gICAqICAgW2phXeasoeOBrm9ucy1jYXJvdXNlbC1pdGVt44KS6KGo56S644GX44G+44GZ44CCWy9qYV1cbiAgICovXG4gIG5leHQob3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLnNldEFjdGl2ZUluZGV4KHRoaXMuZ2V0QWN0aXZlSW5kZXgoKSArIDEsIG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgcHJldlxuICAgKiBAc2lnbmF0dXJlIHByZXYoW29wdGlvbnNdKVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqICAgW2VuXVBhcmFtZXRlciBvYmplY3QuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuY2FsbGJhY2tdXG4gICAqICAgW2VuXUEgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGV4ZWN1dGVkIGFmdGVyIHRoZSBhbmltYXRpb24gaGFzIGZpbmlzaGVkLlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5hbmltYXRpb25dXG4gICAqICAgW2VuXUlmIHRoaXMgYXR0cmlidXRlIGlzIHNldCB0byBgXCJub25lXCJgIHRoZSB0cmFuc2l0aW9ucyB3aWxsIG5vdCBiZSBhbmltYXRlZC5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuYW5pbWF0aW9uT3B0aW9uc11cbiAgICogICBbZW5dQW4gb2JqZWN0IHRoYXQgY2FuIGJlIHVzZWQgdG8gc3BlY2lmeSB0aGUgZHVyYXRpb24sIGRlbGF5IGFuZCB0aW1pbmcgZnVuY3Rpb24gb2YgdGhlIGFuaW1hdGlvbi5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKiAgIFtlbl1SZXNvbHZlcyB0byB0aGUgY2Fyb3VzZWwgZWxlbWVudFsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1TaG93IHByZXZpb3VzIGA8b25zLWNhcm91c2VsLWl0ZW0+YC5bL2VuXVxuICAgKiAgIFtqYV3liY3jga5vbnMtY2Fyb3VzZWwtaXRlbeOCkuihqOekuuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuICBwcmV2KG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5zZXRBY3RpdmVJbmRleCh0aGlzLmdldEFjdGl2ZUluZGV4KCkgLSAxLCBvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIGZpcnN0XG4gICAqIEBzaWduYXR1cmUgZmlyc3QoKVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqICAgW2VuXVBhcmFtZXRlciBvYmplY3QuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuY2FsbGJhY2tdXG4gICAqICAgW2VuXUEgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGV4ZWN1dGVkIGFmdGVyIHRoZSBhbmltYXRpb24gaGFzIGZpbmlzaGVkLlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5hbmltYXRpb25dXG4gICAqICAgW2VuXUlmIHRoaXMgaXMgc2V0IHRvIGBcIm5vbmVcImAsIHRoZSB0cmFuc2l0aW9ucyB3aWxsIG5vdCBiZSBhbmltYXRlZC5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuYW5pbWF0aW9uT3B0aW9uc11cbiAgICogICBbZW5dQW4gb2JqZWN0IHRoYXQgY2FuIGJlIHVzZWQgdG8gc3BlY2lmeSB0aGUgZHVyYXRpb24sIGRlbGF5IGFuZCB0aW1pbmcgZnVuY3Rpb24gb2YgdGhlIGFuaW1hdGlvbi5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKiAgIFtlbl1SZXNvbHZlcyB0byB0aGUgY2Fyb3VzZWwgZWxlbWVudFsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1TaG93IGZpcnN0IGA8b25zLWNhcm91c2VsLWl0ZW0+YC5bL2VuXVxuICAgKiAgIFtqYV3mnIDliJ3jga5vbnMtY2Fyb3VzZWwtaXRlbeOCkuihqOekuuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuICBmaXJzdChvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMuc2V0QWN0aXZlSW5kZXgoMCwgb3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBsYXN0XG4gICAqIEBzaWduYXR1cmUgbGFzdCgpXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogICBbZW5dUGFyYW1ldGVyIG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5jYWxsYmFja11cbiAgICogICBbZW5dQSBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgZXhlY3V0ZWQgYWZ0ZXIgdGhlIGFuaW1hdGlvbiBoYXMgZmluaXNoZWQuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmFuaW1hdGlvbl1cbiAgICogICBbZW5dSWYgdGhpcyBhdHRyaWJ1dGUgaXMgc2V0IHRvIGBcIm5vbmVcImAgdGhlIHRyYW5zaXRpb25zIHdpbGwgbm90IGJlIGFuaW1hdGVkLlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5hbmltYXRpb25PcHRpb25zXVxuICAgKiAgIFtlbl1BbiBvYmplY3QgdGhhdCBjYW4gYmUgdXNlZCB0byBzcGVjaWZ5IHRoZSBkdXJhdGlvbiwgZGVsYXkgYW5kIHRpbWluZyBmdW5jdGlvbiBvZiB0aGUgYW5pbWF0aW9uLlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqICAgW2VuXVJlc29sdmVzIHRvIHRoZSBjYXJvdXNlbCBlbGVtZW50Wy9lbl1cbiAgICogICBbamFdUmVzb2x2ZXMgdG8gdGhlIGNhcm91c2VsIGVsZW1lbnRbL2phXVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dU2hvdyBsYXN0IG9ucy1jYXJvdXNlbCBpdGVtLlsvZW5dXG4gICAqICAgW2phXeacgOW+jOOBrm9ucy1jYXJvdXNlbC1pdGVt44KS6KGo56S644GX44G+44GZ44CCWy9qYV1cbiAgICovXG4gIGxhc3Qob3B0aW9ucykge1xuICAgIHRoaXMuc2V0QWN0aXZlSW5kZXgoTWF0aC5tYXgodGhpcy5pdGVtQ291bnQgLSAxLCAwKSwgb3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCByZWZyZXNoXG4gICAqIEBzaWduYXR1cmUgcmVmcmVzaCgpXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1VcGRhdGUgdGhlIGxheW91dCBvZiB0aGUgY2Fyb3VzZWwuIFVzZWQgd2hlbiBhZGRpbmcgYDxvbnMtY2Fyb3VzZWwtaXRlbXM+YCBkeW5hbWljYWxseSBvciB0byBhdXRvbWF0aWNhbGx5IGFkanVzdCB0aGUgc2l6ZS5bL2VuXVxuICAgKiAgIFtqYV3jg6zjgqTjgqLjgqbjg4jjgoTlhoXpg6jjga7nirbmhYvjgpLmnIDmlrDjga7jgoLjga7jgavmm7TmlrDjgZfjgb7jgZnjgIJvbnMtY2Fyb3VzZWwtaXRlbeOCkuWLleeahOOBq+Wil+OChOOBl+OBn+OCiuOAgW9ucy1jYXJvdXNlbOOBruWkp+OBjeOBleOCkuWLleeahOOBq+WkieOBiOOCi+mam+OBq+WIqeeUqOOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuICByZWZyZXNoKCkge1xuICAgIHRoaXMuX3N3aXBlci5yZWZyZXNoKCk7XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IGl0ZW1Db3VudFxuICAgKiBAcmVhZG9ubHlcbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVRoZSBudW1iZXIgb2YgY2Fyb3VzZWwgaXRlbXMuWy9lbl1cbiAgICogICBbamFd44Kr44Or44O844K744Or6KaB57Sg44Gu5pWw44Gn44GZ44CCWy9qYV1cbiAgICovXG4gIGdldCBpdGVtQ291bnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N3aXBlci5pdGVtQ291bnQ7XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IHN3aXBlYWJsZVxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXXRydWUgaWYgdGhlIGNhcm91c2VsIGlzIHN3aXBlYWJsZS5bL2VuXVxuICAgKiAgIFtqYV1zd2lwZWFibGXjgafjgYLjgozjgbB0cnVl44KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAgICovXG4gIGdldCBzd2lwZWFibGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuaGFzQXR0cmlidXRlKCdzd2lwZWFibGUnKTtcbiAgfVxuXG4gIHNldCBzd2lwZWFibGUodmFsdWUpIHtcbiAgICByZXR1cm4gdXRpbC50b2dnbGVBdHRyaWJ1dGUodGhpcywgJ3N3aXBlYWJsZScsIHZhbHVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgb25Td2lwZVxuICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1Ib29rIGNhbGxlZCB3aGVuZXZlciB0aGUgdXNlciBzbGlkZXMgdGhlIGNhcm91c2VsLiBJdCBnZXRzIGEgZGVjaW1hbCBpbmRleCBhbmQgYW4gYW5pbWF0aW9uT3B0aW9ucyBvYmplY3QgYXMgYXJndW1lbnRzLlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuICBnZXQgb25Td2lwZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fb25Td2lwZTtcbiAgfVxuXG4gIHNldCBvblN3aXBlKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlICYmICEodmFsdWUgaW5zdGFuY2VvZiBGdW5jdGlvbikpIHtcbiAgICAgIHV0aWwudGhyb3coYFwib25Td2lwZVwiIG11c3QgYmUgYSBmdW5jdGlvbmApXG4gICAgfVxuICAgIHRoaXMuX29uU3dpcGUgPSB2YWx1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgYXV0b1Njcm9sbFxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXXRydWUgaWYgYXV0byBzY3JvbGwgaXMgZW5hYmxlZC5bL2VuXVxuICAgKiAgIFtqYV3jgqrjg7zjg4jjgrnjgq/jg63jg7zjg6vjgYzmnInlirnjgafjgYLjgozjgbB0cnVl44KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAgICovXG4gIGdldCBhdXRvU2Nyb2xsKCkge1xuICAgIHJldHVybiB0aGlzLmhhc0F0dHJpYnV0ZSgnYXV0by1zY3JvbGwnKTtcbiAgfVxuXG4gIHNldCBhdXRvU2Nyb2xsKHZhbHVlKSB7XG4gICAgcmV0dXJuIHV0aWwudG9nZ2xlQXR0cmlidXRlKHRoaXMsICdhdXRvLXNjcm9sbCcsIHZhbHVlKTtcbiAgfVxuXG4gIGdldCB2ZXJ0aWNhbCgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRBdHRyaWJ1dGUoJ2RpcmVjdGlvbicpID09PSAndmVydGljYWwnO1xuICB9XG5cbiAgZ2V0IGl0ZW1TaXplKCkge1xuICAgIGNvbnN0IGl0ZW1TaXplQXR0ciA9ICh0aGlzLmdldEF0dHJpYnV0ZShgaXRlbS0ke3RoaXMudmVydGljYWwgPyAnaGVpZ2h0JyA6ICd3aWR0aCd9YCkgfHwgJycpLnRyaW0oKTtcbiAgICByZXR1cm4gaXRlbVNpemVBdHRyLm1hdGNoKC9eXFxkKyhweHwlKSQvKSA/IGl0ZW1TaXplQXR0ciA6ICcxMDAlJztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgYXV0b1Njcm9sbFJhdGlvXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1UaGUgY3VycmVudCBhdXRvIHNjcm9sbCByYXRpby4gWy9lbl1cbiAgICogICBbamFd54++5Zyo44Gu44Kq44O844OI44K544Kv44Ot44O844Or44GucmF0aW/lgKTjgIJbL2phXVxuICAgKi9cbiAgZ2V0IGF1dG9TY3JvbGxSYXRpbygpIHtcbiAgICByZXR1cm4gcGFyc2VGbG9hdCh0aGlzLmdldEF0dHJpYnV0ZSgnYXV0by1zY3JvbGwtcmF0aW8nKSk7XG4gIH1cblxuICBzZXQgYXV0b1Njcm9sbFJhdGlvKHJhdGlvKSB7XG4gICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ2F1dG8tc2Nyb2xsLXJhdGlvJywgcmF0aW8pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBkaXNhYmxlZFxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVdoZXRoZXIgdGhlIGNhcm91c2VsIGlzIGRpc2FibGVkIG9yIG5vdC5bL2VuXVxuICAgKiAgIFtqYV3nhKHlirnljJbjgZXjgozjgabjgYTjgovloLTlkIjjgatgdHJ1ZWDjgIJbL2phXVxuICAgKi9cbiAgZ2V0IGRpc2FibGVkKCkge1xuICAgIHJldHVybiB0aGlzLmhhc0F0dHJpYnV0ZSgnZGlzYWJsZWQnKTtcbiAgfVxuXG4gIHNldCBkaXNhYmxlZCh2YWx1ZSkge1xuICAgIHJldHVybiB1dGlsLnRvZ2dsZUF0dHJpYnV0ZSh0aGlzLCAnZGlzYWJsZWQnLCB2YWx1ZSk7XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IG92ZXJzY3JvbGxhYmxlXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dV2hldGhlciB0aGUgY2Fyb3VzZWwgaXMgb3ZlcnNjcm9sbGFibGUgb3Igbm90LlsvZW5dXG4gICAqICAgW2phXW92ZXJzY3JvbGzjgafjgY3jgozjgbB0cnVl44KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAgICovXG4gIGdldCBvdmVyc2Nyb2xsYWJsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5oYXNBdHRyaWJ1dGUoJ292ZXJzY3JvbGxhYmxlJyk7XG4gIH1cblxuICBzZXQgb3ZlcnNjcm9sbGFibGUodmFsdWUpIHtcbiAgICByZXR1cm4gdXRpbC50b2dnbGVBdHRyaWJ1dGUodGhpcywgJ292ZXJzY3JvbGxhYmxlJywgdmFsdWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBjZW50ZXJlZFxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVdoZXRoZXIgdGhlIGNhcm91c2VsIGlzIGNlbnRlcmVkIG9yIG5vdC5bL2VuXVxuICAgKiAgIFtqYV1jZW50ZXJlZOeKtuaFi+OBq+OBquOBo+OBpuOBhOOCjOOBsHRydWXjgpLov5TjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cbiAgZ2V0IGNlbnRlcmVkKCkge1xuICAgIHJldHVybiB0aGlzLmhhc0F0dHJpYnV0ZSgnY2VudGVyZWQnKTtcbiAgfVxuXG4gIHNldCBjZW50ZXJlZCh2YWx1ZSkge1xuICAgIHJldHVybiB1dGlsLnRvZ2dsZUF0dHJpYnV0ZSh0aGlzLCAnY2VudGVyZWQnLCB2YWx1ZSk7XG4gIH1cblxuICBzdGF0aWMgZ2V0IGV2ZW50cygpIHtcbiAgICByZXR1cm4gWydwb3N0Y2hhbmdlJywgJ3JlZnJlc2gnLCAnb3ZlcnNjcm9sbCddO1xuICB9XG59XG5cbm9uc0VsZW1lbnRzLkNhcm91c2VsID0gQ2Fyb3VzZWxFbGVtZW50O1xuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdvbnMtY2Fyb3VzZWwnLCBDYXJvdXNlbEVsZW1lbnQpO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IG9uc0VsZW1lbnRzIGZyb20gJy4uL29ucy9lbGVtZW50cyc7XG5pbXBvcnQgc3R5bGVyIGZyb20gJy4uL29ucy9zdHlsZXInO1xuaW1wb3J0IEJhc2VFbGVtZW50IGZyb20gJy4vYmFzZS9iYXNlLWVsZW1lbnQnO1xuXG4vKipcbiAqIEBlbGVtZW50IG9ucy1jb2xcbiAqIEBjYXRlZ29yeSBncmlkXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXVJlcHJlc2VudHMgYSBjb2x1bW4gaW4gdGhlIGdyaWQgc3lzdGVtLiBVc2Ugd2l0aCBgPG9ucy1yb3c+YCB0byBsYXlvdXQgY29tcG9uZW50cy5bL2VuXVxuICogICBbamFd44Kw44Oq44OD44OJ44K344K544OG44Og44Gr44Gm5YiX44KS5a6a576p44GX44G+44GZ44CCb25zLXJvd+OBqOOBqOOCguOBq+S9v+eUqOOBl+OAgeOCs+ODs+ODneODvOODjeODs+ODiOOBruODrOOCpOOCouOCpuODiOOBq+WIqeeUqOOBl+OBvuOBmeOAglsvamFdXG4gKiBAbm90ZVxuICogICBbZW5dRm9yIEFuZHJvaWQgNC4zIGFuZCBlYXJsaWVyLCBhbmQgaU9TNiBhbmQgZWFybGllciwgd2hlbiB1c2luZyBtaXhlZCBhbGlnbm1lbnQgd2l0aCBvbnMtcm93IGFuZCBvbnMtY29sdW1uLCB0aGV5IG1heSBub3QgYmUgZGlzcGxheWVkIGNvcnJlY3RseS4gWW91IGNhbiB1c2Ugb25seSBvbmUgYWxpZ25tZW50LlsvZW5dXG4gKiAgIFtqYV1BbmRyb2lkIDQuM+S7peWJjeOAgeOCguOBl+OBj+OBr2lPUyA25Lul5YmN44GuT1Pjga7loLTlkIjjgIFvbnMtcm9344Gob25zLWNvbHVtbuOCkue1hOOBv+WQiOOCj+OBm+OBn+WgtOWQiOOBq+aPj+eUu+OBjOW0qeOCjOOCi+WgtOWQiOOBjOOBguOCiuOBvuOBmeOAglsvamFdXG4gKiBAY29kZXBlbiBHZ3VqQyB7d2lkZX1cbiAqIEBndWlkZSB0aGVtaW5nLmh0bWwgW2VuXUxheW91dGluZyBndWlkZVsvZW5dW2phXeODrOOCpOOCouOCpuODiOapn+iDvVsvamFdXG4gKiBAc2VlYWxzbyBvbnMtcm93XG4gKiAgIFtlbl1UaGUgYDxvbnMtcm93PmAgY29tcG9uZW50IGlzIHRoZSBwYXJlbnQgb2YgYDxvbnMtY29sPmAuWy9lbl1cbiAqICAgW2phXW9ucy1yb3fjgrPjg7Pjg53jg7zjg43jg7Pjg4hbL2phXVxuICogQGV4YW1wbGVcbiAqIDxvbnMtcm93PlxuICogICA8b25zLWNvbCB3aWR0aD1cIjUwcHhcIj48b25zLWljb24gaWNvbj1cImZhLXR3aXR0ZXJcIj48L29ucy1pY29uPjwvb25zLWNvbD5cbiAqICAgPG9ucy1jb2w+VGV4dDwvb25zLWNvbD5cbiAqIDwvb25zLXJvdz5cbiAqL1xuXG4vKipcbiAqIEBhdHRyaWJ1dGUgdmVydGljYWwtYWxpZ25cbiAqIEB0eXBlIHtTdHJpbmd9XG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXVZlcnRpY2FsIGFsaWdubWVudCBvZiB0aGUgY29sdW1uLiBWYWxpZCB2YWx1ZXMgYXJlIFwidG9wXCIsIFwiY2VudGVyXCIsIGFuZCBcImJvdHRvbVwiLlsvZW5dXG4gKiAgIFtqYV3nuKbjga7phY3nva7jgpLmjIflrprjgZnjgovjgIJcInRvcFwiLCBcImNlbnRlclwiLCBcImJvdHRvbVwi44Gu44GE44Ga44KM44GL44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAqL1xuXG4vKipcbiAqIEBhdHRyaWJ1dGUgd2lkdGhcbiAqIEB0eXBlIHtTdHJpbmd9XG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXVRoZSB3aWR0aCBvZiB0aGUgY29sdW1uLiBWYWxpZCB2YWx1ZXMgYXJlIGNzcyB3aWR0aCB2YWx1ZXMgKFwiMTAlXCIsIFwiNTBweFwiKS5bL2VuXVxuICogICBbamFd44Kr44Op44Og44Gu5qiq5bmF44KS5oyH5a6a44GZ44KL44CC44OR44O844K744Oz44OI44KC44GX44GP44Gv44OU44Kv44K744Or44Gn5oyH5a6a44GX44G+44GZ77yIMTAl44KENTBweO+8ieOAglsvamFdXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENvbEVsZW1lbnQgZXh0ZW5kcyBCYXNlRWxlbWVudCB7XG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIGlmICh0aGlzLmdldEF0dHJpYnV0ZSgnd2lkdGgnKSkge1xuICAgICAgdGhpcy5fdXBkYXRlV2lkdGgoKTtcbiAgICB9XG4gIH1cblxuICBzdGF0aWMgZ2V0IG9ic2VydmVkQXR0cmlidXRlcygpIHtcbiAgICByZXR1cm4gWyd3aWR0aCddO1xuICB9XG5cbiAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIGxhc3QsIGN1cnJlbnQpIHtcbiAgICBpZiAobmFtZSA9PT0gJ3dpZHRoJykge1xuICAgICAgdGhpcy5fdXBkYXRlV2lkdGgoKTtcbiAgICB9XG4gIH1cblxuICBfdXBkYXRlV2lkdGgoKSB7XG4gICAgbGV0IHdpZHRoID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ3dpZHRoJyk7XG4gICAgaWYgKCF3aWR0aCkge1xuICAgICAgc3R5bGVyLmNsZWFyKHRoaXMsICdmbGV4IG1heFdpZHRoJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdpZHRoID0gd2lkdGgudHJpbSgpLm1hdGNoKC9eXFxkKyQvKSA/IHdpZHRoICsgJyUnIDogd2lkdGg7XG5cbiAgICAgIHN0eWxlcih0aGlzLCB7XG4gICAgICAgIGZsZXg6ICcwIDAgJyArIHdpZHRoLFxuICAgICAgICBtYXhXaWR0aDogd2lkdGhcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxufVxuXG5vbnNFbGVtZW50cy5Db2wgPSBDb2xFbGVtZW50O1xuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdvbnMtY29sJywgQ29sRWxlbWVudCk7XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgYW5pbWl0IGZyb20gJy4uLy4uL29ucy9hbmltaXQnO1xuaW1wb3J0IEJhc2VBbmltYXRvciBmcm9tICcuLi8uLi9vbnMvYmFzZS1hbmltYXRvcidcblxuZXhwb3J0IGNsYXNzIERpYWxvZ0FuaW1hdG9yIGV4dGVuZHMgQmFzZUFuaW1hdG9yIHtcblxuICBjb25zdHJ1Y3Rvcih7dGltaW5nID0gJ2xpbmVhcicsIGRlbGF5ID0gMCwgZHVyYXRpb24gPSAwLjJ9ID0ge30pIHtcbiAgICBzdXBlcih7IHRpbWluZywgZGVsYXksIGR1cmF0aW9uIH0pXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZGlhbG9nXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGRvbmVcbiAgICovXG4gIHNob3coZGlhbG9nLCBkb25lKSB7XG4gICAgZG9uZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGRpYWxvZ1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBkb25lXG4gICAqL1xuICBoaWRlKGRpYWxvZywgZG9uZSkge1xuICAgIGRvbmUoKTtcbiAgfVxufVxuXG4vKipcbiAqIEFuZHJvaWQgc3R5bGUgYW5pbWF0b3IgZm9yIGRpYWxvZy5cbiAqL1xuZXhwb3J0IGNsYXNzIEFuZHJvaWREaWFsb2dBbmltYXRvciBleHRlbmRzIERpYWxvZ0FuaW1hdG9yIHtcblxuICBjb25zdHJ1Y3Rvcih7dGltaW5nID0gJ2Vhc2UtaW4tb3V0JywgZGVsYXkgPSAwLCBkdXJhdGlvbiA9IDAuM30gPSB7fSkge1xuICAgIHN1cGVyKHt0aW1pbmcsIGRlbGF5LCBkdXJhdGlvbn0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkaWFsb2dcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICovXG4gIHNob3coZGlhbG9nLCBjYWxsYmFjaykge1xuICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgPyBjYWxsYmFjayA6IGZ1bmN0aW9uKCkge307XG5cbiAgICBhbmltaXQucnVuQWxsKFxuXG4gICAgICBhbmltaXQoZGlhbG9nLl9tYXNrLCB0aGlzLmRlZilcbiAgICAgICAgLmRlZmF1bHQoeyBvcGFjaXR5OiAwIH0sIHsgb3BhY2l0eTogMSB9KSxcblxuICAgICAgYW5pbWl0KGRpYWxvZy5fZGlhbG9nLCB0aGlzLmRlZilcbiAgICAgICAgLmRlZmF1bHQoXG4gICAgICAgICAgeyB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzZCgtNTAlLCAtNjAlLCAwKScsIG9wYWNpdHk6IDAgfSxcbiAgICAgICAgICB7IHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNkKC01MCUsIC01MCUsIDApJywgb3BhY2l0eTogMSB9XG4gICAgICAgIClcbiAgICAgICAgLnF1ZXVlKGRvbmUgPT4ge1xuICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgZG9uZSgpO1xuICAgICAgICB9KVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IGRpYWxvZ1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKi9cbiAgaGlkZShkaWFsb2csIGNhbGxiYWNrKSB7XG4gICAgY2FsbGJhY2sgPSBjYWxsYmFjayA/IGNhbGxiYWNrIDogZnVuY3Rpb24oKSB7fTtcblxuICAgIGFuaW1pdC5ydW5BbGwoXG5cbiAgICAgIGFuaW1pdChkaWFsb2cuX21hc2ssIHRoaXMuZGVmKVxuICAgICAgICAuZGVmYXVsdCh7IG9wYWNpdHk6IDEgfSwgeyBvcGFjaXR5OiAwIH0pLFxuXG4gICAgICBhbmltaXQoZGlhbG9nLl9kaWFsb2csIHRoaXMuZGVmKVxuICAgICAgICAuZGVmYXVsdChcbiAgICAgICAgICB7IHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNkKC01MCUsIC01MCUsIDApJywgb3BhY2l0eTogMSB9LFxuICAgICAgICAgIHsgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoLTUwJSwgLTYwJSwgMCknLCBvcGFjaXR5OiAwIH1cbiAgICAgICAgKVxuICAgICAgICAucXVldWUoZG9uZSA9PiB7XG4gICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICBkb25lKCk7XG4gICAgICAgIH0pXG4gICAgKTtcbiAgfVxufVxuXG4vKipcbiAqIGlPUyBzdHlsZSBhbmltYXRvciBmb3IgZGlhbG9nLlxuICovXG5leHBvcnQgY2xhc3MgSU9TRGlhbG9nQW5pbWF0b3IgZXh0ZW5kcyBEaWFsb2dBbmltYXRvciB7XG5cbiAgY29uc3RydWN0b3Ioe3RpbWluZyA9ICdlYXNlLWluLW91dCcsIGRlbGF5ID0gMCwgZHVyYXRpb24gPSAwLjJ9ID0ge30pIHtcbiAgICBzdXBlcih7dGltaW5nLCBkZWxheSwgZHVyYXRpb259KTtcblxuICAgIHRoaXMuYm9keUhlaWdodCA9IGRvY3VtZW50LmJvZHkuY2xpZW50SGVpZ2h0OyAvLyBhdm9pZCBGb3JjZWQgU3luY2hyb25vdXMgTGF5b3V0XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IGRpYWxvZ1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKi9cbiAgc2hvdyhkaWFsb2csIGNhbGxiYWNrKSB7XG4gICAgY2FsbGJhY2sgPSBjYWxsYmFjayA/IGNhbGxiYWNrIDogZnVuY3Rpb24oKSB7fTtcblxuICAgIGFuaW1pdC5ydW5BbGwoXG5cbiAgICAgIGFuaW1pdChkaWFsb2cuX21hc2ssIHRoaXMuZGVmKVxuICAgICAgICAuZGVmYXVsdCh7IG9wYWNpdHk6IDAgfSwgeyBvcGFjaXR5OiAxIH0pLFxuXG4gICAgICBhbmltaXQoZGlhbG9nLl9kaWFsb2csIHRoaXMuZGVmKVxuICAgICAgICAuZGVmYXVsdChcbiAgICAgICAgICB7IHRyYW5zZm9ybTogYHRyYW5zbGF0ZTNkKC01MCUsICR7dGhpcy5ib2R5SGVpZ2h0IC8gMi4wIC0gMX1weCwgMClgIH0sXG4gICAgICAgICAgeyB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzZCgtNTAlLCAtNTAlLCAwKScgfVxuICAgICAgICApXG4gICAgICAgIC5xdWV1ZShkb25lID0+IHtcbiAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgfSlcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkaWFsb2dcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICovXG4gIGhpZGUoZGlhbG9nLCBjYWxsYmFjaykge1xuICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgPyBjYWxsYmFjayA6IGZ1bmN0aW9uKCkge307XG5cbiAgICBhbmltaXQucnVuQWxsKFxuXG4gICAgICBhbmltaXQoZGlhbG9nLl9tYXNrLCB0aGlzLmRlZilcbiAgICAgICAgLmRlZmF1bHQoeyBvcGFjaXR5OiAxIH0sIHsgb3BhY2l0eTogMCB9KSxcblxuICAgICAgYW5pbWl0KGRpYWxvZy5fZGlhbG9nLCB0aGlzLmRlZilcbiAgICAgICAgLmRlZmF1bHQoXG4gICAgICAgICAgeyB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzZCgtNTAlLCAtNTAlLCAwKScgfSxcbiAgICAgICAgICB7IHRyYW5zZm9ybTogYHRyYW5zbGF0ZTNkKC01MCUsICR7dGhpcy5ib2R5SGVpZ2h0IC8gMi4wIC0gMX1weCwgMClgIH1cbiAgICAgICAgKVxuICAgICAgICAucXVldWUoZG9uZSA9PiB7XG4gICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICBkb25lKCk7XG4gICAgICAgIH0pXG4gICAgKTtcbiAgfVxufVxuXG4vKipcbiAqIFNsaWRlIGFuaW1hdG9yIGZvciBkaWFsb2cuXG4gKi9cbmV4cG9ydCBjbGFzcyBTbGlkZURpYWxvZ0FuaW1hdG9yIGV4dGVuZHMgRGlhbG9nQW5pbWF0b3Ige1xuXG4gIGNvbnN0cnVjdG9yKHt0aW1pbmcgPSAnY3ViaWMtYmV6aWVyKC4xLCAuNywgLjQsIDEpJywgZGVsYXkgPSAwLCBkdXJhdGlvbiA9IDAuMn0gPSB7fSkge1xuICAgIHN1cGVyKHt0aW1pbmcsIGRlbGF5LCBkdXJhdGlvbn0pO1xuXG4gICAgdGhpcy5ib2R5SGVpZ2h0ID0gZG9jdW1lbnQuYm9keS5jbGllbnRIZWlnaHQ7IC8vIGF2b2lkIEZvcmNlZCBTeW5jaHJvbm91cyBMYXlvdXRcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gZGlhbG9nXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqL1xuICBzaG93KGRpYWxvZywgY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjayA9IGNhbGxiYWNrID8gY2FsbGJhY2sgOiBmdW5jdGlvbigpIHt9O1xuXG4gICAgYW5pbWl0LnJ1bkFsbChcblxuICAgICAgYW5pbWl0KGRpYWxvZy5fbWFzaywgdGhpcy5kZWYpXG4gICAgICAgIC5kZWZhdWx0KHsgb3BhY2l0eTogMCB9LCB7IG9wYWNpdHk6IDEgfSksXG5cbiAgICAgIGFuaW1pdChkaWFsb2cuX2RpYWxvZywgdGhpcy5kZWYpXG4gICAgICAgIC5kZWZhdWx0KFxuICAgICAgICAgIC8vIEZJWE1FOiBUaGlzIHNob3VsZCBhdm9pZCBGb3JjZWQgU3luY2hyb25vdXMgTGF5b3V0LiBPdGhlcndpc2UsIGZhZGUgYW5pbWF0aW9uIG9mIG1hc2sgd2lsbCBiZSBicm9rZW4uXG4gICAgICAgICAgeyB0cmFuc2Zvcm06IGB0cmFuc2xhdGUzZCgtNTAlLCAkey0gKHRoaXMuYm9keUhlaWdodCAvIDIuMCkgKyAxIC0gZGlhbG9nLl9kaWFsb2cuY2xpZW50SGVpZ2h0fXB4LCAwKWAgfSxcbiAgICAgICAgICB7IHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNkKC01MCUsIC01MCUsIDApJyB9XG4gICAgICAgIClcbiAgICAgICAgLnF1ZXVlKGRvbmUgPT4ge1xuICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgZG9uZSgpO1xuICAgICAgICB9KVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IGRpYWxvZ1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKi9cbiAgaGlkZShkaWFsb2csIGNhbGxiYWNrKSB7XG4gICAgY2FsbGJhY2sgPSBjYWxsYmFjayA/IGNhbGxiYWNrIDogZnVuY3Rpb24oKSB7fTtcblxuICAgIGFuaW1pdC5ydW5BbGwoXG5cbiAgICAgIGFuaW1pdChkaWFsb2cuX21hc2ssIHRoaXMuZGVmKVxuICAgICAgICAuZGVmYXVsdCh7IG9wYWNpdHk6IDEgfSwgeyBvcGFjaXR5OiAwIH0pLFxuXG4gICAgICBhbmltaXQoZGlhbG9nLl9kaWFsb2csIHRoaXMuZGVmKVxuICAgICAgICAuZGVmYXVsdChcbiAgICAgICAgICB7IHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNkKC01MCUsIC01MCUsIDApJyB9LFxuICAgICAgICAgIC8vIEZJWE1FOiBUaGlzIHNob3VsZCBhdm9pZCBGb3JjZWQgU3luY2hyb25vdXMgTGF5b3V0LiBPdGhlcndpc2UsIGZhZGUgYW5pbWF0aW9uIG9mIG1hc2sgd2lsbCBiZSBicm9rZW4uXG4gICAgICAgICAgeyB0cmFuc2Zvcm06IGB0cmFuc2xhdGUzZCgtNTAlLCAkey0gKHRoaXMuYm9keUhlaWdodCAvIDIuMCkgKyAxIC0gZGlhbG9nLl9kaWFsb2cuY2xpZW50SGVpZ2h0fXB4LCAwKWAgfVxuICAgICAgICApXG4gICAgICAgIC5xdWV1ZShkb25lID0+IHtcbiAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgfSlcbiAgICApO1xuICB9XG59XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgb25zRWxlbWVudHMgZnJvbSAnLi4vLi4vb25zL2VsZW1lbnRzJztcbmltcG9ydCB1dGlsIGZyb20gJy4uLy4uL29ucy91dGlsJztcbmltcG9ydCBhdXRvU3R5bGUgZnJvbSAnLi4vLi4vb25zL2F1dG9zdHlsZSc7XG5pbXBvcnQgTW9kaWZpZXJVdGlsIGZyb20gJy4uLy4uL29ucy9pbnRlcm5hbC9tb2RpZmllci11dGlsJztcbmltcG9ydCBBbmltYXRvckZhY3RvcnkgZnJvbSAnLi4vLi4vb25zL2ludGVybmFsL2FuaW1hdG9yLWZhY3RvcnknO1xuaW1wb3J0IHsgRGlhbG9nQW5pbWF0b3IsIElPU0RpYWxvZ0FuaW1hdG9yLCBBbmRyb2lkRGlhbG9nQW5pbWF0b3IsIFNsaWRlRGlhbG9nQW5pbWF0b3IgfSBmcm9tICcuL2FuaW1hdG9yJztcbmltcG9ydCBwbGF0Zm9ybSBmcm9tICcuLi8uLi9vbnMvcGxhdGZvcm0nO1xuaW1wb3J0IEJhc2VEaWFsb2dFbGVtZW50IGZyb20gJy4uL2Jhc2UvYmFzZS1kaWFsb2cnO1xuaW1wb3J0IGNvbnRlbnRSZWFkeSBmcm9tICcuLi8uLi9vbnMvY29udGVudC1yZWFkeSc7XG5cbmNvbnN0IHNjaGVtZSA9IHtcbiAgJy5kaWFsb2cnOiAnZGlhbG9nLS0qJyxcbiAgJy5kaWFsb2ctY29udGFpbmVyJzogJ2RpYWxvZy1jb250YWluZXItLSonLFxuICAnLmRpYWxvZy1tYXNrJzogJ2RpYWxvZy1tYXNrLS0qJ1xufTtcblxuY29uc3QgX2FuaW1hdG9yRGljdCA9IHtcbiAgJ2RlZmF1bHQnOiAoKSA9PiBwbGF0Zm9ybS5pc0FuZHJvaWQoKSA/IEFuZHJvaWREaWFsb2dBbmltYXRvciA6IElPU0RpYWxvZ0FuaW1hdG9yLFxuICAnc2xpZGUnOiBTbGlkZURpYWxvZ0FuaW1hdG9yLFxuICAnbm9uZSc6IERpYWxvZ0FuaW1hdG9yXG59O1xuXG4vKipcbiAqIEBlbGVtZW50IG9ucy1kaWFsb2dcbiAqIEBjYXRlZ29yeSBkaWFsb2dcbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dXG4gKiAgICAgRGlhbG9nIHRoYXQgaXMgZGlzcGxheWVkIG9uIHRvcCBvZiBjdXJyZW50IHNjcmVlbi4gQXMgb3Bwb3NlZCB0byB0aGUgYDxvbnMtYWxlcnQtZGlhbG9nPmAgZWxlbWVudCwgdGhpcyBjb21wb25lbnQgY2FuIGNvbnRhaW4gYW55IGtpbmQgb2YgY29udGVudC5cbiAqXG4gKiAgICAgVG8gdXNlIHRoZSBlbGVtZW50IGl0IGNhbiBlaXRoZXIgYmUgYXR0YWNoZWQgZGlyZWN0bHkgdG8gdGhlIGA8Ym9keT5gIGVsZW1lbnQgb3IgZHluYW1pY2FsbHkgY3JlYXRlZCBmcm9tIGEgdGVtcGxhdGUgdXNpbmcgdGhlIGBvbnMuY3JlYXRlRGlhbG9nKHRlbXBsYXRlKWAgdXRpbGl0eSBmdW5jdGlvbiBhbmQgdGhlIGA8dGVtcGxhdGU+YCB0YWcuXG4gKlxuICogICAgIFRoZSBkaWFsb2cgaXMgdXNlZnVsIGZvciBkaXNwbGF5aW5nIG1lbnVzLCBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIG9yIHRvIGFzayB0aGUgdXNlciB0byBtYWtlIGEgZGVjaXNpb24uXG4gKlxuICogICAgIEl0IHdpbGwgYXV0b21hdGljYWxseSBiZSBkaXNwbGF5ZWQgYXMgTWF0ZXJpYWwgRGVzaWduIHdoZW4gcnVubmluZyBvbiBhbiBBbmRyb2lkIGRldmljZS5cbiAqICAgWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAbW9kaWZpZXIgbWF0ZXJpYWxcbiAqICAgW2VuXURpc3BsYXkgYSBNYXRlcmlhbCBEZXNpZ24gZGlhbG9nLlsvZW5dXG4gKiAgIFtqYV3jg57jg4bjg6rjgqLjg6vjg4fjgrbjgqTjg7Pjga7jg4DjgqTjgqLjg63jgrDjgpLooajnpLrjgZfjgb7jgZnjgIJbL2phXVxuICogQGNvZGVwZW4genh4YUdhXG4gKiBAdHV0b3JpYWwgdmFuaWxsYS9SZWZlcmVuY2UvZGlhbG9nXG4gKiBAZ3VpZGUgdGhlbWluZy5odG1sI21vZGlmaWVycyBbZW5dTW9yZSBkZXRhaWxzIGFib3V0IHRoZSBgbW9kaWZpZXJgIGF0dHJpYnV0ZVsvZW5dW2phXW1vZGlmaWVy5bGe5oCn44Gu5L2/44GE5pa5Wy9qYV1cbiAqIEBzZWVhbHNvIG9ucy1hbGVydC1kaWFsb2dcbiAqICAgW2VuXWA8b25zLWFsZXJ0LWRpYWxvZz5gIGNvbXBvbmVudFsvZW5dXG4gKiAgIFtqYV1vbnMtYWxlcnQtZGlhbG9n44Kz44Oz44Od44O844ON44Oz44OIWy9qYV1cbiAqIEBzZWVhbHNvIG9ucy1wb3BvdmVyXG4gKiAgIFtlbl1gPG9ucy1wb3BvdmVyPmAgY29tcG9uZW50Wy9lbl1cbiAqICAgW2phXW9ucy1wb3BvdmVy44Kz44Oz44Od44O844ON44Oz44OIWy9qYV1cbiAqIEBzZWVhbHNvIG9ucy1tb2RhbFxuICogICBbZW5dYDxvbnMtbW9kYWw+YCBjb21wb25lbnRbL2VuXVxuICogICBbamFdb25zLW1vZGFs44Kz44Oz44Od44O844ON44Oz44OIWy9qYV1cbiAqIEBleGFtcGxlXG4gKiA8b25zLWRpYWxvZyBpZD1cImRpYWxvZ1wiPlxuICogICA8cD5UaGlzIGlzIGEgZGlhbG9nITwvcD5cbiAqIDwvb25zLWRpYWxvZz5cbiAqXG4gKiA8c2NyaXB0PlxuICogICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZGlhbG9nJykuc2hvdygpO1xuICogPC9zY3JpcHQ+XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIERpYWxvZ0VsZW1lbnQgZXh0ZW5kcyBCYXNlRGlhbG9nRWxlbWVudCB7XG5cbiAgLyoqXG4gICAqIEBldmVudCBwcmVzaG93XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBbZW5dRmlyZWQganVzdCBiZWZvcmUgdGhlIGRpYWxvZyBpcyBkaXNwbGF5ZWQuWy9lbl1cbiAgICogW2phXeODgOOCpOOCouODreOCsOOBjOihqOekuuOBleOCjOOCi+ebtOWJjeOBq+eZuueBq+OBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCBbZW5dRXZlbnQgb2JqZWN0LlsvZW5dXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5kaWFsb2dcbiAgICogICBbZW5dQ29tcG9uZW50IG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgrPjg7Pjg53jg7zjg43jg7Pjg4jjga7jgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBldmVudC5jYW5jZWxcbiAgICogICBbZW5dRXhlY3V0ZSB0aGlzIGZ1bmN0aW9uIHRvIHN0b3AgdGhlIGRpYWxvZyBmcm9tIGJlaW5nIHNob3duLlsvZW5dXG4gICAqICAgW2phXeOBk+OBrumWouaVsOOCkuWun+ihjOOBmeOCi+OBqOOAgeODgOOCpOOCouODreOCsOOBruihqOekuuOBjOOCreODo+ODs+OCu+ODq+OBleOCjOOBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAZXZlbnQgcG9zdHNob3dcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIFtlbl1GaXJlZCBqdXN0IGFmdGVyIHRoZSBkaWFsb2cgaXMgZGlzcGxheWVkLlsvZW5dXG4gICAqIFtqYV3jg4DjgqTjgqLjg63jgrDjgYzooajnpLrjgZXjgozjgZ/nm7TlvozjgavnmbrngavjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgW2VuXUV2ZW50IG9iamVjdC5bL2VuXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQuZGlhbG9nXG4gICAqICAgW2VuXUNvbXBvbmVudCBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Kz44Oz44Od44O844ON44Oz44OI44Gu44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBldmVudCBwcmVoaWRlXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBbZW5dRmlyZWQganVzdCBiZWZvcmUgdGhlIGRpYWxvZyBpcyBoaWRkZW4uWy9lbl1cbiAgICogW2phXeODgOOCpOOCouODreOCsOOBjOmaoOOCjOOCi+ebtOWJjeOBq+eZuueBq+OBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCBbZW5dRXZlbnQgb2JqZWN0LlsvZW5dXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5kaWFsb2dcbiAgICogICBbZW5dQ29tcG9uZW50IG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgrPjg7Pjg53jg7zjg43jg7Pjg4jjga7jgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBldmVudC5jYW5jZWxcbiAgICogICBbZW5dRXhlY3V0ZSB0aGlzIGZ1bmN0aW9uIHRvIHN0b3AgdGhlIGRpYWxvZyBmcm9tIGJlaW5nIGhpZGRlbi5bL2VuXVxuICAgKiAgIFtqYV3jgZPjga7plqLmlbDjgpLlrp/ooYzjgZnjgovjgajjgIHjg4DjgqTjgqLjg63jgrDjga7pnZ7ooajnpLrjgYzjgq3jg6Pjg7Pjgrvjg6vjgZXjgozjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGV2ZW50IHBvc3RoaWRlXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBbZW5dRmlyZWQganVzdCBhZnRlciB0aGUgZGlhbG9nIGlzIGhpZGRlbi5bL2VuXVxuICAgKiBbamFd44OA44Kk44Ki44Ot44Kw44GM6Zqg44KM44Gf5b6M44Gr55m654Gr44GX44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IFtlbl1FdmVudCBvYmplY3QuWy9lbl1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50LmRpYWxvZ1xuICAgKiAgIFtlbl1Db21wb25lbnQgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCs+ODs+ODneODvOODjeODs+ODiOOBruOCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIG1vZGlmaWVyXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXVRoZSBhcHBlYXJhbmNlIG9mIHRoZSBkaWFsb2cuWy9lbl1cbiAgICogIFtqYV3jg4DjgqTjgqLjg63jgrDjga7ooajnj77jgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBjYW5jZWxhYmxlXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXUlmIHRoaXMgYXR0cmlidXRlIGlzIHNldCB0aGUgZGlhbG9nIGNhbiBiZSBjbG9zZWQgYnkgdGFwcGluZyB0aGUgYmFja2dyb3VuZCBvciBieSBwcmVzc2luZyB0aGUgYmFjayBidXR0b24gb24gQW5kcm9pZCBkZXZpY2VzLlsvZW5dXG4gICAqICBbamFdWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgZGlzYWJsZWRcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dSWYgdGhpcyBhdHRyaWJ1dGUgaXMgc2V0IHRoZSBkaWFsb2cgaXMgZGlzYWJsZWQuWy9lbl1cbiAgICogIFtqYV3jgZPjga7lsZ7mgKfjgYzjgYLjgovmmYLjgIHjg4DjgqTjgqLjg63jgrDjga9kaXNhYmxlZOeKtuaFi+OBq+OBquOCiuOBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGFuaW1hdGlvblxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVmYXVsdCBkZWZhdWx0XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXVRoZSBhbmltYXRpb24gdXNlZCB3aGVuIHNob3dpbmcgYW5kIGhpZGluZyB0aGUgZGlhbG9nLiBDYW4gYmUgZWl0aGVyIGBcIm5vbmVcImAgb3IgYFwiZGVmYXVsdFwiYC5bL2VuXVxuICAgKiAgW2phXeODgOOCpOOCouODreOCsOOCkuihqOekuuOBmeOCi+mam+OBruOCouODi+ODoeODvOOCt+ODp+ODs+WQjeOCkuaMh+WumuOBl+OBvuOBmeOAglwibm9uZVwi44KC44GX44GP44GvXCJkZWZhdWx0XCLjgpLmjIflrprjgafjgY3jgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBhbmltYXRpb24tb3B0aW9uc1xuICAgKiBAdHlwZSB7RXhwcmVzc2lvbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dU3BlY2lmeSB0aGUgYW5pbWF0aW9uJ3MgZHVyYXRpb24sIHRpbWluZyBhbmQgZGVsYXkgd2l0aCBhbiBvYmplY3QgbGl0ZXJhbC4gRS5nLiBge2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAxLCB0aW1pbmc6ICdlYXNlLWluJ31gLlsvZW5dXG4gICAqICBbamFd44Ki44OL44Oh44O844K344On44Oz5pmC44GuZHVyYXRpb24sIHRpbWluZywgZGVsYXnjgpLjgqrjg5bjgrjjgqfjgq/jg4jjg6rjg4bjg6njg6vjgafmjIflrprjgZfjgb7jgZnjgIJlLmcuIGB7ZHVyYXRpb246IDAuMiwgZGVsYXk6IDEsIHRpbWluZzogJ2Vhc2UtaW4nfWBbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBtYXNrLWNvbG9yXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZWZhdWx0IHJnYmEoMCwgMCwgMCwgMC4yKVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFtlbl1Db2xvciBvZiB0aGUgYmFja2dyb3VuZCBtYXNrLiBEZWZhdWx0IGlzIGBcInJnYmEoMCwgMCwgMCwgMC4yKVwiYC5bL2VuXVxuICAgKiAgW2phXeiDjOaZr+OBruODnuOCueOCr+OBruiJsuOCkuaMh+WumuOBl+OBvuOBmeOAglwicmdiYSgwLCAwLCAwLCAwLjIpXCLjgYzjg4fjg5Xjgqnjg6vjg4jlgKTjgafjgZnjgIJbL2phXVxuICAgKi9cblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHRoaXMuX2NvbXBpbGUoKSk7XG4gIH1cblxuICBnZXQgX3NjaGVtZSgpIHtcbiAgICByZXR1cm4gc2NoZW1lO1xuICB9XG5cbiAgZ2V0IF9tYXNrKCkge1xuICAgIHJldHVybiB1dGlsLmZpbmRDaGlsZCh0aGlzLCAnLmRpYWxvZy1tYXNrJyk7XG4gIH1cblxuICBnZXQgX2RpYWxvZygpIHtcbiAgICByZXR1cm4gdXRpbC5maW5kQ2hpbGQodGhpcywgJy5kaWFsb2cnKTtcbiAgfVxuXG4gIF91cGRhdGVBbmltYXRvckZhY3RvcnkoKSB7XG4gICAgcmV0dXJuIG5ldyBBbmltYXRvckZhY3Rvcnkoe1xuICAgICAgYW5pbWF0b3JzOiBfYW5pbWF0b3JEaWN0LFxuICAgICAgYmFzZUNsYXNzOiBEaWFsb2dBbmltYXRvcixcbiAgICAgIGJhc2VDbGFzc05hbWU6ICdEaWFsb2dBbmltYXRvcicsXG4gICAgICBkZWZhdWx0QW5pbWF0aW9uOiB0aGlzLmdldEF0dHJpYnV0ZSgnYW5pbWF0aW9uJylcbiAgICB9KTtcbiAgfVxuXG4gIF9jb21waWxlKCkge1xuICAgIGF1dG9TdHlsZS5wcmVwYXJlKHRoaXMpO1xuXG4gICAgdGhpcy5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgIHRoaXMuc3R5bGUuekluZGV4ID0gMTAwMDE7XG5cbiAgICAvKiBFeHBlY3RlZCByZXN1bHQ6XG4gICAgICogICA8b25zLWRpYWxvZz5cbiAgICAgKiAgICAgPGRpdiBjbGFzcz1cImRpYWxvZy1tYXNrXCI+PC9kaXY+XG4gICAgICogICAgIDxkaXYgY2xhc3M9XCJkaWFsb2dcIj5cbiAgICAgKiAgICAgICA8ZGl2IGNsYXNzPVwiZGlhbG9nLWNvbnRhaW5lclwiPi4uLjwvZGl2PlxuICAgICAqICAgICA8L2Rpdj5cbiAgICAgKiAgIDwvb25zLWRpYWxvZz5cbiAgICAgKi9cblxuICAgIGlmICghdGhpcy5fZGlhbG9nKSB7XG4gICAgICBjb25zdCBkaWFsb2cgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIGRpYWxvZy5jbGFzc0xpc3QuYWRkKCdkaWFsb2cnKTtcblxuICAgICAgY29uc3QgY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICBjb250YWluZXIuY2xhc3NMaXN0LmFkZCgnZGlhbG9nLWNvbnRhaW5lcicpO1xuICAgICAgd2hpbGUgKHRoaXMuZmlyc3RDaGlsZCkge1xuICAgICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5maXJzdENoaWxkKTtcbiAgICAgIH1cbiAgICAgIGRpYWxvZy5hcHBlbmRDaGlsZChjb250YWluZXIpO1xuXG4gICAgICB0aGlzLmFwcGVuZENoaWxkKGRpYWxvZyk7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLl9tYXNrKSB7XG4gICAgICBjb25zdCBtYXNrID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICBtYXNrLmNsYXNzTGlzdC5hZGQoJ2RpYWxvZy1tYXNrJyk7XG4gICAgICB0aGlzLmluc2VydEJlZm9yZShtYXNrLCB0aGlzLmZpcnN0Q2hpbGQpO1xuICAgIH1cblxuICAgIHRoaXMuX2RpYWxvZy5zdHlsZS56SW5kZXggPSAyMDAwMTtcbiAgICB0aGlzLl9tYXNrLnN0eWxlLnpJbmRleCA9IDIwMDAwO1xuXG4gICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ3N0YXR1cy1iYXItZmlsbCcsICcnKTtcblxuICAgIE1vZGlmaWVyVXRpbC5pbml0TW9kaWZpZXIodGhpcywgdGhpcy5fc2NoZW1lKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgb25EZXZpY2VCYWNrQnV0dG9uXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1CYWNrLWJ1dHRvbiBoYW5kbGVyLlsvZW5dXG4gICAqICAgW2phXeODkOODg+OCr+ODnOOCv+ODs+ODj+ODs+ODieODqeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAbWV0aG9kIHNob3dcbiAgICogQHNpZ25hdHVyZSBzaG93KFtvcHRpb25zXSlcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiAgIFtlbl1QYXJhbWV0ZXIgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCquODl+OCt+ODp+ODs+OCkuaMh+WumuOBmeOCi+OCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5hbmltYXRpb25dXG4gICAqICAgW2VuXUFuaW1hdGlvbiBuYW1lLiBBdmFpbGFibGUgYW5pbWF0aW9ucyBhcmUgYFwibm9uZVwiYCBhbmQgYFwic2xpZGVcImAuWy9lbl1cbiAgICogICBbamFd44Ki44OL44Oh44O844K344On44Oz5ZCN44KS5oyH5a6a44GX44G+44GZ44CCXCJub25lXCIsIFwic2xpZGVcIuOBruOBhOOBmuOCjOOBi+OCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5hbmltYXRpb25PcHRpb25zXVxuICAgKiAgIFtlbl1TcGVjaWZ5IHRoZSBhbmltYXRpb24ncyBkdXJhdGlvbiwgZGVsYXkgYW5kIHRpbWluZy4gRS5nLiBge2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAwLjQsIHRpbWluZzogJ2Vhc2UtaW4nfWAuWy9lbl1cbiAgICogICBbamFd44Ki44OL44Oh44O844K344On44Oz5pmC44GuZHVyYXRpb24sIGRlbGF5LCB0aW1pbmfjgpLmjIflrprjgZfjgb7jgZnjgIJlLmcuIGB7ZHVyYXRpb246IDAuMiwgZGVsYXk6IDAuNCwgdGltaW5nOiAnZWFzZS1pbid9YCBbL2phXVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5jYWxsYmFja11cbiAgICogICBbZW5dVGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgYWZ0ZXIgdGhlIGRpYWxvZyBoYXMgYmVlbiByZXZlYWxlZC5bL2VuXVxuICAgKiAgIFtqYV3jg4DjgqTjgqLjg63jgrDjgYzooajnpLrjgZXjgozntYLjgo/jgaPjgZ/lvozjgavlkbzjgbPlh7rjgZXjgozjgovplqLmlbDjgqrjg5bjgrjjgqfjgq/jg4jjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFtlbl1TaG93IHRoZSBkaWFsb2cuWy9lbl1cbiAgICogIFtqYV3jg4DjgqTjgqLjg63jgrDjgpLplovjgY3jgb7jgZnjgIJbL2phXVxuICAgKiBAcmV0dXJuIHtQcm9taXNlfSBSZXNvbHZlcyB0byB0aGUgZGlzcGxheWVkIGVsZW1lbnQuXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAbWV0aG9kIGhpZGVcbiAgICogQHNpZ25hdHVyZSBoaWRlKFtvcHRpb25zXSlcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiAgIFtlbl1QYXJhbWV0ZXIgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCquODl+OCt+ODp+ODs+OCkuaMh+WumuOBmeOCi+OCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5hbmltYXRpb25dXG4gICAqICAgW2VuXUFuaW1hdGlvbiBuYW1lLiBBdmFpbGFibGUgYW5pbWF0aW9ucyBhcmUgYFwibm9uZVwiYCBhbmQgYFwic2xpZGVcImAuWy9lbl1cbiAgICogICBbamFd44Ki44OL44Oh44O844K344On44Oz5ZCN44KS5oyH5a6a44GX44G+44GZ44CCXCJub25lXCIsIFwic2xpZGVcIuOBruOBhOOBmuOCjOOBi+OCkuaMh+WumuOBp+OBjeOBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5hbmltYXRpb25PcHRpb25zXVxuICAgKiAgIFtlbl1TcGVjaWZ5IHRoZSBhbmltYXRpb24ncyBkdXJhdGlvbiwgZGVsYXkgYW5kIHRpbWluZy4gRS5nLiBge2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAwLjQsIHRpbWluZzogJ2Vhc2UtaW4nfWAuWy9lbl1cbiAgICogICBbamFd44Ki44OL44Oh44O844K344On44Oz5pmC44GuZHVyYXRpb24sIGRlbGF5LCB0aW1pbmfjgpLmjIflrprjgZfjgb7jgZnjgIJlLmcuIGB7ZHVyYXRpb246IDAuMiwgZGVsYXk6IDAuNCwgdGltaW5nOiAnZWFzZS1pbid9YFsvamFdXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmNhbGxiYWNrXVxuICAgKiAgIFtlbl1UaGlzIGZ1bmN0aW9ucyBpcyBjYWxsZWQgYWZ0ZXIgdGhlIGRpYWxvZyBoYXMgYmVlbiBoaWRkZW4uWy9lbl1cbiAgICogICBbamFd44OA44Kk44Ki44Ot44Kw44GM6Zqg44KM44Gf5b6M44Gr5ZG844Gz5Ye644GV44KM44KL6Zai5pWw44Kq44OW44K444Kn44Kv44OI44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUhpZGUgdGhlIGRpYWxvZy5bL2VuXVxuICAgKiAgIFtqYV3jg4DjgqTjgqLjg63jgrDjgpLplonjgZjjgb7jgZnjgIJbL2phXVxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKiAgIFtlbl1SZXNvbHZlcyB0byB0aGUgaGlkZGVuIGVsZW1lbnRbL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQHByb3BlcnR5IHZpc2libGVcbiAgICogQHJlYWRvbmx5XG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dV2hldGhlciB0aGUgZGlhbG9nIGlzIHZpc2libGUgb3Igbm90LlsvZW5dXG4gICAqICAgW2phXeimgee0oOOBjOimi+OBiOOCi+WgtOWQiOOBq2B0cnVlYOOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgZGlzYWJsZWRcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1XaGV0aGVyIHRoZSBkaWFsb2cgaXMgZGlzYWJsZWQgb3Igbm90LlsvZW5dXG4gICAqICAgW2phXeeEoeWKueWMluOBleOCjOOBpuOBhOOCi+WgtOWQiOOBq2B0cnVlYOOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgY2FuY2VsYWJsZVxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVdoZXRoZXIgdGhlIGRpYWxvZyBpcyBjYW5jZWxhYmxlIG9yIG5vdC4gQSBjYW5jZWxhYmxlIGRpYWxvZyBjYW4gYmUgY2xvc2VkIGJ5IHRhcHBpbmcgdGhlIGJhY2tncm91bmQgb3IgYnkgcHJlc3NpbmcgdGhlIGJhY2sgYnV0dG9uIG9uIEFuZHJvaWQgZGV2aWNlcy5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAgICogQHBhcmFtIHtEaWFsb2dBbmltYXRvcn0gQW5pbWF0b3JcbiAgICovXG4gIHN0YXRpYyByZWdpc3RlckFuaW1hdG9yKG5hbWUsIEFuaW1hdG9yKSB7XG4gICAgaWYgKCEoQW5pbWF0b3IucHJvdG90eXBlIGluc3RhbmNlb2YgRGlhbG9nQW5pbWF0b3IpKSB7XG4gICAgICB1dGlsLnRocm93QW5pbWF0b3IoJ0RpYWxvZycpO1xuICAgIH1cbiAgICBfYW5pbWF0b3JEaWN0W25hbWVdID0gQW5pbWF0b3I7XG4gIH1cblxuICBzdGF0aWMgZ2V0IGFuaW1hdG9ycygpIHtcbiAgICByZXR1cm4gX2FuaW1hdG9yRGljdDtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgRGlhbG9nQW5pbWF0b3IoKSB7XG4gICAgcmV0dXJuIERpYWxvZ0FuaW1hdG9yO1xuICB9XG59XG5cbm9uc0VsZW1lbnRzLkRpYWxvZyA9IERpYWxvZ0VsZW1lbnQ7XG5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ29ucy1kaWFsb2cnLCBEaWFsb2dFbGVtZW50KTtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5pbXBvcnQgb25zRWxlbWVudHMgZnJvbSAnLi4vb25zL2VsZW1lbnRzJztcbmltcG9ydCB1dGlsIGZyb20gJy4uL29ucy91dGlsJztcbmltcG9ydCBzdHlsZXIgZnJvbSAnLi4vb25zL3N0eWxlcic7XG5pbXBvcnQgYXV0b1N0eWxlIGZyb20gJy4uL29ucy9hdXRvc3R5bGUnO1xuaW1wb3J0IE1vZGlmaWVyVXRpbCBmcm9tICcuLi9vbnMvaW50ZXJuYWwvbW9kaWZpZXItdXRpbCc7XG5pbXBvcnQgQmFzZUVsZW1lbnQgZnJvbSAnLi9iYXNlL2Jhc2UtZWxlbWVudCc7XG5pbXBvcnQgY29udGVudFJlYWR5IGZyb20gJy4uL29ucy9jb250ZW50LXJlYWR5JztcblxuY29uc3QgZGVmYXVsdENsYXNzTmFtZSA9ICdmYWInO1xuXG5jb25zdCBzY2hlbWUgPSB7XG4gICcnOiAnZmFiLS0qJyxcbiAgJy5mYWJfX2ljb24nOiAnZmFiLS0qX19pY29uJ1xufTtcblxuLyoqXG4gKiBAZWxlbWVudCBvbnMtZmFiXG4gKiBAY2F0ZWdvcnkgZm9ybVxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1cbiAqICAgICBUaGUgRmxvYXRpbmcgYWN0aW9uIGJ1dHRvbiBpcyBhIGNpcmN1bGFyIGJ1dHRvbiBkZWZpbmVkIGluIHRoZSBbTWF0ZXJpYWwgRGVzaWduIHNwZWNpZmljYXRpb25dKGh0dHBzOi8vd3d3Lmdvb2dsZS5jb20vZGVzaWduL3NwZWMvY29tcG9uZW50cy9idXR0b25zLWZsb2F0aW5nLWFjdGlvbi1idXR0b24uaHRtbCkuIFRoZXkgYXJlIG9mdGVuIHVzZWQgdG8gcHJvbW90ZSB0aGUgcHJpbWFyeSBhY3Rpb24gb2YgdGhlIGFwcC5cbiAqXG4gKiAgICAgSXQgY2FuIGJlIGRpc3BsYXllZCBlaXRoZXIgYXMgYW4gaW5saW5lIGVsZW1lbnQgb3IgaW4gb25lIG9mIHRoZSBjb3JuZXJzLiBOb3JtYWxseSBpdCB3aWxsIGJlIHBvc2l0aW9uZWQgaW4gdGhlIGxvd2VyIHJpZ2h0IGNvcm5lciBvZiB0aGUgc2NyZWVuLlxuICogICBbL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEB0dXRvcmlhbCB2YW5pbGxhL1JlZmVyZW5jZS9mYWJcbiAqIEBtb2RpZmllciBtaW5pXG4gKiAgIFtlbl1NYWtlcyB0aGUgYG9ucy1mYWJgIHNtYWxsZXIuWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAZ3VpZGUgdGhlbWluZy5odG1sI2Nyb3NzLXBsYXRmb3JtLXN0eWxpbmctYXV0b3N0eWxpbmcgW2VuXUluZm9ybWF0aW9uIGFib3V0IGNyb3NzIHBsYXRmb3JtIHN0eWxpbmdbL2VuXVtqYV1JbmZvcm1hdGlvbiBhYm91dCBjcm9zcyBwbGF0Zm9ybSBzdHlsaW5nWy9qYV1cbiAqIEBzZWVhbHNvIG9ucy1zcGVlZC1kaWFsXG4gKiAgIFtlbl1UaGUgYDxvbnMtc3BlZWQtZGlhbD5gIGNvbXBvbmVudCBpcyBhIEZsb2F0aW5nIGFjdGlvbiBidXR0b24gdGhhdCBkaXNwbGF5cyBhIG1lbnUgd2hlbiB0YXBwZWQuWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEZhYkVsZW1lbnQgZXh0ZW5kcyBCYXNlRWxlbWVudCB7XG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgbW9kaWZpZXJcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dVGhlIGFwcGVhcmFuY2Ugb2YgdGhlIGJ1dHRvbi5bL2VuXVxuICAgKiAgW2phXeODnOOCv+ODs+OBruihqOePvuOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIHJpcHBsZVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFtlbl1JZiB0aGlzIGF0dHJpYnV0ZSBpcyBkZWZpbmVkLCB0aGUgYnV0dG9uIHdpbGwgaGF2ZSBhIHJpcHBsZSBlZmZlY3Qgd2hlbiB0YXBwZWQuWy9lbl1cbiAgICogIFtqYV1bL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBwb3NpdGlvblxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFtlbl1UaGUgcG9zaXRpb24gb2YgdGhlIGJ1dHRvbi4gU2hvdWxkIGJlIGEgc3RyaW5nIGxpa2UgYFwiYm90dG9tIHJpZ2h0XCJgIG9yIGBcInRvcCBsZWZ0XCJgLiBJZiB0aGlzIGF0dHJpYnV0ZSBpcyBub3QgZGVmaW5lZCBpdCB3aWxsIGJlIGRpc3BsYXllZCBhcyBhbiBpbmxpbmUgZWxlbWVudC5bL2VuXVxuICAgKiAgW2phXVsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGRpc2FibGVkXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1TcGVjaWZ5IGlmIGJ1dHRvbiBzaG91bGQgYmUgZGlzYWJsZWQuWy9lbl1cbiAgICogICBbamFd44Oc44K/44Oz44KS54Sh5Yq55YyW44GZ44KL5aC05ZCI44Gv5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIC8vIFRoZSBmb2xsb3dpbmcgc3RhdGVtZW50cyBjYW4gYmUgZXhlY3V0ZWQgYmVmb3JlIGNvbnRlbnRSZWFkeVxuICAgIC8vIHNpbmNlIHRoZXNlIGRvIG5vdCBhY2Nlc3MgdGhlIGNoaWxkcmVuXG4gICAgdGhpcy5faGlkZSgpO1xuICAgIHRoaXMuY2xhc3NMaXN0LmFkZChkZWZhdWx0Q2xhc3NOYW1lKTtcblxuICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB7XG4gICAgICB0aGlzLl9jb21waWxlKCk7XG4gICAgfSk7XG4gIH1cblxuICBfY29tcGlsZSgpIHtcbiAgICBhdXRvU3R5bGUucHJlcGFyZSh0aGlzKTtcblxuICAgIGlmICghdXRpbC5maW5kQ2hpbGQodGhpcywgJy5mYWJfX2ljb24nKSkge1xuICAgICAgY29uc3QgY29udGVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgICAgIGNvbnRlbnQuY2xhc3NMaXN0LmFkZCgnZmFiX19pY29uJyk7XG5cbiAgICAgIHV0aWwuYXJyYXlGcm9tKHRoaXMuY2hpbGROb2RlcykuZm9yRWFjaChlbGVtZW50ID0+IHtcbiAgICAgICAgaWYgKCFlbGVtZW50LnRhZ05hbWUgfHwgZWxlbWVudC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgIT09ICdvbnMtcmlwcGxlJykge1xuICAgICAgICAgIGNvbnRlbnQuYXBwZW5kQ2hpbGQoZWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdGhpcy5hcHBlbmRDaGlsZChjb250ZW50KTtcbiAgICB9XG5cbiAgICB0aGlzLl91cGRhdGVSaXBwbGUoKTtcblxuICAgIE1vZGlmaWVyVXRpbC5pbml0TW9kaWZpZXIodGhpcywgc2NoZW1lKTtcblxuICAgIHRoaXMuX3VwZGF0ZVBvc2l0aW9uKCk7XG4gIH1cblxuICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICBzZXRJbW1lZGlhdGUoKCkgPT4gdGhpcy5fc2hvdygpKTtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgb2JzZXJ2ZWRBdHRyaWJ1dGVzKCkge1xuICAgIHJldHVybiBbJ21vZGlmaWVyJywgJ3JpcHBsZScsICdwb3NpdGlvbicsICdjbGFzcyddO1xuICB9XG5cbiAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIGxhc3QsIGN1cnJlbnQpIHtcbiAgICBzd2l0Y2ggKG5hbWUpIHtcbiAgICAgIGNhc2UgJ2NsYXNzJzpcbiAgICAgICAgdXRpbC5yZXN0b3JlQ2xhc3ModGhpcywgZGVmYXVsdENsYXNzTmFtZSwgc2NoZW1lKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdtb2RpZmllcic6XG4gICAgICAgIE1vZGlmaWVyVXRpbC5vbk1vZGlmaWVyQ2hhbmdlZChsYXN0LCBjdXJyZW50LCB0aGlzLCBzY2hlbWUpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3JpcHBsZSc6XG4gICAgICAgIHRoaXMuX3VwZGF0ZVJpcHBsZSgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3Bvc2l0aW9uJzpcbiAgICAgICAgdGhpcy5fdXBkYXRlUG9zaXRpb24oKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgX3Nob3coKSB7XG4gICAgaWYgKCF0aGlzLl9tYW51YWxseUhpZGRlbikgeyAvLyBpZiB1c2VyIGhhcyBub3QgY2FsbGVkIG9ucy1mYWIuaGlkZSgpXG4gICAgICB0aGlzLl90b2dnbGUodHJ1ZSk7XG4gICAgfVxuICB9XG5cbiAgX2hpZGUoKSB7XG4gICAgc2V0SW1tZWRpYXRlKCgpID0+IHRoaXMuX3RvZ2dsZShmYWxzZSkpO1xuICB9XG5cbiAgX3VwZGF0ZVJpcHBsZSgpIHtcbiAgICB1dGlsLnVwZGF0ZVJpcHBsZSh0aGlzKTtcbiAgfVxuXG4gIF91cGRhdGVQb3NpdGlvbigpIHtcbiAgICBjb25zdCBwb3NpdGlvbiA9IHRoaXMuZ2V0QXR0cmlidXRlKCdwb3NpdGlvbicpO1xuICAgIHRoaXMuY2xhc3NMaXN0LnJlbW92ZShcbiAgICAgICdmYWItLXRvcF9fbGVmdCcsXG4gICAgICAnZmFiLS1ib3R0b21fX3JpZ2h0JyxcbiAgICAgICdmYWItLWJvdHRvbV9fbGVmdCcsXG4gICAgICAnZmFiLS10b3BfX3JpZ2h0JyxcbiAgICAgICdmYWItLXRvcF9fY2VudGVyJyxcbiAgICAgICdmYWItLWJvdHRvbV9fY2VudGVyJyk7XG4gICAgc3dpdGNoIChwb3NpdGlvbikge1xuICAgICAgY2FzZSAndG9wIHJpZ2h0JzpcbiAgICAgIGNhc2UgJ3JpZ2h0IHRvcCc6XG4gICAgICAgIHRoaXMuY2xhc3NMaXN0LmFkZCgnZmFiLS10b3BfX3JpZ2h0Jyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndG9wIGxlZnQnOlxuICAgICAgY2FzZSAnbGVmdCB0b3AnOlxuICAgICAgICB0aGlzLmNsYXNzTGlzdC5hZGQoJ2ZhYi0tdG9wX19sZWZ0Jyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnYm90dG9tIHJpZ2h0JzpcbiAgICAgIGNhc2UgJ3JpZ2h0IGJvdHRvbSc6XG4gICAgICAgIHRoaXMuY2xhc3NMaXN0LmFkZCgnZmFiLS1ib3R0b21fX3JpZ2h0Jyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnYm90dG9tIGxlZnQnOlxuICAgICAgY2FzZSAnbGVmdCBib3R0b20nOlxuICAgICAgICB0aGlzLmNsYXNzTGlzdC5hZGQoJ2ZhYi0tYm90dG9tX19sZWZ0Jyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnY2VudGVyIHRvcCc6XG4gICAgICBjYXNlICd0b3AgY2VudGVyJzpcbiAgICAgICAgdGhpcy5jbGFzc0xpc3QuYWRkKCdmYWItLXRvcF9fY2VudGVyJyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnY2VudGVyIGJvdHRvbSc6XG4gICAgICBjYXNlICdib3R0b20gY2VudGVyJzpcbiAgICAgICAgdGhpcy5jbGFzc0xpc3QuYWRkKCdmYWItLWJvdHRvbV9fY2VudGVyJyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2Qgc2hvd1xuICAgKiBAc2lnbmF0dXJlIHNob3coKVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFtlbl1TaG93IHRoZSBmbG9hdGluZyBhY3Rpb24gYnV0dG9uLlsvZW5dXG4gICAqICBbamFdWy9qYV1cbiAgICovXG4gIHNob3coKSB7XG4gICAgdGhpcy50b2dnbGUodHJ1ZSk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBoaWRlXG4gICAqIEBzaWduYXR1cmUgaGlkZSgpXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXUhpZGUgdGhlIGZsb2F0aW5nIGFjdGlvbiBidXR0b24uWy9lbl1cbiAgICogIFtqYV1bL2phXVxuICAgKi9cbiAgaGlkZSgpIHtcbiAgICB0aGlzLnRvZ2dsZShmYWxzZSk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCB0b2dnbGVcbiAgICogQHNpZ25hdHVyZSB0b2dnbGUoKVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dVG9nZ2xlIHRoZSB2aXNpYmlsaXR5IG9mIHRoZSBidXR0b24uWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG4gIHRvZ2dsZShhY3Rpb24gPSAhdGhpcy52aXNpYmxlKSB7XG4gICAgdGhpcy5fbWFudWFsbHlIaWRkZW4gPSAhYWN0aW9uO1xuICAgIHRoaXMuX3RvZ2dsZShhY3Rpb24pO1xuICB9XG5cbiAgX3RvZ2dsZShhY3Rpb24gPSAhdGhpcy52aXNpYmxlKSB7XG4gICAgY29uc3QgaXNCb3R0b20gPSAodGhpcy5nZXRBdHRyaWJ1dGUoJ3Bvc2l0aW9uJykgfHwgJycpLmluZGV4T2YoJ2JvdHRvbScpID49IDA7XG4gICAgY29uc3QgdHJhbnNsYXRlID0gaXNCb3R0b20gPyBgdHJhbnNsYXRlM2QoMHB4LCAtJHt1dGlsLmdsb2JhbHMuZmFiT2Zmc2V0IHx8IDB9cHgsIDBweClgIDogJyc7XG5cbiAgICBzdHlsZXIodGhpcywgeyB0cmFuc2Zvcm06IGAke3RyYW5zbGF0ZX0gc2NhbGUoJHtOdW1iZXIoYWN0aW9uKX0pYCB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgZGlzYWJsZWRcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1XaGV0aGVyIHRoZSBlbGVtZW50IGlzIGRpc2FibGVkIG9yIG5vdC5bL2VuXVxuICAgKiAgIFtqYV3nhKHlirnljJbjgZXjgozjgabjgYTjgovloLTlkIjjgatgdHJ1ZWDjgIJbL2phXVxuICAgKi9cbiAgc2V0IGRpc2FibGVkKHZhbHVlKSB7XG4gICAgcmV0dXJuIHV0aWwudG9nZ2xlQXR0cmlidXRlKHRoaXMsICdkaXNhYmxlZCcsIHZhbHVlKTtcbiAgfVxuXG4gIGdldCBkaXNhYmxlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5oYXNBdHRyaWJ1dGUoJ2Rpc2FibGVkJyk7XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IHZpc2libGVcbiAgICogQHJlYWRvbmx5XG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dV2hldGhlciB0aGUgZWxlbWVudCBpcyB2aXNpYmxlIG9yIG5vdC5bL2VuXVxuICAgKiAgIFtqYV3opoHntKDjgYzopovjgYjjgovloLTlkIjjgatgdHJ1ZWDjgIJbL2phXVxuICAgKi9cbiAgZ2V0IHZpc2libGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3R5bGUudHJhbnNmb3JtLmluZGV4T2YoJ3NjYWxlKDApJykgPT09IC0xICYmIHRoaXMuc3R5bGUuZGlzcGxheSAhPT0gJ25vbmUnO1xuICB9XG59XG5cbm9uc0VsZW1lbnRzLkZhYiA9IEZhYkVsZW1lbnQ7XG5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ29ucy1mYWInLCBGYWJFbGVtZW50KTtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCBvbnNFbGVtZW50cyBmcm9tICcuLi9vbnMvZWxlbWVudHMnO1xuaW1wb3J0IEJhc2VFbGVtZW50IGZyb20gJy4vYmFzZS9iYXNlLWVsZW1lbnQnO1xuaW1wb3J0IEdlc3R1cmVEZXRlY3RvciBmcm9tICcuLi9vbnMvZ2VzdHVyZS1kZXRlY3Rvcic7XG5cbi8qKlxuICogQGVsZW1lbnQgb25zLWdlc3R1cmUtZGV0ZWN0b3JcbiAqIEBjYXRlZ29yeSBnZXN0dXJlXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXVxuICogICAgIENvbXBvbmVudCB0byBkZXRlY3QgZmluZ2VyIGdlc3R1cmVzIHdpdGhpbiB0aGUgd3JhcHBlZCBlbGVtZW50LiBGb2xsb3dpbmcgZ2VzdHVyZXMgYXJlIHN1cHBvcnRlZDpcbiAqICAgICAtIERyYWcgZ2VzdHVyZXM6IGBkcmFnYCwgYGRyYWdsZWZ0YCwgYGRyYWdyaWdodGAsIGBkcmFndXBgLCBgZHJhZ2Rvd25gXG4gKiAgICAgLSBIb2xkIGdlc3R1cmVzOiBgaG9sZGAsIGByZWxlYXNlYFxuICogICAgIC0gU3dpcGUgZ2VzdHVyZXM6IGBzd2lwZWAsIGBzd2lwZWxlZnRgLCBgc3dpcGVyaWdodGAsIGBzd2lwZXVwYCwgYHN3aXBlZG93bmBcbiAqICAgICAtIFRhcCBnZXN0dXJlczogYHRhcGAsIGBkb3VibGV0YXBgXG4gKiAgICAgLSBQaW5jaCBnZXN0dXJlczogYHBpbmNoYCwgYHBpbmNoaW5gLCBgcGluY2hvdXRgXG4gKiAgICAgLSBPdGhlciBnZXN0dXJlczogYHRvdWNoYCwgYHRyYW5zZm9ybWAsIGByb3RhdGVgXG4gKiAgIFsvZW5dXG4gKiAgIFtqYV3opoHntKDlhoXjga7jgrjjgqfjgrnjg4Hjg6Pjg7zmk43kvZzjgpLmpJznn6XjgZfjgb7jgZnjgILoqbPjgZfjgY/jga/jgqzjgqTjg4njgpLlj4LnhafjgZfjgabjgY/jgaDjgZXjgYTjgIJbL2phXVxuICogQGd1aWRlIGZlYXR1cmVzLmh0bWwjZ2VzdHVyZS1kZXRlY3Rpb25cbiAqICAgW2VuXURldGVjdGluZyBmaW5nZXIgZ2VzdHVyZXNbL2VuXVxuICogICBbamFd44K444Kn44K544OB44Oj44O85pON5L2c44Gu5qSc55+lWy9qYV1cbiAqIEBleGFtcGxlXG4gKiA8b25zLWdlc3R1cmUtZGV0ZWN0b3I+XG4gKiAgIDxkaXYgaWQ9XCJkZXRlY3QtYXJlYVwiIHN0eWxlPVwid2lkdGg6IDEwMHB4OyBoZWlnaHQ6IDEwMHB4O1wiPlxuICogICAgIFN3aXBlIEhlcmVcbiAqICAgPC9kaXY+XG4gKiA8L29ucy1nZXN0dXJlLWRldGVjdG9yPlxuICpcbiAqIDxzY3JpcHQ+XG4gKiAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3N3aXBlbGVmdCcsIGZ1bmN0aW9uKGV2ZW50KSB7XG4gKiAgICAgaWYgKGV2ZW50LnRhcmdldC5tYXRjaGVzKCcjZGV0ZWN0LWFyZWEnKSkge1xuICogICAgICAgY29uc29sZS5sb2coJ1N3aXBlIGxlZnQgaXMgZGV0ZWN0ZWQuJyk7XG4gKiAgICAgfVxuICogICB9KTtcbiAqIDwvc2NyaXB0PlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBHZXN0dXJlRGV0ZWN0b3JFbGVtZW50IGV4dGVuZHMgQmFzZUVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgdGhpcy5fZ2VzdHVyZURldGVjdG9yID0gbmV3IEdlc3R1cmVEZXRlY3Rvcih0aGlzLCB7IHBhc3NpdmU6IHRydWUgfSk7XG4gIH1cbn1cblxub25zRWxlbWVudHMuR2VzdHVyZURldGVjdG9yID0gR2VzdHVyZURldGVjdG9yRWxlbWVudDtcbmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnb25zLWdlc3R1cmUtZGV0ZWN0b3InLCBHZXN0dXJlRGV0ZWN0b3JFbGVtZW50KTtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCBvbnNFbGVtZW50cyBmcm9tICcuLi9vbnMvZWxlbWVudHMnO1xuaW1wb3J0IHV0aWwgZnJvbSAnLi4vb25zL3V0aWwnO1xuaW1wb3J0IGF1dG9TdHlsZSBmcm9tICcuLi9vbnMvYXV0b3N0eWxlJztcbmltcG9ydCBCYXNlRWxlbWVudCBmcm9tICcuL2Jhc2UvYmFzZS1lbGVtZW50JztcbmltcG9ydCBjb250ZW50UmVhZHkgZnJvbSAnLi4vb25zL2NvbnRlbnQtcmVhZHknO1xuXG5sZXQgYXV0b1ByZWZpeCA9ICdmYSc7IC8vIEZJWE1FOiBUbyBiZSByZW1vdmVkIGluIHYzXG5cbi8qKlxuICogQGVsZW1lbnQgb25zLWljb25cbiAqIEBjYXRlZ29yeSB2aXN1YWxcbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dXG4gKiAgICAgRGlzcGxheXMgYW4gaWNvbi4gVGhlIGZvbGxvd2luZyBpY29uIHN1aXRlcyBhcmUgYXZhaWxhYmxlOlxuICpcbiAqICAgICAqIFtGb250IEF3ZXNvbWVdKGh0dHBzOi8vZm9ydGF3ZXNvbWUuZ2l0aHViLmlvL0ZvbnQtQXdlc29tZS8pXG4gKiAgICAgKiBbSW9uaWNvbnNdKGh0dHA6Ly9pb25pY29ucy5jb20vKVxuICogICAgICogW01hdGVyaWFsIERlc2lnbiBJY29uaWMgRm9udF0oaHR0cDovL3phdm9sb2tsb20uZ2l0aHViLmlvL21hdGVyaWFsLWRlc2lnbi1pY29uaWMtZm9udC8pXG4gKiAgIFsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQGNvZGVwZW4geEFodmdcbiAqIEB0dXRvcmlhbCB2YW5pbGxhL1JlZmVyZW5jZS9pY29uXG4gKiBAZ3VpZGUgdGhlbWluZy5odG1sI2Nyb3NzLXBsYXRmb3JtLXN0eWxpbmctYXV0b3N0eWxpbmcgW2VuXUluZm9ybWF0aW9uIGFib3V0IGNyb3NzIHBsYXRmb3JtIHN0eWxpbmdbL2VuXVtqYV1bL2phXVxuICogQGd1aWRlIGFwcHNpemUuaHRtbCNyZW1vdmluZy1pY29uLXBhY2tzIFtlbl1SZW1vdmluZyBpY29uIHBhY2tzLlsvZW5dW2phXVsvamFdXG4gKiBAZ3VpZGUgZmFxLmh0bWwjaG93LWNhbi1pLXVzZS1jdXN0b20taWNvbi1wYWNrcyBbZW5dQWRkaW5nIGN1c3RvbSBpY29uIHBhY2tzLlsvZW5dW2phXVsvamFdXG4gKiBAZXhhbXBsZVxuICogPG9ucy1pY29uXG4gKiAgIGljb249XCJtZC1jYXJcIlxuICogICBzaXplPVwiMjBweFwiXG4gKiAgIHN0eWxlPVwiY29sb3I6IHJlZFwiPlxuICogPC9vbnMtaWNvbj5cbiAqXG4gKiA8b25zLWJ1dHRvbj5cbiAqICAgPG9ucy1pY29uIGljb249XCJtZC1jYXJcIj48L29ucy1pY29uPlxuICogICBDYXJcbiAqIDwvb25zLWJ1dHRvbj5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSWNvbkVsZW1lbnQgZXh0ZW5kcyBCYXNlRWxlbWVudCB7XG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgaWNvblxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dXG4gICAqICAgICBUaGUgaWNvbiBuYW1lLiBgXCJtZC1cImAgcHJlZml4IGZvciBNYXRlcmlhbCBJY29ucywgYFwiZmEtXCJgIGZvciBGb250IEF3ZXNvbWUgYW5kIGBcImlvbi1cImAgcHJlZml4IGZvciBJb25pY29ucy5cbiAgICpcbiAgICogICAgIFNlZSBhbGwgYXZhaWxhYmxlIGljb25zIG9uIHRoZSBlbGVtZW50IGRlc2NyaXB0aW9uIChhdCB0aGUgdG9wKS5cbiAgICpcbiAgICogICAgIEljb25zIGNhbiBhbHNvIGJlIHN0eWxlZCBiYXNlZCBvbiBtb2RpZmllciBwcmVzZW5jZS4gQWRkIGNvbW1hLXNlcGFyYXRlZCBpY29ucyB3aXRoIGBcIm1vZGlmaWVyTmFtZTpcImAgcHJlZml4LlxuICAgKlxuICAgKiAgICAgVGhlIGNvZGUgYDxvbnMtaWNvbiBpY29uPVwiaW9uLWVkaXQsIG1hdGVyaWFsOm1kLWVkaXRcIj48L29ucy1pY29uPmAgd2lsbCBkaXNwbGF5IGBcIm1kLWVkaXRcImAgZm9yIE1hdGVyaWFsIERlc2lnbiBhbmQgYFwiaW9uLWVkaXRcImAgYXMgdGhlIGRlZmF1bHQgaWNvbi5cbiAgICpcbiAgICogICAgIGBmYS1gIHByZWZpeCBpcyBhZGRlZCBhdXRvbWF0aWNhbGx5IGlmIG5vbmUgaXMgcHJvdmlkZWQuIENoZWNrIFtTZWUgYWxzb10oI3NlZWFsc28pIHNlY3Rpb24gZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gICAqICAgWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgc2l6ZVxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dXG4gICAqICAgICBUaGUgc2l6ZXMgb2YgdGhlIGljb24uIFZhbGlkIHZhbHVlcyBhcmUgbGcsIDJ4LCAzeCwgNHgsIDV4LCBvciBpbiB0aGUgc2l6ZSBpbiBwaXhlbHMuXG4gICAqICAgICBJY29ucyBjYW4gYWxzbyBiZSBzdHlsZWQgYmFzZWQgb24gbW9kaWZpZXIgcHJlc2VuY2UuIEFkZCBjb21tYS1zZXBhcmF0ZWQgaWNvbnMgd2l0aCBgXCJtb2RpZmllck5hbWU6XCJgIHByZWZpeC5cbiAgICpcbiAgICogICAgIFRoZSBjb2RlOlxuICAgKlxuICAgKiAgICAgYGBgXG4gICAqICAgICA8b25zLWljb25cbiAgICogICAgICAgaWNvbj1cImlvbi1lZGl0XCJcbiAgICogICAgICAgc2l6ZT1cIjMycHgsIG1hdGVyaWFsOjI0cHhcIj5cbiAgICogICAgIDwvb25zLWljb24+XG4gICAqICAgICBgYGBcbiAgICpcbiAgICogICAgIHdpbGwgcmVuZGVyIGFzIGEgYDI0cHhgIGljb24gaWYgdGhlIGBcIm1hdGVyaWFsXCJgIG1vZGlmaWVyIGlzIHByZXNlbnQgYW5kIGAzMnB4YCBvdGhlcndpc2UuXG4gICAqICAgWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgcm90YXRlXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1OdW1iZXIgb2YgZGVncmVlcyB0byByb3RhdGUgdGhlIGljb24uIFZhbGlkIHZhbHVlcyBhcmUgOTAsIDE4MCBhbmQgMjcwLlsvZW5dXG4gICAqICAgW2phXeOCouOCpOOCs+ODs+OCkuWbnui7ouOBl+OBpuihqOekuuOBl+OBvuOBmeOAgjkwLCAxODAsIDI3MOOBi+OCieaMh+WumuOBp+OBjeOBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGZpeGVkLXdpZHRoXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFtlbl1XaGVuIHVzZWQgaW4gYSBsaXN0LCB5b3Ugd2FudCB0aGUgaWNvbnMgdG8gaGF2ZSB0aGUgc2FtZSB3aWR0aCBzbyB0aGF0IHRoZXkgYWxpZ24gdmVydGljYWxseSBieSBkZWZpbmluZyB0aGlzIGF0dHJpYnV0ZS5bL2VuXVxuICAgKiAgW2phXVsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIHNwaW5cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVNwZWNpZnkgd2hldGhlciB0aGUgaWNvbiBzaG91bGQgYmUgc3Bpbm5pbmcuWy9lbl1cbiAgICogICBbamFd44Ki44Kk44Kz44Oz44KS5Zue6Lui44GZ44KL44GL44Gp44GG44GL44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB7XG4gICAgICB0aGlzLl9jb21waWxlKCk7XG4gICAgfSk7XG4gIH1cblxuICBzdGF0aWMgZ2V0IG9ic2VydmVkQXR0cmlidXRlcygpIHtcbiAgICByZXR1cm4gWydpY29uJywgJ3NpemUnLCAnbW9kaWZpZXInLCAnY2xhc3MnXTtcbiAgfVxuXG4gIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBsYXN0LCBjdXJyZW50KSB7XG4gICAgdGhpcy5fY2xlYW5DbGFzc0F0dHJpYnV0ZShuYW1lID09PSAnaWNvbicgPyBsYXN0IDogdGhpcy5nZXRBdHRyaWJ1dGUoJ2ljb24nKSwgbmFtZSA9PT0gJ21vZGlmaWVyJyA/IGxhc3QgOiB1bmRlZmluZWQpO1xuICAgIHRoaXMuX3VwZGF0ZSgpO1xuICB9XG5cbiAgX2NvbXBpbGUoKSB7XG4gICAgYXV0b1N0eWxlLnByZXBhcmUodGhpcyk7XG4gICAgdGhpcy5fdXBkYXRlKCk7XG4gIH1cblxuICBfdXBkYXRlKCkge1xuICAgIGNvbnN0IHtjbGFzc0xpc3QsIHN0eWxlfSA9IHRoaXMuX2J1aWxkQ2xhc3NBbmRTdHlsZSh0aGlzLl9wYXJzZUF0dHIoJ2ljb24nKSwgdGhpcy5fcGFyc2VBdHRyKCdzaXplJykpO1xuICAgIHV0aWwuZXh0ZW5kKHRoaXMuc3R5bGUsIHN0eWxlKTtcblxuICAgIGNsYXNzTGlzdC5mb3JFYWNoKGNsYXNzTmFtZSA9PiB0aGlzLmNsYXNzTGlzdC5hZGQoY2xhc3NOYW1lKSk7XG4gIH1cblxuICBfcGFyc2VBdHRyKGF0dHJOYW1lLCBtb2RpZmllciA9IHRoaXMuZ2V0QXR0cmlidXRlKCdtb2RpZmllcicpIHx8ICcnKSB7XG4gICAgY29uc3QgYXR0ciA9IHRoaXMuZ2V0QXR0cmlidXRlKGF0dHJOYW1lKSB8fCBhdHRyTmFtZSB8fCAnJ1xuICAgIGNvbnN0IHBhcnRzID0gYXR0ci5zcGxpdCgvXFxzKixcXHMqLyk7XG4gICAgY29uc3QgZGVmID0gcGFydHNbMF07XG4gICAgbGV0IG1kID0gcGFydHNbMV07XG4gICAgbWQgPSAobWQgfHwgJycpLnNwbGl0KC9cXHMqOlxccyovKTtcblxuICAgIHJldHVybiAobW9kaWZpZXIgJiYgKFJlZ0V4cChgKF58XFxcXHMrKSR7bWRbMF19KCR8XFxcXHMrKWAsICdpJykudGVzdChtb2RpZmllcikpID8gbWRbMV0gOiBkZWYpIHx8ICcnO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSB1bm5lZWRlZCBjbGFzcyB2YWx1ZS5cbiAgICovXG4gIF9jbGVhbkNsYXNzQXR0cmlidXRlKGxhc3RJY29uLCBsYXN0TW9kaWZpZXIpIHtcbiAgICBjb25zdCB7IGNsYXNzTmFtZSwgcHJlZml4IH0gPSB0aGlzLl9wcmVmaXhJY29uKHRoaXMuX3BhcnNlQXR0cihsYXN0SWNvbiwgbGFzdE1vZGlmaWVyKSk7XG4gICAgY29uc3QgY3VzdG9tUHJlZml4UkUgPSBjbGFzc05hbWUgIT09IHByZWZpeCA/IGB8JHtwcmVmaXh9JHwke3ByZWZpeH0tYCA6IGB8JHtjbGFzc05hbWV9JGAgfHwgJyc7XG4gICAgY29uc3QgcmUgPSBuZXcgUmVnRXhwKGBeKGZhJHxmYS18aW9uLXx6bWRpJHx6bWRpLXxvbnMtaWNvbi0tJHtjdXN0b21QcmVmaXhSRX0pYCk7XG5cbiAgICB1dGlsLmFycmF5RnJvbSh0aGlzLmNsYXNzTGlzdClcbiAgICAgIC5maWx0ZXIoY2xhc3NOYW1lID0+IHJlLnRlc3QoY2xhc3NOYW1lKSlcbiAgICAgIC5mb3JFYWNoKGNsYXNzTmFtZSA9PiB0aGlzLmNsYXNzTGlzdC5yZW1vdmUoY2xhc3NOYW1lKSk7XG4gIH1cblxuICBfcHJlZml4SWNvbihpY29uTmFtZSkge1xuICAgIGNvbnN0IGNsYXNzTmFtZSA9IGF1dG9QcmVmaXggKyAoYXV0b1ByZWZpeCA/ICctJyA6ICcnKSArIGljb25OYW1lO1xuICAgIHJldHVybiB7IGNsYXNzTmFtZSwgcHJlZml4OiBjbGFzc05hbWUuc3BsaXQoJy0nKVswXSB9O1xuICB9XG5cbiAgX2J1aWxkQ2xhc3NBbmRTdHlsZShpY29uTmFtZSwgc2l6ZSkge1xuICAgIGNvbnN0IGNsYXNzTGlzdCA9IFsnb25zLWljb24nXTtcbiAgICBjb25zdCBzdHlsZSA9IHt9O1xuXG4gICAgLy8gSWNvblxuICAgIGlmIChpY29uTmFtZS5pbmRleE9mKCdpb24tJykgPT09IDApIHtcbiAgICAgIGNsYXNzTGlzdC5wdXNoKGljb25OYW1lKTtcbiAgICAgIGNsYXNzTGlzdC5wdXNoKCdvbnMtaWNvbi0taW9uJyk7XG4gICAgfSBlbHNlIGlmIChpY29uTmFtZS5pbmRleE9mKCdmYS0nKSA9PT0gMCkge1xuICAgICAgY2xhc3NMaXN0LnB1c2goaWNvbk5hbWUpO1xuICAgICAgLy8gZGVmYXVsdCBpY29uIHN0eWxlIHRvIEZvbnQgQXdlc29tZSBTb2xpZCBpZiBpY29uIHN0eWxlIGlzIG5vdCBzcGVjaWZpZWQgYWxyZWFkeVxuICAgICAgaWYgKCEodGhpcy5jbGFzc0xpc3QuY29udGFpbnMoJ2ZhcicpIHx8IHRoaXMuY2xhc3NMaXN0LmNvbnRhaW5zKCdmYWInKSB8fCB0aGlzLmNsYXNzTGlzdC5jb250YWlucygnZmFsJykpKSB7XG4gICAgICAgIGNsYXNzTGlzdC5wdXNoKCdmYScpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaWNvbk5hbWUuaW5kZXhPZignbWQtJykgPT09IDApICB7XG4gICAgICBjbGFzc0xpc3QucHVzaCgnem1kaScpO1xuICAgICAgY2xhc3NMaXN0LnB1c2goJ3ptZGktJyArIGljb25OYW1lLnNwbGl0KC8tKC4rKT8vKVsxXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHsgY2xhc3NOYW1lLCBwcmVmaXggfSA9IHRoaXMuX3ByZWZpeEljb24oaWNvbk5hbWUpO1xuICAgICAgcHJlZml4ICYmIGNsYXNzTGlzdC5wdXNoKHByZWZpeCk7XG4gICAgICBjbGFzc05hbWUgJiYgY2xhc3NMaXN0LnB1c2goY2xhc3NOYW1lKTtcbiAgICB9XG5cbiAgICAvLyBTaXplXG4gICAgaWYgKHNpemUubWF0Y2goL15bMS01XXh8bGckLykpIHtcbiAgICAgIGNsYXNzTGlzdC5wdXNoKCdvbnMtaWNvbi0tJyArIHNpemUpO1xuICAgICAgdGhpcy5zdHlsZS5yZW1vdmVQcm9wZXJ0eSgnZm9udC1zaXplJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0eWxlLmZvbnRTaXplID0gc2l6ZTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgY2xhc3NMaXN0OiBjbGFzc0xpc3QsXG4gICAgICBzdHlsZTogc3R5bGVcbiAgICB9O1xuICB9XG5cbiAgc3RhdGljIHNldEF1dG9QcmVmaXgocHJlZml4KSB7XG4gICAgYXV0b1ByZWZpeCA9IHByZWZpeCA/ICh0eXBlb2YgcHJlZml4ID09PSAnc3RyaW5nJyAmJiBwcmVmaXggfHwgJ2ZhJykgOiAnJztcbiAgfVxufVxuXG5vbnNFbGVtZW50cy5JY29uID0gSWNvbkVsZW1lbnQ7XG5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ29ucy1pY29uJywgSWNvbkVsZW1lbnQpO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IHV0aWwgZnJvbSAnLi4vdXRpbCc7XG5pbXBvcnQgcGxhdGZvcm0gZnJvbSAnLi4vcGxhdGZvcm0nO1xuXG5leHBvcnQgY2xhc3MgTGF6eVJlcGVhdERlbGVnYXRlIHtcblxuICBjb25zdHJ1Y3Rvcih1c2VyRGVsZWdhdGUsIHRlbXBsYXRlRWxlbWVudCA9IG51bGwpIHtcbiAgICBpZiAodHlwZW9mIHVzZXJEZWxlZ2F0ZSAhPT0gJ29iamVjdCcgfHwgdXNlckRlbGVnYXRlID09PSBudWxsKSB7XG4gICAgICB1dGlsLnRocm93KCdcImRlbGVnYXRlXCIgcGFyYW1ldGVyIG11c3QgYmUgYW4gb2JqZWN0Jyk7XG4gICAgfVxuICAgIHRoaXMuX3VzZXJEZWxlZ2F0ZSA9IHVzZXJEZWxlZ2F0ZTtcblxuICAgIGlmICghKHRlbXBsYXRlRWxlbWVudCBpbnN0YW5jZW9mIEVsZW1lbnQpICYmIHRlbXBsYXRlRWxlbWVudCAhPT0gbnVsbCkge1xuICAgICAgdXRpbC50aHJvdygnXCJ0ZW1wbGF0ZUVsZW1lbnRcIiBwYXJhbWV0ZXIgbXVzdCBiZSBhbiBpbnN0YW5jZSBvZiBFbGVtZW50IG9yIG51bGwnKTtcbiAgICB9XG4gICAgdGhpcy5fdGVtcGxhdGVFbGVtZW50ID0gdGVtcGxhdGVFbGVtZW50O1xuICB9XG5cbiAgZ2V0IGl0ZW1IZWlnaHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3VzZXJEZWxlZ2F0ZS5pdGVtSGVpZ2h0O1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuICBoYXNSZW5kZXJGdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fdXNlckRlbGVnYXRlLl9yZW5kZXIgaW5zdGFuY2VvZiBGdW5jdGlvbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgKi9cbiAgX3JlbmRlcigpIHtcbiAgICB0aGlzLl91c2VyRGVsZWdhdGUuX3JlbmRlci5hcHBseSh0aGlzLl91c2VyRGVsZWdhdGUsIGFyZ3VtZW50cyk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGRvbmUgQSBmdW5jdGlvbiB0aGF0IHRha2UgaXRlbSBvYmplY3QgYXMgcGFyYW1ldGVyLlxuICAgKi9cbiAgbG9hZEl0ZW1FbGVtZW50KGluZGV4LCBkb25lKSB7XG4gICAgaWYgKHRoaXMuX3VzZXJEZWxlZ2F0ZS5sb2FkSXRlbUVsZW1lbnQgaW5zdGFuY2VvZiBGdW5jdGlvbikge1xuICAgICAgdGhpcy5fdXNlckRlbGVnYXRlLmxvYWRJdGVtRWxlbWVudChpbmRleCwgZG9uZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLl91c2VyRGVsZWdhdGUuY3JlYXRlSXRlbUNvbnRlbnQoaW5kZXgsIHRoaXMuX3RlbXBsYXRlRWxlbWVudCk7XG4gICAgICBpZiAoIShlbGVtZW50IGluc3RhbmNlb2YgRWxlbWVudCkpIHtcbiAgICAgICAgdXRpbC50aHJvdygnXCJjcmVhdGVJdGVtQ29udGVudFwiIG11c3QgcmV0dXJuIGFuIGluc3RhbmNlIG9mIEVsZW1lbnQnKTtcbiAgICAgIH1cblxuICAgICAgZG9uZSh7ZWxlbWVudH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAqL1xuICBjb3VudEl0ZW1zKCkge1xuICAgIGNvbnN0IGNvdW50ID0gdGhpcy5fdXNlckRlbGVnYXRlLmNvdW50SXRlbXMoKTtcbiAgICBpZiAodHlwZW9mIGNvdW50ICE9PSAnbnVtYmVyJykge1xuICAgICAgdXRpbC50aHJvdygnXCJjb3VudEl0ZW1zXCIgbXVzdCByZXR1cm4gYSBudW1iZXInKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvdW50O1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxuICAgKiBAcGFyYW0ge09iamVjdH0gaXRlbVxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IGl0ZW0uZWxlbWVudFxuICAgKi9cbiAgdXBkYXRlSXRlbShpbmRleCwgaXRlbSkge1xuICAgIGlmICh0aGlzLl91c2VyRGVsZWdhdGUudXBkYXRlSXRlbUNvbnRlbnQgaW5zdGFuY2VvZiBGdW5jdGlvbikge1xuICAgICAgdGhpcy5fdXNlckRlbGVnYXRlLnVwZGF0ZUl0ZW1Db250ZW50KGluZGV4LCBpdGVtKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7TnVtYmVyfVxuICAgKi9cbiAgY2FsY3VsYXRlSXRlbUhlaWdodChpbmRleCkge1xuICAgIGlmICh0aGlzLl91c2VyRGVsZWdhdGUuY2FsY3VsYXRlSXRlbUhlaWdodCBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XG4gICAgICBjb25zdCBoZWlnaHQgPSB0aGlzLl91c2VyRGVsZWdhdGUuY2FsY3VsYXRlSXRlbUhlaWdodChpbmRleCk7XG5cbiAgICAgIGlmICh0eXBlb2YgaGVpZ2h0ICE9PSAnbnVtYmVyJykge1xuICAgICAgICB1dGlsLnRocm93KCdcImNhbGN1bGF0ZUl0ZW1IZWlnaHRcIiBtdXN0IHJldHVybiBhIG51bWJlcicpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gaGVpZ2h0O1xuICAgIH1cblxuICAgIHJldHVybiAwO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxuICAgKiBAcGFyYW0ge09iamVjdH0gaXRlbVxuICAgKi9cbiAgZGVzdHJveUl0ZW0oaW5kZXgsIGl0ZW0pIHtcbiAgICBpZiAodGhpcy5fdXNlckRlbGVnYXRlLmRlc3Ryb3lJdGVtIGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcbiAgICAgIHRoaXMuX3VzZXJEZWxlZ2F0ZS5kZXN0cm95SXRlbShpbmRleCwgaXRlbSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge3ZvaWR9XG4gICAqL1xuICBkZXN0cm95KCkge1xuICAgIGlmICh0aGlzLl91c2VyRGVsZWdhdGUuZGVzdHJveSBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XG4gICAgICB0aGlzLl91c2VyRGVsZWdhdGUuZGVzdHJveSgpO1xuICAgIH1cblxuICAgIHRoaXMuX3VzZXJEZWxlZ2F0ZSA9IHRoaXMuX3RlbXBsYXRlRWxlbWVudCA9IG51bGw7XG4gIH1cbn1cblxuLyoqXG4gKiBUaGlzIGNsYXNzIHByb3ZpZGUgY29yZSBmdW5jdGlvbnMgZm9yIG9ucy1sYXp5LXJlcGVhdC5cbiAqL1xuZXhwb3J0IGNsYXNzIExhenlSZXBlYXRQcm92aWRlciB7XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gd3JhcHBlckVsZW1lbnRcbiAgICogQHBhcmFtIHtMYXp5UmVwZWF0RGVsZWdhdGV9IGRlbGVnYXRlXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih3cmFwcGVyRWxlbWVudCwgZGVsZWdhdGUpIHtcbiAgICBpZiAoIShkZWxlZ2F0ZSBpbnN0YW5jZW9mIExhenlSZXBlYXREZWxlZ2F0ZSkpIHtcbiAgICAgIHV0aWwudGhyb3coJ1wiZGVsZWdhdGVcIiBwYXJhbWV0ZXIgbXVzdCBiZSBhbiBpbnN0YW5jZSBvZiBMYXp5UmVwZWF0RGVsZWdhdGUnKTtcbiAgICB9XG5cbiAgICB0aGlzLl93cmFwcGVyRWxlbWVudCA9IHdyYXBwZXJFbGVtZW50O1xuICAgIHRoaXMuX2RlbGVnYXRlID0gZGVsZWdhdGU7XG4gICAgdGhpcy5faW5zZXJ0SW5kZXggPSAodGhpcy5fd3JhcHBlckVsZW1lbnQuY2hpbGRyZW5bMF0gJiYgdGhpcy5fd3JhcHBlckVsZW1lbnQuY2hpbGRyZW5bMF0udGFnTmFtZSA9PT0gJ09OUy1MQVpZLVJFUEVBVCcpID8gMSA6IDA7XG5cbiAgICBpZiAod3JhcHBlckVsZW1lbnQudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnb25zLWxpc3QnKSB7XG4gICAgICB3cmFwcGVyRWxlbWVudC5jbGFzc0xpc3QuYWRkKCdsYXp5LWxpc3QnKTtcbiAgICB9XG5cbiAgICB0aGlzLl9wYWdlQ29udGVudCA9IHRoaXMuX2ZpbmRQYWdlQ29udGVudEVsZW1lbnQod3JhcHBlckVsZW1lbnQpO1xuXG4gICAgaWYgKCF0aGlzLl9wYWdlQ29udGVudCkge1xuICAgICAgdXRpbC50aHJvdygnTGF6eVJlcGVhdCBtdXN0IGJlIGRlc2NlbmRhbnQgb2YgYSBQYWdlIGVsZW1lbnQnKTtcbiAgICB9XG5cbiAgICB0aGlzLmxhc3RTY3JvbGxUb3AgPSB0aGlzLl9wYWdlQ29udGVudC5zY3JvbGxUb3A7XG4gICAgdGhpcy5wYWRkaW5nID0gMDtcbiAgICB0aGlzLl90b3BQb3NpdGlvbnMgPSBbMF07XG4gICAgdGhpcy5fcmVuZGVyZWRJdGVtcyA9IHt9O1xuXG4gICAgaWYgKCF0aGlzLl9kZWxlZ2F0ZS5pdGVtSGVpZ2h0ICYmICF0aGlzLl9kZWxlZ2F0ZS5jYWxjdWxhdGVJdGVtSGVpZ2h0KDApKSB7XG4gICAgICB0aGlzLl91bmtub3duSXRlbUhlaWdodCA9IHRydWU7XG4gICAgfVxuXG4gICAgdGhpcy5fYWRkRXZlbnRMaXN0ZW5lcnMoKTtcbiAgICB0aGlzLl9vbkNoYW5nZSgpO1xuICB9XG5cbiAgZ2V0IHBhZGRpbmcoKSB7XG4gICAgcmV0dXJuIHBhcnNlSW50KHRoaXMuX3dyYXBwZXJFbGVtZW50LnN0eWxlLnBhZGRpbmdUb3AsIDEwKTtcbiAgfVxuXG4gIHNldCBwYWRkaW5nKG5ld1ZhbHVlKSB7XG4gICAgdGhpcy5fd3JhcHBlckVsZW1lbnQuc3R5bGUucGFkZGluZ1RvcCA9IG5ld1ZhbHVlICsgJ3B4JztcbiAgfVxuXG4gIF9maW5kUGFnZUNvbnRlbnRFbGVtZW50KHdyYXBwZXJFbGVtZW50KSB7XG4gICAgY29uc3QgcGFnZUNvbnRlbnQgPSB1dGlsLmZpbmRQYXJlbnQod3JhcHBlckVsZW1lbnQsICcucGFnZV9fY29udGVudCcpO1xuXG4gICAgaWYgKHBhZ2VDb250ZW50KSB7XG4gICAgICByZXR1cm4gcGFnZUNvbnRlbnQ7XG4gICAgfVxuXG4gICAgY29uc3QgcGFnZSA9IHV0aWwuZmluZFBhcmVudCh3cmFwcGVyRWxlbWVudCwgJ29ucy1wYWdlJyk7XG4gICAgaWYgKHBhZ2UpIHtcbiAgICAgIGNvbnN0IGNvbnRlbnQgPSB1dGlsLmZpbmRDaGlsZChwYWdlLCAnLmNvbnRlbnQnKTtcbiAgICAgIGlmIChjb250ZW50KSB7XG4gICAgICAgIHJldHVybiBjb250ZW50O1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgX2NoZWNrSXRlbUhlaWdodChjYWxsYmFjaykge1xuICAgIHRoaXMuX2RlbGVnYXRlLmxvYWRJdGVtRWxlbWVudCgwLCBpdGVtID0+IHtcbiAgICAgIGlmICghdGhpcy5fdW5rbm93bkl0ZW1IZWlnaHQpIHtcbiAgICAgICAgdXRpbC50aHJvdygnSW52YWxpZCBzdGF0ZScpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl93cmFwcGVyRWxlbWVudC5hcHBlbmRDaGlsZChpdGVtLmVsZW1lbnQpO1xuXG4gICAgICBjb25zdCBkb25lID0gKCkgPT4ge1xuICAgICAgICB0aGlzLl9kZWxlZ2F0ZS5kZXN0cm95SXRlbSgwLCBpdGVtKTtcbiAgICAgICAgaXRlbS5lbGVtZW50ICYmIGl0ZW0uZWxlbWVudC5yZW1vdmUoKTtcbiAgICAgICAgZGVsZXRlIHRoaXMuX3Vua25vd25JdGVtSGVpZ2h0O1xuICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgfTtcblxuICAgICAgdGhpcy5faXRlbUhlaWdodCA9IGl0ZW0uZWxlbWVudC5vZmZzZXRIZWlnaHQ7XG5cbiAgICAgIGlmICh0aGlzLl9pdGVtSGVpZ2h0ID4gMCkge1xuICAgICAgICBkb25lKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gcmV0cnkgdG8gbWVhc3VyZSBvZmZzZXQgaGVpZ2h0XG4gICAgICAvLyBkaXJ0eSBmaXggZm9yIGFuZ3VsYXIyIGRpcmVjdGl2ZVxuICAgICAgdGhpcy5fd3JhcHBlckVsZW1lbnQuc3R5bGUudmlzaWJpbGl0eSA9ICdoaWRkZW4nO1xuICAgICAgaXRlbS5lbGVtZW50LnN0eWxlLnZpc2liaWxpdHkgPSAnaGlkZGVuJztcblxuICAgICAgc2V0SW1tZWRpYXRlKCgpID0+IHtcbiAgICAgICAgdGhpcy5faXRlbUhlaWdodCA9IGl0ZW0uZWxlbWVudC5vZmZzZXRIZWlnaHQ7XG4gICAgICAgIGlmICh0aGlzLl9pdGVtSGVpZ2h0ID09IDApIHtcbiAgICAgICAgICB1dGlsLnRocm93KCdJbnZhbGlkIHN0YXRlOiBcIml0ZW1IZWlnaHRcIiBtdXN0IGJlIGdyZWF0ZXIgdGhhbiB6ZXJvJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fd3JhcHBlckVsZW1lbnQuc3R5bGUudmlzaWJpbGl0eSA9ICcnO1xuICAgICAgICBkb25lKCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIGdldCBzdGF0aWNJdGVtSGVpZ2h0KCkge1xuICAgIHJldHVybiB0aGlzLl9kZWxlZ2F0ZS5pdGVtSGVpZ2h0IHx8IHRoaXMuX2l0ZW1IZWlnaHQ7XG4gIH1cbiAgX2NvdW50SXRlbXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RlbGVnYXRlLmNvdW50SXRlbXMoKTtcbiAgfVxuXG4gIF9nZXRJdGVtSGVpZ2h0KGkpIHtcbiAgICAvLyBJdGVtIGlzIHJlbmRlcmVkXG4gICAgaWYgKHRoaXMuX3JlbmRlcmVkSXRlbXMuaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgIGlmICghdGhpcy5fcmVuZGVyZWRJdGVtc1tpXS5oYXNPd25Qcm9wZXJ0eSgnaGVpZ2h0JykpIHtcbiAgICAgICAgdGhpcy5fcmVuZGVyZWRJdGVtc1tpXS5oZWlnaHQgPSB0aGlzLl9yZW5kZXJlZEl0ZW1zW2ldLmVsZW1lbnQub2Zmc2V0SGVpZ2h0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuX3JlbmRlcmVkSXRlbXNbaV0uaGVpZ2h0O1xuICAgIH1cblxuICAgIC8vIEl0ZW0gaXMgbm90IHJlbmRlcmVkLCBzY3JvbGwgdXBcbiAgICBpZiAodGhpcy5fdG9wUG9zaXRpb25zW2kgKyAxXSAmJiB0aGlzLl90b3BQb3NpdGlvbnNbaV0pIHtcbiAgICAgIHJldHVybiB0aGlzLl90b3BQb3NpdGlvbnNbaSArIDFdIC0gdGhpcy5fdG9wUG9zaXRpb25zW2ldO1xuICAgIH1cbiAgICAvLyBJdGVtIGlzIG5vdCByZW5kZXJlZCwgc2Nyb2xsIGRvd25cbiAgICByZXR1cm4gdGhpcy5zdGF0aWNJdGVtSGVpZ2h0IHx8IHRoaXMuX2RlbGVnYXRlLmNhbGN1bGF0ZUl0ZW1IZWlnaHQoaSk7XG4gIH1cblxuICBfY2FsY3VsYXRlUmVuZGVyZWRIZWlnaHQoKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuX3JlbmRlcmVkSXRlbXMpLnJlZHVjZSgoYSwgYikgPT4gYSArIHRoaXMuX2dldEl0ZW1IZWlnaHQoKyhiKSksIDApXG4gIH1cblxuICBfb25DaGFuZ2UoKSB7XG4gICAgdGhpcy5fcmVuZGVyKCk7XG4gIH1cblxuICBfbGFzdEl0ZW1SZW5kZXJlZCgpIHtcbiAgICByZXR1cm4gTWF0aC5tYXgoLi4uT2JqZWN0LmtleXModGhpcy5fcmVuZGVyZWRJdGVtcykpO1xuICB9XG5cbiAgX2ZpcnN0SXRlbVJlbmRlcmVkKCkge1xuICAgIHJldHVybiBNYXRoLm1pbiguLi5PYmplY3Qua2V5cyh0aGlzLl9yZW5kZXJlZEl0ZW1zKSk7XG4gIH1cblxuICByZWZyZXNoKCkge1xuICAgIGNvbnN0IGZvcmNlUmVuZGVyID0geyBmb3JjZVNjcm9sbERvd246IHRydWUgfTtcbiAgICBjb25zdCBmaXJzdEl0ZW1JbmRleCA9IHRoaXMuX2ZpcnN0SXRlbVJlbmRlcmVkKCk7XG5cbiAgICBpZiAodXRpbC5pc0ludGVnZXIoZmlyc3RJdGVtSW5kZXgpKSB7XG4gICAgICB0aGlzLl93cmFwcGVyRWxlbWVudC5zdHlsZS5oZWlnaHQgPSB0aGlzLl90b3BQb3NpdGlvbnNbZmlyc3RJdGVtSW5kZXhdICsgdGhpcy5fY2FsY3VsYXRlUmVuZGVyZWRIZWlnaHQoKSArICdweCc7XG4gICAgICB0aGlzLnBhZGRpbmcgPSB0aGlzLl90b3BQb3NpdGlvbnNbZmlyc3RJdGVtSW5kZXhdO1xuICAgICAgZm9yY2VSZW5kZXIuZm9yY2VGaXJzdEluZGV4ID0gZmlyc3RJdGVtSW5kZXg7XG4gICAgfVxuXG4gICAgdGhpcy5fcmVtb3ZlQWxsRWxlbWVudHMoKTtcbiAgICB0aGlzLl9yZW5kZXIoZm9yY2VSZW5kZXIpO1xuICAgIHRoaXMuX3dyYXBwZXJFbGVtZW50LnN0eWxlLmhlaWdodCA9ICdpbmhlcml0JztcbiAgfVxuXG4gIF9yZW5kZXIoe2ZvcmNlU2Nyb2xsRG93biA9IGZhbHNlLCBmb3JjZUZpcnN0SW5kZXgsIGZvcmNlTGFzdEluZGV4fSA9IHt9KSB7XG4gICAgaWYgKHRoaXMuX3Vua25vd25JdGVtSGVpZ2h0KSB7XG4gICAgICByZXR1cm4gdGhpcy5fY2hlY2tJdGVtSGVpZ2h0KHRoaXMuX3JlbmRlci5iaW5kKHRoaXMsIGFyZ3VtZW50c1swXSkpO1xuICAgIH1cblxuICAgIGNvbnN0IGlzU2Nyb2xsVXAgPSAhZm9yY2VTY3JvbGxEb3duICYmIHRoaXMubGFzdFNjcm9sbFRvcCA+IHRoaXMuX3BhZ2VDb250ZW50LnNjcm9sbFRvcDtcbiAgICB0aGlzLmxhc3RTY3JvbGxUb3AgPSB0aGlzLl9wYWdlQ29udGVudC5zY3JvbGxUb3A7XG4gICAgY29uc3Qga2VlcCA9IHt9O1xuXG4gICAgY29uc3Qgb2Zmc2V0ID0gdGhpcy5fd3JhcHBlckVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wO1xuICAgIGNvbnN0IGxpbWl0ID0gNCAqIHdpbmRvdy5pbm5lckhlaWdodCAtIG9mZnNldDtcbiAgICBjb25zdCBjb3VudCA9IHRoaXMuX2NvdW50SXRlbXMoKTtcblxuICAgIGNvbnN0IGl0ZW1zID0gW107XG4gICAgY29uc3Qgc3RhcnQgPSBmb3JjZUZpcnN0SW5kZXggfHwgTWF0aC5tYXgoMCwgdGhpcy5fY2FsY3VsYXRlU3RhcnRJbmRleChvZmZzZXQpIC0gMzApOyAvLyBSZWNhbGN1bGF0ZSBmb3IgMCBvciB1bmRlZmluZWRcbiAgICBsZXQgaSA9IHN0YXJ0O1xuXG4gICAgZm9yIChsZXQgdG9wID0gdGhpcy5fdG9wUG9zaXRpb25zW2ldOyBpIDwgY291bnQgJiYgdG9wIDwgbGltaXQ7IGkrKykge1xuICAgICAgaWYgKGkgPj0gdGhpcy5fdG9wUG9zaXRpb25zLmxlbmd0aCkgeyAvLyBwZXJmIG9wdGltaXphdGlvblxuICAgICAgICB0aGlzLl90b3BQb3NpdGlvbnMubGVuZ3RoICs9IDEwMDtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fdG9wUG9zaXRpb25zW2ldID0gdG9wO1xuICAgICAgdG9wICs9IHRoaXMuX2dldEl0ZW1IZWlnaHQoaSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2RlbGVnYXRlLmhhc1JlbmRlckZ1bmN0aW9uICYmIHRoaXMuX2RlbGVnYXRlLmhhc1JlbmRlckZ1bmN0aW9uKCkpIHtcbiAgICAgIHJldHVybiB0aGlzLl9kZWxlZ2F0ZS5fcmVuZGVyKHN0YXJ0LCBpLCAoKSA9PiB7XG4gICAgICAgIHRoaXMucGFkZGluZyA9IHRoaXMuX3RvcFBvc2l0aW9uc1tzdGFydF07XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoaXNTY3JvbGxVcCkge1xuICAgICAgZm9yIChsZXQgaiA9IGkgLSAxOyBqID49IHN0YXJ0OyBqLS0pIHtcbiAgICAgICAga2VlcFtqXSA9IHRydWU7XG4gICAgICAgIHRoaXMuX3JlbmRlckVsZW1lbnQoaiwgaXNTY3JvbGxVcCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGxhc3RJbmRleCA9IGZvcmNlTGFzdEluZGV4IHx8IE1hdGgubWF4KGkgLSAxLCAuLi5PYmplY3Qua2V5cyh0aGlzLl9yZW5kZXJlZEl0ZW1zKSk7IC8vIFJlY2FsY3VsYXRlIGZvciAwIG9yIHVuZGVmaW5lZFxuICAgICAgZm9yIChsZXQgaiA9IHN0YXJ0OyBqIDw9IGxhc3RJbmRleDsgaisrKSB7XG4gICAgICAgIGtlZXBbal0gPSB0cnVlO1xuICAgICAgICB0aGlzLl9yZW5kZXJFbGVtZW50KGosIGlzU2Nyb2xsVXApO1xuICAgICAgfVxuICAgIH1cblxuICAgIE9iamVjdC5rZXlzKHRoaXMuX3JlbmRlcmVkSXRlbXMpLmZvckVhY2goa2V5ID0+IGtlZXBba2V5XSB8fCB0aGlzLl9yZW1vdmVFbGVtZW50KGtleSwgaXNTY3JvbGxVcCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGlzU2Nyb2xsVXBcbiAgICovXG4gIF9yZW5kZXJFbGVtZW50KGluZGV4LCBpc1Njcm9sbFVwKSB7XG4gICAgY29uc3QgaXRlbSA9IHRoaXMuX3JlbmRlcmVkSXRlbXNbaW5kZXhdO1xuICAgIGlmIChpdGVtKSB7XG4gICAgICB0aGlzLl9kZWxlZ2F0ZS51cGRhdGVJdGVtKGluZGV4LCBpdGVtKTsgLy8gdXBkYXRlIGlmIGl0IGV4aXN0c1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuX2RlbGVnYXRlLmxvYWRJdGVtRWxlbWVudChpbmRleCwgaXRlbSA9PiB7XG4gICAgICBpZiAoaXNTY3JvbGxVcCkge1xuICAgICAgICB0aGlzLl93cmFwcGVyRWxlbWVudC5pbnNlcnRCZWZvcmUoaXRlbS5lbGVtZW50LCB0aGlzLl93cmFwcGVyRWxlbWVudC5jaGlsZHJlblt0aGlzLl9pbnNlcnRJbmRleF0pXG4gICAgICAgIHRoaXMucGFkZGluZyA9IHRoaXMuX3RvcFBvc2l0aW9uc1tpbmRleF07XG4gICAgICAgIGl0ZW0uaGVpZ2h0ID0gdGhpcy5fdG9wUG9zaXRpb25zW2luZGV4ICsgMV0gLSB0aGlzLl90b3BQb3NpdGlvbnNbaW5kZXhdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fd3JhcHBlckVsZW1lbnQuYXBwZW5kQ2hpbGQoaXRlbS5lbGVtZW50KTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fcmVuZGVyZWRJdGVtc1tpbmRleF0gPSBpdGVtO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGlzU2Nyb2xsVXBcbiAgICovXG4gIF9yZW1vdmVFbGVtZW50KGluZGV4LCBpc1Njcm9sbFVwID0gdHJ1ZSkge1xuICAgIGluZGV4ID0gKyhpbmRleCk7XG4gICAgY29uc3QgaXRlbSA9IHRoaXMuX3JlbmRlcmVkSXRlbXNbaW5kZXhdO1xuICAgIHRoaXMuX2RlbGVnYXRlLmRlc3Ryb3lJdGVtKGluZGV4LCBpdGVtKTtcblxuICAgIGlmIChpc1Njcm9sbFVwKSB7XG4gICAgICB0aGlzLl90b3BQb3NpdGlvbnNbaW5kZXggKyAxXSA9IHVuZGVmaW5lZDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5wYWRkaW5nID0gdGhpcy5wYWRkaW5nICsgdGhpcy5fZ2V0SXRlbUhlaWdodChpbmRleCk7XG4gICAgfVxuXG4gICAgaWYgKGl0ZW0uZWxlbWVudC5wYXJlbnRFbGVtZW50KSB7XG4gICAgICBpdGVtLmVsZW1lbnQucGFyZW50RWxlbWVudC5yZW1vdmVDaGlsZChpdGVtLmVsZW1lbnQpO1xuICAgIH1cblxuICAgIGRlbGV0ZSB0aGlzLl9yZW5kZXJlZEl0ZW1zW2luZGV4XTtcbiAgfVxuXG4gIF9yZW1vdmVBbGxFbGVtZW50cygpIHtcbiAgICBPYmplY3Qua2V5cyh0aGlzLl9yZW5kZXJlZEl0ZW1zKS5mb3JFYWNoKGtleSA9PiB0aGlzLl9yZW1vdmVFbGVtZW50KGtleSkpO1xuICB9XG5cbiAgX3JlY2FsY3VsYXRlVG9wUG9zaXRpb25zKHN0YXJ0LCBlbmQpIHtcbiAgICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPD0gZW5kOyBpKyspIHtcbiAgICAgIHRoaXMuX3RvcFBvc2l0aW9uc1tpICsgMV0gPSB0aGlzLl90b3BQb3NpdGlvbnNbaV0gKyB0aGlzLl9nZXRJdGVtSGVpZ2h0KGkpO1xuICAgIH1cbiAgfVxuXG4gIF9jYWxjdWxhdGVTdGFydEluZGV4KGN1cnJlbnQpIHtcbiAgICBjb25zdCBmaXJzdEl0ZW1JbmRleCA9IHRoaXMuX2ZpcnN0SXRlbVJlbmRlcmVkKCk7XG4gICAgY29uc3QgbGFzdEl0ZW1JbmRleCA9IHRoaXMuX2xhc3RJdGVtUmVuZGVyZWQoKTtcblxuICAgIC8vIEZpeCBmb3IgU2FmYXJpIHNjcm9sbCBhbmQgQW5ndWxhciAyXG4gICAgdGhpcy5fcmVjYWxjdWxhdGVUb3BQb3NpdGlvbnMoZmlyc3RJdGVtSW5kZXgsIGxhc3RJdGVtSW5kZXgpO1xuXG4gICAgbGV0IHN0YXJ0ID0gMDtcbiAgICBsZXQgZW5kID0gdGhpcy5fY291bnRJdGVtcygpIC0gMTtcblxuICAgIC8vIEJpbmFyeSBzZWFyY2ggZm9yIGluZGV4IGF0IHRvcCBvZiBzY3JlZW4gc28gd2UgY2FuIHNwZWVkIHVwIHJlbmRlcmluZy5cbiAgICBmb3IgKDs7KSB7XG4gICAgICBjb25zdCBtaWRkbGUgPSBNYXRoLmZsb29yKChzdGFydCArIGVuZCkgLyAyKTtcbiAgICAgIGNvbnN0IHZhbHVlID0gY3VycmVudCArIHRoaXMuX3RvcFBvc2l0aW9uc1ttaWRkbGVdO1xuXG4gICAgICBpZiAoZW5kIDwgc3RhcnQpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9IGVsc2UgaWYgKHZhbHVlIDw9IDAgJiYgdmFsdWUgKyB0aGlzLl9nZXRJdGVtSGVpZ2h0KG1pZGRsZSkgPiAwKSB7XG4gICAgICAgIHJldHVybiBtaWRkbGU7XG4gICAgICB9IGVsc2UgaWYgKGlzTmFOKHZhbHVlKSB8fCB2YWx1ZSA+PSAwKSB7XG4gICAgICAgIGVuZCA9IG1pZGRsZSAtIDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGFydCA9IG1pZGRsZSArIDE7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgX2RlYm91bmNlKGZ1bmMsIHdhaXQsIGltbWVkaWF0ZSkge1xuICAgIGxldCB0aW1lb3V0O1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIGNvbnN0IGNhbGxOb3cgPSBpbW1lZGlhdGUgJiYgIXRpbWVvdXQ7XG4gICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICBpZiAoY2FsbE5vdykge1xuICAgICAgICBmdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgdGltZW91dCA9IG51bGw7XG4gICAgICAgICAgZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9LCB3YWl0KTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgX2RvdWJsZUZpcmVPblRvdWNoZW5kKCkge1xuICAgIHRoaXMuX3JlbmRlcigpO1xuICAgIHRoaXMuX2RlYm91bmNlKHRoaXMuX3JlbmRlci5iaW5kKHRoaXMpLCAxMDApO1xuICB9XG5cbiAgX2FkZEV2ZW50TGlzdGVuZXJzKCkge1xuICAgIHV0aWwuYmluZExpc3RlbmVycyh0aGlzLCBbJ19vbkNoYW5nZScsICdfZG91YmxlRmlyZU9uVG91Y2hlbmQnXSk7XG5cbiAgICBpZiAocGxhdGZvcm0uaXNJT1MoKSkge1xuICAgICAgdGhpcy5fYm91bmRPbkNoYW5nZSA9IHRoaXMuX2RlYm91bmNlKHRoaXMuX2JvdW5kT25DaGFuZ2UsIDMwKTtcbiAgICB9XG5cbiAgICB0aGlzLl9wYWdlQ29udGVudC5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLCB0aGlzLl9ib3VuZE9uQ2hhbmdlLCB0cnVlKTtcblxuICAgIGlmIChwbGF0Zm9ybS5pc0lPUygpKSB7XG4gICAgICB1dGlsLmFkZEV2ZW50TGlzdGVuZXIodGhpcy5fcGFnZUNvbnRlbnQsICd0b3VjaG1vdmUnLCB0aGlzLl9ib3VuZE9uQ2hhbmdlLCB7IGNhcHR1cmU6IHRydWUsIHBhc3NpdmU6IHRydWUgfSk7XG4gICAgICB0aGlzLl9wYWdlQ29udGVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIHRoaXMuX2JvdW5kRG91YmxlRmlyZU9uVG91Y2hlbmQsIHRydWUpO1xuICAgIH1cblxuICAgIHdpbmRvdy5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLl9ib3VuZE9uQ2hhbmdlLCB0cnVlKTtcbiAgfVxuXG4gIF9yZW1vdmVFdmVudExpc3RlbmVycygpIHtcbiAgICB0aGlzLl9wYWdlQ29udGVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdzY3JvbGwnLCB0aGlzLl9ib3VuZE9uQ2hhbmdlLCB0cnVlKTtcblxuICAgIGlmIChwbGF0Zm9ybS5pc0lPUygpKSB7XG4gICAgICB1dGlsLnJlbW92ZUV2ZW50TGlzdGVuZXIodGhpcy5fcGFnZUNvbnRlbnQsICd0b3VjaG1vdmUnLCB0aGlzLl9ib3VuZE9uQ2hhbmdlLCB7IGNhcHR1cmU6IHRydWUsIHBhc3NpdmU6IHRydWUgfSk7XG4gICAgICB0aGlzLl9wYWdlQ29udGVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIHRoaXMuX2JvdW5kRG91YmxlRmlyZU9uVG91Y2hlbmQsIHRydWUpO1xuICAgIH1cblxuICAgIHdpbmRvdy5kb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLl9ib3VuZE9uQ2hhbmdlLCB0cnVlKTtcbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5fcmVtb3ZlQWxsRWxlbWVudHMoKTtcbiAgICB0aGlzLl9kZWxlZ2F0ZS5kZXN0cm95KCk7XG4gICAgdGhpcy5fcGFyZW50RWxlbWVudCA9IHRoaXMuX2RlbGVnYXRlID0gdGhpcy5fcmVuZGVyZWRJdGVtcyA9IG51bGw7XG4gICAgdGhpcy5fcmVtb3ZlRXZlbnRMaXN0ZW5lcnMoKTtcbiAgfVxufVxuXG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuaW1wb3J0IG9uc0VsZW1lbnRzIGZyb20gJy4uL29ucy9lbGVtZW50cyc7XG5pbXBvcnQgdXRpbCBmcm9tICcuLi9vbnMvdXRpbCc7XG5pbXBvcnQgaW50ZXJuYWwgZnJvbSAnLi4vb25zL2ludGVybmFsJztcbmltcG9ydCBCYXNlRWxlbWVudCBmcm9tICcuL2Jhc2UvYmFzZS1lbGVtZW50JztcbmltcG9ydCB7IExhenlSZXBlYXREZWxlZ2F0ZSwgTGF6eVJlcGVhdFByb3ZpZGVyIH0gZnJvbSAnLi4vb25zL2ludGVybmFsL2xhenktcmVwZWF0JztcblxuLyoqXG4gKiBAZWxlbWVudCBvbnMtbGF6eS1yZXBlYXRcbiAqIEBjYXRlZ29yeSBsaXN0XG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXVxuICogICAgIFVzaW5nIHRoaXMgY29tcG9uZW50IGEgbGlzdCB3aXRoIG1pbGxpb25zIG9mIGl0ZW1zIGNhbiBiZSByZW5kZXJlZCB3aXRob3V0IGEgZHJvcCBpbiBwZXJmb3JtYW5jZS5cbiAqICAgICBJdCBkb2VzIHRoYXQgYnkgXCJsYXppbHlcIiBsb2FkaW5nIGVsZW1lbnRzIGludG8gdGhlIERPTSB3aGVuIHRoZXkgY29tZSBpbnRvIHZpZXcgYW5kXG4gKiAgICAgcmVtb3ZpbmcgaXRlbXMgZnJvbSB0aGUgRE9NIHdoZW4gdGhleSBhcmUgbm90IHZpc2libGUuXG4gKiAgIFsvZW5dXG4gKiAgIFtqYV1cbiAqICAgICDjgZPjga7jgrPjg7Pjg53jg7zjg43jg7Pjg4jlhoXjgafmj4/nlLvjgZXjgozjgovjgqLjgqTjg4bjg6Djga5ET03opoHntKDjga7oqq3jgb/ovrzjgb/jga/jgIHnlLvpnaLjgavopovjgYjjgZ3jgYbjgavjgarjgaPjgZ/mmYLjgb7jgafoh6rli5XnmoTjgavpgYXlu7bjgZXjgozjgIFcbiAqICAgICDnlLvpnaLjgYvjgonopovjgYjjgarjgY/jgarjgaPjgZ/loLTlkIjjgavjga/jgZ3jga7opoHntKDjga/li5XnmoTjgavjgqLjg7Pjg63jg7zjg4njgZXjgozjgb7jgZnjgIJcbiAqICAgICDjgZPjga7jgrPjg7Pjg53jg7zjg43jg7Pjg4jjgpLkvb/jgYbjgZPjgajjgafjgIHjg5Hjg5Xjgqnjg7zjg57jg7PjgrnjgpLliqPljJbjgZXjgZvjgovjgZPjgajnhKHjgZfjgavlt6jlpKfjgarmlbDjga7opoHntKDjgpLmj4/nlLvjgafjgY3jgb7jgZnjgIJcbiAqICAgWy9qYV1cbiAqIEBjb2RlcGVuIFF3ckdCbVxuICogQHR1dG9yaWFsIHZhbmlsbGEvUmVmZXJlbmNlL2xhenktcmVwZWF0XG4gKiBAc2VlYWxzbyBvbnMtbGlzdFxuICogICBbZW5dVGhlIGA8b25zLWxpc3Q+YCBlbGVtZW50IGlzIHVzZWQgdG8gcmVuZGVyIGEgbGlzdC5bL2VuXVxuICogICBbamFdYDxvbnMtbGlzdD5g6KaB57Sg44Gv44Oq44K544OI44KS5o+P55S744GZ44KL44Gu44Gr5L2/44KP44KM44G+44GZ44CCWy9qYV1cbiAqIEBleGFtcGxlXG4gKiA8c2NyaXB0PlxuICogICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsIGZ1bmN0aW9uKCkge1xuICogICAgIHZhciBsYXp5UmVwZWF0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI2xpc3QnKTtcbiAqICAgICBsYXp5UmVwZWF0LmRlbGVnYXRlID0ge1xuICogICAgICBjcmVhdGVJdGVtQ29udGVudDogZnVuY3Rpb24oaSwgdGVtcGxhdGUpIHtcbiAqICAgICAgICB2YXIgZG9tID0gdGVtcGxhdGUuY2xvbmVOb2RlKHRydWUpO1xuICogICAgICAgIGRvbS5pbm5lclRleHQgPSBpO1xuICpcbiAqICAgICAgICByZXR1cm4gZG9tO1xuICogICAgICB9LFxuICogICAgICBjb3VudEl0ZW1zOiBmdW5jdGlvbigpIHtcbiAqICAgICAgICByZXR1cm4gMTAwMDAwMDA7XG4gKiAgICAgIH0sXG4gKiAgICAgIGRlc3Ryb3lJdGVtOiBmdW5jdGlvbihpbmRleCwgaXRlbSkge1xuICogICAgICAgIGNvbnNvbGUubG9nKCdEZXN0cm95ZWQgaXRlbSB3aXRoIGluZGV4OiAnICsgaW5kZXgpO1xuICogICAgICB9XG4gKiAgICAgfTtcbiAqICAgfSk7XG4gKiA8L3NjcmlwdD5cbiAqXG4gKiA8b25zLWxpc3QgaWQ9XCJsaXN0XCI+XG4gKiAgIDxvbnMtbGF6eS1yZXBlYXQ+XG4gKiAgICAgPG9ucy1saXN0LWl0ZW0+PC9vbnMtbGlzdC1pdGVtPlxuICogICA8L29ucy1sYXp5LXJlcGVhdD5cbiAqIDwvb25zLWxpc3Q+XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExhenlSZXBlYXRFbGVtZW50IGV4dGVuZHMgQmFzZUVsZW1lbnQge1xuXG4gIGNvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIC8vIG5vdCB2ZXJ5IGdvb2QgaWRlYSBhbmQgYWxzbyBub3QgZG9jdW1lbnRlZFxuICAgIGlmICh0aGlzLmhhc0F0dHJpYnV0ZSgnZGVsZWdhdGUnKSkge1xuICAgICAgdGhpcy5kZWxlZ2F0ZSA9IHdpbmRvd1t0aGlzLmdldEF0dHJpYnV0ZSgnZGVsZWdhdGUnKV07XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBkZWxlZ2F0ZVxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFtlbl1TcGVjaWZ5IGEgZGVsZWdhdGUgb2JqZWN0IHRvIGxvYWQgYW5kIHVubG9hZCBpdGVtIGVsZW1lbnRzLlsvZW5dXG4gICAqICBbamFd6KaB57Sg44Gu44Ot44O844OJ44CB44Ki44Oz44Ot44O844OJ44Gq44Gp44Gu5Yem55CG44KS5aeU6K2y44GZ44KL44Kq44OW44K444Kn44Kv44OI44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBkZWxlZ2F0ZS5jcmVhdGVJdGVtQ29udGVudFxuICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1cbiAgICogICAgIFRoaXMgZnVuY3Rpb24gc2hvdWxkIHJldHVybiBhIGBIVE1MRWxlbWVudGAuXG4gICAqXG4gICAqICAgICBUbyBoZWxwIHJlbmRlcmluZyB0aGUgZWxlbWVudCwgdGhlIGN1cnJlbnQgaW5kZXggYW5kIGEgdGVtcGxhdGUgaXMgc3VwcGxpZWQgYXMgYXJndW1lbnRzLiBUaGUgdGVtcGxhdGUgaXMgdGhlIGluaXRpYWwgY29udGVudCBvZiB0aGUgYDxvbnMtbGF6eS1yZXBlYXQ+YCBlbGVtZW50LlxuICAgKiAgIFsvZW5dXG4gICAqICAgW2phXVxuICAgKiAgICAg44GT44Gu6Zai5pWw44GvYEhUTUxFbGVtZW50YOOCkui/lOOBl+OBpuOBj+OBoOOBleOBhOOAglxuICAgKiAgICAg6KaB57Sg44KS55Sf5oiQ44GX44KE44GZ44GP44GZ44KL44Gf44KB44Gr44CB54++5Zyo44Gu44Ki44Kk44OG44Og44Gu44Kk44Oz44OH44OD44Kv44K544Go44OG44Oz44OX44Os44O844OI44GM5byV5pWw44Gr5rih44GV44KM44G+44GZ44CCXG4gICAqICAgICDjgZPjga7jg4bjg7Pjg5fjg6zjg7zjg4jjga/jgIFgPG9ucy1sYXp5LXJlcGVhdD5g6KaB57Sg44Gu44Kz44Oz44OG44Oz44OE44GM5rih44GV44KM44G+44GZ44CCXG4gICAqICAgWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBkZWxlZ2F0ZS5jb3VudEl0ZW1zXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVNob3VsZCByZXR1cm4gdGhlIG51bWJlciBvZiBpdGVtcyBpbiB0aGUgbGlzdC5bL2VuXVxuICAgKiAgIFtqYV3jg6rjgrnjg4jlhoXjga7jgqLjgqTjg4bjg6DmlbDjgpLov5TjgZfjgabjgY/jgaDjgZXjgYTjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQHByb3BlcnR5IGRlbGVnYXRlLmNhbGN1bGF0ZUl0ZW1IZWlnaHRcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dXG4gICAqICAgICBTaG91bGQgcmV0dXJuIHRoZSBoZWlnaHQgb2YgYW4gaXRlbS4gVGhlIGluZGV4IGlzIHByb3ZpZGVkIGFzIGFuIGFyZ3VtZW50LlxuICAgKlxuICAgKiAgICAgVGhpcyBpcyBpbXBvcnRhbnQgd2hlbiByZW5kZXJpbmcgbGlzdHMgd2hlcmUgdGhlIGl0ZW1zIGhhdmUgZGlmZmVyZW50IGhlaWdodC5cbiAgICpcbiAgICogICAgIFRoZSBmdW5jdGlvbiBpcyBvcHRpb25hbCBhbmQgaWYgaXQgaXNuJ3QgcHJlc2VudCB0aGUgaGVpZ2h0IG9mIHRoZSBmaXJzdCBpdGVtIHdpbGwgYmUgYXV0b21hdGljYWxseSBjYWxjdWxhdGVkIGFuZCB1c2VkIGZvciBhbGwgb3RoZXIgaXRlbXMuXG4gICAqICAgWy9lbl1cbiAgICogICBbamFdXG4gICAqICAgICDjgqLjgqTjg4bjg6Djga7pq5jjgZUo44OU44Kv44K744OrKeOCkui/lOOBl+OBpuOBj+OBoOOBleOBhOOAguOCouOCpOODhuODoOOBruOCpOODs+ODh+ODg+OCr+OCueWApOOBr+W8leaVsOOBp+a4oeOBleOCjOOBvuOBmeOAglxuICAgKiAgICAg44GT44Gu6Zai5pWw44Gv44CB44Gd44KM44Ge44KM44Gu44Ki44Kk44Og44GM6YGV44Gj44Gf6auY44GV44KS5oyB44Gk44Oq44K544OI44KS44Os44Oz44OA44Oq44Oz44Kw44GZ44KL6Zqb44Gr6YeN6KaB44Gn44GZ44CCXG4gICAqICAgICDjgZPjga7plqLmlbDjga/jgqrjg5fjgrfjg6fjg4rjg6vjgafjgZnjgILjgoLjgZfjgZPjga7plqLmlbDjgYznhKHjgYTloLTlkIjjgavjga/jgIFcbiAgICogICAgIOacgOWIneOBruOCouOCpOODhuODoOOBrumrmOOBleOBjOS7luOBruOBmeOBueOBpuOBruOCouOCpOODhuODoOOBrumrmOOBleOBqOOBl+OBpuWIqeeUqOOBleOCjOOBvuOBmeOAglxuICAgKiAgIFsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgZGVsZWdhdGUuZGVzdHJveUl0ZW1cbiAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dXG4gICAqICAgICBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgY2FsbGVkIHdoZW4gYW4gaXRlbSBpcyByZW1vdmVkIGZyb20gdGhlIERPTS4gVGhlIGluZGV4IGFuZCBET00gZWxlbWVudCBpcyBwcm92aWRlZCBhcyBhcmd1bWVudHMuXG4gICAqXG4gICAqICAgICBUaGUgZnVuY3Rpb24gaXMgb3B0aW9uYWwgYnV0IG1heSBiZSBpbXBvcnRhbnQgaW4gb3JkZXIgdG8gYXZvaWQgbWVtb3J5IGxlYWtzLlxuICAgKiAgIFsvZW5dXG4gICAqICAgW2phXVxuICAgKiAgICAg44GT44Gu6Zai5pWw44Gv44CB44GC44KL44Ki44Kk44OG44Og44GMRE9N44OE44Oq44O844GL44KJ6Zmk44GL44KM44Gf5pmC44Gr5ZG844Gz5Ye644GV44KM44G+44GZ44CCXG4gICAqICAgICDjgqLjgqTjg4bjg6Djga7jgqTjg7Pjg4fjg4Pjgq/jgrnlgKTjgahET03opoHntKDjgYzlvJXmlbDjgajjgZfjgabmuKHjgZXjgozjgb7jgZnjgIJcbiAgICogICAgIOOBk+OBrumWouaVsOOBr+OCquODl+OCt+ODp+ODiuODq+OBp+OBmeOBjOOAgeWQhOOCouOCpOODhuODoOOBruW+jOWHpueQhuOBjOW/heimgeOBquWgtOWQiOOBq+OBr+ODoeODouODquODvOODquODvOOCr+OCkumBv+OBkeOCi+OBn+OCgeOBq+mHjeimgeOBp+OBmeOAglxuICAgKiAgIFsvamFdXG4gICAqL1xuXG4gIHNldCBkZWxlZ2F0ZSh1c2VyRGVsZWdhdGUpIHtcbiAgICB0aGlzLl9sYXp5UmVwZWF0UHJvdmlkZXIgJiYgdGhpcy5fbGF6eVJlcGVhdFByb3ZpZGVyLmRlc3Ryb3koKTtcblxuICAgIGlmICghdGhpcy5fdGVtcGxhdGVFbGVtZW50ICYmIHRoaXMuY2hpbGRyZW5bMF0pIHtcbiAgICAgIHRoaXMuX3RlbXBsYXRlRWxlbWVudCA9IHRoaXMucmVtb3ZlQ2hpbGQodGhpcy5jaGlsZHJlblswXSk7XG4gICAgfVxuXG4gICAgY29uc3QgZGVsZWdhdGUgPSBuZXcgTGF6eVJlcGVhdERlbGVnYXRlKHVzZXJEZWxlZ2F0ZSwgdGhpcy5fdGVtcGxhdGVFbGVtZW50IHx8IG51bGwpO1xuICAgIHRoaXMuX2xhenlSZXBlYXRQcm92aWRlciA9IG5ldyBMYXp5UmVwZWF0UHJvdmlkZXIodGhpcy5wYXJlbnRFbGVtZW50LCBkZWxlZ2F0ZSk7XG4gIH1cblxuICBnZXQgZGVsZWdhdGUoKSB7XG4gICAgdXRpbC50aHJvdygnTm8gZGVsZWdhdGUgZ2V0dGVyJyk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCByZWZyZXNoXG4gICAqIEBzaWduYXR1cmUgcmVmcmVzaCgpXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1SZWZyZXNoIHRoZSBsaXN0LiBVc2UgdGhpcyBtZXRob2Qgd2hlbiB0aGUgZGF0YSBoYXMgY2hhbmdlZC5bL2VuXVxuICAgKiAgIFtqYV3jg6rjgrnjg4jjgpLmm7TmlrDjgZfjgb7jgZnjgILjgoLjgZfjg4fjg7zjgr/jgYzlpInjgo/jgaPjgZ/loLTlkIjjgavjga/jgZPjga7jg6Hjgr3jg4Pjg4njgpLkvb/jgaPjgabjgY/jgaDjgZXjgYTjgIJbL2phXVxuICAgKi9cbiAgcmVmcmVzaCgpIHtcbiAgICB0aGlzLl9sYXp5UmVwZWF0UHJvdmlkZXIgJiYgdGhpcy5fbGF6eVJlcGVhdFByb3ZpZGVyLnJlZnJlc2goKTtcbiAgfVxuXG4gIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBsYXN0LCBjdXJyZW50KSB7fVxuXG4gIGRpc2Nvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIGlmICh0aGlzLl9sYXp5UmVwZWF0UHJvdmlkZXIpIHtcbiAgICAgIHRoaXMuX2xhenlSZXBlYXRQcm92aWRlci5kZXN0cm95KCk7XG4gICAgICB0aGlzLl9sYXp5UmVwZWF0UHJvdmlkZXIgPSBudWxsO1xuICAgIH1cbiAgfVxuXG59XG5cbmludGVybmFsLkxhenlSZXBlYXREZWxlZ2F0ZSA9IExhenlSZXBlYXREZWxlZ2F0ZTtcbmludGVybmFsLkxhenlSZXBlYXRQcm92aWRlciA9IExhenlSZXBlYXRQcm92aWRlcjtcblxub25zRWxlbWVudHMuTGF6eVJlcGVhdCA9IExhenlSZXBlYXRFbGVtZW50O1xuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdvbnMtbGF6eS1yZXBlYXQnLCBMYXp5UmVwZWF0RWxlbWVudCk7XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgb25zRWxlbWVudHMgZnJvbSAnLi4vb25zL2VsZW1lbnRzJztcbmltcG9ydCB1dGlsIGZyb20gJy4uL29ucy91dGlsJztcbmltcG9ydCBhdXRvU3R5bGUgZnJvbSAnLi4vb25zL2F1dG9zdHlsZSc7XG5pbXBvcnQgTW9kaWZpZXJVdGlsIGZyb20gJy4uL29ucy9pbnRlcm5hbC9tb2RpZmllci11dGlsJztcbmltcG9ydCBCYXNlRWxlbWVudCBmcm9tICcuL2Jhc2UvYmFzZS1lbGVtZW50JztcblxuY29uc3QgZGVmYXVsdENsYXNzTmFtZSA9ICdsaXN0LWhlYWRlcic7XG5jb25zdCBzY2hlbWUgPSB7Jyc6ICdsaXN0LWhlYWRlci0tKid9O1xuXG4vKipcbiAqIEBlbGVtZW50IG9ucy1saXN0LWhlYWRlclxuICogQGNhdGVnb3J5IGxpc3RcbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dSGVhZGVyIGVsZW1lbnQgZm9yIGxpc3QgaXRlbXMuIE11c3QgYmUgcHV0IGluc2lkZSB0aGUgYDxvbnMtbGlzdD5gIGNvbXBvbmVudC5bL2VuXVxuICogICBbamFd44Oq44K544OI6KaB57Sg44Gr5L2/55So44GZ44KL44OY44OD44OA44O855So44Kz44Oz44Od44O844ON44Oz44OI44CCb25zLWxpc3TjgajlhbHjgavkvb/nlKjjgZfjgb7jgZnjgIJbL2phXVxuICogQHNlZWFsc28gb25zLWxpc3RcbiAqICAgW2VuXVRoZSBgPG9ucy1saXN0PmAgY29tcG9uZW50Wy9lbl1cbiAqICAgW2phXW9ucy1saXN044Kz44Oz44Od44O844ON44Oz44OIWy9qYV1cbiAqIEBzZWVhbHNvIG9ucy1saXN0LWl0ZW1cbiAqICAgW2VuXVRoZSBgPG9ucy1saXN0LWl0ZW0+YCBjb21wb25lbnRbL2VuXVxuICogICBbamFdb25zLWxpc3QtaXRlbeOCs+ODs+ODneODvOODjeODs+ODiFsvamFdXG4gKiBAY29kZXBlbiB5eGNDdFxuICogQHR1dG9yaWFsIHZhbmlsbGEvUmVmZXJlbmNlL2xpc3RcbiAqIEBtb2RpZmllciBtYXRlcmlhbFxuICogICBbZW5dRGlzcGxheSBhIE1hdGVyaWFsIERlc2lnbiBsaXN0IGhlYWRlci5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBleGFtcGxlXG4gKiA8b25zLWxpc3Q+XG4gKiAgIDxvbnMtbGlzdC1oZWFkZXI+SGVhZGVyIFRleHQ8L29ucy1saXN0LWhlYWRlcj5cbiAqICAgPG9ucy1saXN0LWl0ZW0+SXRlbTwvb25zLWxpc3QtaXRlbT5cbiAqICAgPG9ucy1saXN0LWl0ZW0+SXRlbTwvb25zLWxpc3QtaXRlbT5cbiAqIDwvb25zLWxpc3Q+XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExpc3RIZWFkZXJFbGVtZW50IGV4dGVuZHMgQmFzZUVsZW1lbnQge1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIG1vZGlmaWVyXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1UaGUgYXBwZWFyYW5jZSBvZiB0aGUgbGlzdCBoZWFkZXIuWy9lbl1cbiAgICogICBbamFd44OY44OD44OA44O844Gu6KGo54++44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIHRoaXMuX2NvbXBpbGUoKTtcbiAgfVxuXG4gIF9jb21waWxlKCkge1xuICAgIGF1dG9TdHlsZS5wcmVwYXJlKHRoaXMpO1xuICAgIHRoaXMuY2xhc3NMaXN0LmFkZChkZWZhdWx0Q2xhc3NOYW1lKTtcbiAgICBNb2RpZmllclV0aWwuaW5pdE1vZGlmaWVyKHRoaXMsIHNjaGVtZSk7XG4gIH1cblxuICBzdGF0aWMgZ2V0IG9ic2VydmVkQXR0cmlidXRlcygpIHtcbiAgICByZXR1cm4gWydtb2RpZmllcicsICdjbGFzcyddO1xuICB9XG5cbiAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIGxhc3QsIGN1cnJlbnQpIHtcbiAgICBzd2l0Y2ggKG5hbWUpIHtcbiAgICAgIGNhc2UgJ2NsYXNzJzpcbiAgICAgICAgdXRpbC5yZXN0b3JlQ2xhc3ModGhpcywgZGVmYXVsdENsYXNzTmFtZSwgc2NoZW1lKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdtb2RpZmllcic6XG4gICAgICAgIE1vZGlmaWVyVXRpbC5vbk1vZGlmaWVyQ2hhbmdlZChsYXN0LCBjdXJyZW50LCB0aGlzLCBzY2hlbWUpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cbn1cblxub25zRWxlbWVudHMuTGlzdEhlYWRlciA9IExpc3RIZWFkZXJFbGVtZW50O1xuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdvbnMtbGlzdC1oZWFkZXInLCBMaXN0SGVhZGVyRWxlbWVudCk7XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgb25zRWxlbWVudHMgZnJvbSAnLi4vb25zL2VsZW1lbnRzJztcbmltcG9ydCBCYXNlRWxlbWVudCBmcm9tICcuL2Jhc2UvYmFzZS1lbGVtZW50JztcbmltcG9ydCBhdXRvU3R5bGUgZnJvbSAnLi4vb25zL2F1dG9zdHlsZSc7XG5pbXBvcnQgTW9kaWZpZXJVdGlsIGZyb20gJy4uL29ucy9pbnRlcm5hbC9tb2RpZmllci11dGlsJztcbmltcG9ydCB1dGlsIGZyb20gJy4uL29ucy91dGlsJztcblxuY29uc3QgZGVmYXVsdENsYXNzTmFtZSA9ICdsaXN0LXRpdGxlJztcbmNvbnN0IHNjaGVtZSA9IHsnJzogJ2xpc3QtdGl0bGUtLSonfTtcblxuLyoqXG4gKiBAZWxlbWVudCBvbnMtbGlzdC10aXRsZVxuICogQGNhdGVnb3J5IGxpc3RcbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dUmVwcmVzZW50cyBhIGxpc3QgdGl0bGUuWy9lbl1cbiAqICAgW2phXeODquOCueODiOOBruOCv+OCpOODiOODq+OCkuihqOePvuOBl+OBvuOBmeOAglsvamFdXG4gKiBAZXhhbXBsZVxuICogPG9ucy1saXN0LXRpdGxlPkxpc3QgVGl0bGU8L29ucy1saXN0LXRpdGxlPlxuICogPG9ucy1saXN0PlxuICogICA8b25zLWxpc3QtaXRlbT5JdGVtPC9vbnMtbGlzdC1pdGVtPlxuICogPC9vbnMtbGlzdD5cbiAqIEBtb2RpZmllciBtYXRlcmlhbFxuICogICBbZW5dRGlzcGxheSBhIE1hdGVyaWFsIERlc2lnbiBsaXN0IHRpdGxlLlsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICovXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExpc3RUaXRsZUVsZW1lbnQgZXh0ZW5kcyBCYXNlRWxlbWVudCB7XG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIHRoaXMuX2NvbXBpbGUoKTtcbiAgfVxuXG4gIF9jb21waWxlKCkge1xuICAgIGF1dG9TdHlsZS5wcmVwYXJlKHRoaXMpO1xuICAgIHRoaXMuY2xhc3NMaXN0LmFkZChkZWZhdWx0Q2xhc3NOYW1lKTtcbiAgICBNb2RpZmllclV0aWwuaW5pdE1vZGlmaWVyKHRoaXMsIHNjaGVtZSk7XG4gIH1cblxuICBzdGF0aWMgZ2V0IG9ic2VydmVkQXR0cmlidXRlcygpIHtcbiAgICByZXR1cm4gWydtb2RpZmllcicsICdjbGFzcyddO1xuICB9XG5cbiAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIGxhc3QsIGN1cnJlbnQpIHtcbiAgICBzd2l0Y2ggKG5hbWUpIHtcbiAgICAgIGNhc2UgJ2NsYXNzJzpcbiAgICAgICAgdXRpbC5yZXN0b3JlQ2xhc3ModGhpcywgZGVmYXVsdENsYXNzTmFtZSwgc2NoZW1lKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdtb2RpZmllcic6XG4gICAgICAgIE1vZGlmaWVyVXRpbC5vbk1vZGlmaWVyQ2hhbmdlZChsYXN0LCBjdXJyZW50LCB0aGlzLCBzY2hlbWUpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cbn1cblxub25zRWxlbWVudHMuTGlzdFRpdGxlID0gTGlzdFRpdGxlRWxlbWVudDtcbmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnb25zLWxpc3QtdGl0bGUnLCBMaXN0VGl0bGVFbGVtZW50KTtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE4IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5pbXBvcnQgYW5pbWl0IGZyb20gJy4uLy4uL29ucy9hbmltaXQnO1xuaW1wb3J0IEJhc2VBbmltYXRvciBmcm9tICcuLi8uLi9vbnMvYmFzZS1hbmltYXRvcidcblxuZXhwb3J0IGNsYXNzIExpc3RJdGVtQW5pbWF0b3IgZXh0ZW5kcyBCYXNlQW5pbWF0b3Ige1xuICBjb25zdHJ1Y3Rvcih7dGltaW5nID0gJ2xpbmVhcicsIGRlbGF5ID0gMCwgZHVyYXRpb24gPSAwLjJ9ID0ge30pIHtcbiAgICBzdXBlcih7IHRpbWluZywgZGVsYXksIGR1cmF0aW9uIH0pO1xuICB9XG5cbiAgc2hvd0V4cGFuc2lvbihsaXN0SXRlbSwgY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjaygpO1xuICB9XG5cbiAgaGlkZUV4cGFuc2lvbihsaXN0SXRlbSwgY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjaygpO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBTbGlkZUxpc3RJdGVtQW5pbWF0b3IgZXh0ZW5kcyBMaXN0SXRlbUFuaW1hdG9yIHtcblxuICBzaG93RXhwYW5zaW9uKGxpc3RJdGVtLCBjYWxsYmFjaykge1xuICAgIHRoaXMuX2FuaW1hdGVFeHBhbnNpb24obGlzdEl0ZW0sIHRydWUsIGNhbGxiYWNrKTtcbiAgfVxuXG4gIGhpZGVFeHBhbnNpb24obGlzdEl0ZW0sIGNhbGxiYWNrKSB7XG4gICAgdGhpcy5fYW5pbWF0ZUV4cGFuc2lvbihsaXN0SXRlbSwgZmFsc2UsIGNhbGxiYWNrKTtcbiAgfVxuXG4gIF9hbmltYXRlRXhwYW5zaW9uKGxpc3RJdGVtLCBzaG91bGRPcGVuLCBjYWxsYmFjaykge1xuICAgIC8vIFRvIGFuaW1hdGUgdGhlIG9wZW5pbmcgb2YgdGhlIGV4cGFuc2lvbiBwYW5lbCBjb3JyZWN0bHksIHdlIG5lZWQgdG8ga25vdyBpdHNcbiAgICAvLyBoZWlnaHQuIFRvIGNhbGN1bGF0ZSB0aGlzLCB3ZSBzZXQgaXRzIGhlaWdodCB0byBhdXRvLCBhbmQgdGhlbiBnZXQgdGhlIGNvbXB1dGVkXG4gICAgLy8gaGVpZ2h0IGFuZCBwYWRkaW5nLiBPbmNlIHRoaXMgaXMgZG9uZSwgd2Ugc2V0IHRoZSBoZWlnaHQgYmFjayB0byBpdHMgb3JpZ2luYWwgdmFsdWUuXG4gICAgY29uc3Qgb2xkSGVpZ2h0ID0gbGlzdEl0ZW0uZXhwYW5kYWJsZUNvbnRlbnQuc3R5bGUuaGVpZ2h0O1xuICAgIGNvbnN0IG9sZERpc3BsYXkgPSBsaXN0SXRlbS5leHBhbmRhYmxlQ29udGVudC5zdHlsZS5kaXNwbGF5O1xuICAgIGxpc3RJdGVtLmV4cGFuZGFibGVDb250ZW50LnN0eWxlLmhlaWdodCA9ICdhdXRvJztcbiAgICBsaXN0SXRlbS5leHBhbmRhYmxlQ29udGVudC5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICBjb25zdCBjb21wdXRlZFN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUobGlzdEl0ZW0uZXhwYW5kYWJsZUNvbnRlbnQpO1xuXG4gICAgY29uc3QgZXhwYW5zaW9uT3BlblRyYW5zaXRpb24gPSBbXG4gICAgICB7IGhlaWdodDogMCwgcGFkZGluZ1RvcDogMCwgcGFkZGluZ0JvdHRvbTogMCB9LFxuICAgICAge1xuICAgICAgICBoZWlnaHQ6IGNvbXB1dGVkU3R5bGUuaGVpZ2h0LFxuICAgICAgICBwYWRkaW5nVG9wOiBjb21wdXRlZFN0eWxlLnBhZGRpbmdUb3AsXG4gICAgICAgIHBhZGRpbmdCb3R0b206IGNvbXB1dGVkU3R5bGUucGFkZGluZ0JvdHRvbSxcbiAgICAgIH1cbiAgICBdO1xuICAgIGNvbnN0IGljb25PcGVuVHJhbnNpdGlvbiA9IFt7dHJhbnNmb3JtOiAncm90YXRlKDQ1ZGVnKSd9LCB7dHJhbnNmb3JtOiAncm90YXRlKDIyNWRlZyknfV07XG5cbiAgICAvLyBOb3cgdGhhdCB3ZSBoYXZlIHRoZSB2YWx1ZXMgd2UgbmVlZCwgcmVzZXQgdGhlIGhlaWdodCBiYWNrIHRvIGl0cyBvcmlnaW5hbCBzdGF0ZVxuICAgIGxpc3RJdGVtLmV4cGFuZGFibGVDb250ZW50LnN0eWxlLmhlaWdodCA9IG9sZEhlaWdodDtcblxuICAgIGFuaW1pdChsaXN0SXRlbS5leHBhbmRhYmxlQ29udGVudCwgeyBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbiwgcHJvcGVydHk6ICdoZWlnaHQgcGFkZGluZy10b3AgcGFkZGluZy1ib3R0b20nIH0pXG4gICAgICAuZGVmYXVsdCguLi4oc2hvdWxkT3BlbiA/IGV4cGFuc2lvbk9wZW5UcmFuc2l0aW9uIDogZXhwYW5zaW9uT3BlblRyYW5zaXRpb24ucmV2ZXJzZSgpKSlcbiAgICAgIC5wbGF5KCgpID0+IHtcbiAgICAgICAgbGlzdEl0ZW0uZXhwYW5kYWJsZUNvbnRlbnQuc3R5bGUuZGlzcGxheSA9IG9sZERpc3BsYXk7XG4gICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKCk7XG4gICAgICB9KTtcblxuICAgIGlmIChsaXN0SXRlbS5leHBhbmRDaGV2cm9uKSB7XG4gICAgICBhbmltaXQobGlzdEl0ZW0uZXhwYW5kQ2hldnJvbiwgeyBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbiwgcHJvcGVydHk6ICd0cmFuc2Zvcm0nIH0pXG4gICAgICAgIC5kZWZhdWx0KC4uLihzaG91bGRPcGVuID8gaWNvbk9wZW5UcmFuc2l0aW9uIDogaWNvbk9wZW5UcmFuc2l0aW9uLnJldmVyc2UoKSkpXG4gICAgICAgIC5wbGF5KCk7XG4gICAgfVxuICB9XG5cbn0iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgb25zRWxlbWVudHMgZnJvbSAnLi4vLi4vb25zL2VsZW1lbnRzJztcbmltcG9ydCBhbmltaXQgZnJvbSAnLi4vLi4vb25zL2FuaW1pdCc7XG5pbXBvcnQgdXRpbCBmcm9tICcuLi8uLi9vbnMvdXRpbCc7XG5pbXBvcnQgc3R5bGVyIGZyb20gJy4uLy4uL29ucy9zdHlsZXInO1xuaW1wb3J0IGF1dG9TdHlsZSBmcm9tICcuLi8uLi9vbnMvYXV0b3N0eWxlJztcbmltcG9ydCBNb2RpZmllclV0aWwgZnJvbSAnLi4vLi4vb25zL2ludGVybmFsL21vZGlmaWVyLXV0aWwnO1xuaW1wb3J0IEFuaW1hdG9yRmFjdG9yeSBmcm9tICcuLi8uLi9vbnMvaW50ZXJuYWwvYW5pbWF0b3ItZmFjdG9yeSc7XG5pbXBvcnQgeyBMaXN0SXRlbUFuaW1hdG9yLCBTbGlkZUxpc3RJdGVtQW5pbWF0b3IgfSBmcm9tICcuL2FuaW1hdG9yJztcbmltcG9ydCBCYXNlRWxlbWVudCBmcm9tICcuLi9iYXNlL2Jhc2UtZWxlbWVudCc7XG5pbXBvcnQgY29udGVudFJlYWR5IGZyb20gJy4uLy4uL29ucy9jb250ZW50LXJlYWR5JztcblxuY29uc3QgZGVmYXVsdENsYXNzTmFtZSA9ICdsaXN0LWl0ZW0nO1xuY29uc3Qgc2NoZW1lID0ge1xuICAnLmxpc3QtaXRlbSc6ICdsaXN0LWl0ZW0tLSonLFxuICAnLmxpc3QtaXRlbV9fbGVmdCc6ICdsaXN0LWl0ZW0tLSpfX2xlZnQnLFxuICAnLmxpc3QtaXRlbV9fY2VudGVyJzogJ2xpc3QtaXRlbS0tKl9fY2VudGVyJyxcbiAgJy5saXN0LWl0ZW1fX3JpZ2h0JzogJ2xpc3QtaXRlbS0tKl9fcmlnaHQnLFxuICAnLmxpc3QtaXRlbV9fbGFiZWwnOiAnbGlzdC1pdGVtLS0qX19sYWJlbCcsXG4gICcubGlzdC1pdGVtX190aXRsZSc6ICdsaXN0LWl0ZW0tLSpfX3RpdGxlJyxcbiAgJy5saXN0LWl0ZW1fX3N1YnRpdGxlJzogJ2xpc3QtaXRlbS0tKl9fc3VidGl0bGUnLFxuICAnLmxpc3QtaXRlbV9fdGh1bWJuYWlsJzogJ2xpc3QtaXRlbS0tKl9fdGh1bWJuYWlsJyxcbiAgJy5saXN0LWl0ZW1fX2ljb24nOiAnbGlzdC1pdGVtLS0qX19pY29uJ1xufTtcblxuY29uc3QgX2FuaW1hdG9yRGljdCA9IHtcbiAgJ2RlZmF1bHQnOiBTbGlkZUxpc3RJdGVtQW5pbWF0b3IsXG4gICdub25lJzogTGlzdEl0ZW1BbmltYXRvclxufTtcblxuLyoqXG4gKiBAZWxlbWVudCBvbnMtbGlzdC1pdGVtXG4gKiBAY2F0ZWdvcnkgbGlzdFxuICogQG1vZGlmaWVyIHRhcHBhYmxlXG4gKiAgIFtlbl1NYWtlIHRoZSBsaXN0IGl0ZW0gY2hhbmdlIGFwcGVhcmFuY2Ugd2hlbiBpdCdzIHRhcHBlZC4gT24gaU9TIGl0IGlzIGJldHRlciB0byB1c2UgdGhlIFwidGFwcGFibGVcIiBhbmQgXCJ0YXAtYmFja2dyb3VuZC1jb2xvclwiIGF0dHJpYnV0ZSBmb3IgYmV0dGVyIGJlaGF2aW9yIHdoZW4gc2Nyb2xsaW5nLlsvZW5dXG4gKiAgIFtqYV3jgr/jg4Pjg5fjgoTjgq/jg6rjg4Pjgq/jgZfjgZ/mmYLjgavlirnmnpzjgYzooajnpLrjgZXjgozjgovjgojjgYbjgavjgarjgorjgb7jgZnjgIJbL2phXVxuICogQG1vZGlmaWVyIGNoZXZyb25cbiAqICAgW2VuXURpc3BsYXkgYSBjaGV2cm9uIGF0IHRoZSByaWdodCBlbmQgb2YgdGhlIGxpc3QgaXRlbSBhbmQgbWFrZSBpdCBjaGFuZ2UgYXBwZWFyYW5jZSB3aGVuIHRhcHBlZC5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBtb2RpZmllciBsb25nZGl2aWRlclxuICogICBbZW5dRGlzcGxheXMgYSBsb25nIGhvcml6b250YWwgZGl2aWRlciBiZXR3ZWVuIGl0ZW1zLlsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQG1vZGlmaWVyIG5vZGl2aWRlclxuICogICBbZW5dUmVtb3ZlcyB0aGUgZGl2aWRlciBiZXR3ZWVuIGxpc3QgaXRlbXMuWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAbW9kaWZpZXIgbWF0ZXJpYWxcbiAqICAgW2VuXURpc3BsYXkgYSBNYXRlcmlhbCBEZXNpZ24gbGlzdCBpdGVtLlsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1cbiAqICAgICBDb21wb25lbnQgdGhhdCByZXByZXNlbnRzIGVhY2ggaXRlbSBpbiBhIGxpc3QuIFRoZSBsaXN0IGl0ZW0gaXMgY29tcG9zZWQgb2YgZm91ciBwYXJ0cyB0aGF0IGFyZSByZXByZXNlbnRlZCB3aXRoIHRoZSBgbGVmdGAsIGBjZW50ZXJgLCBgcmlnaHRgIGFuZCBgZXhwYW5kYWJsZS1jb250ZW50YCBjbGFzc2VzLiBUaGVzZSBjbGFzc2VzIGNhbiBiZSB1c2VkIHRvIGVuc3VyZSB0aGF0IHRoZSBjb250ZW50IG9mIHRoZSBsaXN0IGl0ZW1zIGlzIHByb3Blcmx5IGFsaWduZWQuXG4gKlxuICogICAgIGBgYFxuICogICAgIDxvbnMtbGlzdC1pdGVtPlxuICogICAgICAgPGRpdiBjbGFzcz1cImxlZnRcIj5MZWZ0PC9kaXY+XG4gKiAgICAgICA8ZGl2IGNsYXNzPVwiY2VudGVyXCI+Q2VudGVyPC9kaXY+XG4gKiAgICAgICA8ZGl2IGNsYXNzPVwicmlnaHRcIj5SaWdodDwvZGl2PlxuICogICAgICAgPGRpdiBjbGFzcz1cImV4cGFuZGFibGUtY29udGVudFwiPkV4cGFuZGFibGUgY29udGVudDwvZGl2PlxuICogICAgIDwvb25zLWxpc3QtaXRlbT5cbiAqICAgICBgYGBcbiAqXG4gKiAgICAgVGhlcmUgYXJlIGFsc28gYSBudW1iZXIgb2YgY2xhc3NlcyAocHJlZml4ZWQgd2l0aCBgbGlzdC1pdGVtX18qYCkgdGhhdCBoZWxwIHdoZW4gcHV0dGluZyB0aGluZ3MgbGlrZSBpY29ucyBhbmQgdGh1bWJuYWlscyBpbnRvIHRoZSBsaXN0IGl0ZW1zLlxuICogICBbL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBzZWVhbHNvIG9ucy1saXN0XG4gKiAgIFtlbl1vbnMtbGlzdCBjb21wb25lbnRbL2VuXVxuICogICBbamFdb25zLWxpc3TjgrPjg7Pjg53jg7zjg43jg7Pjg4hbL2phXVxuICogQHNlZWFsc28gb25zLWxpc3QtaGVhZGVyXG4gKiAgIFtlbl1vbnMtbGlzdC1oZWFkZXIgY29tcG9uZW50Wy9lbl1cbiAqICAgW2phXW9ucy1saXN0LWhlYWRlcuOCs+ODs+ODneODvOODjeODs+ODiFsvamFdXG4gKiBAY29kZXBlbiB5eGNDdFxuICogQHR1dG9yaWFsIHZhbmlsbGEvUmVmZXJlbmNlL2xpc3RcbiAqIEBleGFtcGxlXG4gKiA8b25zLWxpc3QtaXRlbT5cbiAqICAgPGRpdiBjbGFzcz1cImxlZnRcIj5cbiAqICAgICA8b25zLWljb24gaWNvbj1cIm1kLWZhY2VcIiBjbGFzcz1cImxpc3QtaXRlbV9faWNvblwiPjwvb25zLWljb24+XG4gKiAgIDwvZGl2PlxuICogICA8ZGl2IGNsYXNzPVwiY2VudGVyXCI+XG4gKiAgICAgPGRpdiBjbGFzcz1cImxpc3QtaXRlbV9fdGl0bGVcIj5UaXRsZTwvZGl2PlxuICogICAgIDxkaXYgY2xhc3M9XCJsaXN0LWl0ZW1fX3N1YnRpdGxlXCI+U3VidGl0bGU8L2Rpdj5cbiAqICAgPC9kaXY+XG4gKiAgIDxkaXYgY2xhc3M9XCJyaWdodFwiPlxuICogICAgIDxvbnMtc3dpdGNoPjwvb25zLXN3aXRjaD5cbiAqICAgPC9kaXY+XG4gKiA8L29ucy1saXN0LWl0ZW0+XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExpc3RJdGVtRWxlbWVudCBleHRlbmRzIEJhc2VFbGVtZW50IHtcblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBtb2RpZmllclxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dVGhlIGFwcGVhcmFuY2Ugb2YgdGhlIGxpc3QgaXRlbS5bL2VuXVxuICAgKiAgIFtqYV3lkITopoHntKDjga7ooajnj77jgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBsb2NrLW9uLWRyYWdcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVByZXZlbnQgdmVydGljYWwgc2Nyb2xsaW5nIHdoZW4gdGhlIHVzZXIgZHJhZ3MgaG9yaXpvbnRhbGx5LlsvZW5dXG4gICAqICAgW2phXeOBk+OBruWxnuaAp+OBjOOBguOCi+OBqOOAgeODpuODvOOCtuODvOOBjOOBk+OBruimgee0oOOCkuaoquaWueWQkeOBq+ODieODqeODg+OCsOOBl+OBpuOBhOOCi+aZguOBq+OAgee4puaWueWQkeOBruOCueOCr+ODreODvOODq+OBjOi1t+OBjeOBquOBhOOCiOOBhuOBq+OBquOCiuOBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIHRhcHBhYmxlXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dTWFrZXMgdGhlIGVsZW1lbnQgcmVhY3QgdG8gdGFwcy4gYHByZXZlbnQtdGFwYCBhdHRyaWJ1dGUgY2FuIGJlIGFkZGVkIHRvIGNoaWxkIGVsZW1lbnRzIGxpa2UgYnV0dG9ucyBvciBpbnB1dHMgdG8gcHJldmVudCB0aGlzIGVmZmVjdC4gYG9ucy0qYCBlbGVtZW50cyBhcmUgaWdub3JlZCBieSBkZWZhdWx0LlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIHRhcC1iYWNrZ3JvdW5kLWNvbG9yXG4gICAqIEB0eXBlIHtDb2xvcn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXSBDaGFuZ2VzIHRoZSBiYWNrZ3JvdW5kIGNvbG9yIHdoZW4gdGFwcGVkLiBGb3IgdGhpcyB0byB3b3JrLCB0aGUgYXR0cmlidXRlIFwidGFwcGFibGVcIiBuZWVkcyB0byBiZSBzZXQuIFRoZSBkZWZhdWx0IGNvbG9yIGlzIFwiI2Q5ZDlkOVwiLiBJdCB3aWxsIGRpc3BsYXkgYXMgYSByaXBwbGUgZWZmZWN0IG9uIEFuZHJvaWQuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgZXhwYW5kYWJsZVxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXU1ha2VzIHRoZSBlbGVtZW50IGFibGUgdG8gYmUgZXhwYW5kZWQgdG8gcmV2ZWFsIGV4dHJhIGNvbnRlbnQuIEZvciB0aGlzIHRvIHdvcmssIHRoZSBleHBhbmRhYmxlIGNvbnRlbnQgbXVzdCBiZSBkZWZpbmVkIGluIGBkaXYuZXhwYW5kYWJsZS1jb250ZW50YC5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBhbmltYXRpb25cbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlZmF1bHQgZGVmYXVsdFxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFtlbl1UaGUgYW5pbWF0aW9uIHVzZWQgd2hlbiBzaG93aW5nIGFuZCBoaWRpbmcgdGhlIGV4cGFuZGFibGUgY29udGVudC4gQ2FuIGJlIGVpdGhlciBgXCJkZWZhdWx0XCJgIG9yIGBcIm5vbmVcImAuWy9lbl1cbiAgICogIFtqYV1bL2phXVxuICAgKi9cblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgdGhpcy5fYW5pbWF0b3JGYWN0b3J5ID0gdGhpcy5fdXBkYXRlQW5pbWF0b3JGYWN0b3J5KCk7XG4gICAgdGhpcy50b2dnbGVFeHBhbnNpb24gPSB0aGlzLnRvZ2dsZUV4cGFuc2lvbi5iaW5kKHRoaXMpO1xuXG4gICAgLy8gRWxlbWVudHMgaWdub3JlZCB3aGVuIHRhcHBpbmdcbiAgICBjb25zdCByZSA9IC9eb25zLSg/IWNvbCR8cm93JHxpZiQpL2k7XG4gICAgdGhpcy5fc2hvdWxkSWdub3JlVGFwID0gZSA9PiBlLmhhc0F0dHJpYnV0ZSgncHJldmVudC10YXAnKSB8fCByZS50ZXN0KGUudGFnTmFtZSk7XG5cbiAgICAvLyBzaG93IGFuZCBoaWRlIGZ1bmN0aW9ucyBmb3IgVnVlIGhpZGFibGUgbWl4aW5cbiAgICB0aGlzLnNob3cgPSB0aGlzLnNob3dFeHBhbnNpb247XG4gICAgdGhpcy5oaWRlID0gdGhpcy5oaWRlRXhwYW5zaW9uO1xuXG4gICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHtcbiAgICAgIHRoaXMuX2NvbXBpbGUoKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb21waWxlcyB0aGUgbGlzdCBpdGVtLlxuICAgKlxuICAgKiBWYXJpb3VzIGVsZW1lbnRzIGFyZSBhbGxvd2VkIGluIHRoZSBib2R5IG9mIGEgbGlzdCBpdGVtOlxuICAgKlxuICAgKiAgLSBkaXYubGVmdCwgZGl2LnJpZ2h0LCBhbmQgZGl2LmNlbnRlciBhcmUgYWxsb3dlZCBhcyBkaXJlY3QgY2hpbGRyZW5cbiAgICogIC0gaWYgZGl2LmNlbnRlciBpcyBub3QgZGVmaW5lZCwgYW55dGhpbmcgdGhhdCBpc24ndCBkaXYubGVmdCwgZGl2LnJpZ2h0IG9yIGRpdi5leHBhbmRhYmxlLWNvbnRlbnQgd2lsbCBiZSBwdXQgaW4gYSBkaXYuY2VudGVyXG4gICAqICAtIGlmIGRpdi5jZW50ZXIgaXMgZGVmaW5lZCwgYW55dGhpbmcgdGhhdCBpc24ndCBkaXYubGVmdCwgZGl2LnJpZ2h0IG9yIGRpdi5leHBhbmRhYmxlLWNvbnRlbnQgd2lsbCBiZSBpZ25vcmVkXG4gICAqICAtIGlmIGxpc3QgaXRlbSBoYXMgZXhwYW5kYWJsZSBhdHRyaWJ1dGU6XG4gICAqICAgICAgLSBkaXYuZXhwYW5kYWJsZS1jb250ZW50IGlzIGFsbG93ZWQgYXMgYSBkaXJlY3QgY2hpbGRcbiAgICogICAgICAtIGRpdi50b3AgaXMgYWxsb3dlZCBhcyBkaXJlY3QgY2hpbGRcbiAgICogICAgICAtIGlmIGRpdi50b3AgaXMgZGVmaW5lZCwgYW55dGhpbmcgdGhhdCBpc24ndCBkaXYuZXhwYW5kYWJsZS1jb250ZW50IHNob3VsZCBiZSBpbnNpZGUgZGl2LnRvcCAtIGFueXRoaW5nIGVsc2Ugd2lsbCBiZSBpZ25vcmVkXG4gICAqICAgICAgLSBpZiBkaXYucmlnaHQgaXMgbm90IGRlZmluZWQsIGEgZGl2LnJpZ2h0IHdpbGwgYmUgY3JlYXRlZCB3aXRoIGEgZHJvcC1kb3duIGNoZXZyb25cbiAgICpcbiAgICogU2VlIHRoZSB0ZXN0cyBmb3IgZXhhbXBsZXMuXG4gICAqL1xuICBfY29tcGlsZSgpIHtcbiAgICBhdXRvU3R5bGUucHJlcGFyZSh0aGlzKTtcbiAgICB0aGlzLmNsYXNzTGlzdC5hZGQoZGVmYXVsdENsYXNzTmFtZSk7XG5cbiAgICBsZXQgdG9wLCBleHBhbmRhYmxlQ29udGVudDtcbiAgICBsZXQgdG9wQ29udGVudCA9IFtdO1xuICAgIEFycmF5LmZyb20odGhpcy5jaGlsZE5vZGVzKS5mb3JFYWNoKG5vZGUgPT4ge1xuICAgICAgaWYgKG5vZGUubm9kZVR5cGUgIT09IE5vZGUuRUxFTUVOVF9OT0RFKSB7XG4gICAgICAgIHRvcENvbnRlbnQucHVzaChub2RlKTtcbiAgICAgIH0gZWxzZSBpZiAobm9kZS5jbGFzc0xpc3QuY29udGFpbnMoJ3RvcCcpKSB7XG4gICAgICAgIHRvcCA9IG5vZGU7XG4gICAgICB9IGVsc2UgaWYgKG5vZGUuY2xhc3NMaXN0LmNvbnRhaW5zKCdleHBhbmRhYmxlLWNvbnRlbnQnKSkge1xuICAgICAgICBleHBhbmRhYmxlQ29udGVudCA9IG5vZGU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0b3BDb250ZW50LnB1c2gobm9kZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChub2RlLm5vZGVOYW1lICE9PSAnT05TLVJJUFBMRScpIHtcbiAgICAgICAgbm9kZS5yZW1vdmUoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0b3BDb250ZW50ID0gdG9wID8gQXJyYXkuZnJvbSh0b3AuY2hpbGROb2RlcykgOiB0b3BDb250ZW50O1xuXG4gICAgbGV0IGxlZnQsIHJpZ2h0LCBjZW50ZXI7XG4gICAgY29uc3QgY2VudGVyQ29udGVudCA9IFtdO1xuICAgIHRvcENvbnRlbnQuZm9yRWFjaChub2RlID0+IHtcbiAgICAgIGlmIChub2RlLm5vZGVUeXBlICE9PSBOb2RlLkVMRU1FTlRfTk9ERSkge1xuICAgICAgICBjZW50ZXJDb250ZW50LnB1c2gobm9kZSk7XG4gICAgICB9IGVsc2UgaWYgKG5vZGUuY2xhc3NMaXN0LmNvbnRhaW5zKCdsZWZ0JykpIHtcbiAgICAgICAgbGVmdCA9IG5vZGU7XG4gICAgICB9IGVsc2UgaWYgKG5vZGUuY2xhc3NMaXN0LmNvbnRhaW5zKCdyaWdodCcpKSB7XG4gICAgICAgIHJpZ2h0ID0gbm9kZTtcbiAgICAgIH0gZWxzZSBpZiAobm9kZS5jbGFzc0xpc3QuY29udGFpbnMoJ2NlbnRlcicpKSB7XG4gICAgICAgIGNlbnRlciA9IG5vZGU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjZW50ZXJDb250ZW50LnB1c2gobm9kZSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpZiAodGhpcy5oYXNBdHRyaWJ1dGUoJ2V4cGFuZGFibGUnKSkge1xuICAgICAgdGhpcy5jbGFzc0xpc3QuYWRkKCdsaXN0LWl0ZW0tLWV4cGFuZGFibGUnKTtcblxuICAgICAgaWYgKCF0b3ApIHtcbiAgICAgICAgdG9wID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRvcC5jbGFzc0xpc3QuYWRkKCd0b3AnKTtcbiAgICAgIH1cbiAgICAgIHRvcC5jbGFzc0xpc3QuYWRkKCdsaXN0LWl0ZW1fX3RvcCcpO1xuICAgICAgdGhpcy5hcHBlbmRDaGlsZCh0b3ApO1xuICAgICAgdGhpcy5fdG9wID0gdG9wO1xuXG4gICAgICBpZiAoZXhwYW5kYWJsZUNvbnRlbnQpIHtcbiAgICAgICAgZXhwYW5kYWJsZUNvbnRlbnQuY2xhc3NMaXN0LmFkZCgnbGlzdC1pdGVtX19leHBhbmRhYmxlLWNvbnRlbnQnKTtcbiAgICAgICAgdGhpcy5hcHBlbmRDaGlsZChleHBhbmRhYmxlQ29udGVudCk7XG4gICAgICB9XG5cbiAgICAgIGlmICghcmlnaHQpIHtcbiAgICAgICAgcmlnaHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgcmlnaHQuY2xhc3NMaXN0LmFkZCgnbGlzdC1pdGVtX19yaWdodCcsICdyaWdodCcpO1xuXG4gICAgICAgIC8vIFdlIGNhbm5vdCB1c2UgYSBwc2V1ZG8tZWxlbWVudCBmb3IgdGhpcyBjaGV2cm9uLCBhcyB3ZSBjYW5ub3QgYW5pbWF0ZSBpdCB1c2luZ1xuICAgICAgICAvLyBKUy4gU28sIHdlIG1ha2UgYSBjaGV2cm9uIHNwYW4gaW5zdGVhZC5cbiAgICAgICAgY29uc3QgY2hldnJvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgICAgICAgY2hldnJvbi5jbGFzc0xpc3QuYWRkKCdsaXN0LWl0ZW1fX2V4cGFuZC1jaGV2cm9uJyk7XG4gICAgICAgIHJpZ2h0LmFwcGVuZENoaWxkKGNoZXZyb24pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0b3AgPSB0aGlzO1xuICAgIH1cblxuICAgIGlmICghY2VudGVyKSB7XG4gICAgICBjZW50ZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIGNlbnRlci5jbGFzc0xpc3QuYWRkKCdjZW50ZXInKTtcbiAgICAgIGNlbnRlckNvbnRlbnQuZm9yRWFjaChub2RlID0+IGNlbnRlci5hcHBlbmRDaGlsZChub2RlKSk7XG4gICAgfVxuICAgIGNlbnRlci5jbGFzc0xpc3QuYWRkKCdsaXN0LWl0ZW1fX2NlbnRlcicpO1xuICAgIHRvcC5hcHBlbmRDaGlsZChjZW50ZXIpO1xuXG4gICAgaWYgKGxlZnQpIHtcbiAgICAgIGxlZnQuY2xhc3NMaXN0LmFkZCgnbGlzdC1pdGVtX19sZWZ0Jyk7XG4gICAgICB0b3AuYXBwZW5kQ2hpbGQobGVmdCk7XG4gICAgfVxuICAgIGlmIChyaWdodCkge1xuICAgICAgcmlnaHQuY2xhc3NMaXN0LmFkZCgnbGlzdC1pdGVtX19yaWdodCcpO1xuICAgICAgdG9wLmFwcGVuZENoaWxkKHJpZ2h0KTtcbiAgICB9XG5cbiAgICB1dGlsLnVwZGF0ZVJpcHBsZSh0aGlzKTtcbiAgICBNb2RpZmllclV0aWwuaW5pdE1vZGlmaWVyKHRoaXMsIHNjaGVtZSk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBzaG93RXhwYW5zaW9uXG4gICAqIEBzaWduYXR1cmUgc2hvd0V4cGFuc2lvbigpXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1TaG93IHRoZSBleHBhbmRhYmxlIGNvbnRlbnQgaWYgdGhlIGVsZW1lbnQgaXMgZXhwYW5kYWJsZS5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cbiAgc2hvd0V4cGFuc2lvbigpIHtcbiAgICBpZiAodGhpcy5oYXNBdHRyaWJ1dGUoJ2V4cGFuZGFibGUnKSAmJiAhdGhpcy5fZXhwYW5kaW5nKSB7XG4gICAgICB0aGlzLmV4cGFuZGVkID0gdHJ1ZTtcbiAgICAgIHRoaXMuX2V4cGFuZGluZyA9IHRydWU7XG5cbiAgICAgIGNvbnN0IGFuaW1hdG9yID0gdGhpcy5fYW5pbWF0b3JGYWN0b3J5Lm5ld0FuaW1hdG9yKCk7XG4gICAgICBhbmltYXRvci5zaG93RXhwYW5zaW9uKHRoaXMsICgpID0+IHtcbiAgICAgICAgdGhpcy5jbGFzc0xpc3QuYWRkKCdleHBhbmRlZCcpO1xuICAgICAgICB0aGlzLl9leHBhbmRpbmcgPSBmYWxzZTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIGhpZGVFeHBhbnNpb25cbiAgICogQHNpZ25hdHVyZSBoaWRlRXhwYW5zaW9uKClcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUhpZGUgdGhlIGV4cGFuZGFibGUgY29udGVudCBpZiB0aGUgZWxlbWVudCBleHBhbmRhYmxlLlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuICBoaWRlRXhwYW5zaW9uKCkge1xuICAgIGlmICh0aGlzLmhhc0F0dHJpYnV0ZSgnZXhwYW5kYWJsZScpICYmICF0aGlzLl9leHBhbmRpbmcpIHtcbiAgICAgIHRoaXMuZXhwYW5kZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMuX2V4cGFuZGluZyA9IHRydWU7XG5cbiAgICAgIGNvbnN0IGFuaW1hdG9yID0gdGhpcy5fYW5pbWF0b3JGYWN0b3J5Lm5ld0FuaW1hdG9yKCk7XG4gICAgICBhbmltYXRvci5oaWRlRXhwYW5zaW9uKHRoaXMsICgpID0+IHtcbiAgICAgICAgdGhpcy5jbGFzc0xpc3QucmVtb3ZlKCdleHBhbmRlZCcpO1xuICAgICAgICB0aGlzLl9leHBhbmRpbmcgPSBmYWxzZTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIHRvZ2dsZUV4cGFuc2lvbigpIHtcbiAgICB0aGlzLmNsYXNzTGlzdC5jb250YWlucygnZXhwYW5kZWQnKSA/IHRoaXMuaGlkZUV4cGFuc2lvbigpIDogdGhpcy5zaG93RXhwYW5zaW9uKCk7XG4gICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudCgnZXhwYW5zaW9uJykpO1xuICB9XG5cbiAgX3VwZGF0ZUFuaW1hdG9yRmFjdG9yeSgpIHtcbiAgICByZXR1cm4gbmV3IEFuaW1hdG9yRmFjdG9yeSh7XG4gICAgICBhbmltYXRvcnM6IF9hbmltYXRvckRpY3QsXG4gICAgICBiYXNlQ2xhc3M6IExpc3RJdGVtQW5pbWF0b3IsXG4gICAgICBiYXNlQ2xhc3NOYW1lOiAnTGlzdEl0ZW1BbmltYXRvcicsXG4gICAgICBkZWZhdWx0QW5pbWF0aW9uOiB0aGlzLmdldEF0dHJpYnV0ZSgnYW5pbWF0aW9uJykgfHwgJ2RlZmF1bHQnXG4gICAgfSk7XG4gIH1cblxuICBzdGF0aWMgZ2V0IG9ic2VydmVkQXR0cmlidXRlcygpIHtcbiAgICByZXR1cm4gWydtb2RpZmllcicsICdjbGFzcycsICdyaXBwbGUnLCAnYW5pbWF0aW9uJ107XG4gIH1cblxuICBnZXQgZXhwYW5kYWJsZUNvbnRlbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMucXVlcnlTZWxlY3RvcignLmxpc3QtaXRlbV9fZXhwYW5kYWJsZS1jb250ZW50Jyk7XG4gIH1cblxuICBnZXQgZXhwYW5kQ2hldnJvbigpIHtcbiAgICByZXR1cm4gdGhpcy5xdWVyeVNlbGVjdG9yKCcubGlzdC1pdGVtX19leHBhbmQtY2hldnJvbicpO1xuICB9XG5cbiAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIGxhc3QsIGN1cnJlbnQpIHtcbiAgICBzd2l0Y2ggKG5hbWUpIHtcbiAgICAgIGNhc2UgJ2NsYXNzJzpcbiAgICAgICAgdXRpbC5yZXN0b3JlQ2xhc3ModGhpcywgZGVmYXVsdENsYXNzTmFtZSwgc2NoZW1lKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdtb2RpZmllcic6XG4gICAgICAgIE1vZGlmaWVyVXRpbC5vbk1vZGlmaWVyQ2hhbmdlZChsYXN0LCBjdXJyZW50LCB0aGlzLCBzY2hlbWUpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3JpcHBsZSc6XG4gICAgICAgIHV0aWwudXBkYXRlUmlwcGxlKHRoaXMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2FuaW1hdGlvbic6XG4gICAgICAgIHRoaXMuX2FuaW1hdG9yRmFjdG9yeSA9IHRoaXMuX3VwZGF0ZUFuaW1hdG9yRmFjdG9yeSgpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4ge1xuICAgICAgdGhpcy5fc2V0dXBMaXN0ZW5lcnModHJ1ZSk7XG4gICAgICB0aGlzLl9vcmlnaW5hbEJhY2tncm91bmRDb2xvciA9IHRoaXMuc3R5bGUuYmFja2dyb3VuZENvbG9yO1xuICAgICAgdGhpcy50YXBwZWQgPSBmYWxzZTtcbiAgICB9KTtcbiAgfVxuXG4gIGRpc2Nvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIHRoaXMuX3NldHVwTGlzdGVuZXJzKGZhbHNlKTtcbiAgfVxuXG4gIF9zZXR1cExpc3RlbmVycyhhZGQpIHtcbiAgICBjb25zdCBhY3Rpb24gPSAoYWRkID8gJ2FkZCcgOiAncmVtb3ZlJykgKyAnRXZlbnRMaXN0ZW5lcic7XG4gICAgdXRpbFthY3Rpb25dKHRoaXMsICd0b3VjaHN0YXJ0JywgdGhpcy5fb25Ub3VjaCwgeyBwYXNzaXZlOiB0cnVlIH0pO1xuICAgIHV0aWxbYWN0aW9uXSh0aGlzLCAndG91Y2htb3ZlJywgdGhpcy5fb25SZWxlYXNlLCB7IHBhc3NpdmU6IHRydWUgfSk7XG4gICAgdGhpc1thY3Rpb25dKCd0b3VjaGNhbmNlbCcsIHRoaXMuX29uUmVsZWFzZSk7XG4gICAgdGhpc1thY3Rpb25dKCd0b3VjaGVuZCcsIHRoaXMuX29uUmVsZWFzZSk7XG4gICAgdGhpc1thY3Rpb25dKCd0b3VjaGxlYXZlJywgdGhpcy5fb25SZWxlYXNlKTtcbiAgICB0aGlzW2FjdGlvbl0oJ2RyYWcnLCB0aGlzLl9vbkRyYWcpO1xuICAgIHRoaXNbYWN0aW9uXSgnbW91c2Vkb3duJywgdGhpcy5fb25Ub3VjaCk7XG4gICAgdGhpc1thY3Rpb25dKCdtb3VzZXVwJywgdGhpcy5fb25SZWxlYXNlKTtcbiAgICB0aGlzW2FjdGlvbl0oJ21vdXNlb3V0JywgdGhpcy5fb25SZWxlYXNlKTtcblxuICAgIGlmICh0aGlzLl90b3ApIHtcbiAgICAgIHRoaXMuX3RvcFthY3Rpb25dKCdjbGljaycsIHRoaXMudG9nZ2xlRXhwYW5zaW9uKTtcbiAgICB9XG4gIH1cblxuICBfb25EcmFnKGV2ZW50KSB7XG4gICAgY29uc3QgZ2VzdHVyZSA9IGV2ZW50Lmdlc3R1cmU7XG4gICAgLy8gUHJldmVudCB2ZXJ0aWNhbCBzY3JvbGxpbmcgaWYgdGhlIHVzZXJzIHBhbnMgbGVmdCBvciByaWdodC5cbiAgICBpZiAodGhpcy5oYXNBdHRyaWJ1dGUoJ2xvY2stb24tZHJhZycpICYmIFsnbGVmdCcsICdyaWdodCddLmluZGV4T2YoZ2VzdHVyZS5kaXJlY3Rpb24pID4gLTEpIHtcbiAgICAgIGdlc3R1cmUucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gIH1cblxuICBfb25Ub3VjaChlKSB7XG4gICAgaWYgKHRoaXMudGFwcGVkIHx8XG4gICAgICAodGhpcyAhPT0gZS50YXJnZXQgJiYgKHRoaXMuX3Nob3VsZElnbm9yZVRhcChlLnRhcmdldCkgfHwgdXRpbC5maW5kUGFyZW50KGUudGFyZ2V0LCB0aGlzLl9zaG91bGRJZ25vcmVUYXAsIHAgPT4gcCA9PT0gdGhpcykpKVxuICAgICkge1xuICAgICAgcmV0dXJuOyAvLyBJZ25vcmUgdGFwXG4gICAgfVxuXG4gICAgdGhpcy50YXBwZWQgPSB0cnVlO1xuICAgIGNvbnN0IHRvdWNoU3R5bGUgPSB7IHRyYW5zaXRpb246ICdiYWNrZ3JvdW5kLWNvbG9yIDAuMHMgbGluZWFyIDAuMDJzLCBib3gtc2hhZG93IDAuMHMgbGluZWFyIDAuMDJzJyB9O1xuXG4gICAgaWYgKHRoaXMuaGFzQXR0cmlidXRlKCd0YXBwYWJsZScpKSB7XG4gICAgICBpZiAodGhpcy5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IpIHtcbiAgICAgICAgdGhpcy5fb3JpZ2luYWxCYWNrZ3JvdW5kQ29sb3IgPSB0aGlzLnN0eWxlLmJhY2tncm91bmRDb2xvcjtcbiAgICAgIH1cblxuICAgICAgdG91Y2hTdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSB0aGlzLmdldEF0dHJpYnV0ZSgndGFwLWJhY2tncm91bmQtY29sb3InKSB8fCAnI2Q5ZDlkOSc7XG4gICAgICB0b3VjaFN0eWxlLmJveFNoYWRvdyA9IGAwcHggLTFweCAwcHggMHB4ICR7dG91Y2hTdHlsZS5iYWNrZ3JvdW5kQ29sb3J9YDtcbiAgICB9XG5cbiAgICBzdHlsZXIodGhpcywgdG91Y2hTdHlsZSk7XG4gIH1cblxuICBfb25SZWxlYXNlKCkge1xuICAgIHRoaXMudGFwcGVkID0gZmFsc2U7XG4gICAgdGhpcy5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSB0aGlzLl9vcmlnaW5hbEJhY2tncm91bmRDb2xvciB8fCAnJztcbiAgICBzdHlsZXIuY2xlYXIodGhpcywgJ3RyYW5zaXRpb24gYm94U2hhZG93Jyk7XG4gIH1cbn1cblxub25zRWxlbWVudHMuTGlzdEl0ZW0gPSBMaXN0SXRlbUVsZW1lbnQ7XG5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ29ucy1saXN0LWl0ZW0nLCBMaXN0SXRlbUVsZW1lbnQpO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IG9uc0VsZW1lbnRzIGZyb20gJy4uL29ucy9lbGVtZW50cyc7XG5pbXBvcnQgdXRpbCBmcm9tICcuLi9vbnMvdXRpbCc7XG5pbXBvcnQgYXV0b1N0eWxlIGZyb20gJy4uL29ucy9hdXRvc3R5bGUnO1xuaW1wb3J0IE1vZGlmaWVyVXRpbCBmcm9tICcuLi9vbnMvaW50ZXJuYWwvbW9kaWZpZXItdXRpbCc7XG5pbXBvcnQgQmFzZUVsZW1lbnQgZnJvbSAnLi9iYXNlL2Jhc2UtZWxlbWVudCc7XG5cbmNvbnN0IGRlZmF1bHRDbGFzc05hbWUgPSAnbGlzdCc7XG5jb25zdCBzY2hlbWUgPSB7Jyc6ICdsaXN0LS0qJ307XG5cbi8qKlxuICogQGVsZW1lbnQgb25zLWxpc3RcbiAqIEBjYXRlZ29yeSBsaXN0XG4gKiBAbW9kaWZpZXIgaW5zZXRcbiAqICAgW2VuXUluc2V0IGxpc3QgdGhhdCBkb2Vzbid0IGNvdmVyIHRoZSB3aG9sZSB3aWR0aCBvZiB0aGUgcGFyZW50LlsvZW5dXG4gKiAgIFtqYV3opqropoHntKDjga7nlLvpnaLjgYTjgaPjgbHjgYTjgavluoPjgYzjgonjgarjgYTjg6rjgrnjg4jjgpLooajnpLrjgZfjgb7jgZnjgIJbL2phXVxuICogQG1vZGlmaWVyIG5vYm9yZGVyXG4gKiAgIFtlbl1BIGxpc3Qgd2l0aCBubyBib3JkZXJzIGF0IHRoZSB0b3AgYW5kIGJvdHRvbS5bL2VuXVxuICogICBbamFd44Oq44K544OI44Gu5LiK5LiL44Gu44Oc44O844OA44O844GM54Sh44GE44Oq44K544OI44KS6KGo56S644GX44G+44GZ44CCWy9qYV1cbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dQ29tcG9uZW50IHRvIGRlZmluZSBhIGxpc3QsIGFuZCB0aGUgY29udGFpbmVyIGZvciBvbnMtbGlzdC1pdGVtKHMpLlsvZW5dXG4gKiAgIFtqYV3jg6rjgrnjg4jjgpLooajnj77jgZnjgovjgZ/jgoHjga7jgrPjg7Pjg53jg7zjg43jg7Pjg4jjgIJvbnMtbGlzdC1pdGVt44Gu44Kz44Oz44OG44OK44Go44GX44Gm5L2/55So44GX44G+44GZ44CCWy9qYV1cbiAqIEBzZWVhbHNvIG9ucy1saXN0LWl0ZW1cbiAqICAgW2VuXW9ucy1saXN0LWl0ZW0gY29tcG9uZW50Wy9lbl1cbiAqICAgW2phXW9ucy1saXN0LWl0ZW3jgrPjg7Pjg53jg7zjg43jg7Pjg4hbL2phXVxuICogQHNlZWFsc28gb25zLWxpc3QtaGVhZGVyXG4gKiAgIFtlbl1vbnMtbGlzdC1oZWFkZXIgY29tcG9uZW50Wy9lbl1cbiAqICAgW2phXW9ucy1saXN0LWhlYWRlcuOCs+ODs+ODneODvOODjeODs+ODiFsvamFdXG4gKiBAc2VlYWxzbyBvbnMtbGF6eS1yZXBlYXRcbiAqICAgW2VuXW9ucy1sYXp5LXJlcGVhdCBjb21wb25lbnRbL2VuXVxuICogICBbamFdb25zLWxhenktcmVwZWF044Kz44Oz44Od44O844ON44Oz44OIWy9qYV1cbiAqIEBjb2RlcGVuIHl4Y0N0XG4gKiBAdHV0b3JpYWwgdmFuaWxsYS9SZWZlcmVuY2UvbGlzdFxuICogQGV4YW1wbGVcbiAqIDxvbnMtbGlzdD5cbiAqICAgPG9ucy1saXN0LWhlYWRlcj5IZWFkZXIgVGV4dDwvb25zLWxpc3QtaGVhZGVyPlxuICogICA8b25zLWxpc3QtaXRlbT5JdGVtPC9vbnMtbGlzdC1pdGVtPlxuICogICA8b25zLWxpc3QtaXRlbT5JdGVtPC9vbnMtbGlzdC1pdGVtPlxuICogPC9vbnMtbGlzdD5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTGlzdEVsZW1lbnQgZXh0ZW5kcyBCYXNlRWxlbWVudCB7XG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgbW9kaWZpZXJcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVRoZSBhcHBlYXJhbmNlIG9mIHRoZSBsaXN0LlsvZW5dXG4gICAqICAgW2phXeODquOCueODiOOBruihqOePvuOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG5cbiAgICB0aGlzLl9jb21waWxlKCk7XG4gIH1cblxuICBfY29tcGlsZSgpIHtcbiAgICBhdXRvU3R5bGUucHJlcGFyZSh0aGlzKTtcbiAgICB0aGlzLmNsYXNzTGlzdC5hZGQoZGVmYXVsdENsYXNzTmFtZSk7XG4gICAgTW9kaWZpZXJVdGlsLmluaXRNb2RpZmllcih0aGlzLCBzY2hlbWUpO1xuICB9XG5cbiAgc3RhdGljIGdldCBvYnNlcnZlZEF0dHJpYnV0ZXMoKSB7XG4gICAgcmV0dXJuIFsnbW9kaWZpZXInLCAnY2xhc3MnXTtcbiAgfVxuXG4gIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBsYXN0LCBjdXJyZW50KSB7XG4gICAgc3dpdGNoIChuYW1lKSB7XG4gICAgICBjYXNlICdjbGFzcyc6XG4gICAgICAgIHV0aWwucmVzdG9yZUNsYXNzKHRoaXMsIGRlZmF1bHRDbGFzc05hbWUsIHNjaGVtZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnbW9kaWZpZXInOlxuICAgICAgICBNb2RpZmllclV0aWwub25Nb2RpZmllckNoYW5nZWQobGFzdCwgY3VycmVudCwgdGhpcywgc2NoZW1lKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG59XG5cbm9uc0VsZW1lbnRzLkxpc3QgPSBMaXN0RWxlbWVudDtcbmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnb25zLWxpc3QnLCBMaXN0RWxlbWVudCk7XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuaW1wb3J0IHV0aWwgZnJvbSAnLi4vLi4vb25zL3V0aWwnO1xuaW1wb3J0IEJhc2VFbGVtZW50IGZyb20gJy4vYmFzZS1lbGVtZW50JztcbmltcG9ydCBhdXRvU3R5bGUgZnJvbSAnLi4vLi4vb25zL2F1dG9zdHlsZSc7XG5pbXBvcnQgTW9kaWZpZXJVdGlsIGZyb20gJy4uLy4uL29ucy9pbnRlcm5hbC9tb2RpZmllci11dGlsJztcbmltcG9ydCBjb250ZW50UmVhZHkgZnJvbSAnLi4vLi4vb25zL2NvbnRlbnQtcmVhZHknO1xuXG5jb25zdCBJTlBVVF9BVFRSSUJVVEVTID0gW1xuICAnYXV0b2NhcGl0YWxpemUnLFxuICAnYXV0b2NvbXBsZXRlJyxcbiAgJ2F1dG9jb3JyZWN0JyxcbiAgJ2F1dG9mb2N1cycsXG4gICdkaXNhYmxlZCcsXG4gICdpbnB1dG1vZGUnLFxuICAnbWF4JyxcbiAgJ21heGxlbmd0aCcsXG4gICdtaW4nLFxuICAnbWlubGVuZ3RoJyxcbiAgJ25hbWUnLFxuICAncGF0dGVybicsXG4gICdwbGFjZWhvbGRlcicsXG4gICdyZWFkb25seScsXG4gICdyZXF1aXJlZCcsXG4gICdzaXplJyxcbiAgJ3N0ZXAnLFxuICAndmFsaWRhdG9yJyxcbiAgJ3ZhbHVlJ1xuXTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQmFzZUlucHV0RWxlbWVudCBleHRlbmRzIEJhc2VFbGVtZW50IHtcblxuICBfdXBkYXRlKCkge30gLy8gT3B0aW9uYWxseSBpbXBsZW1lbnRlZFxuXG4gIGdldCBfc2NoZW1lKCkge1xuICAgIHV0aWwudGhyb3dNZW1iZXIoKTtcbiAgfVxuXG4gIGdldCBfdGVtcGxhdGUoKSB7XG4gICAgdXRpbC50aHJvd01lbWJlcigpO1xuICB9XG5cbiAgZ2V0IHR5cGUoKSB7XG4gICAgdXRpbC50aHJvd01lbWJlcigpO1xuICB9XG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIGlmICh0aGlzLmNvbnN0cnVjdG9yID09PSBCYXNlSW5wdXRFbGVtZW50KSB7XG4gICAgICB1dGlsLnRocm93QWJzdHJhY3QoKTtcbiAgICB9XG5cbiAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4gdGhpcy5fY29tcGlsZSgpKTtcbiAgICB0aGlzLl9ib3VuZERlbGVnYXRlRXZlbnQgPSB0aGlzLl9kZWxlZ2F0ZUV2ZW50LmJpbmQodGhpcyk7XG4gIH1cblxuICBfY29tcGlsZSgpIHtcbiAgICBhdXRvU3R5bGUucHJlcGFyZSh0aGlzKTtcbiAgICB0aGlzLl9kZWZhdWx0Q2xhc3NOYW1lICYmIHRoaXMuY2xhc3NMaXN0LmFkZCh0aGlzLl9kZWZhdWx0Q2xhc3NOYW1lKTtcblxuICAgIGlmICh0aGlzLmNoaWxkcmVuLmxlbmd0aCAhPT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuYXBwZW5kQ2hpbGQodXRpbC5jcmVhdGVGcmFnbWVudCh0aGlzLl90ZW1wbGF0ZSkpO1xuXG4gICAgdGhpcy5fc2V0SW5wdXRJZCgpO1xuXG4gICAgdGhpcy5fdXBkYXRlQm91bmRBdHRyaWJ1dGVzKCk7XG5cbiAgICBNb2RpZmllclV0aWwuaW5pdE1vZGlmaWVyKHRoaXMsIHRoaXMuX3NjaGVtZSk7XG4gIH1cblxuICBfdXBkYXRlQm91bmRBdHRyaWJ1dGVzKCkge1xuICAgIElOUFVUX0FUVFJJQlVURVMuZm9yRWFjaChhdHRyID0+IHtcbiAgICAgIGlmICh0aGlzLmhhc0F0dHJpYnV0ZShhdHRyKSkge1xuICAgICAgICB0aGlzLl9pbnB1dC5zZXRBdHRyaWJ1dGUoYXR0ciwgdGhpcy5nZXRBdHRyaWJ1dGUoYXR0cikpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5faW5wdXQucmVtb3ZlQXR0cmlidXRlKGF0dHIpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdGhpcy5fdXBkYXRlKCk7XG4gIH1cblxuICBfZGVsZWdhdGVFdmVudChldmVudCkge1xuICAgIGNvbnN0IGUgPSBuZXcgQ3VzdG9tRXZlbnQoZXZlbnQudHlwZSwge1xuICAgICAgYnViYmxlczogZmFsc2UsXG4gICAgICBjYW5jZWxhYmxlOiB0cnVlXG4gICAgfSk7XG5cbiAgICByZXR1cm4gdGhpcy5kaXNwYXRjaEV2ZW50KGUpO1xuICB9XG5cbiAgX3NldElucHV0SWQoKSB7XG4gICAgaWYgKHRoaXMuaGFzQXR0cmlidXRlKCdpbnB1dC1pZCcpKSB7XG4gICAgICB0aGlzLl9pbnB1dC5pZCA9IHRoaXMuZ2V0QXR0cmlidXRlKCdpbnB1dC1pZCcpO1xuICAgIH1cbiAgfVxuXG4gIGdldCBfZGVmYXVsdENsYXNzTmFtZSgpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICBnZXQgX2lucHV0KCkge1xuICAgIHJldHVybiB0aGlzLnF1ZXJ5U2VsZWN0b3IoJ2lucHV0Jyk7XG4gIH1cblxuICBnZXQgdmFsdWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2lucHV0ID09PSBudWxsXG4gICAgICA/IHRoaXMuZ2V0QXR0cmlidXRlKCd2YWx1ZScpXG4gICAgICA6IHRoaXMuX2lucHV0LnZhbHVlO1xuICB9XG5cbiAgc2V0IHZhbHVlKHZhbCkge1xuICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB7XG4gICAgICBpZiAodmFsIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICB2YWwgPSB2YWwudG9JU09TdHJpbmcoKS5zdWJzdHJpbmcoMCwgMTApO1xuICAgICAgfVxuICAgICAgdGhpcy5faW5wdXQudmFsdWUgPSB2YWw7XG4gICAgICB0aGlzLl91cGRhdGUoKTtcbiAgICB9KTtcbiAgfVxuXG4gIHNldCBkaXNhYmxlZCh2YWx1ZSkge1xuICAgIHJldHVybiB1dGlsLnRvZ2dsZUF0dHJpYnV0ZSh0aGlzLCAnZGlzYWJsZWQnLCB2YWx1ZSk7XG4gIH1cblxuICBnZXQgZGlzYWJsZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaGFzQXR0cmlidXRlKCdkaXNhYmxlZCcpO1xuICB9XG5cbiAgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHtcbiAgICAgIHRoaXMuX2lucHV0LmFkZEV2ZW50TGlzdGVuZXIoJ2ZvY3VzJywgdGhpcy5fYm91bmREZWxlZ2F0ZUV2ZW50KTtcbiAgICAgIHRoaXMuX2lucHV0LmFkZEV2ZW50TGlzdGVuZXIoJ2JsdXInLCB0aGlzLl9ib3VuZERlbGVnYXRlRXZlbnQpO1xuICAgIH0pO1xuICB9XG5cbiAgZGlzY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHtcbiAgICAgIHRoaXMuX2lucHV0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2ZvY3VzJywgdGhpcy5fYm91bmREZWxlZ2F0ZUV2ZW50KTtcbiAgICAgIHRoaXMuX2lucHV0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2JsdXInLCB0aGlzLl9ib3VuZERlbGVnYXRlRXZlbnQpO1xuICAgIH0pO1xuICB9XG5cbiAgc3RhdGljIGdldCBvYnNlcnZlZEF0dHJpYnV0ZXMoKSB7XG4gICAgcmV0dXJuIFsnbW9kaWZpZXInLCAnaW5wdXQtaWQnLCAnY2xhc3MnLCAuLi5JTlBVVF9BVFRSSUJVVEVTXTtcbiAgfVxuXG4gIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBsYXN0LCBjdXJyZW50KSB7XG4gICAgc3dpdGNoIChuYW1lKSB7XG4gICAgICBjYXNlICdtb2RpZmllcic6XG4gICAgICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiBNb2RpZmllclV0aWwub25Nb2RpZmllckNoYW5nZWQobGFzdCwgY3VycmVudCwgdGhpcywgdGhpcy5fc2NoZW1lKSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnaW5wdXQtaWQnOlxuICAgICAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4gdGhpcy5fc2V0SW5wdXRJZCgpKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdjbGFzcyc6XG4gICAgICAgIHV0aWwucmVzdG9yZUNsYXNzKHRoaXMsIHRoaXMuX2RlZmF1bHRDbGFzc05hbWUsIHRoaXMuX3NjaGVtZSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGlmIChJTlBVVF9BVFRSSUJVVEVTLmluZGV4T2YobmFtZSkgPj0gMCkge1xuICAgICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHRoaXMuX3VwZGF0ZUJvdW5kQXR0cmlidXRlcygpKTtcbiAgICB9XG4gIH1cbn1cbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5pbXBvcnQgb25zRWxlbWVudHMgZnJvbSAnLi4vb25zL2VsZW1lbnRzJztcbmltcG9ydCBCYXNlSW5wdXRFbGVtZW50IGZyb20gJy4vYmFzZS9iYXNlLWlucHV0JztcbmltcG9ydCBjb250ZW50UmVhZHkgZnJvbSAnLi4vb25zL2NvbnRlbnQtcmVhZHknO1xuaW1wb3J0IHV0aWwgZnJvbSAnLi4vb25zL3V0aWwnO1xuXG5jb25zdCBzY2hlbWUgPSB7XG4gICcudGV4dC1pbnB1dCc6ICd0ZXh0LWlucHV0LS0qJyxcbiAgJy50ZXh0LWlucHV0X19sYWJlbCc6ICd0ZXh0LWlucHV0LS0qX19sYWJlbCdcbn07XG5cbi8qKlxuICogQGVsZW1lbnQgb25zLWlucHV0XG4gKiBAY2F0ZWdvcnkgZm9ybVxuICogQG1vZGlmaWVyIG1hdGVyaWFsXG4gKiAgW2VuXURpc3BsYXlzIGEgTWF0ZXJpYWwgRGVzaWduIGlucHV0LlsvZW5dXG4gKiAgW2phXVsvamFdXG4gKiBAbW9kaWZpZXIgdW5kZXJiYXJcbiAqICBbZW5dRGlzcGxheXMgYSBob3Jpem9udGFsIGxpbmUgdW5kZXJuZWF0aCBhIHRleHQgaW5wdXQuWy9lbl1cbiAqICBbamFdWy9qYV1cbiAqIEBtb2RpZmllciB0cmFuc3BhcmVudFxuICogIFtlbl1EaXNwbGF5cyBhIHRyYW5zcGFyZW50IGlucHV0LiBXb3JrcyBmb3IgTWF0ZXJpYWwgRGVzaWduLlsvZW5dXG4gKiAgW2phXVsvamFdXG4gKiBAZGVzY3JpcHRpb25cbiAqICBbZW5dXG4gKiAgICBBbiBpbnB1dCBlbGVtZW50LiBUaGUgYHR5cGVgIGF0dHJpYnV0ZSBjYW4gYmUgdXNlZCB0byBjaGFuZ2UgdGhlIGlucHV0IHR5cGUuIEFsbCB0ZXh0IGlucHV0IHR5cGVzIGFyZSBzdXBwb3J0ZWQuXG4gKlxuICogICAgVGhlIGNvbXBvbmVudCB3aWxsIGF1dG9tYXRpY2FsbHkgcmVuZGVyIGFzIGEgTWF0ZXJpYWwgRGVzaWduIGlucHV0IG9uIEFuZHJvaWQgZGV2aWNlcy5cbiAqXG4gKiAgICBNb3N0IGF0dHJpYnV0ZXMgdGhhdCBjYW4gYmUgdXNlZCBmb3IgYSBub3JtYWwgYDxpbnB1dD5gIGVsZW1lbnQgY2FuIGFsc28gYmUgdXNlZCBvbiB0aGUgYDxvbnMtaW5wdXQ+YCBlbGVtZW50LlxuICogIFsvZW5dXG4gKiAgW2phXVsvamFdXG4gKiBAdHV0b3JpYWwgdmFuaWxsYS9SZWZlcmVuY2UvaW5wdXRcbiAqIEBzZWVhbHNvIG9ucy1jaGVja2JveFxuICogICBbZW5dVGhlIGA8b25zLWNoZWNrYm94PmAgZWxlbWVudCBpcyB1c2VkIHRvIGRpc3BsYXkgYSBjaGVja2JveC5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBzZWVhbHNvIG9ucy1yYWRpb1xuICogICBbZW5dVGhlIGA8b25zLXJhZGlvPmAgZWxlbWVudCBpcyB1c2VkIHRvIGRpc3BsYXkgYSByYWRpbyBidXR0b24uWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAc2VlYWxzbyBvbnMtcmFuZ2VcbiAqICAgW2VuXVRoZSBgPG9ucy1yYW5nZT5gIGVsZW1lbnQgaXMgdXNlZCB0byBkaXNwbGF5IGEgcmFuZ2Ugc2xpZGVyLlsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQHNlZWFsc28gb25zLXN3aXRjaFxuICogICBbZW5dVGhlIGA8b25zLXN3aXRjaD5gIGVsZW1lbnQgaXMgdXNlZCB0byBkaXNwbGF5IGEgZHJhZ2dhYmxlIHRvZ2dsZSBzd2l0Y2guWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAc2VlYWxzbyBvbnMtc2VsZWN0XG4gKiAgIFtlbl1UaGUgYDxvbnMtc2VsZWN0PmAgZWxlbWVudCBpcyB1c2VkIHRvIGRpc3BsYXkgYSBzZWxlY3QgYm94LlsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQGd1aWRlIHRoZW1pbmcuaHRtbCNtb2RpZmllcnMgW2VuXU1vcmUgZGV0YWlscyBhYm91dCB0aGUgYG1vZGlmaWVyYCBhdHRyaWJ1dGVbL2VuXVtqYV1tb2RpZmllcuWxnuaAp+OBruS9v+OBhOaWuVsvamFdXG4gKiBAZXhhbXBsZVxuICogPG9ucy1pbnB1dCBwbGFjZWhvbGRlcj1cIlVzZXJuYW1lXCIgZmxvYXQ+PC9vbnMtaW5wdXQ+XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIElucHV0RWxlbWVudCBleHRlbmRzIEJhc2VJbnB1dEVsZW1lbnQge1xuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG5cbiAgICB0aGlzLl9ib3VuZE9uSW5wdXQgPSB0aGlzLl91cGRhdGUuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9ib3VuZE9uRm9jdXNpbiA9IHRoaXMuX3VwZGF0ZS5iaW5kKHRoaXMpO1xuICB9XG5cbiAgLyogSW5oZXJpdGVkIHByb3BzICovXG5cbiAgX3VwZGF0ZSgpIHtcbiAgICB0aGlzLl91cGRhdGVMYWJlbCgpO1xuICAgIHRoaXMuX3VwZGF0ZUxhYmVsQ2xhc3MoKTtcbiAgfVxuXG4gIGdldCBfc2NoZW1lKCkge1xuICAgIHJldHVybiBzY2hlbWU7XG4gIH1cblxuICBnZXQgX3RlbXBsYXRlKCkge1xuICAgIHJldHVybiBgXG4gICAgICA8aW5wdXQgdHlwZT1cIiR7dGhpcy50eXBlfVwiIGNsYXNzPVwidGV4dC1pbnB1dFwiPlxuICAgICAgPHNwYW4gY2xhc3M9XCJ0ZXh0LWlucHV0X19sYWJlbFwiPjwvc3Bhbj5cbiAgICBgO1xuICB9XG5cbiAgZ2V0IHR5cGUoKSB7XG4gICAgY29uc3QgdHlwZSA9IHRoaXMuZ2V0QXR0cmlidXRlKCd0eXBlJyk7XG4gICAgcmV0dXJuIChbJ2NoZWNrYm94JywgJ3JhZGlvJ10uaW5kZXhPZih0eXBlKSA8IDApICYmIHR5cGUgfHwgJ3RleHQnO1xuICB9XG5cbiAgLyogT3duIHByb3BzICovXG5cbiAgX3VwZGF0ZUxhYmVsKCkge1xuICAgIGNvbnN0IGxhYmVsID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ3BsYWNlaG9sZGVyJykgfHwgJyc7XG5cbiAgICBpZiAodHlwZW9mIHRoaXMuX2hlbHBlci50ZXh0Q29udGVudCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRoaXMuX2hlbHBlci50ZXh0Q29udGVudCA9IGxhYmVsO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9oZWxwZXIuaW5uZXJUZXh0ID0gbGFiZWw7XG4gICAgfVxuICB9XG5cbiAgX3VwZGF0ZUxhYmVsQ2xhc3MoKSB7XG4gICAgaWYgKHRoaXMudmFsdWUgPT09ICcnKSB7XG4gICAgICB0aGlzLl9oZWxwZXIuY2xhc3NMaXN0LnJlbW92ZSgndGV4dC1pbnB1dC0tbWF0ZXJpYWxfX2xhYmVsLS1hY3RpdmUnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5faGVscGVyLmNsYXNzTGlzdC5hZGQoJ3RleHQtaW5wdXQtLW1hdGVyaWFsX19sYWJlbC0tYWN0aXZlJyk7XG4gICAgfVxuICB9XG5cbiAgZ2V0IF9oZWxwZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMucXVlcnlTZWxlY3Rvcignc3BhbicpO1xuICB9XG5cbiAgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgc3VwZXIuY29ubmVjdGVkQ2FsbGJhY2soKTtcblxuICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB7XG4gICAgICB0aGlzLl9pbnB1dC5hZGRFdmVudExpc3RlbmVyKCdpbnB1dCcsIHRoaXMuX2JvdW5kT25JbnB1dCk7XG4gICAgICB0aGlzLl9pbnB1dC5hZGRFdmVudExpc3RlbmVyKCdmb2N1c2luJywgdGhpcy5fYm91bmRPbkZvY3VzaW4pO1xuICAgIH0pO1xuXG4gICAgY29uc3QgdHlwZSA9IHRoaXMuZ2V0QXR0cmlidXRlKCd0eXBlJyk7XG4gICAgaWYgKFsnY2hlY2tib3gnLCAncmFkaW8nXS5pbmRleE9mKHR5cGUpID49IDApIHtcbiAgICAgIHV0aWwud2FybihgV2FybjogPG9ucy1pbnB1dCB0eXBlPVwiJHt0eXBlfVwiPiBpcyBkZXByZWNhdGVkIHNpbmNlIHYyLjQuMC4gVXNlIDxvbnMtJHt0eXBlfT4gaW5zdGVhZC5gKVxuICAgIH1cbiAgfVxuXG4gIGRpc2Nvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIHN1cGVyLmRpc2Nvbm5lY3RlZENhbGxiYWNrKCk7XG5cbiAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4ge1xuICAgICAgdGhpcy5faW5wdXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignaW5wdXQnLCB0aGlzLl9ib3VuZE9uSW5wdXQpO1xuICAgICAgdGhpcy5faW5wdXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignZm9jdXNpbicsIHRoaXMuX2JvdW5kT25Gb2N1c2luKTtcbiAgICB9KTtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgb2JzZXJ2ZWRBdHRyaWJ1dGVzKCkge1xuICAgIHJldHVybiBbLi4uc3VwZXIub2JzZXJ2ZWRBdHRyaWJ1dGVzLCAndHlwZSddO1xuICB9XG5cbiAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIGxhc3QsIGN1cnJlbnQpIHtcbiAgICBzd2l0Y2ggKG5hbWUpIHtcbiAgICAgIGNhc2UgJ3R5cGUnOlxuICAgICAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4gdGhpcy5faW5wdXQuc2V0QXR0cmlidXRlKCd0eXBlJywgdGhpcy50eXBlKSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgc3VwZXIuYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIGxhc3QsIGN1cnJlbnQpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIHBsYWNlaG9sZGVyXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1QbGFjZWhvbGRlciB0ZXh0LiBJbiBNYXRlcmlhbCBEZXNpZ24sIHRoaXMgcGxhY2Vob2xkZXIgd2lsbCBiZSBhIGZsb2F0aW5nIGxhYmVsLlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGZsb2F0XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXUlmIHRoaXMgYXR0cmlidXRlIGlzIHByZXNlbnQsIHRoZSBwbGFjZWhvbGRlciB3aWxsIGJlIGFuaW1hdGVkIGluIE1hdGVyaWFsIERlc2lnbi5bL2VuXVxuICAgKiAgW2phXeOBk+OBruWxnuaAp+OBjOioreWumuOBleOCjOOBn+aZguOAgeODqeODmeODq+OBr+OCouODi+ODoeODvOOCt+ODp+ODs+OBmeOCi+OCiOOBhuOBq+OBquOCiuOBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIHR5cGVcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dXG4gICAqICAgIFNwZWNpZnkgdGhlIGlucHV0IHR5cGUuIFRoaXMgaXMgdGhlIHNhbWUgYXMgdGhlIFwidHlwZVwiIGF0dHJpYnV0ZSBmb3Igbm9ybWFsIGlucHV0cy4gSXQgZXhwZWN0cyBzdHJpY3QgdGV4dCB0eXBlcyBzdWNoIGFzIGB0ZXh0YCwgYHBhc3N3b3JkYCwgZXRjLiBGb3IgY2hlY2tib3gsIHJhZGlvIGJ1dHRvbiwgc2VsZWN0IG9yIHJhbmdlLCBwbGVhc2UgaGF2ZSBhIGxvb2sgYXQgdGhlIGNvcnJlc3BvbmRpbmcgZWxlbWVudHMuXG4gICAqXG4gICAqICAgIFBsZWFzZSB0YWtlIGEgbG9vayBhdCBbTUROXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVE1ML0VsZW1lbnQvaW5wdXQjYXR0ci10eXBlKSBmb3IgYW4gZXhoYXVzdGl2ZSBsaXN0IG9mIHBvc3NpYmxlIHZhbHVlcy4gRGVwZW5kaW5nIG9uIHRoZSBwbGF0Zm9ybSBhbmQgYnJvd3NlciB2ZXJzaW9uIHNvbWUgb2YgdGhlc2UgbWlnaHQgbm90IHdvcmsuXG4gICAqICBbL2VuXVxuICAgKiAgW2phXVsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGlucHV0LWlkXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXVNwZWNpZnkgdGhlIFwiaWRcIiBhdHRyaWJ1dGUgb2YgdGhlIGlubmVyIGA8aW5wdXQ+YCBlbGVtZW50LiBUaGlzIGlzIHVzZWZ1bCB3aGVuIHVzaW5nIGA8bGFiZWwgZm9yPVwiLi4uXCI+YCBlbGVtZW50cy5bL2VuXVxuICAgKiAgW2phXVsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgdmFsdWVcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVRoZSBjdXJyZW50IHZhbHVlIG9mIHRoZSBpbnB1dC5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQHByb3BlcnR5IGRpc2FibGVkXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dV2hldGhlciB0aGUgaW5wdXQgaXMgZGlzYWJsZWQgb3Igbm90LlsvZW5dXG4gICAqICAgW2phXeeEoeWKueWMluOBleOCjOOBpuOBhOOCi+WgtOWQiOOBq2B0cnVlYOOAglsvamFdXG4gICAqL1xufVxuXG5vbnNFbGVtZW50cy5JbnB1dCA9IElucHV0RWxlbWVudDtcbmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnb25zLWlucHV0JywgSW5wdXRFbGVtZW50KTtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5pbXBvcnQgQmFzZUlucHV0RWxlbWVudCBmcm9tICcuL2Jhc2UtaW5wdXQnO1xuaW1wb3J0IGNvbnRlbnRSZWFkeSBmcm9tICcuLi8uLi9vbnMvY29udGVudC1yZWFkeSc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEJhc2VDaGVja2JveEVsZW1lbnQgZXh0ZW5kcyBCYXNlSW5wdXRFbGVtZW50IHtcblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgaWYgKHRoaXMuY29uc3RydWN0b3IgPT09IEJhc2VDaGVja2JveEVsZW1lbnQpIHtcbiAgICAgIHV0aWwudGhyb3dBYnN0cmFjdCgpO1xuICAgIH1cblxuICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB7XG4gICAgICB0aGlzLmF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjaygnY2hlY2tlZCcsIG51bGwsIHRoaXMuZ2V0QXR0cmlidXRlKCdjaGVja2VkJykpO1xuICAgIH0pO1xuICB9XG5cbiAgLyogSW5oZXJpdGVkIHByb3BzICovXG5cbiAgZ2V0IF90ZW1wbGF0ZSgpIHtcbiAgICByZXR1cm4gYFxuICAgICAgPGlucHV0IHR5cGU9XCIke3RoaXMudHlwZX1cIiBjbGFzcz1cIiR7dGhpcy5fZGVmYXVsdENsYXNzTmFtZX1fX2lucHV0XCI+XG4gICAgICA8c3BhbiBjbGFzcz1cIiR7dGhpcy5fZGVmYXVsdENsYXNzTmFtZX1fX2NoZWNrbWFya1wiPjwvc3Bhbj5cbiAgICBgO1xuICB9XG5cbiAgLyogT3duIHByb3BzICovXG5cbiAgZ2V0IF9oZWxwZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMucXVlcnlTZWxlY3Rvcignc3BhbicpO1xuICB9XG5cbiAgZ2V0IGNoZWNrZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2lucHV0LmNoZWNrZWQ7XG4gIH1cblxuICBzZXQgY2hlY2tlZCh2YWwpIHtcbiAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4ge1xuICAgICAgdGhpcy5faW5wdXQuY2hlY2tlZCA9IHZhbDtcbiAgICB9KTtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgb2JzZXJ2ZWRBdHRyaWJ1dGVzKCkge1xuICAgIHJldHVybiBbLi4uc3VwZXIub2JzZXJ2ZWRBdHRyaWJ1dGVzLCAnY2hlY2tlZCddO1xuICB9XG5cbiAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIGxhc3QsIGN1cnJlbnQpIHtcbiAgICBzd2l0Y2ggKG5hbWUpIHtcbiAgICAgIGNhc2UgJ2NoZWNrZWQnOlxuICAgICAgICB0aGlzLmNoZWNrZWQgPSBjdXJyZW50ICE9PSBudWxsO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHN1cGVyLmF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBsYXN0LCBjdXJyZW50KTtcbiAgICB9XG4gIH1cbn1cbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5pbXBvcnQgb25zRWxlbWVudHMgZnJvbSAnLi4vb25zL2VsZW1lbnRzJztcbmltcG9ydCBCYXNlQ2hlY2tib3hFbGVtZW50IGZyb20gJy4vYmFzZS9iYXNlLWNoZWNrYm94JztcblxuY29uc3Qgc2NoZW1lID0ge1xuICAnLmNoZWNrYm94JzogJ2NoZWNrYm94LS0qJyxcbiAgJy5jaGVja2JveF9faW5wdXQnOiAnY2hlY2tib3gtLSpfX2lucHV0JyxcbiAgJy5jaGVja2JveF9fY2hlY2ttYXJrJzogJ2NoZWNrYm94LS0qX19jaGVja21hcmsnXG59O1xuXG4vKipcbiAqIEBlbGVtZW50IG9ucy1jaGVja2JveFxuICogQGNhdGVnb3J5IGZvcm1cbiAqIEBtb2RpZmllciBtYXRlcmlhbFxuICogIFtlbl1EaXNwbGF5cyBhIE1hdGVyaWFsIERlc2lnbiBjaGVja2JveC5bL2VuXVxuICogIFtqYV1bL2phXVxuICogQG1vZGlmaWVyIG5vYm9yZGVyXG4gKiAgW2VuXWlPUyBib3JkZXJsZXNzIGNoZWNrYm94LlsvZW5dXG4gKiAgW2phXVsvamFdXG4gKiBAZGVzY3JpcHRpb25cbiAqICBbZW5dXG4gKiAgICBBIGNoZWNrYm94IGVsZW1lbnQuIFRoZSBjb21wb25lbnQgd2lsbCBhdXRvbWF0aWNhbGx5IHJlbmRlciBhcyBhIE1hdGVyaWFsIERlc2lnbiBjaGVja2JveCBvbiBBbmRyb2lkIGRldmljZXMuXG4gKlxuICogICAgTW9zdCBhdHRyaWJ1dGVzIHRoYXQgY2FuIGJlIHVzZWQgZm9yIGEgbm9ybWFsIGA8aW5wdXQgdHlwZT1cImNoZWNrYm94XCI+YCBlbGVtZW50IGNhbiBhbHNvIGJlIHVzZWQgb24gdGhlIGA8b25zLWNoZWNrYm94PmAgZWxlbWVudC5cbiAqICBbL2VuXVxuICogIFtqYV1bL2phXVxuICogQHR1dG9yaWFsIHZhbmlsbGEvUmVmZXJlbmNlL2NoZWNrYm94XG4gKiBAc2VlYWxzbyBvbnMtc3dpdGNoXG4gKiAgIFtlbl1UaGUgYDxvbnMtc3dpdGNoPmAgZWxlbWVudCBpcyB1c2VkIHRvIGRpc3BsYXkgYSBkcmFnZ2FibGUgdG9nZ2xlIHN3aXRjaC5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBzZWVhbHNvIG9ucy1yYWRpb1xuICogICBbZW5dVGhlIGA8b25zLXJhZGlvPmAgZWxlbWVudCBpcyB1c2VkIHRvIGRpc3BsYXkgYSByYWRpbyBidXR0b24uWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAc2VlYWxzbyBvbnMtaW5wdXRcbiAqICAgW2VuXVRoZSBgPG9ucy1pbnB1dD5gIGVsZW1lbnQgaXMgdXNlZCB0byBkaXNwbGF5IGEgdGV4dCBpbnB1dC5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBzZWVhbHNvIG9ucy1zZWFyY2gtaW5wdXRcbiAqICAgW2VuXVRoZSBgPG9ucy1zZWFyY2gtaW5wdXQ+YCBlbGVtZW50IGlzIHVzZWQgdG8gZGlzcGxheSBhIHNlYXJjaCBpbnB1dC5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBzZWVhbHNvIG9ucy1yYW5nZVxuICogICBbZW5dVGhlIGA8b25zLXJhbmdlPmAgZWxlbWVudCBpcyB1c2VkIHRvIGRpc3BsYXkgYSByYW5nZSBzbGlkZXIuWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAc2VlYWxzbyBvbnMtc2VsZWN0XG4gKiAgIFtlbl1UaGUgYDxvbnMtc2VsZWN0PmAgZWxlbWVudCBpcyB1c2VkIHRvIGRpc3BsYXkgYSBzZWxlY3QgYm94LlsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQGd1aWRlIHRoZW1pbmcuaHRtbCNtb2RpZmllcnMgW2VuXU1vcmUgZGV0YWlscyBhYm91dCB0aGUgYG1vZGlmaWVyYCBhdHRyaWJ1dGVbL2VuXVtqYV1tb2RpZmllcuWxnuaAp+OBruS9v+OBhOaWuVsvamFdXG4gKiBAZXhhbXBsZVxuICogPG9ucy1jaGVja2JveCBjaGVja2VkPjwvb25zLWNoZWNrYm94PlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDaGVja2JveEVsZW1lbnQgZXh0ZW5kcyBCYXNlQ2hlY2tib3hFbGVtZW50IHtcblxuICBnZXQgX3NjaGVtZSgpIHtcbiAgICByZXR1cm4gc2NoZW1lO1xuICB9XG5cbiAgZ2V0IF9kZWZhdWx0Q2xhc3NOYW1lKCkge1xuICAgIHJldHVybiAnY2hlY2tib3gnO1xuICB9XG5cbiAgZ2V0IHR5cGUoKSB7XG4gICAgcmV0dXJuICdjaGVja2JveCc7XG4gIH1cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBpbnB1dC1pZFxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFtlbl1TcGVjaWZ5IHRoZSBcImlkXCIgYXR0cmlidXRlIG9mIHRoZSBpbm5lciBgPGlucHV0PmAgZWxlbWVudC4gVGhpcyBpcyB1c2VmdWwgd2hlbiB1c2luZyBgPGxhYmVsIGZvcj1cIi4uLlwiPmAgZWxlbWVudHMuWy9lbl1cbiAgICogIFtqYV1bL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQHByb3BlcnR5IHZhbHVlXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1UaGUgY3VycmVudCB2YWx1ZSBvZiB0aGUgY2hlY2tib3guWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBjaGVja2VkXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dV2hldGhlciB0aGUgY2hlY2tib3ggaXMgY2hlY2tlZCBvciBub3QuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBkaXNhYmxlZFxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVdoZXRoZXIgdGhlIGNoZWNrYm94IGlzIGRpc2FibGVkIG9yIG5vdC5bL2VuXVxuICAgKiAgIFtqYV3nhKHlirnljJbjgZXjgozjgabjgYTjgovloLTlkIjjgatgdHJ1ZWDjgIJbL2phXVxuICAgKi9cbn1cblxub25zRWxlbWVudHMuQ2hlY2tib3ggPSBDaGVja2JveEVsZW1lbnQ7XG5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ29ucy1jaGVja2JveCcsIENoZWNrYm94RWxlbWVudCk7XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuaW1wb3J0IG9uc0VsZW1lbnRzIGZyb20gJy4uL29ucy9lbGVtZW50cyc7XG5pbXBvcnQgQmFzZUNoZWNrYm94RWxlbWVudCBmcm9tICcuL2Jhc2UvYmFzZS1jaGVja2JveCc7XG5cbmNvbnN0IHNjaGVtZSA9IHtcbiAgJy5yYWRpby1idXR0b24nOiAncmFkaW8tYnV0dG9uLS0qJyxcbiAgJy5yYWRpby1idXR0b25fX2lucHV0JzogJ3JhZGlvLWJ1dHRvbi0tKl9faW5wdXQnLFxuICAnLnJhZGlvLWJ1dHRvbl9fY2hlY2ttYXJrJzogJ3JhZGlvLWJ1dHRvbi0tKl9fY2hlY2ttYXJrJ1xufTtcblxuLyoqXG4gKiBAZWxlbWVudCBvbnMtcmFkaW9cbiAqIEBjYXRlZ29yeSBmb3JtXG4gKiBAbW9kaWZpZXIgbWF0ZXJpYWxcbiAqICBbZW5dRGlzcGxheXMgYSBNYXRlcmlhbCBEZXNpZ24gcmFkaW8gYnV0dG9uLlsvZW5dXG4gKiAgW2phXVsvamFdXG4gKiBAZGVzY3JpcHRpb25cbiAqICBbZW5dXG4gKiAgICBBIHJhZGlvIGJ1dHRvbiBlbGVtZW50LiBUaGUgY29tcG9uZW50IHdpbGwgYXV0b21hdGljYWxseSByZW5kZXIgYXMgYSBNYXRlcmlhbCBEZXNpZ24gcmFkaW8gYnV0dG9uIG9uIEFuZHJvaWQgZGV2aWNlcy5cbiAqXG4gKiAgICBNb3N0IGF0dHJpYnV0ZXMgdGhhdCBjYW4gYmUgdXNlZCBmb3IgYSBub3JtYWwgYDxpbnB1dCB0eXBlPVwicmFkaW9cIj5gIGVsZW1lbnQgY2FuIGFsc28gYmUgdXNlZCBvbiB0aGUgYDxvbnMtcmFkaW8+YCBlbGVtZW50LlxuICogIFsvZW5dXG4gKiAgW2phXVsvamFdXG4gKiBAdHV0b3JpYWwgdmFuaWxsYS9SZWZlcmVuY2UvcmFkaW9cbiAqIEBzZWVhbHNvIG9ucy1zZWxlY3RcbiAqICAgW2VuXVRoZSBgPG9ucy1zZWxlY3Q+YCBlbGVtZW50IGlzIHVzZWQgdG8gZGlzcGxheSBhIHNlbGVjdCBib3guWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAc2VlYWxzbyBvbnMtY2hlY2tib3hcbiAqICAgW2VuXVRoZSBgPG9ucy1jaGVja2JveD5gIGVsZW1lbnQgaXMgdXNlZCB0byBkaXNwbGF5IGEgY2hlY2tib3guWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAc2VlYWxzbyBvbnMtc3dpdGNoXG4gKiAgIFtlbl1UaGUgYDxvbnMtc3dpdGNoPmAgZWxlbWVudCBpcyB1c2VkIHRvIGRpc3BsYXkgYSBkcmFnZ2FibGUgdG9nZ2xlIHN3aXRjaC5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBzZWVhbHNvIG9ucy1pbnB1dFxuICogICBbZW5dVGhlIGA8b25zLWlucHV0PmAgZWxlbWVudCBpcyB1c2VkIHRvIGRpc3BsYXkgYSB0ZXh0IGlucHV0LlsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQHNlZWFsc28gb25zLXNlYXJjaC1pbnB1dFxuICogICBbZW5dVGhlIGA8b25zLXNlYXJjaC1pbnB1dD5gIGVsZW1lbnQgaXMgdXNlZCB0byBkaXNwbGF5IGEgc2VhcmNoIGlucHV0LlsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQHNlZWFsc28gb25zLXJhbmdlXG4gKiAgIFtlbl1UaGUgYDxvbnMtcmFuZ2U+YCBlbGVtZW50IGlzIHVzZWQgdG8gZGlzcGxheSBhIHJhbmdlIHNsaWRlci5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBndWlkZSB0aGVtaW5nLmh0bWwjbW9kaWZpZXJzIFtlbl1Nb3JlIGRldGFpbHMgYWJvdXQgdGhlIGBtb2RpZmllcmAgYXR0cmlidXRlWy9lbl1bamFdbW9kaWZpZXLlsZ7mgKfjga7kvb/jgYTmlrlbL2phXVxuICogQGV4YW1wbGVcbiAqIDxvbnMtcmFkaW8gY2hlY2tlZD48L29ucy1yYWRpbz5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUmFkaW9FbGVtZW50IGV4dGVuZHMgQmFzZUNoZWNrYm94RWxlbWVudCB7XG5cbiAgZ2V0IF9zY2hlbWUoKSB7XG4gICAgcmV0dXJuIHNjaGVtZTtcbiAgfVxuXG4gIGdldCBfZGVmYXVsdENsYXNzTmFtZSgpIHtcbiAgICByZXR1cm4gJ3JhZGlvLWJ1dHRvbic7XG4gIH1cblxuICBnZXQgdHlwZSgpIHtcbiAgICByZXR1cm4gJ3JhZGlvJztcbiAgfVxuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGlucHV0LWlkXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXVNwZWNpZnkgdGhlIFwiaWRcIiBhdHRyaWJ1dGUgb2YgdGhlIGlubmVyIGA8aW5wdXQ+YCBlbGVtZW50LiBUaGlzIGlzIHVzZWZ1bCB3aGVuIHVzaW5nIGA8bGFiZWwgZm9yPVwiLi4uXCI+YCBlbGVtZW50cy5bL2VuXVxuICAgKiAgW2phXVsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgdmFsdWVcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVRoZSBjdXJyZW50IHZhbHVlIG9mIHRoZSByYWRpbyBidXR0b24uWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBjaGVja2VkXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dV2hldGhlciB0aGUgcmFkaW8gYnV0dG9uIGlzIGNoZWNrZWQgb3Igbm90LlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgZGlzYWJsZWRcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1XaGV0aGVyIHRoZSByYWRpbyBidXR0b24gaXMgZGlzYWJsZWQgb3Igbm90LlsvZW5dXG4gICAqICAgW2phXeeEoeWKueWMluOBleOCjOOBpuOBhOOCi+WgtOWQiOOBq2B0cnVlYOOAglsvamFdXG4gICAqL1xufVxuXG5vbnNFbGVtZW50cy5SYWRpbyA9IFJhZGlvRWxlbWVudDtcbmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnb25zLXJhZGlvJywgUmFkaW9FbGVtZW50KTtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5pbXBvcnQgb25zRWxlbWVudHMgZnJvbSAnLi4vb25zL2VsZW1lbnRzJztcbmltcG9ydCBCYXNlSW5wdXRFbGVtZW50IGZyb20gJy4vYmFzZS9iYXNlLWlucHV0JztcblxuY29uc3Qgc2NoZW1lID0ge1xuICAnLnNlYXJjaC1pbnB1dCc6ICdzZWFyY2gtaW5wdXQtLSonXG59O1xuXG4vKipcbiAqIEBlbGVtZW50IG9ucy1zZWFyY2gtaW5wdXRcbiAqIEBjYXRlZ29yeSBmb3JtXG4gKiBAbW9kaWZpZXIgbWF0ZXJpYWxcbiAqICBbZW5dRGlzcGxheXMgYSBNYXRlcmlhbCBEZXNpZ24gc2VhcmNoIGlucHV0LlsvZW5dXG4gKiAgW2phXVsvamFdXG4gKiBAZGVzY3JpcHRpb25cbiAqICBbZW5dXG4gKiAgICBBIHNlYXJjaCBpbnB1dCBlbGVtZW50LiBUaGUgY29tcG9uZW50IHdpbGwgYXV0b21hdGljYWxseSByZW5kZXIgYXMgYSBNYXRlcmlhbCBEZXNpZ24gc2VhcmNoIGlucHV0IG9uIEFuZHJvaWQgZGV2aWNlcy5cbiAqXG4gKiAgICBNb3N0IGF0dHJpYnV0ZXMgdGhhdCBjYW4gYmUgdXNlZCBmb3IgYSBub3JtYWwgYDxpbnB1dD5gIGVsZW1lbnQgY2FuIGFsc28gYmUgdXNlZCBvbiB0aGUgYDxvbnMtc2VhcmNoLWlucHV0PmAgZWxlbWVudC5cbiAqICBbL2VuXVxuICogIFtqYV1bL2phXVxuICogQHR1dG9yaWFsIHZhbmlsbGEvUmVmZXJlbmNlL3NlYXJjaC1pbnB1dFxuICogQHNlZWFsc28gb25zLWlucHV0XG4gKiAgIFtlbl1UaGUgYDxvbnMtaW5wdXQ+YCBlbGVtZW50IGlzIHVzZWQgdG8gZGlzcGxheSBhIHRleHQgaW5wdXQuWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAc2VlYWxzbyBvbnMtcmFuZ2VcbiAqICAgW2VuXVRoZSBgPG9ucy1yYW5nZT5gIGVsZW1lbnQgaXMgdXNlZCB0byBkaXNwbGF5IGEgcmFuZ2Ugc2xpZGVyLlsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQHNlZWFsc28gb25zLXN3aXRjaFxuICogICBbZW5dVGhlIGA8b25zLXN3aXRjaD5gIGVsZW1lbnQgaXMgdXNlZCB0byBkaXNwbGF5IGEgZHJhZ2dhYmxlIHRvZ2dsZSBzd2l0Y2guWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAc2VlYWxzbyBvbnMtc2VsZWN0XG4gKiAgIFtlbl1UaGUgYDxvbnMtc2VsZWN0PmAgZWxlbWVudCBpcyB1c2VkIHRvIGRpc3BsYXkgYSBzZWxlY3QgYm94LlsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQHNlZWFsc28gb25zLWNoZWNrYm94XG4gKiAgIFtlbl1UaGUgYDxvbnMtY2hlY2tib3g+YCBlbGVtZW50IGlzIHVzZWQgdG8gZGlzcGxheSBhIGNoZWNrYm94LlsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQHNlZWFsc28gb25zLXJhZGlvXG4gKiAgIFtlbl1UaGUgYDxvbnMtcmFkaW8+YCBlbGVtZW50IGlzIHVzZWQgdG8gZGlzcGxheSBhIHJhZGlvIGJ1dHRvbi5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBndWlkZSB0aGVtaW5nLmh0bWwjbW9kaWZpZXJzIFtlbl1Nb3JlIGRldGFpbHMgYWJvdXQgdGhlIGBtb2RpZmllcmAgYXR0cmlidXRlWy9lbl1bamFdbW9kaWZpZXLlsZ7mgKfjga7kvb/jgYTmlrlbL2phXVxuICogQGV4YW1wbGVcbiAqIDxvbnMtc2VhcmNoLWlucHV0IHBsYWNlaG9sZGVyPVwiU2VhcmNoXCI+PC9vbnMtc2VhcmNoLWlucHV0PlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTZWFyY2hJbnB1dEVsZW1lbnQgZXh0ZW5kcyBCYXNlSW5wdXRFbGVtZW50IHtcblxuICBnZXQgX3NjaGVtZSgpIHtcbiAgICByZXR1cm4gc2NoZW1lO1xuICB9XG5cbiAgZ2V0IF90ZW1wbGF0ZSgpIHtcbiAgICByZXR1cm4gYFxuICAgICAgPGlucHV0IHR5cGU9XCIke3RoaXMudHlwZX1cIiBjbGFzcz1cInNlYXJjaC1pbnB1dFwiPlxuICAgIGA7XG4gIH1cblxuICBnZXQgdHlwZSgpIHtcbiAgICByZXR1cm4gJ3NlYXJjaCc7XG4gIH1cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBpbnB1dC1pZFxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFtlbl1TcGVjaWZ5IHRoZSBcImlkXCIgYXR0cmlidXRlIG9mIHRoZSBpbm5lciBgPGlucHV0PmAgZWxlbWVudC4gVGhpcyBpcyB1c2VmdWwgd2hlbiB1c2luZyBgPGxhYmVsIGZvcj1cIi4uLlwiPmAgZWxlbWVudHMuWy9lbl1cbiAgICogIFtqYV1bL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQHByb3BlcnR5IHZhbHVlXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1UaGUgY3VycmVudCB2YWx1ZSBvZiB0aGUgaW5wdXQuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBkaXNhYmxlZFxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVdoZXRoZXIgdGhlIGlucHV0IGlzIGRpc2FibGVkIG9yIG5vdC5bL2VuXVxuICAgKiAgIFtqYV3nhKHlirnljJbjgZXjgozjgabjgYTjgovloLTlkIjjgatgdHJ1ZWDjgIJbL2phXVxuICAgKi9cbn1cblxub25zRWxlbWVudHMuU2VhcmNoSW5wdXQgPSBTZWFyY2hJbnB1dEVsZW1lbnQ7XG5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ29ucy1zZWFyY2gtaW5wdXQnLCBTZWFyY2hJbnB1dEVsZW1lbnQpO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IEJhc2VBbmltYXRvciBmcm9tICcuLi8uLi9vbnMvYmFzZS1hbmltYXRvcic7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1vZGFsQW5pbWF0b3IgZXh0ZW5kcyBCYXNlQW5pbWF0b3Ige1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge1N0cmluZ30gb3B0aW9ucy50aW1pbmdcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbnMuZHVyYXRpb25cbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbnMuZGVsYXlcbiAgICovXG4gIGNvbnN0cnVjdG9yKHt0aW1pbmcgPSAnbGluZWFyJywgZGVsYXkgPSAwLCBkdXJhdGlvbiA9IDAuMn0gPSB7fSkge1xuICAgIHN1cGVyKHsgdGltaW5nLCBkZWxheSwgZHVyYXRpb24gfSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gbW9kYWxcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICovXG4gIHNob3cobW9kYWwsIGNhbGxiYWNrKSB7XG4gICAgY2FsbGJhY2soKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBtb2RhbFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKi9cbiAgaGlkZShtb2RhbCwgY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjaygpO1xuICB9XG59XG4iLCJcbi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCBhbmltaXQgZnJvbSAnLi4vLi4vb25zL2FuaW1pdCc7XG5pbXBvcnQgTW9kYWxBbmltYXRvciBmcm9tICcuL2FuaW1hdG9yJztcblxuLyoqXG4gKiBpT1Mgc3R5bGUgYW5pbWF0b3IgZm9yIGRpYWxvZy5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRmFkZU1vZGFsQW5pbWF0b3IgZXh0ZW5kcyBNb2RhbEFuaW1hdG9yIHtcblxuICBjb25zdHJ1Y3Rvcih7dGltaW5nID0gJ2xpbmVhcicsIGRlbGF5ID0gMCwgZHVyYXRpb24gPSAwLjN9ID0ge30pIHtcbiAgICBzdXBlcih7IHRpbWluZywgZGVsYXksIGR1cmF0aW9uIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IG1vZGFsXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqL1xuICBzaG93KG1vZGFsLCBjYWxsYmFjaykge1xuICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgPyBjYWxsYmFjayA6IGZ1bmN0aW9uKCkge307XG5cbiAgICBhbmltaXQobW9kYWwsIHRoaXMuZGVmKVxuICAgICAgLmRlZmF1bHQoeyBvcGFjaXR5OiAwIH0sIHsgb3BhY2l0eTogMSB9KVxuICAgICAgLnF1ZXVlKGRvbmUgPT4ge1xuICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICBkb25lKCk7XG4gICAgICB9KVxuICAgICAgLnBsYXkoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBtb2RhbFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKi9cbiAgaGlkZShtb2RhbCwgY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjayA9IGNhbGxiYWNrID8gY2FsbGJhY2sgOiBmdW5jdGlvbigpIHt9O1xuXG4gICAgYW5pbWl0KG1vZGFsLCB0aGlzLmRlZilcbiAgICAgIC5kZWZhdWx0KHsgb3BhY2l0eTogMSB9LCB7IG9wYWNpdHk6IDAgfSlcbiAgICAgIC5xdWV1ZShkb25lID0+IHtcbiAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgZG9uZSgpO1xuICAgICAgfSlcbiAgICAgIC5wbGF5KCk7XG4gIH1cbn1cbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCBhbmltaXQgZnJvbSAnLi4vLi4vb25zL2FuaW1pdCc7XG5pbXBvcnQgTW9kYWxBbmltYXRvciBmcm9tICcuL2FuaW1hdG9yJztcblxuLyoqXG4gKiBpT1Mgc3R5bGUgYW5pbWF0b3IgZm9yIG1vZGFsLlxuICovXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExpZnRNb2RhbEFuaW1hdG9yIGV4dGVuZHMgTW9kYWxBbmltYXRvclxue1xuICBjb25zdHJ1Y3Rvcih7dGltaW5nID0gJ2N1YmljLWJlemllciggLjEsIC43LCAuMSwgMSknLCBkZWxheSA9IDAsIGR1cmF0aW9uID0gMC40fSA9IHt9KSB7XG4gICAgc3VwZXIoeyB0aW1pbmcsIGRlbGF5LCBkdXJhdGlvbiB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBtb2RhbFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKi9cbiAgc2hvdyhtb2RhbCwgY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjayA9IGNhbGxiYWNrID8gY2FsbGJhY2sgOiBmdW5jdGlvbigpIHt9O1xuXG4gICAgYW5pbWl0KG1vZGFsLCB0aGlzLmRlZilcbiAgICAgIC5kZWZhdWx0KFxuICAgICAgICB7IHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNkKDAsIDEwMCUsIDApJyB9LFxuICAgICAgICB7IHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNkKDAsIDAsIDApJyB9XG4gICAgICApXG4gICAgICAucXVldWUoZG9uZSA9PiB7XG4gICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgIGRvbmUoKTtcbiAgICAgIH0pXG4gICAgICAucGxheSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IG1vZGFsXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqL1xuICBoaWRlKG1vZGFsLCBjYWxsYmFjaykge1xuICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgPyBjYWxsYmFjayA6IGZ1bmN0aW9uKCkge307XG5cbiAgICBhbmltaXQobW9kYWwsIHRoaXMuZGVmKVxuICAgICAgLmRlZmF1bHQoXG4gICAgICAgIHsgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoMCwgMCwgMCknIH0sXG4gICAgICAgIHsgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoMCwgMTAwJSwgMCknIH1cbiAgICAgIClcbiAgICAgIC5xdWV1ZShkb25lID0+IHtcbiAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgZG9uZSgpO1xuICAgICAgfSlcbiAgICAgIC5wbGF5KCk7XG4gIH1cbn1cbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCBvbnNFbGVtZW50cyBmcm9tICcuLi8uLi9vbnMvZWxlbWVudHMnO1xuaW1wb3J0IHV0aWwgZnJvbSAnLi4vLi4vb25zL3V0aWwnO1xuaW1wb3J0IE1vZGlmaWVyVXRpbCBmcm9tICcuLi8uLi9vbnMvaW50ZXJuYWwvbW9kaWZpZXItdXRpbCc7XG5pbXBvcnQgQW5pbWF0b3JGYWN0b3J5IGZyb20gJy4uLy4uL29ucy9pbnRlcm5hbC9hbmltYXRvci1mYWN0b3J5JztcbmltcG9ydCBNb2RhbEFuaW1hdG9yIGZyb20gJy4vYW5pbWF0b3InO1xuaW1wb3J0IEZhZGVNb2RhbEFuaW1hdG9yIGZyb20gJy4vZmFkZS1hbmltYXRvcic7XG5pbXBvcnQgTGlmdE1vZGFsQW5pbWF0b3IgZnJvbSAnLi9saWZ0LWFuaW1hdG9yJztcbmltcG9ydCBwbGF0Zm9ybSBmcm9tICcuLi8uLi9vbnMvcGxhdGZvcm0nO1xuaW1wb3J0IEJhc2VEaWFsb2dFbGVtZW50IGZyb20gJy4uL2Jhc2UvYmFzZS1kaWFsb2cnO1xuaW1wb3J0IGNvbnRlbnRSZWFkeSBmcm9tICcuLi8uLi9vbnMvY29udGVudC1yZWFkeSc7XG5cbmNvbnN0IHNjaGVtZSA9IHtcbiAgJyc6ICdtb2RhbC0tKicsXG4gICdtb2RhbF9fY29udGVudCc6ICdtb2RhbC0tKl9fY29udGVudCdcbn07XG5cbmNvbnN0IGRlZmF1bHRDbGFzc05hbWUgPSAnbW9kYWwnO1xuXG5jb25zdCBfYW5pbWF0b3JEaWN0ID0ge1xuICAnZGVmYXVsdCc6IE1vZGFsQW5pbWF0b3IsXG4gICdmYWRlJzogRmFkZU1vZGFsQW5pbWF0b3IsXG4gICdsaWZ0JzogTGlmdE1vZGFsQW5pbWF0b3IsXG4gICdub25lJzogTW9kYWxBbmltYXRvclxufTtcblxuLyoqXG4gKiBAZWxlbWVudCBvbnMtbW9kYWxcbiAqIEBjYXRlZ29yeSBkaWFsb2dcbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dXG4gKiAgICAgTW9kYWwgY29tcG9uZW50IHRoYXQgbWFza3MgY3VycmVudCBzY3JlZW4uIFVuZGVybHlpbmcgY29tcG9uZW50cyBhcmUgbm90IHN1YmplY3QgdG8gYW55IGV2ZW50cyB3aGlsZSB0aGUgbW9kYWwgY29tcG9uZW50IGlzIHNob3duLlxuICpcbiAqICAgICBUaGlzIGNvbXBvbmVudCBjYW4gYmUgdXNlZCB0byBibG9jayB1c2VyIGlucHV0IHdoaWxlIHNvbWUgb3BlcmF0aW9uIGlzIHJ1bm5pbmcgb3IgdG8gc2hvdyBzb21lIGluZm9ybWF0aW9uIHRvIHRoZSB1c2VyLlxuICogICBbL2VuXVxuICogICBbamFdXG4gKiAgICAg55S76Z2i5YWo5L2T44KS44Oe44K544Kv44GZ44KL44Oi44O844OA44Or55So44Kz44Oz44Od44O844ON44Oz44OI44Gn44GZ44CC5LiL5YG044Gr44GC44KL44Kz44Oz44Od44O844ON44Oz44OI44Gv44CBXG4gKiAgICAg44Oi44O844OA44Or44GM6KGo56S644GV44KM44Gm44GE44KL6ZaT44Gv44Kk44OZ44Oz44OI6YCa55+l44GM6KGM44KP44KM44G+44Gb44KT44CCXG4gKiAgIFsvamFdXG4gKiBAc2VlYWxzbyBvbnMtZGlhbG9nXG4gKiAgIFtlbl1UaGUgYDxvbnMtZGlhbG9nPmAgY29tcG9uZW50IGNhbiBiZSB1c2VkIHRvIGNyZWF0ZSBhIG1vZGFsIGRpYWxvZy5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBjb2RlcGVuIGRldklnXG4gKiBAdHV0b3JpYWwgdmFuaWxsYS9yZWZlcmVuY2UvbW9kYWxcbiAqIEBleGFtcGxlXG4gKiA8b25zLW1vZGFsIGlkPVwibW9kYWxcIj5cbiAqICAgTW9kYWwgY29udGVudFxuICogPC9vbnMtbW9kYWw+XG4gKiA8c2NyaXB0PlxuICogICB2YXIgbW9kYWwgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbW9kYWwnKTtcbiAqICAgbW9kYWwuc2hvdygpO1xuICogPC9zY3JpcHQ+XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1vZGFsRWxlbWVudCBleHRlbmRzIEJhc2VEaWFsb2dFbGVtZW50IHtcblxuICAvKipcbiAgICogQGV2ZW50IHByZXNob3dcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIFtlbl1GaXJlZCBqdXN0IGJlZm9yZSB0aGUgbW9kYWwgaXMgZGlzcGxheWVkLlsvZW5dXG4gICAqIFtqYV3jg6Ljg7zjg4Djg6vjgYzooajnpLrjgZXjgozjgovnm7TliY3jgavnmbrngavjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgW2VuXUV2ZW50IG9iamVjdC5bL2VuXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQubW9kYWxcbiAgICogICBbZW5dQ29tcG9uZW50IG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgrPjg7Pjg53jg7zjg43jg7Pjg4jjga7jgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBldmVudC5jYW5jZWxcbiAgICogICBbZW5dRXhlY3V0ZSB0aGlzIGZ1bmN0aW9uIHRvIHN0b3AgdGhlIG1vZGFsIGZyb20gYmVpbmcgc2hvd24uWy9lbl1cbiAgICogICBbamFd44GT44Gu6Zai5pWw44KS5a6f6KGM44GZ44KL44Go44CB44OA44Kk44Ki44Ot44Kw44Gu6KGo56S644GM44Kt44Oj44Oz44K744Or44GV44KM44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBldmVudCBwb3N0c2hvd1xuICAgKiBAZGVzY3JpcHRpb25cbiAgICogW2VuXUZpcmVkIGp1c3QgYWZ0ZXIgdGhlIG1vZGFsIGlzIGRpc3BsYXllZC5bL2VuXVxuICAgKiBbamFd44Oi44O844OA44Or44GM6KGo56S644GV44KM44Gf55u05b6M44Gr55m654Gr44GX44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IFtlbl1FdmVudCBvYmplY3QuWy9lbl1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50Lm1vZGFsXG4gICAqICAgW2VuXUNvbXBvbmVudCBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Kz44Oz44Od44O844ON44Oz44OI44Gu44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBldmVudCBwcmVoaWRlXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBbZW5dRmlyZWQganVzdCBiZWZvcmUgdGhlIG1vZGFsIGlzIGhpZGRlbi5bL2VuXVxuICAgKiBbamFd44Oi44O844OA44Or44GM6Zqg44KM44KL55u05YmN44Gr55m654Gr44GX44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IFtlbl1FdmVudCBvYmplY3QuWy9lbl1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50Lm1vZGFsXG4gICAqICAgW2VuXUNvbXBvbmVudCBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Kz44Oz44Od44O844ON44Oz44OI44Gu44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZXZlbnQuY2FuY2VsXG4gICAqICAgW2VuXUV4ZWN1dGUgdGhpcyBmdW5jdGlvbiB0byBzdG9wIHRoZSBtb2RhbCBmcm9tIGJlaW5nIGhpZGRlbi5bL2VuXVxuICAgKiAgIFtqYV3jgZPjga7plqLmlbDjgpLlrp/ooYzjgZnjgovjgajjgIHjg4DjgqTjgqLjg63jgrDjga7pnZ7ooajnpLrjgYzjgq3jg6Pjg7Pjgrvjg6vjgZXjgozjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGV2ZW50IHBvc3RoaWRlXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBbZW5dRmlyZWQganVzdCBhZnRlciB0aGUgbW9kYWwgaXMgaGlkZGVuLlsvZW5dXG4gICAqIFtqYV3jg6Ljg7zjg4Djg6vjgYzpmqDjgozjgZ/lvozjgavnmbrngavjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgW2VuXUV2ZW50IG9iamVjdC5bL2VuXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQubW9kYWxcbiAgICogICBbZW5dQ29tcG9uZW50IG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgrPjg7Pjg53jg7zjg43jg7Pjg4jjga7jgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBhbmltYXRpb25cbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlZmF1bHQgZGVmYXVsdFxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFtlbl1UaGUgYW5pbWF0aW9uIHVzZWQgd2hlbiBzaG93aW5nIGFuZCBoaWRpbmcgdGhlIG1vZGFsLiBDYW4gYmUgZWl0aGVyIGBcIm5vbmVcImAsIGBcImZhZGVcImAgb3IgYFwibGlmdFwiYC5bL2VuXVxuICAgKiAgW2phXeODouODvOODgOODq+OCkuihqOekuuOBmeOCi+mam+OBruOCouODi+ODoeODvOOCt+ODp+ODs+WQjeOCkuaMh+WumuOBl+OBvuOBmeOAglwibm9uZVwi44KC44GX44GP44GvXCJmYWRlXCIsXCJsaWZ0XCLjgpLmjIflrprjgafjgY3jgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBhbmltYXRpb24tb3B0aW9uc1xuICAgKiBAdHlwZSB7RXhwcmVzc2lvbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dU3BlY2lmeSB0aGUgYW5pbWF0aW9uJ3MgZHVyYXRpb24sIHRpbWluZyBhbmQgZGVsYXkgd2l0aCBhbiBvYmplY3QgbGl0ZXJhbC4gRS5nLiBge2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAxLCB0aW1pbmc6ICdlYXNlLWluJ31gLlsvZW5dXG4gICAqICBbamFd44Ki44OL44Oh44O844K344On44Oz5pmC44GuZHVyYXRpb24sIHRpbWluZywgZGVsYXnjgpLjgqrjg5bjgrjjgqfjgq/jg4jjg6rjg4bjg6njg6vjgafmjIflrprjgZfjgb7jgZnjgIJlLmcuIDxjb2RlPntkdXJhdGlvbjogMC4yLCBkZWxheTogMSwgdGltaW5nOiAnZWFzZS1pbid9PC9jb2RlPlsvamFdXG4gICAqL1xuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG5cbiAgICB0aGlzLl9kZWZhdWx0REJCID0gKCkgPT4gdW5kZWZpbmVkO1xuICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB0aGlzLl9jb21waWxlKCkpO1xuICB9XG5cbiAgZ2V0IF9zY2hlbWUoKSB7XG4gICAgcmV0dXJuIHNjaGVtZTtcbiAgfVxuXG4gIF91cGRhdGVBbmltYXRvckZhY3RvcnkoKSB7XG4gICAgcmV0dXJuIG5ldyBBbmltYXRvckZhY3Rvcnkoe1xuICAgICAgYW5pbWF0b3JzOiBfYW5pbWF0b3JEaWN0LFxuICAgICAgYmFzZUNsYXNzOiBNb2RhbEFuaW1hdG9yLFxuICAgICAgYmFzZUNsYXNzTmFtZTogJ01vZGFsQW5pbWF0b3InLFxuICAgICAgZGVmYXVsdEFuaW1hdGlvbjogdGhpcy5nZXRBdHRyaWJ1dGUoJ2FuaW1hdGlvbicpXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IG9uRGV2aWNlQmFja0J1dHRvblxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dQmFjay1idXR0b24gaGFuZGxlci5bL2VuXVxuICAgKiAgIFtqYV3jg5Djg4Pjgq/jg5zjgr/jg7Pjg4/jg7Pjg4njg6njgIJbL2phXVxuICAgKi9cblxuICBfY29tcGlsZSgpIHtcbiAgICB0aGlzLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgdGhpcy5zdHlsZS56SW5kZXggPSAxMDAwMTtcbiAgICB0aGlzLmNsYXNzTGlzdC5hZGQoZGVmYXVsdENsYXNzTmFtZSk7XG5cbiAgICBpZiAoIXV0aWwuZmluZENoaWxkKHRoaXMsICcubW9kYWxfX2NvbnRlbnQnKSkge1xuICAgICAgY29uc3QgY29udGVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgY29udGVudC5jbGFzc0xpc3QuYWRkKCdtb2RhbF9fY29udGVudCcpO1xuXG4gICAgICB3aGlsZSAodGhpcy5jaGlsZE5vZGVzWzBdKSB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLmNoaWxkTm9kZXNbMF07XG4gICAgICAgIHRoaXMucmVtb3ZlQ2hpbGQobm9kZSk7XG4gICAgICAgIGNvbnRlbnQuaW5zZXJ0QmVmb3JlKG5vZGUsIG51bGwpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmFwcGVuZENoaWxkKGNvbnRlbnQpO1xuICAgIH1cblxuICAgIE1vZGlmaWVyVXRpbC5pbml0TW9kaWZpZXIodGhpcywgdGhpcy5fc2NoZW1lKTtcbiAgfVxuXG4gIF90b2dnbGVTdHlsZShzaG91bGRTaG93KSB7XG4gICAgdGhpcy5zdHlsZS5kaXNwbGF5ID0gc2hvdWxkU2hvdyA/ICd0YWJsZScgOiAnbm9uZSc7XG4gIH1cblxuICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICBzdXBlci5jb25uZWN0ZWRDYWxsYmFjaygpO1xuICB9XG5cbiAgZGlzY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgc3VwZXIuZGlzY29ubmVjdGVkQ2FsbGJhY2soKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgdmlzaWJsZVxuICAgKiBAcmVhZG9ubHlcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1XaGV0aGVyIHRoZSBlbGVtZW50IGlzIHZpc2libGUgb3Igbm90LlsvZW5dXG4gICAqICAgW2phXeimgee0oOOBjOimi+OBiOOCi+WgtOWQiOOBq2B0cnVlYOOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAbWV0aG9kIHNob3dcbiAgICogQHNpZ25hdHVyZSBzaG93KFtvcHRpb25zXSlcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiAgIFtlbl1QYXJhbWV0ZXIgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCquODl+OCt+ODp+ODs+OCkuaMh+WumuOBmeOCi+OCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5hbmltYXRpb25dXG4gICAqICAgW2VuXUFuaW1hdGlvbiBuYW1lLiBBdmFpbGFibGUgYW5pbWF0aW9ucyBhcmUgYFwibm9uZVwiYCBhbmQgYFwiZmFkZVwiYC5bL2VuXVxuICAgKiAgIFtqYV3jgqLjg4vjg6Hjg7zjgrfjg6fjg7PlkI3jgpLmjIflrprjgZfjgb7jgZnjgIJcIm5vbmVcIiwgXCJmYWRlXCLjga7jgYTjgZrjgozjgYvjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuYW5pbWF0aW9uT3B0aW9uc11cbiAgICogICBbZW5dU3BlY2lmeSB0aGUgYW5pbWF0aW9uJ3MgZHVyYXRpb24sIGRlbGF5IGFuZCB0aW1pbmcuIEUuZy4gYHtkdXJhdGlvbjogMC4yLCBkZWxheTogMC40LCB0aW1pbmc6ICdlYXNlLWluJ31gLlsvZW5dXG4gICAqICAgW2phXeOCouODi+ODoeODvOOCt+ODp+ODs+aZguOBrmR1cmF0aW9uLCBkZWxheSwgdGltaW5n44KS5oyH5a6a44GX44G+44GZ44CCZS5nLiB7ZHVyYXRpb246IDAuMiwgZGVsYXk6IDAuNCwgdGltaW5nOiAnZWFzZS1pbid9Wy9qYV1cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuY2FsbGJhY2tdXG4gICAqICAgW2VuXVRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIGFmdGVyIHRoZSBtb2RhbCBoYXMgYmVlbiByZXZlYWxlZC5bL2VuXVxuICAgKiAgIFtqYV3jg6Ljg7zjg4Djg6vjgYzooajnpLrjgZXjgozntYLjgo/jgaPjgZ/lvozjgavlkbzjgbPlh7rjgZXjgozjgovplqLmlbDjgqrjg5bjgrjjgqfjgq/jg4jjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dU2hvdyBtb2RhbC5bL2VuXVxuICAgKiAgIFtqYV3jg6Ljg7zjg4Djg6vjgpLooajnpLrjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKiAgIFtlbl1SZXNvbHZlcyB0byB0aGUgZGlzcGxheWVkIGVsZW1lbnRbL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQG1ldGhvZCB0b2dnbGVcbiAgICogQHNpZ25hdHVyZSB0b2dnbGUoW29wdGlvbnNdKVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqICAgW2VuXVBhcmFtZXRlciBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Kq44OX44K344On44Oz44KS5oyH5a6a44GZ44KL44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmFuaW1hdGlvbl1cbiAgICogICBbZW5dQW5pbWF0aW9uIG5hbWUuIEF2YWlsYWJsZSBhbmltYXRpb25zIGFyZSBgXCJub25lXCJgIGFuZCBgXCJmYWRlXCJgLlsvZW5dXG4gICAqICAgW2phXeOCouODi+ODoeODvOOCt+ODp+ODs+WQjeOCkuaMh+WumuOBl+OBvuOBmeOAglwibm9uZVwiLCBcImZhZGVcIuOBruOBhOOBmuOCjOOBi+OCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5hbmltYXRpb25PcHRpb25zXVxuICAgKiAgIFtlbl1TcGVjaWZ5IHRoZSBhbmltYXRpb24ncyBkdXJhdGlvbiwgZGVsYXkgYW5kIHRpbWluZy4gRS5nLiBge2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAwLjQsIHRpbWluZzogJ2Vhc2UtaW4nfWAuWy9lbl1cbiAgICogICBbamFd44Ki44OL44Oh44O844K344On44Oz5pmC44GuZHVyYXRpb24sIGRlbGF5LCB0aW1pbmfjgpLmjIflrprjgZfjgb7jgZnjgIJlLmcuIHtkdXJhdGlvbjogMC4yLCBkZWxheTogMC40LCB0aW1pbmc6ICdlYXNlLWluJ31bL2phXVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5jYWxsYmFja11cbiAgICogICBbZW5dVGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgYWZ0ZXIgdGhlIG1vZGFsIGhhcyBiZWVuIHJldmVhbGVkLlsvZW5dXG4gICAqICAgW2phXeODouODvOODgOODq+OBjOihqOekuuOBleOCjOe1guOCj+OBo+OBn+W+jOOBq+WRvOOBs+WHuuOBleOCjOOCi+mWouaVsOOCquODluOCuOOCp+OCr+ODiOOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1Ub2dnbGUgbW9kYWwgdmlzaWJpbGl0eS5bL2VuXVxuICAgKiAgIFtqYV3jg6Ljg7zjg4Djg6vjga7ooajnpLrjgpLliIfjgormm7/jgYjjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQG1ldGhvZCBoaWRlXG4gICAqIEBzaWduYXR1cmUgaGlkZShbb3B0aW9uc10pXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogICBbZW5dUGFyYW1ldGVyIG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgqrjg5fjgrfjg6fjg7PjgpLmjIflrprjgZnjgovjgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuYW5pbWF0aW9uXVxuICAgKiAgIFtlbl1BbmltYXRpb24gbmFtZS4gQXZhaWxhYmxlIGFuaW1hdGlvbnMgYXJlIGBcIm5vbmVcImAgYW5kIGBcImZhZGVcImAuWy9lbl1cbiAgICogICBbamFd44Ki44OL44Oh44O844K344On44Oz5ZCN44KS5oyH5a6a44GX44G+44GZ44CCXCJub25lXCIsIFwiZmFkZVwi44Gu44GE44Ga44KM44GL44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmFuaW1hdGlvbk9wdGlvbnNdXG4gICAqICAgW2VuXVNwZWNpZnkgdGhlIGFuaW1hdGlvbidzIGR1cmF0aW9uLCBkZWxheSBhbmQgdGltaW5nLiBFLmcuIGB7ZHVyYXRpb246IDAuMiwgZGVsYXk6IDAuNCwgdGltaW5nOiAnZWFzZS1pbid9YC5bL2VuXVxuICAgKiAgIFtqYV3jgqLjg4vjg6Hjg7zjgrfjg6fjg7PmmYLjga5kdXJhdGlvbiwgZGVsYXksIHRpbWluZ+OCkuaMh+WumuOBl+OBvuOBmeOAgmUuZy4ge2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAwLjQsIHRpbWluZzogJ2Vhc2UtaW4nfVsvamFdXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmNhbGxiYWNrXVxuICAgKiAgIFtlbl1UaGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCBhZnRlciB0aGUgbW9kYWwgaGFzIGJlZW4gcmV2ZWFsZWQuWy9lbl1cbiAgICogICBbamFd44Oi44O844OA44Or44GM6KGo56S644GV44KM57WC44KP44Gj44Gf5b6M44Gr5ZG844Gz5Ye644GV44KM44KL6Zai5pWw44Kq44OW44K444Kn44Kv44OI44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUhpZGUgbW9kYWwuWy9lbl1cbiAgICogICBbamFd44Oi44O844OA44Or44KS6Z2e6KGo56S644Gr44GX44G+44GZ44CCWy9qYV1cbiAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICogICBbZW5dUmVzb2x2ZXMgdG8gdGhlIGhpZGRlbiBlbGVtZW50Wy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG5cbiAgc3RhdGljIGdldCBvYnNlcnZlZEF0dHJpYnV0ZXMoKSB7XG4gICAgcmV0dXJuIFsuLi5zdXBlci5vYnNlcnZlZEF0dHJpYnV0ZXMsICdjbGFzcyddO1xuICB9XG5cbiAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIGxhc3QsIGN1cnJlbnQpIHtcbiAgICBpZiAobmFtZSA9PT0gJ2NsYXNzJykge1xuICAgICAgdXRpbC5yZXN0b3JlQ2xhc3ModGhpcywgZGVmYXVsdENsYXNzTmFtZSwgc2NoZW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3VwZXIuYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIGxhc3QsIGN1cnJlbnQpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBBbmltYXRvclxuICAgKi9cbiAgc3RhdGljIHJlZ2lzdGVyQW5pbWF0b3IobmFtZSwgQW5pbWF0b3IpIHtcbiAgICBpZiAoIShBbmltYXRvci5wcm90b3R5cGUgaW5zdGFuY2VvZiBNb2RhbEFuaW1hdG9yKSkge1xuICAgICAgdXRpbC50aHJvd0FuaW1hdG9yKCdNb2RhbCcpO1xuICAgIH1cbiAgICBfYW5pbWF0b3JEaWN0W25hbWVdID0gQW5pbWF0b3I7XG4gIH1cblxuICBzdGF0aWMgZ2V0IGFuaW1hdG9ycygpIHtcbiAgICByZXR1cm4gX2FuaW1hdG9yRGljdDtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgTW9kYWxBbmltYXRvcigpIHtcbiAgICByZXR1cm4gTW9kYWxBbmltYXRvcjtcbiAgfVxufVxuXG5vbnNFbGVtZW50cy5Nb2RhbCA9IE1vZGFsRWxlbWVudDtcbmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnb25zLW1vZGFsJywgTW9kYWxFbGVtZW50KTtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCB1dGlsIGZyb20gJy4uLy4uL29ucy91dGlsJztcbmltcG9ydCBHZXN0dXJlRGV0ZWN0b3IgZnJvbSAnLi4vLi4vb25zL2dlc3R1cmUtZGV0ZWN0b3InO1xuXG5jb25zdCB3aWR0aFRvUHggPSAod2lkdGgpID0+IHtcbiAgY29uc3QgW3ZhbHVlLCBweF0gPSBbcGFyc2VJbnQod2lkdGgsIDEwKSwgL3B4Ly50ZXN0KHdpZHRoKV07XG4gIHJldHVybiBweCA/IHZhbHVlIDogTWF0aC5yb3VuZChkb2N1bWVudC5ib2R5Lm9mZnNldFdpZHRoICogdmFsdWUgLyAxMDApO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU3dpcGVSZXZlYWwge1xuXG4gIGNvbnN0cnVjdG9yKHBhcmFtcykge1xuICAgICdlbGVtZW50IGlnbm9yZVN3aXBlIGlzSW5pdGlhbFN0YXRlIG9uRHJhZ0NhbGxiYWNrIHN3aXBlTWF4IHN3aXBlTWluIHN3aXBlTWlkJ1xuICAgICAgLnNwbGl0KC9cXHMrLykuZm9yRWFjaChrZXkgPT4gdGhpc1trZXldID0gcGFyYW1zW2tleV0pO1xuXG4gICAgdGhpcy5lbGVtZW50SGFuZGxlciA9IHBhcmFtcy5lbGVtZW50SGFuZGxlciB8fCBwYXJhbXMuZWxlbWVudDtcbiAgICB0aGlzLmdldFRocmVzaG9sZCA9IHBhcmFtcy5nZXRUaHJlc2hvbGQgfHwgKCgpID0+IC41KTtcbiAgICB0aGlzLmdldFNpZGUgPSBwYXJhbXMuZ2V0U2lkZSB8fCAoKCkgPT4gJ2xlZnQnKTtcblxuICAgIHRoaXMuaGFuZGxlR2VzdHVyZSA9IHRoaXMuaGFuZGxlR2VzdHVyZS5iaW5kKHRoaXMpO1xuXG4gICAgdGhpcy5fc2hvdWxkRml4U2Nyb2xsID0gdXRpbC5nbG9iYWxzLmFjdHVhbE1vYmlsZU9TID09PSAnaW9zJztcbiAgfVxuXG4gIHVwZGF0ZShzd2lwZWFibGUgPSB0aGlzLmVsZW1lbnQuaGFzQXR0cmlidXRlKCdzd2lwZWFibGUnKSkge1xuICAgIGlmICghdGhpcy5nZXN0dXJlRGV0ZWN0b3IpIHtcbiAgICAgIHRoaXMuZ2VzdHVyZURldGVjdG9yID0gbmV3IEdlc3R1cmVEZXRlY3Rvcih0aGlzLmVsZW1lbnRIYW5kbGVyLCB7IGRyYWdNaW5EaXN0YW5jZTogMSwgcGFzc2l2ZTogIXRoaXMuX3Nob3VsZEZpeFNjcm9sbCB9KTtcbiAgICB9XG5cbiAgICBjb25zdCBhY3Rpb24gPSBzd2lwZWFibGUgPyAnb24nIDogJ29mZic7XG4gICAgdGhpcy5nZXN0dXJlRGV0ZWN0b3JbYWN0aW9uXSgnZHJhZyBkcmFnc3RhcnQgZHJhZ2VuZCcsIHRoaXMuaGFuZGxlR2VzdHVyZSk7XG4gIH1cblxuICBoYW5kbGVHZXN0dXJlKGUpIHtcbiAgICBpZiAoZS5nZXN0dXJlKSB7XG4gICAgICBpZiAoZS50eXBlID09PSAnZHJhZ3N0YXJ0Jykge1xuICAgICAgICB0aGlzLm9uRHJhZ1N0YXJ0KGUpO1xuICAgICAgfSBlbHNlIGlmICghdGhpcy5faWdub3JlRHJhZykge1xuICAgICAgICBlLnR5cGUgPT09ICdkcmFnZW5kJyA/IHRoaXMub25EcmFnRW5kKGUpIDogdGhpcy5vbkRyYWcoZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgb25EcmFnU3RhcnQoZXZlbnQpIHtcbiAgICBjb25zdCBnZXREaXN0YW5jZSA9ICgpID0+IHRoaXMuZ2V0U2lkZSgpID09PSAnbGVmdCcgPyBldmVudC5nZXN0dXJlLmNlbnRlci5jbGllbnRYIDogd2luZG93LmlubmVyV2lkdGggLSBldmVudC5nZXN0dXJlLmNlbnRlci5jbGllbnRYO1xuICAgIHRoaXMuX2lnbm9yZURyYWcgPSBldmVudC5jb25zdW1lZCB8fCAhdXRpbC5pc1ZhbGlkR2VzdHVyZShldmVudCkgfHwgdGhpcy5pZ25vcmVTd2lwZShldmVudCwgZ2V0RGlzdGFuY2UoKSk7XG5cbiAgICBpZiAoIXRoaXMuX2lnbm9yZURyYWcpIHtcbiAgICAgIGV2ZW50LmNvbnN1bWUgJiYgZXZlbnQuY29uc3VtZSgpO1xuICAgICAgZXZlbnQuY29uc3VtZWQgPSB0cnVlO1xuXG4gICAgICB0aGlzLl93aWR0aCA9IHdpZHRoVG9QeCh0aGlzLmVsZW1lbnQuc3R5bGUud2lkdGggfHwgJzEwMCUnKTtcbiAgICAgIHRoaXMuX3N0YXJ0RGlzdGFuY2UgPSB0aGlzLl9kaXN0YW5jZSA9ICghKHRoaXMuaXNJbml0aWFsU3RhdGUgaW5zdGFuY2VvZiBGdW5jdGlvbikgfHwgdGhpcy5pc0luaXRpYWxTdGF0ZSgpKSA/IDAgOiB0aGlzLl93aWR0aDtcblxuICAgICAgdXRpbC5pb3NQcmV2ZW50U2Nyb2xsKHRoaXMuZ2VzdHVyZURldGVjdG9yKTtcbiAgICB9XG4gIH1cblxuICBvbkRyYWcoZXZlbnQpIHtcbiAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblxuICAgIGNvbnN0IGRlbHRhID0gdGhpcy5nZXRTaWRlKCkgPT09ICdsZWZ0JyA/IGV2ZW50Lmdlc3R1cmUuZGVsdGFYIDogLWV2ZW50Lmdlc3R1cmUuZGVsdGFYO1xuICAgIGNvbnN0IGRpc3RhbmNlID0gTWF0aC5tYXgoMCwgTWF0aC5taW4odGhpcy5fd2lkdGgsIHRoaXMuX3N0YXJ0RGlzdGFuY2UgKyBkZWx0YSkpO1xuICAgIGlmIChkaXN0YW5jZSAhPT0gdGhpcy5fZGlzdGFuY2UpIHtcbiAgICAgIHRoaXMuX2Rpc3RhbmNlID0gZGlzdGFuY2U7XG4gICAgICB0aGlzLnN3aXBlTWlkKHRoaXMuX2Rpc3RhbmNlLCB0aGlzLl93aWR0aCk7XG4gICAgfVxuICB9XG5cbiAgb25EcmFnRW5kKGV2ZW50KSB7XG4gICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG5cbiAgICBjb25zdCBkaXJlY3Rpb24gPSBldmVudC5nZXN0dXJlLmludGVyaW1EaXJlY3Rpb247XG4gICAgY29uc3QgaXNTd2lwZU1heCA9IHRoaXMuZ2V0U2lkZSgpICE9PSBkaXJlY3Rpb24gJiYgdGhpcy5fZGlzdGFuY2UgPiB0aGlzLl93aWR0aCAqIHRoaXMuZ2V0VGhyZXNob2xkKCk7XG4gICAgaXNTd2lwZU1heCA/IHRoaXMuc3dpcGVNYXgoKSA6IHRoaXMuc3dpcGVNaW4oKTtcbiAgfVxuXG4gIGRpc3Bvc2UoKSB7XG4gICAgdGhpcy5nZXN0dXJlRGV0ZWN0b3IgJiYgdGhpcy5nZXN0dXJlRGV0ZWN0b3IuZGlzcG9zZSgpO1xuICAgIHRoaXMuZ2VzdHVyZURldGVjdG9yID0gdGhpcy5lbGVtZW50ID0gdGhpcy5lbGVtZW50SGFuZGxlciA9IG51bGw7XG4gIH1cbn1cbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCB1dGlsIGZyb20gJy4uLy4uL29ucy91dGlsJztcbmltcG9ydCBCYXNlQW5pbWF0b3IgZnJvbSAnLi4vLi4vb25zL2Jhc2UtYW5pbWF0b3InXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE5hdmlnYXRvckFuaW1hdG9yIGV4dGVuZHMgQmFzZUFuaW1hdG9yIHtcblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbnMudGltaW5nXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25zLmR1cmF0aW9uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25zLmRlbGF5XG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IHV0aWwuZXh0ZW5kKHtcbiAgICAgIHRpbWluZzogJ2xpbmVhcicsXG4gICAgICBkdXJhdGlvbjogJzAuNCcsXG4gICAgICBkZWxheTogJzAnXG4gICAgfSwgb3B0aW9ucyB8fCB7fSk7XG5cbiAgICBzdXBlcihvcHRpb25zKTtcbiAgfVxuXG4gIHB1c2goZW50ZXJQYWdlLCBsZWF2ZVBhZ2UsIGNhbGxiYWNrKSB7XG4gICAgY2FsbGJhY2soKTtcbiAgfVxuXG4gIHBvcChlbnRlclBhZ2UsIGxlYXZlUGFnZSwgY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjaygpO1xuICB9XG5cbiAgYmxvY2socGFnZSkge1xuICAgIGNvbnN0IGJsb2NrZXIgPSB1dGlsLmNyZWF0ZUVsZW1lbnQoYFxuICAgICAgPGRpdiBzdHlsZT1cInBvc2l0aW9uOiBhYnNvbHV0ZTsgYmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQ7IHdpZHRoOiAxMDAlOyBoZWlnaHQ6IDEwMCU7IHotaW5kZXg6IDEwMDAwMFwiPjwvZGl2PlxuICAgIGApO1xuICAgIHBhZ2UucGFyZW50Tm9kZS5hcHBlbmRDaGlsZChibG9ja2VyKTtcbiAgICByZXR1cm4gKCkgPT4gYmxvY2tlci5yZW1vdmUoKTtcbiAgfVxufVxuXG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgTmF2aWdhdG9yQW5pbWF0b3IgZnJvbSAnLi9hbmltYXRvcic7XG5pbXBvcnQgdXRpbCBmcm9tICcuLi8uLi9vbnMvdXRpbCc7XG5pbXBvcnQgYW5pbWl0IGZyb20gJy4uLy4uL29ucy9hbmltaXQnO1xuXG4vKipcbiAqIEFic3RyYWN0IHN3aXBlIGFuaW1hdG9yIGZvciBpT1MgbmF2aWdhdG9yIHRyYW5zaXRpb24uXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIElPU1N3aXBlTmF2aWdhdG9yQW5pbWF0b3IgZXh0ZW5kcyBOYXZpZ2F0b3JBbmltYXRvciB7XG5cbiAgc3RhdGljIGdldCBzd2lwZWFibGUoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBjb25zdHJ1Y3Rvcih7IGR1cmF0aW9uUmVzdG9yZSA9IDAuMSwgZHVyYXRpb25Td2lwZSA9IDAuMTUsIHRpbWluZ1N3aXBlID0gJ2xpbmVhcicsIC4uLnJlc3QgfSA9IHt9KSB7XG4gICAgc3VwZXIoey4uLnJlc3R9KTtcblxuICAgIGlmICh0aGlzLmNvbnN0cnVjdG9yID09PSBJT1NTd2lwZU5hdmlnYXRvckFuaW1hdG9yKSB7XG4gICAgICB1dGlsLnRocm93QWJzdHJhY3QoKTtcbiAgICB9XG5cbiAgICB0aGlzLmR1cmF0aW9uUmVzdG9yZSA9IGR1cmF0aW9uUmVzdG9yZTtcbiAgICB0aGlzLmR1cmF0aW9uU3dpcGUgPSBkdXJhdGlvblN3aXBlO1xuICAgIHRoaXMudGltaW5nU3dpcGUgPSB0aW1pbmdTd2lwZTtcblxuICAgIHRoaXMub3B0U3dpcGUgPSB7IHRpbWluZzogdGltaW5nU3dpcGUsIGR1cmF0aW9uOiBkdXJhdGlvblN3aXBlIH07XG4gICAgdGhpcy5vcHRSZXN0b3JlID0geyB0aW1pbmc6IHRpbWluZ1N3aXBlLCBkdXJhdGlvbjogZHVyYXRpb25SZXN0b3JlIH07XG5cbiAgICB0aGlzLnN3aXBlU2hhZG93ID0gdXRpbC5jcmVhdGVFbGVtZW50KFxuICAgICAgYDxkaXYgc3R5bGU9XCJwb3NpdGlvbjogYWJzb2x1dGU7IGhlaWdodDogMTAwJTsgd2lkdGg6IDEycHg7IHJpZ2h0OiAxMDAlOyB0b3A6IDA7IGJvdHRvbTogMDsgei1pbmRleDogLTE7YCArXG4gICAgICAgIGBiYWNrZ3JvdW5kOiBsaW5lYXItZ3JhZGllbnQodG8gcmlnaHQsIHRyYW5zcGFyZW50IDAsIHJnYmEoMCwwLDAsLjA0KSA0MCUsIHJnYmEoMCwwLDAsLjEyKSA4MCUsIHJnYmEoMCwwLDAsLjE2KSAxMDAlKTtcIj48L2Rpdj5gXG4gICAgKTtcblxuICAgIHRoaXMuaXNEcmFnU3RhcnQgPSB0cnVlO1xuICB9XG5cbiAgX2RlY29tcG9zZSgpIHtcbiAgICB1dGlsLnRocm93TWVtYmVyKCk7XG4gIH1cblxuICBfc2hvdWxkQW5pbWF0ZVRvb2xiYXIoKSB7XG4gICAgdXRpbC50aHJvd01lbWJlcigpO1xuICB9XG5cbiAgX2NhbGN1bGF0ZURlbHRhKCkge1xuICAgIHV0aWwudGhyb3dNZW1iZXIoKTtcbiAgfVxuXG4gIF9kcmFnU3RhcnRTZXR1cChlbnRlclBhZ2UsIGxlYXZlUGFnZSkge1xuICAgIHRoaXMuaXNEcmFnU3RhcnQgPSBmYWxzZTtcblxuICAgIC8vIEF2b2lkIGNvbnRlbnQgY2xpY2tzXG4gICAgdGhpcy51bmJsb2NrID0gc3VwZXIuYmxvY2sobGVhdmVQYWdlKTtcblxuICAgIC8vIE1hc2tcbiAgICBlbnRlclBhZ2UucGFyZW50RWxlbWVudC5pbnNlcnRCZWZvcmUodGhpcy5iYWNrZ3JvdW5kTWFzaywgZW50ZXJQYWdlKTtcblxuICAgIC8vIERlY29tcG9zaXRpb25cbiAgICB0aGlzLnRhcmdldCA9IHtcbiAgICAgIGVudGVyOiB1dGlsLmZpbmRUb29sYmFyUGFnZShlbnRlclBhZ2UpIHx8IGVudGVyUGFnZSxcbiAgICAgIGxlYXZlOiB1dGlsLmZpbmRUb29sYmFyUGFnZShsZWF2ZVBhZ2UpIHx8IGxlYXZlUGFnZSxcbiAgICB9O1xuICAgIHRoaXMuZGVjb21wID0ge1xuICAgICAgZW50ZXI6IHRoaXMuX2RlY29tcG9zZSh0aGlzLnRhcmdldC5lbnRlciksXG4gICAgICBsZWF2ZTogdGhpcy5fZGVjb21wb3NlKHRoaXMudGFyZ2V0LmxlYXZlKVxuICAgIH07XG5cbiAgICAvLyBBbmltYXRpb24gdmFsdWVzXG4gICAgdGhpcy5kZWx0YSA9IHRoaXMuX2NhbGN1bGF0ZURlbHRhKGxlYXZlUGFnZSwgdGhpcy5kZWNvbXAubGVhdmUpO1xuICAgIHRoaXMuc2hvdWxkQW5pbWF0ZVRvb2xiYXIgPSB0aGlzLl9zaG91bGRBbmltYXRlVG9vbGJhcih0aGlzLnRhcmdldC5lbnRlciwgdGhpcy50YXJnZXQubGVhdmUpO1xuXG4gICAgLy8gU2hhZG93ICYmIHN0eWxlc1xuICAgIGlmICh0aGlzLnNob3VsZEFuaW1hdGVUb29sYmFyKSB7XG4gICAgICB0aGlzLnN3aXBlU2hhZG93LnN0eWxlLnRvcCA9IHRoaXMuZGVjb21wLmxlYXZlLnRvb2xiYXIub2Zmc2V0SGVpZ2h0ICsgJ3B4JztcbiAgICAgIHRoaXMudGFyZ2V0LmxlYXZlLmFwcGVuZENoaWxkKHRoaXMuc3dpcGVTaGFkb3cpO1xuICAgICAgdGhpcy5fc2F2ZVN0eWxlKHRoaXMudGFyZ2V0LmVudGVyLCB0aGlzLnRhcmdldC5sZWF2ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxlYXZlUGFnZS5hcHBlbmRDaGlsZCh0aGlzLnN3aXBlU2hhZG93KTtcbiAgICAgIHRoaXMuX3NhdmVTdHlsZShlbnRlclBhZ2UsIGxlYXZlUGFnZSk7XG4gICAgfVxuICAgIGxlYXZlUGFnZS5jbGFzc0xpc3QuYWRkKCdvdmVyZmxvdy12aXNpYmxlJyk7XG4gICAgdGhpcy5vdmVyZmxvd0VsZW1lbnQgPSBsZWF2ZVBhZ2U7XG4gICAgdGhpcy5kZWNvbXAubGVhdmUuY29udGVudC5jbGFzc0xpc3QuYWRkKCdjb250ZW50LXN3aXBpbmcnKTtcblxuICB9XG5cbiAgdHJhbnNsYXRlKGRpc3RhbmNlLCBtYXhXaWR0aCwgZW50ZXJQYWdlLCBsZWF2ZVBhZ2UpIHtcbiAgICB0aGlzLmlzU3dpcGluZyA9IHRydWU7XG5cbiAgICBpZiAoZW50ZXJQYWdlLnN0eWxlLmRpc3BsYXkgPT09ICdub25lJykge1xuICAgICAgZW50ZXJQYWdlLnN0eWxlLmRpc3BsYXkgPSAnJztcbiAgICB9XG5cbiAgICBpZiAodGhpcy5pc0RyYWdTdGFydCkge1xuICAgICAgdGhpcy5tYXhXaWR0aCA9IG1heFdpZHRoO1xuICAgICAgdGhpcy5fZHJhZ1N0YXJ0U2V0dXAoZW50ZXJQYWdlLCBsZWF2ZVBhZ2UpO1xuICAgIH1cblxuICAgIGNvbnN0IHN3aXBlUmF0aW8gPSAoZGlzdGFuY2UgLSBtYXhXaWR0aCkgLyBtYXhXaWR0aDtcblxuICAgIGlmICh0aGlzLnNob3VsZEFuaW1hdGVUb29sYmFyKSB7XG5cbiAgICAgIGFuaW1pdC5ydW5BbGwoXG5cbiAgICAgICAgLyogRW50ZXIgcGFnZSAqL1xuXG4gICAgICAgIGFuaW1pdChbdGhpcy5kZWNvbXAuZW50ZXIuY29udGVudCwgdGhpcy5kZWNvbXAuZW50ZXIuYm90dG9tVG9vbGJhciwgdGhpcy5kZWNvbXAuZW50ZXIuYmFja2dyb3VuZF0pXG4gICAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogYHRyYW5zbGF0ZTNkKCR7c3dpcGVSYXRpbyAqIDI1fSUsIDAsIDApYCxcbiAgICAgICAgICAgIG9wYWNpdHk6IDEgKyBzd2lwZVJhdGlvICogMTAgLyAxMDAgLy8gMC45IC0+IDFcbiAgICAgICAgICB9KSxcblxuICAgICAgICBhbmltaXQodGhpcy5kZWNvbXAuZW50ZXIudG9vbGJhckNlbnRlcilcbiAgICAgICAgICAucXVldWUoe1xuICAgICAgICAgICAgdHJhbnNmb3JtOiBgdHJhbnNsYXRlM2QoJHt0aGlzLmRlbHRhLnRpdGxlICogc3dpcGVSYXRpb31weCwgMCwgMClgLFxuICAgICAgICAgICAgb3BhY2l0eTogMSArIHN3aXBlUmF0aW8gLy8gMCAtPiAxXG4gICAgICAgICAgfSksXG5cbiAgICAgICAgYW5pbWl0KHRoaXMuZGVjb21wLmVudGVyLmJhY2tCdXR0b25MYWJlbClcbiAgICAgICAgICAucXVldWUoe1xuICAgICAgICAgICAgb3BhY2l0eTogMSArIHN3aXBlUmF0aW8gKiAxMCAvIDEwMCwgLy8gMC45IC0+IDFcbiAgICAgICAgICAgIHRyYW5zZm9ybTogYHRyYW5zbGF0ZTNkKCR7dGhpcy5kZWx0YS5sYWJlbCAqIHN3aXBlUmF0aW99cHgsIDAsIDApYFxuICAgICAgICAgIH0pLFxuXG4gICAgICAgIGFuaW1pdCh0aGlzLmRlY29tcC5lbnRlci5vdGhlcilcbiAgICAgICAgICAucXVldWUoe1xuICAgICAgICAgICAgb3BhY2l0eTogMSArIHN3aXBlUmF0aW8gLy8gMCAtPiAxXG4gICAgICAgICAgfSksXG5cbiAgICAgICAgLyogTGVhdmUgcGFnZSAqL1xuXG4gICAgICAgIGFuaW1pdChbdGhpcy5kZWNvbXAubGVhdmUuY29udGVudCwgdGhpcy5kZWNvbXAubGVhdmUuYm90dG9tVG9vbGJhciwgdGhpcy5kZWNvbXAubGVhdmUuYmFja2dyb3VuZCwgdGhpcy5zd2lwZVNoYWRvd10pXG4gICAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogYHRyYW5zbGF0ZTNkKCR7ZGlzdGFuY2V9cHgsIDAsIDApYFxuICAgICAgICAgIH0pLFxuXG4gICAgICAgIGFuaW1pdCh0aGlzLmRlY29tcC5sZWF2ZS50b29sYmFyKVxuICAgICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgICBvcGFjaXR5OiAtMSAqIHN3aXBlUmF0aW8gLy8gMSAtPiAwXG4gICAgICAgICAgfSksXG5cbiAgICAgICAgYW5pbWl0KHRoaXMuZGVjb21wLmxlYXZlLnRvb2xiYXJDZW50ZXIpXG4gICAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogYHRyYW5zbGF0ZTNkKCR7KDEgKyBzd2lwZVJhdGlvKSAqIDEyNX0lLCAwLCAwKWBcbiAgICAgICAgICB9KSxcblxuICAgICAgICBhbmltaXQodGhpcy5kZWNvbXAubGVhdmUuYmFja0J1dHRvbkxhYmVsKVxuICAgICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgICBvcGFjaXR5OiAtMSAqIHN3aXBlUmF0aW8sIC8vIDEgLT4gMFxuICAgICAgICAgICAgdHJhbnNmb3JtOiBgdHJhbnNsYXRlM2QoJHt0aGlzLmRlbHRhLnRpdGxlICogKDEgKyBzd2lwZVJhdGlvKX1weCwgMCwgMClgXG4gICAgICAgICAgfSksXG5cblxuICAgICAgICAvKiBPdGhlciAqL1xuXG4gICAgICAgIGFuaW1pdCh0aGlzLnN3aXBlU2hhZG93KVxuICAgICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgICBvcGFjaXR5OiAtMSAqIHN3aXBlUmF0aW8gLy8gMSAtPiAwXG4gICAgICAgICAgfSlcbiAgICAgICk7XG5cblxuICAgIH0gZWxzZSB7XG4gICAgICBhbmltaXQucnVuQWxsKFxuICAgICAgICBhbmltaXQobGVhdmVQYWdlKVxuICAgICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgICB0cmFuc2Zvcm06IGB0cmFuc2xhdGUzZCgke2Rpc3RhbmNlfXB4LCAwLCAwKWBcbiAgICAgICAgICB9KSxcblxuICAgICAgICBhbmltaXQoZW50ZXJQYWdlKVxuICAgICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgICB0cmFuc2Zvcm06IGB0cmFuc2xhdGUzZCgke3N3aXBlUmF0aW8gKiAyNX0lLCAwLCAwKWAsXG4gICAgICAgICAgICBvcGFjaXR5OiAxICsgc3dpcGVSYXRpbyAqIDEwIC8gMTAwIC8vIDAuOSAtPiAxXG4gICAgICAgICAgfSksXG5cbiAgICAgICAgYW5pbWl0KHRoaXMuc3dpcGVTaGFkb3cpXG4gICAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICAgIG9wYWNpdHk6IC0xICogc3dpcGVSYXRpbyAvLyAxIC0+IDBcbiAgICAgICAgICB9KVxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICByZXN0b3JlKGVudGVyUGFnZSwgbGVhdmVQYWdlLCBjYWxsYmFjaykge1xuICAgIGlmICh0aGlzLmlzRHJhZ1N0YXJ0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuc2hvdWxkQW5pbWF0ZVRvb2xiYXIpIHtcblxuICAgICAgYW5pbWl0LnJ1bkFsbChcblxuICAgICAgICAvKiBFbnRlciBwYWdlICovXG5cbiAgICAgICAgYW5pbWl0KFt0aGlzLmRlY29tcC5lbnRlci5jb250ZW50LCB0aGlzLmRlY29tcC5lbnRlci5ib3R0b21Ub29sYmFyLCB0aGlzLmRlY29tcC5lbnRlci5iYWNrZ3JvdW5kXSlcbiAgICAgICAgICAucXVldWUoe1xuICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoLTI1JSwgMCwgMCknLFxuICAgICAgICAgICAgb3BhY2l0eTogMC45XG4gICAgICAgICAgfSwgdGhpcy5vcHRSZXN0b3JlKSxcblxuICAgICAgICBhbmltaXQodGhpcy5kZWNvbXAuZW50ZXIudG9vbGJhckNlbnRlcilcbiAgICAgICAgICAucXVldWUoe1xuICAgICAgICAgICAgdHJhbnNmb3JtOiBgdHJhbnNsYXRlM2QoLSR7dGhpcy5kZWx0YS50aXRsZX1weCwgMCwgMClgLFxuICAgICAgICAgICAgdHJhbnNpdGlvbjogYG9wYWNpdHkgJHt0aGlzLmR1cmF0aW9uUmVzdG9yZX1zIGxpbmVhciwgdHJhbnNmb3JtICR7dGhpcy5kdXJhdGlvblJlc3RvcmV9cyAke3RoaXMudGltaW5nU3dpcGV9YCxcbiAgICAgICAgICAgIG9wYWNpdHk6IDBcbiAgICAgICAgICB9KSxcblxuICAgICAgICBhbmltaXQodGhpcy5kZWNvbXAuZW50ZXIuYmFja0J1dHRvbkxhYmVsKVxuICAgICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgICB0cmFuc2Zvcm06IGB0cmFuc2xhdGUzZCgtJHt0aGlzLmRlbHRhLmxhYmVsfXB4LCAwLCAwKWBcbiAgICAgICAgICB9LCB0aGlzLm9wdFJlc3RvcmUpLFxuXG4gICAgICAgIGFuaW1pdCh0aGlzLmRlY29tcC5lbnRlci5vdGhlcilcbiAgICAgICAgICAucXVldWUoe1xuICAgICAgICAgICAgb3BhY2l0eTogMFxuICAgICAgICAgIH0sIHRoaXMub3B0UmVzdG9yZSksXG5cbiAgICAgICAgLyogTGVhdmUgcGFnZSAqL1xuXG4gICAgICAgIGFuaW1pdChbdGhpcy5kZWNvbXAubGVhdmUuY29udGVudCwgdGhpcy5kZWNvbXAubGVhdmUuYm90dG9tVG9vbGJhciwgdGhpcy5kZWNvbXAubGVhdmUuYmFja2dyb3VuZCwgdGhpcy5zd2lwZVNoYWRvd10pXG4gICAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogYHRyYW5zbGF0ZTNkKDAsIDAsIDApYFxuICAgICAgICAgIH0sIHRoaXMub3B0UmVzdG9yZSksXG5cbiAgICAgICAgYW5pbWl0KHRoaXMuZGVjb21wLmxlYXZlLnRvb2xiYXIpXG4gICAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICAgIG9wYWNpdHk6IDFcbiAgICAgICAgICB9LCB0aGlzLm9wdFJlc3RvcmUpLFxuXG4gICAgICAgIGFuaW1pdCh0aGlzLmRlY29tcC5sZWF2ZS50b29sYmFyQ2VudGVyKVxuICAgICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgICB0cmFuc2Zvcm06IGB0cmFuc2xhdGUzZCgwLCAwLCAwKWBcbiAgICAgICAgICB9LCB0aGlzLm9wdFJlc3RvcmUpLFxuXG4gICAgICAgIGFuaW1pdCh0aGlzLmRlY29tcC5sZWF2ZS5iYWNrQnV0dG9uTGFiZWwpXG4gICAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICAgIG9wYWNpdHk6IDEsXG4gICAgICAgICAgICB0cmFuc2Zvcm06IGB0cmFuc2xhdGUzZCgwLCAwLCAwKWAsXG4gICAgICAgICAgICB0cmFuc2l0aW9uOiBgb3BhY2l0eSAke3RoaXMuZHVyYXRpb25SZXN0b3JlfXMgbGluZWFyLCB0cmFuc2Zvcm0gJHt0aGlzLmR1cmF0aW9uUmVzdG9yZX1zICR7dGhpcy50aW1pbmdTd2lwZX1gXG4gICAgICAgICAgfSksXG5cblxuICAgICAgICAvKiBPdGhlciAqL1xuXG4gICAgICAgIGFuaW1pdCh0aGlzLnN3aXBlU2hhZG93KVxuICAgICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgICBvcGFjaXR5OiAwXG4gICAgICAgICAgfSwgdGhpcy5vcHRSZXN0b3JlKVxuICAgICAgICAgIC5xdWV1ZShkb25lID0+IHtcbiAgICAgICAgICAgIHRoaXMuX3Jlc2V0KHRoaXMudGFyZ2V0LmVudGVyLCB0aGlzLnRhcmdldC5sZWF2ZSk7XG4gICAgICAgICAgICBlbnRlclBhZ2Uuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICBkb25lKCk7XG4gICAgICAgICAgfSlcbiAgICAgICk7XG5cblxuICAgIH0gZWxzZSB7XG4gICAgICBhbmltaXQucnVuQWxsKFxuXG4gICAgICAgIGFuaW1pdChlbnRlclBhZ2UpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM0QoLTI1JSwgMCwgMCknLFxuICAgICAgICAgIG9wYWNpdHk6IDAuOVxuICAgICAgICB9LCB0aGlzLm9wdFJlc3RvcmUpLFxuXG4gICAgICAgIGFuaW1pdChsZWF2ZVBhZ2UpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM0QoMCwgMCwgMCknXG4gICAgICAgIH0sIHRoaXMub3B0UmVzdG9yZSlcbiAgICAgICAgLnF1ZXVlKGRvbmUgPT4ge1xuICAgICAgICAgIHRoaXMuX3Jlc2V0KGVudGVyUGFnZSwgbGVhdmVQYWdlKTtcbiAgICAgICAgICBlbnRlclBhZ2Uuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjaygpO1xuICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgcG9wU3dpcGUoZW50ZXJQYWdlLCBsZWF2ZVBhZ2UsIGNhbGxiYWNrKSB7XG4gICAgaWYgKHRoaXMuaXNEcmFnU3RhcnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5zaG91bGRBbmltYXRlVG9vbGJhcikge1xuXG4gICAgICBhbmltaXQucnVuQWxsKFxuXG4gICAgICAgIC8qIEVudGVyIHBhZ2UgKi9cblxuICAgICAgICBhbmltaXQoW3RoaXMuZGVjb21wLmVudGVyLmNvbnRlbnQsIHRoaXMuZGVjb21wLmVudGVyLmJvdHRvbVRvb2xiYXIsIHRoaXMuZGVjb21wLmVudGVyLmJhY2tncm91bmRdKVxuICAgICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzZCgwLCAwLCAwKScsXG4gICAgICAgICAgICBvcGFjaXR5OiAxXG4gICAgICAgICAgfSwgdGhpcy5vcHRTd2lwZSksXG5cbiAgICAgICAgYW5pbWl0KHRoaXMuZGVjb21wLmVudGVyLnRvb2xiYXJDZW50ZXIpXG4gICAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogYHRyYW5zbGF0ZTNkKDAsIDAsIDApYCxcbiAgICAgICAgICAgIHRyYW5zaXRpb246IGBvcGFjaXR5ICR7dGhpcy5kdXJhdGlvblN3aXBlfXMgbGluZWFyLCB0cmFuc2Zvcm0gJHt0aGlzLmR1cmF0aW9uU3dpcGV9cyAke3RoaXMudGltaW5nU3dpcGV9YCxcbiAgICAgICAgICAgIG9wYWNpdHk6IDFcbiAgICAgICAgICB9KSxcblxuICAgICAgICBhbmltaXQodGhpcy5kZWNvbXAuZW50ZXIuYmFja0J1dHRvbkxhYmVsKVxuICAgICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgICB0cmFuc2Zvcm06IGB0cmFuc2xhdGUzZCgwLCAwLCAwKWBcbiAgICAgICAgICB9LCB0aGlzLm9wdFN3aXBlKSxcblxuICAgICAgICBhbmltaXQodGhpcy5kZWNvbXAuZW50ZXIub3RoZXIpXG4gICAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICAgIG9wYWNpdHk6IDFcbiAgICAgICAgICB9LCB0aGlzLm9wdFN3aXBlKSxcblxuICAgICAgICAvKiBMZWF2ZSBwYWdlICovXG5cbiAgICAgICAgYW5pbWl0KFt0aGlzLmRlY29tcC5sZWF2ZS5jb250ZW50LCB0aGlzLmRlY29tcC5sZWF2ZS5ib3R0b21Ub29sYmFyLCB0aGlzLmRlY29tcC5sZWF2ZS5iYWNrZ3JvdW5kXSlcbiAgICAgICAgICAucXVldWUoe1xuICAgICAgICAgICAgdHJhbnNmb3JtOiBgdHJhbnNsYXRlM2QoMTAwJSwgMCwgMClgXG4gICAgICAgICAgfSwgdGhpcy5vcHRTd2lwZSksXG5cbiAgICAgICAgYW5pbWl0KHRoaXMuZGVjb21wLmxlYXZlLnRvb2xiYXIpXG4gICAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICAgIG9wYWNpdHk6IDBcbiAgICAgICAgICB9LCB0aGlzLm9wdFN3aXBlKSxcblxuICAgICAgICBhbmltaXQodGhpcy5kZWNvbXAubGVhdmUudG9vbGJhckNlbnRlcilcbiAgICAgICAgICAucXVldWUoe1xuICAgICAgICAgICAgdHJhbnNmb3JtOiBgdHJhbnNsYXRlM2QoMTI1JSwgMCwgMClgXG4gICAgICAgICAgfSwgdGhpcy5vcHRTd2lwZSksXG5cbiAgICAgICAgYW5pbWl0KHRoaXMuZGVjb21wLmxlYXZlLmJhY2tCdXR0b25MYWJlbClcbiAgICAgICAgICAucXVldWUoe1xuICAgICAgICAgICAgb3BhY2l0eTogMCxcbiAgICAgICAgICAgIHRyYW5zZm9ybTogYHRyYW5zbGF0ZTNkKCR7dGhpcy5kZWx0YS50aXRsZX1weCwgMCwgMClgLFxuICAgICAgICAgICAgdHJhbnNpdGlvbjogYG9wYWNpdHkgJHt0aGlzLmR1cmF0aW9uU3dpcGV9cyBsaW5lYXIsIHRyYW5zZm9ybSAke3RoaXMuZHVyYXRpb25Td2lwZX1zICR7dGhpcy50aW1pbmdTd2lwZX1gXG4gICAgICAgICAgfSksXG5cblxuICAgICAgICAvKiBPdGhlciAqL1xuXG4gICAgICAgIGFuaW1pdCh0aGlzLnN3aXBlU2hhZG93KVxuICAgICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgICBvcGFjaXR5OiAwLFxuICAgICAgICAgICAgdHJhbnNmb3JtOiBgdHJhbnNsYXRlM2QoJHt0aGlzLm1heFdpZHRofXB4LCAwLCAwKWBcbiAgICAgICAgICB9LCB0aGlzLm9wdFN3aXBlKVxuICAgICAgICAgIC5xdWV1ZShkb25lID0+IHtcbiAgICAgICAgICAgIHRoaXMuX3Jlc2V0KHRoaXMudGFyZ2V0LmVudGVyLCB0aGlzLnRhcmdldC5sZWF2ZSk7XG4gICAgICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjaygpO1xuICAgICAgICAgICAgZG9uZSgpO1xuICAgICAgICAgIH0pXG4gICAgICApO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgIGFuaW1pdC5ydW5BbGwoXG5cbiAgICAgICAgYW5pbWl0KGVudGVyUGFnZSlcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgwLCAwLCAwKScsXG4gICAgICAgICAgb3BhY2l0eTogMS4wXG4gICAgICAgIH0sIHRoaXMub3B0U3dpcGUpLFxuXG4gICAgICAgIGFuaW1pdChsZWF2ZVBhZ2UpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM0QoMTAwJSwgMCwgMCknXG4gICAgICAgIH0sIHRoaXMub3B0U3dpcGUpXG4gICAgICAgIC5xdWV1ZShkb25lID0+IHtcbiAgICAgICAgICB0aGlzLl9yZXNldChlbnRlclBhZ2UsIGxlYXZlUGFnZSk7XG4gICAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soKTtcbiAgICAgICAgICBkb25lKCk7XG4gICAgICAgIH0pXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIF9zYXZlU3R5bGUoLi4uYXJncykge1xuICAgIHRoaXMuX3NhdmVkU3R5bGUgPSBuZXcgV2Vha01hcCgpO1xuICAgIGNvbnN0IHNhdmUgPSBlbCA9PiB0aGlzLl9zYXZlZFN0eWxlLnNldChlbCwgZWwuZ2V0QXR0cmlidXRlKCdzdHlsZScpKTtcbiAgICBhcmdzLmZvckVhY2goc2F2ZSk7XG5cbiAgICBPYmplY3Qua2V5cyh0aGlzLmRlY29tcCkuZm9yRWFjaChwID0+IHtcbiAgICAgIE9iamVjdC5rZXlzKHRoaXMuZGVjb21wW3BdKS5mb3JFYWNoKGsgPT4ge1xuICAgICAgICAodGhpcy5kZWNvbXBbcF1ba10gaW5zdGFuY2VvZiBBcnJheSA/IHRoaXMuZGVjb21wW3BdW2tdIDogW3RoaXMuZGVjb21wW3BdW2tdXSkuZm9yRWFjaChzYXZlKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgX3Jlc3RvcmVTdHlsZSguLi5hcmdzKSB7XG4gICAgY29uc3QgcmVzdG9yZSA9IGVsID0+IHtcbiAgICAgIHRoaXMuX3NhdmVkU3R5bGUuZ2V0KGVsKSA9PT0gbnVsbCA/IGVsLnJlbW92ZUF0dHJpYnV0ZSgnc3R5bGUnKSA6IGVsLnNldEF0dHJpYnV0ZSgnc3R5bGUnLCB0aGlzLl9zYXZlZFN0eWxlLmdldChlbCkpXG4gICAgICB0aGlzLl9zYXZlZFN0eWxlLmRlbGV0ZShlbClcbiAgICB9O1xuICAgIGFyZ3MuZm9yRWFjaChyZXN0b3JlKTtcblxuICAgIE9iamVjdC5rZXlzKHRoaXMuZGVjb21wKS5mb3JFYWNoKHAgPT4ge1xuICAgICAgT2JqZWN0LmtleXModGhpcy5kZWNvbXBbcF0pLmZvckVhY2goayA9PiB7XG4gICAgICAgICh0aGlzLmRlY29tcFtwXVtrXSBpbnN0YW5jZW9mIEFycmF5ID8gdGhpcy5kZWNvbXBbcF1ba10gOiBbdGhpcy5kZWNvbXBbcF1ba11dKS5mb3JFYWNoKHJlc3RvcmUpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICBfcmVzZXQoLi4uYXJncykge1xuICAgIHRoaXMuaXNTd2lwaW5nID0gZmFsc2U7XG4gICAgdGhpcy5fc2F2ZWRTdHlsZSAmJiB0aGlzLl9yZXN0b3JlU3R5bGUoLi4uYXJncyk7XG4gICAgdGhpcy51bmJsb2NrICYmIHRoaXMudW5ibG9jaygpO1xuICAgIHRoaXMuc3dpcGVTaGFkb3cucmVtb3ZlKCk7XG4gICAgdGhpcy5iYWNrZ3JvdW5kTWFzay5yZW1vdmUoKTtcbiAgICB0aGlzLm92ZXJmbG93RWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKCdvdmVyZmxvdy12aXNpYmxlJyk7XG4gICAgdGhpcy5kZWNvbXAubGVhdmUuY29udGVudC5jbGFzc0xpc3QucmVtb3ZlKCdjb250ZW50LXN3aXBpbmcnKTtcbiAgICB0aGlzLmRlY29tcCA9IHRoaXMudGFyZ2V0ID0gdGhpcy5vdmVyZmxvd0VsZW1lbnQgPSB0aGlzLl9zYXZlZFN0eWxlID0gbnVsbDtcbiAgICB0aGlzLmlzRHJhZ1N0YXJ0ID0gdHJ1ZTtcbiAgfVxufVxuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IElPU1N3aXBlTmF2aWdhdG9yQW5pbWF0b3IgZnJvbSAnLi9pb3Mtc3dpcGUtYW5pbWF0b3InO1xuaW1wb3J0IHV0aWwgZnJvbSAnLi4vLi4vb25zL3V0aWwnO1xuaW1wb3J0IGFuaW1pdCBmcm9tICcuLi8uLi9vbnMvYW5pbWl0JztcbmltcG9ydCBjb250ZW50UmVhZHkgZnJvbSAnLi4vLi4vb25zL2NvbnRlbnQtcmVhZHknO1xuXG5jb25zdCB0cmFuc2xhdGUzZCA9ICh4ID0gMCwgeSA9IDAsIHogPSAwKSA9PiBgdHJhbnNsYXRlM2QoJHt4fSwgJHt5fSwgJHt6fSlgO1xuXG4vKipcbiAqIFNsaWRlIGFuaW1hdG9yIGZvciBuYXZpZ2F0b3IgdHJhbnNpdGlvbiBsaWtlIGlPUydzIHNjcmVlbiBzbGlkZSB0cmFuc2l0aW9uLlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBJT1NTbGlkZU5hdmlnYXRvckFuaW1hdG9yIGV4dGVuZHMgSU9TU3dpcGVOYXZpZ2F0b3JBbmltYXRvciB7XG5cbiAgY29uc3RydWN0b3IoeyB0aW1pbmcgPSAnY3ViaWMtYmV6aWVyKDAuMywgLjQsIDAsIC45KScsIGRlbGF5ID0gMCwgZHVyYXRpb24gPSAwLjQsIC4uLnJlc3QgfSA9IHt9KSB7XG4gICAgc3VwZXIoeyB0aW1pbmcsIGRlbGF5LCBkdXJhdGlvbiwgLi4ucmVzdCB9KTtcblxuICAgIHRoaXMuYmFja2dyb3VuZE1hc2sgPSB1dGlsLmNyZWF0ZUVsZW1lbnQoXG4gICAgICBgPGRpdiBzdHlsZT1cInBvc2l0aW9uOiBhYnNvbHV0ZTsgd2lkdGg6IDEwMCU7IGhlaWdodDogMTAwJTtgICtcbiAgICAgICAgYGJhY2tncm91bmQtY29sb3I6IGJsYWNrOyB6LWluZGV4OiAyXCI+PC9kaXY+YFxuICAgICk7XG4gIH1cblxuICBfZGVjb21wb3NlKHBhZ2UpIHtcbiAgICBjb25zdCB0b29sYmFyID0gcGFnZS5fZ2V0VG9vbGJhckVsZW1lbnQoKTtcbiAgICBjb25zdCBsZWZ0ID0gdG9vbGJhci5fZ2V0VG9vbGJhckxlZnRJdGVtc0VsZW1lbnQoKTtcbiAgICBjb25zdCByaWdodCA9IHRvb2xiYXIuX2dldFRvb2xiYXJSaWdodEl0ZW1zRWxlbWVudCgpO1xuXG4gICAgY29uc3QgZXhjbHVkZUJhY2tCdXR0b24gPSBmdW5jdGlvbihlbGVtZW50cykge1xuICAgICAgY29uc3QgcmVzdWx0ID0gW107XG5cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZWxlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGVsZW1lbnRzW2ldLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgIT09ICdvbnMtYmFjay1idXR0b24nKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2goZWxlbWVudHNbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcblxuICAgIGNvbnN0IG90aGVyID0gW11cbiAgICAgIC5jb25jYXQobGVmdC5jaGlsZHJlbi5sZW5ndGggPT09IDAgPyBsZWZ0IDogZXhjbHVkZUJhY2tCdXR0b24obGVmdC5jaGlsZHJlbikpXG4gICAgICAuY29uY2F0KHJpZ2h0LmNoaWxkcmVuLmxlbmd0aCA9PT0gMCA/IHJpZ2h0IDogZXhjbHVkZUJhY2tCdXR0b24ocmlnaHQuY2hpbGRyZW4pKTtcblxuICAgIHJldHVybiB7XG4gICAgICB0b29sYmFyQ2VudGVyOiB0b29sYmFyLl9nZXRUb29sYmFyQ2VudGVySXRlbXNFbGVtZW50KCksXG4gICAgICBiYWNrQnV0dG9uSWNvbjogdG9vbGJhci5fZ2V0VG9vbGJhckJhY2tCdXR0b25JY29uRWxlbWVudCgpLFxuICAgICAgYmFja0J1dHRvbkxhYmVsOiB0b29sYmFyLl9nZXRUb29sYmFyQmFja0J1dHRvbkxhYmVsRWxlbWVudCgpLFxuICAgICAgb3RoZXI6IG90aGVyLFxuICAgICAgY29udGVudDogcGFnZS5fZ2V0Q29udGVudEVsZW1lbnQoKSxcbiAgICAgIGJhY2tncm91bmQ6IHBhZ2UuX2dldEJhY2tncm91bmRFbGVtZW50KCksXG4gICAgICB0b29sYmFyOiB0b29sYmFyLFxuICAgICAgYm90dG9tVG9vbGJhcjogcGFnZS5fZ2V0Qm90dG9tVG9vbGJhckVsZW1lbnQoKVxuICAgIH07XG4gIH1cblxuICBfc2hvdWxkQW5pbWF0ZVRvb2xiYXIoZW50ZXJQYWdlLCBsZWF2ZVBhZ2UpIHtcbiAgICBjb25zdCB0b29sYmFycyA9IGVudGVyUGFnZS5fY2FuQW5pbWF0ZVRvb2xiYXIoKSAmJiBsZWF2ZVBhZ2UuX2NhbkFuaW1hdGVUb29sYmFyKCk7XG5cbiAgICBjb25zdCBlbnRlclRvb2xiYXIgPSBlbnRlclBhZ2UuX2dldFRvb2xiYXJFbGVtZW50KCk7XG4gICAgY29uc3QgbGVhdmVUb29sYmFyID0gbGVhdmVQYWdlLl9nZXRUb29sYmFyRWxlbWVudCgpO1xuXG4gICAgY29uc3QgaXNTdGF0aWMgPSBlbnRlclRvb2xiYXIuaGFzQXR0cmlidXRlKCdzdGF0aWMnKSB8fCBsZWF2ZVRvb2xiYXIuaGFzQXR0cmlidXRlKCdzdGF0aWMnKTtcbiAgICBjb25zdCBpc01hdGVyaWFsID0gdXRpbC5oYXNNb2RpZmllcihlbnRlclRvb2xiYXIsICdtYXRlcmlhbCcpIHx8IHV0aWwuaGFzTW9kaWZpZXIobGVhdmVUb29sYmFyLCAnbWF0ZXJpYWwnKTtcbiAgICBjb25zdCBpc1RyYW5zcGFyZW50ID0gdXRpbC5oYXNNb2RpZmllcihlbnRlclRvb2xiYXIsICd0cmFuc3BhcmVudCcpIHx8IHV0aWwuaGFzTW9kaWZpZXIobGVhdmVUb29sYmFyLCAndHJhbnNwYXJlbnQnKTtcblxuICAgIHJldHVybiB0b29sYmFycyAmJiAhaXNTdGF0aWMgJiYgIWlzTWF0ZXJpYWwgJiYgIWlzVHJhbnNwYXJlbnQ7XG4gIH1cblxuICBfY2FsY3VsYXRlRGVsdGEoZWxlbWVudCwgZGVjb21wb3NpdGlvbikge1xuICAgIGxldCB0aXRsZSwgbGFiZWw7XG5cbiAgICBjb25zdCBwYWdlUmVjdCA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgaWYgKGRlY29tcG9zaXRpb24uYmFja0J1dHRvbkxhYmVsLmNsYXNzTGlzdC5jb250YWlucygnYmFjay1idXR0b25fX2xhYmVsJykpIHtcbiAgICAgIGNvbnN0IGxhYmVsUmVjdCA9IGRlY29tcG9zaXRpb24uYmFja0J1dHRvbkxhYmVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgdGl0bGUgPSBNYXRoLnJvdW5kKHBhZ2VSZWN0LndpZHRoIC8gMiAtIGxhYmVsUmVjdC53aWR0aCAvIDIgLSBsYWJlbFJlY3QubGVmdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRpdGxlID0gTWF0aC5yb3VuZCgocGFnZVJlY3Qud2lkdGggLyAyKSAqIDAuNik7XG4gICAgfVxuXG4gICAgaWYgKGRlY29tcG9zaXRpb24uYmFja0J1dHRvbkljb24uY2xhc3NMaXN0LmNvbnRhaW5zKCdiYWNrLWJ1dHRvbl9faWNvbicpKSB7XG4gICAgICBsYWJlbCA9IGRlY29tcG9zaXRpb24uYmFja0J1dHRvbkljb24uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkucmlnaHQgLSAyO1xuICAgIH1cblxuICAgIHJldHVybiB7dGl0bGUsIGxhYmVsfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBlbnRlclBhZ2VcbiAgICogQHBhcmFtIHtPYmplY3R9IGxlYXZlUGFnZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKi9cbiAgcHVzaChlbnRlclBhZ2UsIGxlYXZlUGFnZSwgY2FsbGJhY2spIHtcbiAgICB0aGlzLmJhY2tncm91bmRNYXNrLnJlbW92ZSgpO1xuICAgIGxlYXZlUGFnZS5wYXJlbnROb2RlLmluc2VydEJlZm9yZSh0aGlzLmJhY2tncm91bmRNYXNrLCBsZWF2ZVBhZ2UpO1xuXG4gICAgY29uc3QgdW5ibG9jayA9IHN1cGVyLmJsb2NrKGVudGVyUGFnZSk7XG5cbiAgICBjb250ZW50UmVhZHkoZW50ZXJQYWdlLCAoKSA9PiB7XG4gICAgICBjb25zdCBlbnRlclBhZ2VUYXJnZXQgPSB1dGlsLmZpbmRUb29sYmFyUGFnZShlbnRlclBhZ2UpIHx8IGVudGVyUGFnZTtcbiAgICAgIGNvbnN0IGxlYXZlUGFnZVRhcmdldCA9IHV0aWwuZmluZFRvb2xiYXJQYWdlKGxlYXZlUGFnZSkgfHwgbGVhdmVQYWdlO1xuICAgICAgY29uc3QgZW50ZXJQYWdlRGVjb21wb3NpdGlvbiA9IHRoaXMuX2RlY29tcG9zZShlbnRlclBhZ2VUYXJnZXQpO1xuICAgICAgY29uc3QgbGVhdmVQYWdlRGVjb21wb3NpdGlvbiA9IHRoaXMuX2RlY29tcG9zZShsZWF2ZVBhZ2VUYXJnZXQpO1xuXG4gICAgICBjb25zdCBkZWx0YSA9IHRoaXMuX2NhbGN1bGF0ZURlbHRhKGxlYXZlUGFnZSwgZW50ZXJQYWdlRGVjb21wb3NpdGlvbik7XG5cbiAgICAgIGNvbnN0IHNob3VsZEFuaW1hdGVUb29sYmFyID0gdGhpcy5fc2hvdWxkQW5pbWF0ZVRvb2xiYXIoZW50ZXJQYWdlVGFyZ2V0LCBsZWF2ZVBhZ2VUYXJnZXQpO1xuXG4gICAgICBpZiAoc2hvdWxkQW5pbWF0ZVRvb2xiYXIpIHtcblxuICAgICAgICBhbmltaXQucnVuQWxsKFxuXG4gICAgICAgICAgYW5pbWl0KFtlbnRlclBhZ2VEZWNvbXBvc2l0aW9uLmNvbnRlbnQsIGVudGVyUGFnZURlY29tcG9zaXRpb24uYm90dG9tVG9vbGJhciwgZW50ZXJQYWdlRGVjb21wb3NpdGlvbi5iYWNrZ3JvdW5kXSwgdGhpcy5kZWYpXG4gICAgICAgICAgICAuZGVmYXVsdChcbiAgICAgICAgICAgICAgeyB0cmFuc2Zvcm06IHRyYW5zbGF0ZTNkKCcxMDAlJykgfSxcbiAgICAgICAgICAgICAgeyB0cmFuc2Zvcm06IHRyYW5zbGF0ZTNkKCkgfVxuICAgICAgICAgICAgKSxcblxuICAgICAgICAgIGFuaW1pdChlbnRlclBhZ2VEZWNvbXBvc2l0aW9uLnRvb2xiYXIsIHRoaXMuZGVmKVxuICAgICAgICAgICAgLmRlZmF1bHQoeyBvcGFjaXR5OiAwIH0sIHsgb3BhY2l0eTogMSB9KSxcblxuICAgICAgICAgIGFuaW1pdChlbnRlclBhZ2VEZWNvbXBvc2l0aW9uLnRvb2xiYXJDZW50ZXIsIHRoaXMuZGVmKVxuICAgICAgICAgICAgLmRlZmF1bHQoXG4gICAgICAgICAgICAgIHsgdHJhbnNmb3JtOiB0cmFuc2xhdGUzZCgnMTI1JScpLCBvcGFjaXR5OiAxIH0sXG4gICAgICAgICAgICAgIHsgdHJhbnNmb3JtOiB0cmFuc2xhdGUzZCgpLCBvcGFjaXR5OiAxIH1cbiAgICAgICAgICAgICksXG5cbiAgICAgICAgICBhbmltaXQoZW50ZXJQYWdlRGVjb21wb3NpdGlvbi5iYWNrQnV0dG9uTGFiZWwsIHRoaXMuZGVmKVxuICAgICAgICAgICAgLmRlZmF1bHQoXG4gICAgICAgICAgICAgIHsgdHJhbnNmb3JtOiB0cmFuc2xhdGUzZChgJHtkZWx0YS50aXRsZX1weGApLCBvcGFjaXR5OiAwIH0sXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZTNkKCksXG4gICAgICAgICAgICAgICAgb3BhY2l0eTogMSxcbiAgICAgICAgICAgICAgICB0cmFuc2l0aW9uOiBgb3BhY2l0eSAke3RoaXMuZHVyYXRpb259cyBsaW5lYXIsIHRyYW5zZm9ybSAke3RoaXMuZHVyYXRpb259cyAke3RoaXMudGltaW5nfWBcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKSxcblxuICAgICAgICAgIGFuaW1pdChlbnRlclBhZ2VEZWNvbXBvc2l0aW9uLm90aGVyLCB0aGlzLmRlZilcbiAgICAgICAgICAgIC5kZWZhdWx0KFxuICAgICAgICAgICAgICB7IG9wYWNpdHk6IDAgfSxcbiAgICAgICAgICAgICAgeyBjc3M6IHsgb3BhY2l0eTogMSB9LCB0aW1pbmc6ICdsaW5lYXInIH1cbiAgICAgICAgICAgICksXG5cbiAgICAgICAgICBhbmltaXQoW2xlYXZlUGFnZURlY29tcG9zaXRpb24uY29udGVudCwgbGVhdmVQYWdlRGVjb21wb3NpdGlvbi5ib3R0b21Ub29sYmFyLCBsZWF2ZVBhZ2VEZWNvbXBvc2l0aW9uLmJhY2tncm91bmRdLCB0aGlzLmRlZilcbiAgICAgICAgICAgIC5kZWZhdWx0KFxuICAgICAgICAgICAgICB7IHRyYW5zZm9ybTogdHJhbnNsYXRlM2QoKSwgb3BhY2l0eTogMSB9LFxuICAgICAgICAgICAgICB7IHRyYW5zZm9ybTogdHJhbnNsYXRlM2QoJy0yNSUnKSwgb3BhY2l0eTogMC45IH1cbiAgICAgICAgICAgIClcbiAgICAgICAgICAgIC5xdWV1ZShkb25lID0+IHtcbiAgICAgICAgICAgICAgdGhpcy5iYWNrZ3JvdW5kTWFzay5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgdW5ibG9jaygpO1xuICAgICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgICBkb25lKCk7XG4gICAgICAgICAgICB9KSxcblxuICAgICAgICAgIGFuaW1pdChsZWF2ZVBhZ2VEZWNvbXBvc2l0aW9uLnRvb2xiYXJDZW50ZXIsIHRoaXMuZGVmKVxuICAgICAgICAgICAgLmRlZmF1bHQoXG4gICAgICAgICAgICAgIHsgdHJhbnNmb3JtOiB0cmFuc2xhdGUzZCgpLCBvcGFjaXR5OiAxIH0sXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZTNkKGAtJHtkZWx0YS50aXRsZX1weGApLFxuICAgICAgICAgICAgICAgIG9wYWNpdHk6IDAsXG4gICAgICAgICAgICAgICAgdHJhbnNpdGlvbjogYG9wYWNpdHkgJHt0aGlzLmR1cmF0aW9ufXMgbGluZWFyLCB0cmFuc2Zvcm0gJHt0aGlzLmR1cmF0aW9ufXMgJHt0aGlzLnRpbWluZ31gXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICksXG5cbiAgICAgICAgICBhbmltaXQobGVhdmVQYWdlRGVjb21wb3NpdGlvbi5iYWNrQnV0dG9uTGFiZWwsIHRoaXMuZGVmKVxuICAgICAgICAgICAgLmRlZmF1bHQoXG4gICAgICAgICAgICAgIHsgdHJhbnNmb3JtOiB0cmFuc2xhdGUzZCgpLCBvcGFjaXR5OiAxIH0sXG4gICAgICAgICAgICAgIHsgdHJhbnNmb3JtOiB0cmFuc2xhdGUzZChgLSR7ZGVsdGEubGFiZWx9cHhgKSwgb3BhY2l0eTogMCB9XG4gICAgICAgICAgICApLFxuXG4gICAgICAgICAgYW5pbWl0KGxlYXZlUGFnZURlY29tcG9zaXRpb24ub3RoZXIsIHRoaXMuZGVmKVxuICAgICAgICAgICAgLmRlZmF1bHQoIHsgb3BhY2l0eTogMSB9LCB7IGNzczogeyBvcGFjaXR5OiAwIH0sIHRpbWluZzogJ2xpbmVhcicgfSlcblxuICAgICAgICApO1xuXG4gICAgICB9IGVsc2Uge1xuXG4gICAgICAgIGFuaW1pdC5ydW5BbGwoXG5cbiAgICAgICAgICBhbmltaXQoZW50ZXJQYWdlLCB0aGlzLmRlZilcbiAgICAgICAgICAgIC5kZWZhdWx0KCB7IHRyYW5zZm9ybTogdHJhbnNsYXRlM2QoJzEwMCUnKSwgfSwgeyB0cmFuc2Zvcm06IHRyYW5zbGF0ZTNkKCkgfSksXG5cbiAgICAgICAgICBhbmltaXQobGVhdmVQYWdlLCB0aGlzLmRlZilcbiAgICAgICAgICAgIC5kZWZhdWx0KCB7IHRyYW5zZm9ybTogdHJhbnNsYXRlM2QoKSwgb3BhY2l0eTogMSB9LCB7IHRyYW5zZm9ybTogdHJhbnNsYXRlM2QoJy0yNSUnKSwgb3BhY2l0eTogLjkgfSlcbiAgICAgICAgICAgIC5xdWV1ZShkb25lID0+IHtcbiAgICAgICAgICAgICAgdGhpcy5iYWNrZ3JvdW5kTWFzay5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgdW5ibG9jaygpO1xuICAgICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgICBkb25lKCk7XG4gICAgICAgICAgICB9KVxuICAgICAgICApO1xuXG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IGVudGVyUGFnZVxuICAgKiBAcGFyYW0ge09iamVjdH0gbGVhdmVQYWdlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqL1xuICBwb3AoZW50ZXJQYWdlLCBsZWF2ZVBhZ2UsIGNhbGxiYWNrKSB7XG4gICAgaWYgKHRoaXMuaXNTd2lwaW5nKSB7XG4gICAgICByZXR1cm4gdGhpcy5wb3BTd2lwZShlbnRlclBhZ2UsIGxlYXZlUGFnZSwgY2FsbGJhY2spO1xuICAgIH1cblxuICAgIHRoaXMuYmFja2dyb3VuZE1hc2sucmVtb3ZlKCk7XG4gICAgZW50ZXJQYWdlLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHRoaXMuYmFja2dyb3VuZE1hc2ssIGVudGVyUGFnZSk7XG5cbiAgICBjb25zdCB1bmJsb2NrID0gc3VwZXIuYmxvY2soZW50ZXJQYWdlKTtcblxuICAgIGNvbnN0IGVudGVyUGFnZVRhcmdldCA9IHV0aWwuZmluZFRvb2xiYXJQYWdlKGVudGVyUGFnZSkgfHwgZW50ZXJQYWdlO1xuICAgIGNvbnN0IGxlYXZlUGFnZVRhcmdldCA9IHV0aWwuZmluZFRvb2xiYXJQYWdlKGxlYXZlUGFnZSkgfHwgbGVhdmVQYWdlO1xuICAgIGNvbnN0IGVudGVyUGFnZURlY29tcG9zaXRpb24gPSB0aGlzLl9kZWNvbXBvc2UoZW50ZXJQYWdlVGFyZ2V0KTtcbiAgICBjb25zdCBsZWF2ZVBhZ2VEZWNvbXBvc2l0aW9uID0gdGhpcy5fZGVjb21wb3NlKGxlYXZlUGFnZVRhcmdldCk7XG5cbiAgICBjb25zdCBkZWx0YSA9IHRoaXMuX2NhbGN1bGF0ZURlbHRhKGxlYXZlUGFnZSwgbGVhdmVQYWdlRGVjb21wb3NpdGlvbik7XG5cbiAgICBjb25zdCBzaG91bGRBbmltYXRlVG9vbGJhciA9IHRoaXMuX3Nob3VsZEFuaW1hdGVUb29sYmFyKGVudGVyUGFnZVRhcmdldCwgbGVhdmVQYWdlVGFyZ2V0KTtcblxuICAgIGlmIChzaG91bGRBbmltYXRlVG9vbGJhcikge1xuICAgICAgYW5pbWl0LnJ1bkFsbChcblxuICAgICAgICBhbmltaXQoW2VudGVyUGFnZURlY29tcG9zaXRpb24uY29udGVudCwgZW50ZXJQYWdlRGVjb21wb3NpdGlvbi5ib3R0b21Ub29sYmFyLCBlbnRlclBhZ2VEZWNvbXBvc2l0aW9uLmJhY2tncm91bmRdLCB0aGlzLmRlZilcbiAgICAgICAgICAuZGVmYXVsdChcbiAgICAgICAgICAgIHsgdHJhbnNmb3JtOiB0cmFuc2xhdGUzZCgnLTI1JScpLCBvcGFjaXR5OiAuOSB9LFxuICAgICAgICAgICAgeyB0cmFuc2Zvcm06IHRyYW5zbGF0ZTNkKCksIG9wYWNpdHk6IDEgfVxuICAgICAgICAgICksXG5cbiAgICAgICAgYW5pbWl0KGVudGVyUGFnZURlY29tcG9zaXRpb24udG9vbGJhckNlbnRlciwgdGhpcy5kZWYpXG4gICAgICAgICAgLmRlZmF1bHQoXG4gICAgICAgICAgICB7IHRyYW5zZm9ybTogdHJhbnNsYXRlM2QoYC0ke2RlbHRhLnRpdGxlfXB4YCksIG9wYWNpdHk6IDAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdHJhbnNmb3JtOiB0cmFuc2xhdGUzZCgpLFxuICAgICAgICAgICAgICBvcGFjaXR5OiAxLFxuICAgICAgICAgICAgICB0cmFuc2l0aW9uOiBgb3BhY2l0eSAke3RoaXMuZHVyYXRpb259cyBsaW5lYXIsIHRyYW5zZm9ybSAke3RoaXMuZHVyYXRpb259cyAke3RoaXMudGltaW5nfWBcbiAgICAgICAgICAgIH1cbiAgICAgICAgICApLFxuXG4gICAgICAgIGFuaW1pdChlbnRlclBhZ2VEZWNvbXBvc2l0aW9uLmJhY2tCdXR0b25MYWJlbCwgdGhpcy5kZWYpXG4gICAgICAgICAgLmRlZmF1bHQoXG4gICAgICAgICAgICB7IHRyYW5zZm9ybTogdHJhbnNsYXRlM2QoYC0ke2RlbHRhLmxhYmVsfXB4YCkgfSxcbiAgICAgICAgICAgIHsgdHJhbnNmb3JtOiB0cmFuc2xhdGUzZCgpIH1cbiAgICAgICAgICApLFxuXG4gICAgICAgIGFuaW1pdChlbnRlclBhZ2VEZWNvbXBvc2l0aW9uLm90aGVyLCB0aGlzLmRlZilcbiAgICAgICAgICAuZGVmYXVsdChcbiAgICAgICAgICAgIHsgb3BhY2l0eTogMCB9LFxuICAgICAgICAgICAgeyBjc3M6IHsgb3BhY2l0eTogMSB9LCB0aW1pbmc6ICdsaW5lYXInIH1cbiAgICAgICAgICApLFxuXG4gICAgICAgIGFuaW1pdChbbGVhdmVQYWdlRGVjb21wb3NpdGlvbi5jb250ZW50LCBsZWF2ZVBhZ2VEZWNvbXBvc2l0aW9uLmJvdHRvbVRvb2xiYXIsIGxlYXZlUGFnZURlY29tcG9zaXRpb24uYmFja2dyb3VuZF0sIHRoaXMuZGVmKVxuICAgICAgICAgIC5kZWZhdWx0KFxuICAgICAgICAgICAgeyB0cmFuc2Zvcm06IHRyYW5zbGF0ZTNkKCkgfSxcbiAgICAgICAgICAgIHsgdHJhbnNmb3JtOiB0cmFuc2xhdGUzZCgnMTAwJScpIH1cbiAgICAgICAgICApXG4gICAgICAgICAgLndhaXQoMClcbiAgICAgICAgICAucXVldWUoZG9uZSA9PiB7XG4gICAgICAgICAgICB0aGlzLmJhY2tncm91bmRNYXNrLnJlbW92ZSgpO1xuICAgICAgICAgICAgdW5ibG9jaygpO1xuICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgICB9KSxcblxuICAgICAgICBhbmltaXQobGVhdmVQYWdlRGVjb21wb3NpdGlvbi50b29sYmFyLCB0aGlzLmRlZilcbiAgICAgICAgICAuZGVmYXVsdChcbiAgICAgICAgICAgIHsgb3BhY2l0eTogMSB9LFxuICAgICAgICAgICAgeyBvcGFjaXR5OiAwIH1cbiAgICAgICAgICApLFxuXG4gICAgICAgIGFuaW1pdChsZWF2ZVBhZ2VEZWNvbXBvc2l0aW9uLnRvb2xiYXJDZW50ZXIsIHRoaXMuZGVmKVxuICAgICAgICAgIC5kZWZhdWx0KFxuICAgICAgICAgICAgeyB0cmFuc2Zvcm06IHRyYW5zbGF0ZTNkKCkgfSxcbiAgICAgICAgICAgIHsgdHJhbnNmb3JtOiB0cmFuc2xhdGUzZCgnMTI1JScpIH1cbiAgICAgICAgICApLFxuXG4gICAgICAgIGFuaW1pdChsZWF2ZVBhZ2VEZWNvbXBvc2l0aW9uLmJhY2tCdXR0b25MYWJlbCwgdGhpcy5kZWYpXG4gICAgICAgICAgLmRlZmF1bHQoXG4gICAgICAgICAgICB7IHRyYW5zZm9ybTogdHJhbnNsYXRlM2QoKSwgb3BhY2l0eTogMSB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZTNkKGAke2RlbHRhLnRpdGxlfXB4YCksXG4gICAgICAgICAgICAgIG9wYWNpdHk6IDAsXG4gICAgICAgICAgICAgIHRyYW5zaXRpb246IGBvcGFjaXR5ICR7dGhpcy5kdXJhdGlvbn1zIGxpbmVhciwgdHJhbnNmb3JtICR7dGhpcy5kdXJhdGlvbn1zICR7dGhpcy50aW1pbmd9YFxuICAgICAgICAgICAgfVxuICAgICAgICAgIClcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFuaW1pdC5ydW5BbGwoXG5cbiAgICAgICAgYW5pbWl0KGVudGVyUGFnZSwgdGhpcy5kZWYpXG4gICAgICAgICAgLmRlZmF1bHQoXG4gICAgICAgICAgICB7IHRyYW5zZm9ybTogdHJhbnNsYXRlM2QoJy0yNSUnKSwgb3BhY2l0eTogLjkgfSxcbiAgICAgICAgICAgIHsgdHJhbnNmb3JtOiB0cmFuc2xhdGUzZCgpLCBvcGFjaXR5OiAxIH1cbiAgICAgICAgICApLFxuXG4gICAgICAgIGFuaW1pdChsZWF2ZVBhZ2UsIHRoaXMuZGVmKVxuICAgICAgICAgIC5kZWZhdWx0KFxuICAgICAgICAgICAgeyB0cmFuc2Zvcm06IHRyYW5zbGF0ZTNkKCkgfSxcbiAgICAgICAgICAgIHsgdHJhbnNmb3JtOiB0cmFuc2xhdGUzZCgnMTAwJScpIH1cbiAgICAgICAgICApXG4gICAgICAgICAgLnF1ZXVlKGRvbmUgPT4ge1xuICAgICAgICAgICAgdGhpcy5iYWNrZ3JvdW5kTWFzay5yZW1vdmUoKTtcbiAgICAgICAgICAgIHVuYmxvY2soKTtcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICBkb25lKCk7XG4gICAgICAgICAgfSlcbiAgICAgICk7XG4gICAgfVxuICB9XG59XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgTmF2aWdhdG9yQW5pbWF0b3IgZnJvbSAnLi9hbmltYXRvcic7XG5pbXBvcnQgdXRpbCBmcm9tICcuLi8uLi9vbnMvdXRpbCc7XG5pbXBvcnQgYW5pbWl0IGZyb20gJy4uLy4uL29ucy9hbmltaXQnO1xuXG4vKipcbiAqIExpZnQgc2NyZWVuIHRyYW5zaXRpb24uXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIElPU0xpZnROYXZpZ2F0b3JBbmltYXRvciBleHRlbmRzIE5hdmlnYXRvckFuaW1hdG9yIHtcblxuICBjb25zdHJ1Y3Rvcih7dGltaW5nID0gJ2N1YmljLWJlemllciguMSwgLjcsIC4xLCAxKScsIGRlbGF5ID0gMCwgZHVyYXRpb24gPSAwLjR9ID0ge30pIHtcbiAgICBzdXBlcih7IHRpbWluZywgZGVsYXksIGR1cmF0aW9uIH0pO1xuXG4gICAgdGhpcy5iYWNrZ3JvdW5kTWFzayA9IHV0aWwuY3JlYXRlRWxlbWVudChcbiAgICAgICc8ZGl2IHN0eWxlPVwicG9zaXRpb246IGFic29sdXRlOyB3aWR0aDogMTAwJTsgaGVpZ2h0OiAxMDAlOycgK1xuICAgICAgICAnYmFja2dyb3VuZDogbGluZWFyLWdyYWRpZW50KGJsYWNrLCB3aGl0ZSk7XCI+PC9kaXY+J1xuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IGVudGVyUGFnZVxuICAgKiBAcGFyYW0ge09iamVjdH0gbGVhdmVQYWdlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqL1xuICBwdXNoKGVudGVyUGFnZSwgbGVhdmVQYWdlLCBjYWxsYmFjaykge1xuICAgIHRoaXMuYmFja2dyb3VuZE1hc2sucmVtb3ZlKCk7XG4gICAgbGVhdmVQYWdlLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHRoaXMuYmFja2dyb3VuZE1hc2ssIGxlYXZlUGFnZSk7XG5cbiAgICBjb25zdCB1bmJsb2NrID0gc3VwZXIuYmxvY2soZW50ZXJQYWdlKTtcblxuICAgIGFuaW1pdC5ydW5BbGwoXG5cbiAgICAgIGFuaW1pdChlbnRlclBhZ2UsIHRoaXMuZGVmKVxuICAgICAgICAuZGVmYXVsdChcbiAgICAgICAgICB7IHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKDAsIDEwMCUsIDApJyB9LFxuICAgICAgICAgIHsgdHJhbnNmb3JtOiAndHJhbnNsYXRlM0QoMCwgMCwgMCknIH1cbiAgICAgICAgKSxcblxuICAgICAgYW5pbWl0KGxlYXZlUGFnZSwgdGhpcy5kZWYpXG4gICAgICAgIC5kZWZhdWx0KFxuICAgICAgICAgIHsgdHJhbnNmb3JtOiAndHJhbnNsYXRlM0QoMCwgMCwgMCknLCBvcGFjaXR5OiAxIH0sXG4gICAgICAgICAgeyB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgwLCAtMTAlLCAwKScsIG9wYWNpdHk6IC45IH1cbiAgICAgICAgKVxuICAgICAgICAucXVldWUoZG9uZSA9PiB7XG4gICAgICAgICAgdGhpcy5iYWNrZ3JvdW5kTWFzay5yZW1vdmUoKTtcbiAgICAgICAgICB1bmJsb2NrKCk7XG4gICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICBkb25lKCk7XG4gICAgICAgIH0pXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gZW50ZXJQYWdlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBsZWF2ZVBhZ2VcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICovXG4gIHBvcChlbnRlclBhZ2UsIGxlYXZlUGFnZSwgY2FsbGJhY2spIHtcbiAgICB0aGlzLmJhY2tncm91bmRNYXNrLnJlbW92ZSgpO1xuICAgIGVudGVyUGFnZS5wYXJlbnROb2RlLmluc2VydEJlZm9yZSh0aGlzLmJhY2tncm91bmRNYXNrLCBlbnRlclBhZ2UpO1xuXG4gICAgY29uc3QgdW5ibG9jayA9IHN1cGVyLmJsb2NrKGVudGVyUGFnZSk7XG5cbiAgICBhbmltaXQucnVuQWxsKFxuXG4gICAgICBhbmltaXQoZW50ZXJQYWdlLCB0aGlzLmRlZilcbiAgICAgICAgLmRlZmF1bHQoXG4gICAgICAgICAgeyB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgwLCAtNDNweCwgMCknLCBvcGFjaXR5OiAuOSB9LFxuICAgICAgICAgIHsgdHJhbnNmb3JtOiAndHJhbnNsYXRlM0QoMCwgMCwgMCknLCBvcGFjaXR5OiAxIH1cbiAgICAgICAgKVxuICAgICAgICAucXVldWUoZG9uZSA9PiB7XG4gICAgICAgICAgdGhpcy5iYWNrZ3JvdW5kTWFzay5yZW1vdmUoKTtcbiAgICAgICAgICB1bmJsb2NrKCk7XG4gICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICBkb25lKCk7XG4gICAgICAgIH0pLFxuXG4gICAgICBhbmltaXQobGVhdmVQYWdlLCB0aGlzLmRlZilcbiAgICAgICAgLmRlZmF1bHQoXG4gICAgICAgICAgeyB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgwLCAwLCAwKScgfSxcbiAgICAgICAgICB7IHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKDAsIDEwMCUsIDApJyB9XG4gICAgICAgIClcbiAgICApO1xuICB9XG59XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgTmF2aWdhdG9yQW5pbWF0b3IgZnJvbSAnLi9hbmltYXRvcic7XG5pbXBvcnQgdXRpbCBmcm9tICcuLi8uLi9vbnMvdXRpbCc7XG5pbXBvcnQgYW5pbWl0IGZyb20gJy4uLy4uL29ucy9hbmltaXQnO1xuXG5jb25zdCB0cmFuc2Zvcm0gPSAndHJhbnNsYXRlM2QoMCwgMCwgMCknO1xuXG4vKipcbiAqIEZhZGUtaW4gc2NyZWVuIHRyYW5zaXRpb24uXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIElPU0ZhZGVOYXZpZ2F0b3JBbmltYXRvciBleHRlbmRzIE5hdmlnYXRvckFuaW1hdG9yIHtcblxuICBjb25zdHJ1Y3Rvcih7dGltaW5nID0gJ2xpbmVhcicsIGRlbGF5ID0gMCwgZHVyYXRpb24gPSAwLjR9ID0ge30pIHtcbiAgICBzdXBlcih7IHRpbWluZywgZGVsYXksIGR1cmF0aW9uIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBlbnRlclBhZ2VcbiAgICogQHBhcmFtIHtPYmplY3R9IGxlYXZlUGFnZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKi9cbiAgcHVzaChlbnRlclBhZ2UsIGxlYXZlUGFnZSwgY2FsbGJhY2spIHtcbiAgICBjb25zdCB1bmJsb2NrID0gc3VwZXIuYmxvY2soZW50ZXJQYWdlKTtcblxuICAgIGFuaW1pdC5ydW5BbGwoXG5cbiAgICAgIGFuaW1pdChlbnRlclBhZ2UsIHRoaXMuZGVmKVxuICAgICAgICAuZGVmYXVsdChcbiAgICAgICAgICB7IHRyYW5zZm9ybSwgb3BhY2l0eTogMCB9LFxuICAgICAgICAgIHsgdHJhbnNmb3JtLCBvcGFjaXR5OiAxIH1cbiAgICAgICAgKVxuICAgICAgICAucXVldWUoZG9uZSA9PiB7XG4gICAgICAgICAgdW5ibG9jaygpO1xuICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgZG9uZSgpO1xuICAgICAgICB9KSxcbiAgICApO1xuXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IGVudGVyUGFnZVxuICAgKiBAcGFyYW0ge09iamVjdH0gbGVhdmVQYWdlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGRvbmVcbiAgICovXG4gIHBvcChlbnRlclBhZ2UsIGxlYXZlUGFnZSwgY2FsbGJhY2spIHtcbiAgICBjb25zdCB1bmJsb2NrID0gc3VwZXIuYmxvY2soZW50ZXJQYWdlKTtcblxuICAgIGFuaW1pdC5ydW5BbGwoXG5cbiAgICAgIGFuaW1pdChsZWF2ZVBhZ2UsIHRoaXMuZGVmKVxuICAgICAgICAuZGVmYXVsdChcbiAgICAgICAgICB7IHRyYW5zZm9ybSwgb3BhY2l0eTogMSB9LFxuICAgICAgICAgIHsgdHJhbnNmb3JtLCBvcGFjaXR5OiAwIH1cbiAgICAgICAgKVxuICAgICAgICAucXVldWUoZG9uZSA9PiB7XG4gICAgICAgICAgdW5ibG9jaygpO1xuICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgZG9uZSgpO1xuICAgICAgICB9KVxuICAgICk7XG4gIH1cbn1cbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCB1dGlsIGZyb20gJy4uLy4uL29ucy91dGlsJztcbmltcG9ydCBOYXZpZ2F0b3JBbmltYXRvciBmcm9tICcuL2FuaW1hdG9yJztcbmltcG9ydCBhbmltaXQgZnJvbSAnLi4vLi4vb25zL2FuaW1pdCc7XG5cbi8qKlxuICogU2xpZGUgYW5pbWF0b3IgZm9yIG5hdmlnYXRvciB0cmFuc2l0aW9uLlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNRFNsaWRlTmF2aWdhdG9yQW5pbWF0b3IgZXh0ZW5kcyBOYXZpZ2F0b3JBbmltYXRvciB7XG5cbiAgY29uc3RydWN0b3Ioe3RpbWluZyA9ICdjdWJpYy1iZXppZXIoLjEsIC43LCAuNCwgMSknLCBkZWxheSA9IDAsIGR1cmF0aW9uID0gMC4zfSA9IHt9KSB7XG4gICAgc3VwZXIoe3RpbWluZywgZGVsYXksIGR1cmF0aW9ufSk7XG5cbiAgICB0aGlzLmJsYWNrTWFza09wYWNpdHkgPSAwLjQ7XG4gICAgdGhpcy5iYWNrZ3JvdW5kTWFzayA9IHV0aWwuY3JlYXRlRWxlbWVudChcbiAgICAgICc8ZGl2IHN0eWxlPVwicG9zaXRpb246IGFic29sdXRlOyB3aWR0aDogMTAwJTsgaGVpZ2h0OiAxMDAlOyB6LWluZGV4OiAyOycgK1xuICAgICAgICAnYmFja2dyb3VuZC1jb2xvcjogYmxhY2s7IG9wYWNpdHk6IDA7XCI+PC9kaXY+J1xuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IGVudGVyUGFnZVxuICAgKiBAcGFyYW0ge09iamVjdH0gbGVhdmVQYWdlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqL1xuICBwdXNoKGVudGVyUGFnZSwgbGVhdmVQYWdlLCBjYWxsYmFjaykge1xuICAgIHRoaXMuYmFja2dyb3VuZE1hc2sucmVtb3ZlKCk7XG4gICAgbGVhdmVQYWdlLnBhcmVudEVsZW1lbnQuaW5zZXJ0QmVmb3JlKHRoaXMuYmFja2dyb3VuZE1hc2ssIGxlYXZlUGFnZS5uZXh0U2libGluZyk7XG5cbiAgICBjb25zdCB1bmJsb2NrID0gc3VwZXIuYmxvY2soZW50ZXJQYWdlKTtcblxuICAgIGFuaW1pdC5ydW5BbGwoXG5cbiAgICAgIGFuaW1pdCh0aGlzLmJhY2tncm91bmRNYXNrLCB0aGlzLmRlZilcbiAgICAgICAgLmRlZmF1bHQoXG4gICAgICAgICAgeyB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzZCgwLCAwLCAwKScsIG9wYWNpdHk6IDAgfSxcbiAgICAgICAgICB7IG9wYWNpdHk6IHRoaXMuYmxhY2tNYXNrT3BhY2l0eSB9XG4gICAgICAgIClcbiAgICAgICAgLnF1ZXVlKGRvbmUgPT4ge1xuICAgICAgICAgIHRoaXMuYmFja2dyb3VuZE1hc2sucmVtb3ZlKCk7XG4gICAgICAgICAgZG9uZSgpO1xuICAgICAgICB9KSxcblxuICAgICAgYW5pbWl0KGVudGVyUGFnZSwgdGhpcy5kZWYpXG4gICAgICAgIC5kZWZhdWx0KFxuICAgICAgICAgIHsgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoMTAwJSwgMCwgMCknIH0sXG4gICAgICAgICAgeyB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzZCgwLCAwLCAwKScgfVxuICAgICAgICApLFxuXG4gICAgICBhbmltaXQobGVhdmVQYWdlLCB0aGlzLmRlZilcbiAgICAgICAgLmRlZmF1bHQoXG4gICAgICAgICAgeyB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzZCgwLCAwLCAwKScgfSxcbiAgICAgICAgICB7IHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNkKC00NSUsIDAsIDApJyB9XG4gICAgICAgIClcbiAgICAgICAgLnF1ZXVlKGRvbmUgPT4ge1xuICAgICAgICAgIHVuYmxvY2soKTtcbiAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgfSlcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBlbnRlclBhZ2VcbiAgICogQHBhcmFtIHtPYmplY3R9IGxlYXZlUGFnZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKi9cbiAgcG9wKGVudGVyUGFnZSwgbGVhdmVQYWdlLCBjYWxsYmFjaykge1xuICAgIHRoaXMuYmFja2dyb3VuZE1hc2sucmVtb3ZlKCk7XG4gICAgZW50ZXJQYWdlLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHRoaXMuYmFja2dyb3VuZE1hc2ssIGVudGVyUGFnZS5uZXh0U2libGluZyk7XG5cbiAgICBjb25zdCB1bmJsb2NrID0gc3VwZXIuYmxvY2soZW50ZXJQYWdlKTtcblxuICAgIGFuaW1pdC5ydW5BbGwoXG5cbiAgICAgIGFuaW1pdCh0aGlzLmJhY2tncm91bmRNYXNrLCB0aGlzLmRlZilcbiAgICAgICAgLmRlZmF1bHQoXG4gICAgICAgICAgeyB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzZCgwLCAwLCAwKScsIG9wYWNpdHk6IHRoaXMuYmxhY2tNYXNrT3BhY2l0eSB9LFxuICAgICAgICAgIHsgb3BhY2l0eTogMCB9XG4gICAgICAgIClcbiAgICAgICAgLnF1ZXVlKGRvbmUgPT4ge1xuICAgICAgICAgIHRoaXMuYmFja2dyb3VuZE1hc2sucmVtb3ZlKCk7XG4gICAgICAgICAgZG9uZSgpO1xuICAgICAgICB9KSxcblxuICAgICAgYW5pbWl0KGVudGVyUGFnZSwgdGhpcy5kZWYpXG4gICAgICAgIC5kZWZhdWx0KFxuICAgICAgICAgIHsgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoLTQ1JSwgMCwgMCknLCBvcGFjaXR5OiAuOSB9LFxuICAgICAgICAgIHsgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoMCwgMCwgMCknLCBvcGFjaXR5OiAxIH1cbiAgICAgICAgKSxcblxuICAgICAgYW5pbWl0KGxlYXZlUGFnZSwgdGhpcy5kZWYpXG4gICAgICAgIC5kZWZhdWx0KFxuICAgICAgICAgIHsgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoMCwgMCwgMCknIH0sXG4gICAgICAgICAgeyB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzZCgxMDAlLCAwLCAwKScgfVxuICAgICAgICApXG4gICAgICAgIC5xdWV1ZShkb25lID0+IHtcbiAgICAgICAgICB1bmJsb2NrKCk7XG4gICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICBkb25lKCk7XG4gICAgICAgIH0pXG4gICAgKTtcbiAgfVxufVxuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IE5hdmlnYXRvckFuaW1hdG9yIGZyb20gJy4vYW5pbWF0b3InO1xuaW1wb3J0IHV0aWwgZnJvbSAnLi4vLi4vb25zL3V0aWwnO1xuaW1wb3J0IGFuaW1pdCBmcm9tICcuLi8uLi9vbnMvYW5pbWl0JztcblxuLyoqXG4gKiBMaWZ0IHNjcmVlbiB0cmFuc2l0aW9uLlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNRExpZnROYXZpZ2F0b3JBbmltYXRvciBleHRlbmRzIE5hdmlnYXRvckFuaW1hdG9yIHtcblxuICBjb25zdHJ1Y3Rvcih7dGltaW5nID0gJ2N1YmljLWJlemllciguMSwgLjcsIC4xLCAxKScsIGRlbGF5ID0gMC4wNSwgZHVyYXRpb24gPSAwLjR9ID0ge30pIHtcbiAgICBzdXBlcih7IHRpbWluZywgZGVsYXksIGR1cmF0aW9uIH0pO1xuXG4gICAgdGhpcy5iYWNrZ3JvdW5kTWFzayA9IHV0aWwuY3JlYXRlRWxlbWVudChcbiAgICAgICc8ZGl2IHN0eWxlPVwicG9zaXRpb246IGFic29sdXRlOyB3aWR0aDogMTAwJTsgaGVpZ2h0OiAxMDAlOycgK1xuICAgICAgICAnYmFja2dyb3VuZC1jb2xvcjogYmxhY2s7XCI+PC9kaXY+J1xuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IGVudGVyUGFnZVxuICAgKiBAcGFyYW0ge09iamVjdH0gbGVhdmVQYWdlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqL1xuICBwdXNoKGVudGVyUGFnZSwgbGVhdmVQYWdlLCBjYWxsYmFjaykge1xuICAgIHRoaXMuYmFja2dyb3VuZE1hc2sucmVtb3ZlKCk7XG4gICAgbGVhdmVQYWdlLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHRoaXMuYmFja2dyb3VuZE1hc2ssIGxlYXZlUGFnZSk7XG5cbiAgICBjb25zdCB1bmJsb2NrID0gc3VwZXIuYmxvY2soZW50ZXJQYWdlKTtcblxuICAgIGNvbnN0IG1hc2tDbGVhciA9IGFuaW1pdCh0aGlzLmJhY2tncm91bmRNYXNrKVxuICAgICAgLndhaXQodGhpcy5kZWxheSArIHRoaXMuZHVyYXRpb24pXG4gICAgICAucXVldWUoZG9uZSA9PiB7XG4gICAgICAgIHRoaXMuYmFja2dyb3VuZE1hc2sucmVtb3ZlKCk7XG4gICAgICAgIGRvbmUoKTtcbiAgICAgIH0pO1xuXG4gICAgYW5pbWl0LnJ1bkFsbChcblxuICAgICAgbWFza0NsZWFyLFxuXG4gICAgICBhbmltaXQoZW50ZXJQYWdlLCB0aGlzLmRlZilcbiAgICAgICAgLmRlZmF1bHQoXG4gICAgICAgICAgeyB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzZCgwLCAxMDAlLCAwKScgfSxcbiAgICAgICAgICB7IHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNkKDAsIDAsIDApJyB9XG4gICAgICAgICksXG5cbiAgICAgIGFuaW1pdChsZWF2ZVBhZ2UsIHRoaXMuZGVmKVxuICAgICAgICAuZGVmYXVsdCh7IG9wYWNpdHk6IDEgfSwgeyBvcGFjaXR5OiAuNCB9KVxuICAgICAgICAucXVldWUoZG9uZSA9PiB7XG4gICAgICAgICAgdW5ibG9jaygpO1xuICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgZG9uZSgpO1xuICAgICAgICB9KVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IGVudGVyUGFnZVxuICAgKiBAcGFyYW0ge09iamVjdH0gbGVhdmVQYWdlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqL1xuICBwb3AoZW50ZXJQYWdlLCBsZWF2ZVBhZ2UsIGNhbGxiYWNrKSB7XG4gICAgdGhpcy5iYWNrZ3JvdW5kTWFzay5yZW1vdmUoKTtcbiAgICBlbnRlclBhZ2UucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUodGhpcy5iYWNrZ3JvdW5kTWFzaywgZW50ZXJQYWdlKTtcblxuICAgIGNvbnN0IHVuYmxvY2sgPSBzdXBlci5ibG9jayhlbnRlclBhZ2UpO1xuXG4gICAgYW5pbWl0LnJ1bkFsbChcblxuICAgICAgYW5pbWl0KHRoaXMuYmFja2dyb3VuZE1hc2spXG4gICAgICAgIC53YWl0KHRoaXMuZGVsYXkgKyB0aGlzLmR1cmF0aW9uKVxuICAgICAgICAucXVldWUoZG9uZSA9PiB7XG4gICAgICAgICAgdGhpcy5iYWNrZ3JvdW5kTWFzay5yZW1vdmUoKTtcbiAgICAgICAgICBkb25lKCk7XG4gICAgICAgIH0pLFxuXG4gICAgICBhbmltaXQoZW50ZXJQYWdlLCB0aGlzLmRlZilcbiAgICAgICAgLmRlZmF1bHQoeyBvcGFjaXR5OiAuNCB9LCB7IG9wYWNpdHk6IDEgfSlcbiAgICAgICAgLnF1ZXVlKGRvbmUgPT4ge1xuICAgICAgICAgIHVuYmxvY2soKTtcbiAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgfSksXG5cbiAgICAgIGFuaW1pdChsZWF2ZVBhZ2UsIHRoaXMuZGVmKVxuICAgICAgICAuZGVmYXVsdChcbiAgICAgICAgICB7IHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNkKDAsIDAsIDApJyB9LFxuICAgICAgICAgIHsgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoMCwgMTAwJSwgMCknIH1cbiAgICAgICAgKVxuICAgICk7XG4gIH1cbn1cbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCBOYXZpZ2F0b3JBbmltYXRvciBmcm9tICcuL2FuaW1hdG9yJztcbmltcG9ydCB1dGlsIGZyb20gJy4uLy4uL29ucy91dGlsJztcbmltcG9ydCBhbmltaXQgZnJvbSAnLi4vLi4vb25zL2FuaW1pdCc7XG5cbi8qKlxuICogRmFkZS1pbiArIExpZnQgc2NyZWVuIHRyYW5zaXRpb24uXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1ERmFkZU5hdmlnYXRvckFuaW1hdG9yIGV4dGVuZHMgTmF2aWdhdG9yQW5pbWF0b3Ige1xuXG4gIGNvbnN0cnVjdG9yKHt0aW1pbmcgPSAnY3ViaWMtYmV6aWVyKDAuNCwgMCwgMC4yLCAxKScsIHRpbWluZ1BvcCA9ICdjdWJpYy1iZXppZXIoMC40LCAwLCAxLCAxKScsIGRlbGF5ID0gMCwgZHVyYXRpb24gPSAwLjJ9ID0ge30pIHtcbiAgICBzdXBlcih7dGltaW5nLCBkZWxheSwgZHVyYXRpb259KTtcbiAgICB0aGlzLnRpbWluZ1BvcCA9IHRpbWluZ1BvcDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gZW50ZXJQYWdlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBsZWF2ZVBhZ2VcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICovXG4gIHB1c2goZW50ZXJQYWdlLCBsZWF2ZVBhZ2UsIGNhbGxiYWNrKSB7XG4gICAgY29uc3QgdW5ibG9jayA9IHN1cGVyLmJsb2NrKGVudGVyUGFnZSk7XG5cbiAgICBhbmltaXQucnVuQWxsKFxuXG4gICAgICBhbmltaXQoZW50ZXJQYWdlLCB0aGlzLmRlZilcbiAgICAgICAgLmRlZmF1bHQoXG4gICAgICAgICAgeyB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgwLCA0MnB4LCAwKScsIG9wYWNpdHk6IDAgfSxcbiAgICAgICAgICB7IHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKDAsIDAsIDApJywgb3BhY2l0eTogMSB9XG4gICAgICAgIClcbiAgICAgICAgLnF1ZXVlKGRvbmUgPT4ge1xuICAgICAgICAgIHVuYmxvY2soKTtcbiAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgfSlcbiAgICApO1xuXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IGVudGVyUGFnZVxuICAgKiBAcGFyYW0ge09iamVjdH0gbGVhdmVQYWdlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGRvbmVcbiAgICovXG4gIHBvcChlbnRlclBhZ2UsIGxlYXZlUGFnZSwgY2FsbGJhY2spIHtcbiAgICBjb25zdCB1bmJsb2NrID0gc3VwZXIuYmxvY2soZW50ZXJQYWdlKTtcblxuICAgIGFuaW1pdC5ydW5BbGwoXG5cbiAgICAgIGFuaW1pdChsZWF2ZVBhZ2UsIHRoaXMuZGVmKVxuICAgICAgICAuZGVmYXVsdChcbiAgICAgICAgICB7IHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKDAsIDAsIDApJywgb3BhY2l0eTogMSB9LFxuICAgICAgICAgIHsgY3NzOiB7IHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKDAsIDM4cHgsIDApJywgb3BhY2l0eTogMCB9LCB0aW1pbmc6IHRoaXMudGltaW5nUG9wIH1cbiAgICAgICAgKVxuICAgICAgICAucXVldWUoZG9uZSA9PiB7XG4gICAgICAgICAgdW5ibG9jaygpO1xuICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgZG9uZSgpO1xuICAgICAgICB9KVxuICAgICk7XG4gIH1cbn1cbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCBOYXZpZ2F0b3JBbmltYXRvciBmcm9tICcuL2FuaW1hdG9yJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTm9uZU5hdmlnYXRvckFuaW1hdG9yIGV4dGVuZHMgTmF2aWdhdG9yQW5pbWF0b3Ige1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgc3VwZXIob3B0aW9ucyk7XG4gIH1cbiAgcHVzaChlbnRlclBhZ2UsIGxlYXZlUGFnZSwgY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjaygpO1xuICB9XG5cbiAgcG9wKGVudGVyUGFnZSwgbGVhdmVQYWdlLCBjYWxsYmFjaykge1xuICAgIGNhbGxiYWNrKCk7XG4gIH1cbn1cbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCBvbnNFbGVtZW50cyBmcm9tICcuLi8uLi9vbnMvZWxlbWVudHMnO1xuaW1wb3J0IHV0aWwgZnJvbSAnLi4vLi4vb25zL3V0aWwnO1xuaW1wb3J0IGludGVybmFsIGZyb20gJy4uLy4uL29ucy9pbnRlcm5hbCc7XG5pbXBvcnQgU3dpcGVSZXZlYWwgZnJvbSAnLi4vLi4vb25zL2ludGVybmFsL3N3aXBlLXJldmVhbCc7XG5pbXBvcnQgQW5pbWF0b3JGYWN0b3J5IGZyb20gJy4uLy4uL29ucy9pbnRlcm5hbC9hbmltYXRvci1mYWN0b3J5JztcbmltcG9ydCBOYXZpZ2F0b3JBbmltYXRvciBmcm9tICcuL2FuaW1hdG9yJztcbmltcG9ydCBJT1NTbGlkZU5hdmlnYXRvckFuaW1hdG9yIGZyb20gJy4vaW9zLXNsaWRlLWFuaW1hdG9yJztcbmltcG9ydCBJT1NMaWZ0TmF2aWdhdG9yQW5pbWF0b3IgZnJvbSAnLi9pb3MtbGlmdC1hbmltYXRvcic7XG5pbXBvcnQgSU9TRmFkZU5hdmlnYXRvckFuaW1hdG9yIGZyb20gJy4vaW9zLWZhZGUtYW5pbWF0b3InO1xuaW1wb3J0IE1EU2xpZGVOYXZpZ2F0b3JBbmltYXRvciBmcm9tICcuL21kLXNsaWRlLWFuaW1hdG9yJztcbmltcG9ydCBNRExpZnROYXZpZ2F0b3JBbmltYXRvciBmcm9tICcuL21kLWxpZnQtYW5pbWF0b3InO1xuaW1wb3J0IE1ERmFkZU5hdmlnYXRvckFuaW1hdG9yIGZyb20gJy4vbWQtZmFkZS1hbmltYXRvcic7XG5pbXBvcnQgTm9uZU5hdmlnYXRvckFuaW1hdG9yIGZyb20gJy4vbm9uZS1hbmltYXRvcic7XG5pbXBvcnQgcGxhdGZvcm0gZnJvbSAnLi4vLi4vb25zL3BsYXRmb3JtJztcbmltcG9ydCBjb250ZW50UmVhZHkgZnJvbSAnLi4vLi4vb25zL2NvbnRlbnQtcmVhZHknO1xuaW1wb3J0IEJhc2VFbGVtZW50IGZyb20gJy4uL2Jhc2UvYmFzZS1lbGVtZW50JztcbmltcG9ydCBkZXZpY2VCYWNrQnV0dG9uRGlzcGF0Y2hlciBmcm9tICcuLi8uLi9vbnMvaW50ZXJuYWwvZGV2aWNlLWJhY2stYnV0dG9uLWRpc3BhdGNoZXInO1xuaW1wb3J0IHtQYWdlTG9hZGVyLCBkZWZhdWx0UGFnZUxvYWRlciwgaW5zdGFudFBhZ2VMb2FkZXJ9IGZyb20gJy4uLy4uL29ucy9wYWdlLWxvYWRlcic7XG5cbmNvbnN0IF9hbmltYXRvckRpY3QgPSB7XG4gICdkZWZhdWx0JzogKCkgPT4gcGxhdGZvcm0uaXNBbmRyb2lkKCkgPyBNREZhZGVOYXZpZ2F0b3JBbmltYXRvciA6IElPU1NsaWRlTmF2aWdhdG9yQW5pbWF0b3IsXG4gICdzbGlkZSc6ICgpID0+IHBsYXRmb3JtLmlzQW5kcm9pZCgpID8gTURTbGlkZU5hdmlnYXRvckFuaW1hdG9yIDogSU9TU2xpZGVOYXZpZ2F0b3JBbmltYXRvcixcbiAgJ2xpZnQnOiAoKSA9PiBwbGF0Zm9ybS5pc0FuZHJvaWQoKSA/IE1ETGlmdE5hdmlnYXRvckFuaW1hdG9yIDogSU9TTGlmdE5hdmlnYXRvckFuaW1hdG9yLFxuICAnZmFkZSc6ICgpID0+IHBsYXRmb3JtLmlzQW5kcm9pZCgpID8gTURGYWRlTmF2aWdhdG9yQW5pbWF0b3IgOiBJT1NGYWRlTmF2aWdhdG9yQW5pbWF0b3IsXG4gICdzbGlkZS1pb3MnOiBJT1NTbGlkZU5hdmlnYXRvckFuaW1hdG9yLFxuICAnc2xpZGUtbWQnOiBNRFNsaWRlTmF2aWdhdG9yQW5pbWF0b3IsXG4gICdsaWZ0LWlvcyc6IElPU0xpZnROYXZpZ2F0b3JBbmltYXRvcixcbiAgJ2xpZnQtbWQnOiBNRExpZnROYXZpZ2F0b3JBbmltYXRvcixcbiAgJ2ZhZGUtaW9zJzogSU9TRmFkZU5hdmlnYXRvckFuaW1hdG9yLFxuICAnZmFkZS1tZCc6IE1ERmFkZU5hdmlnYXRvckFuaW1hdG9yLFxuICAnbm9uZSc6IE5vbmVOYXZpZ2F0b3JBbmltYXRvclxufTtcblxuY29uc3QgcmV3cml0YWJsZXMgPSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IG5hdmlnYXRvclNpZGVFbGVtZW50XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqL1xuICByZWFkeShuYXZpZ2F0b3JFbGVtZW50LCBjYWxsYmFjaykge1xuICAgIGNhbGxiYWNrKCk7XG4gIH1cbn07XG5cbmNvbnN0IHZlcmlmeVBhZ2VFbGVtZW50ID0gZWwgPT4gKGVsLm5vZGVOYW1lICE9PSAnT05TLVBBR0UnKSAmJiB1dGlsLnRocm93KCAnT25seSBwYWdlIGVsZW1lbnRzIGNhbiBiZSBjaGlsZHJlbiBvZiBuYXZpZ2F0b3InKTtcblxuLyoqXG4gKiBAZWxlbWVudCBvbnMtbmF2aWdhdG9yXG4gKiBAY2F0ZWdvcnkgbmF2aWdhdGlvblxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1cbiAqICAgICBBIGNvbXBvbmVudCB0aGF0IHByb3ZpZGVzIHBhZ2Ugc3RhY2sgbWFuYWdlbWVudCBhbmQgbmF2aWdhdGlvbi4gU3RhY2sgbmF2aWdhdGlvbiBpcyB0aGUgbW9zdCBjb21tb24gbmF2aWdhdGlvbiBwYXR0ZXJuIGZvciBtb2JpbGUgYXBwcy5cbiAqXG4gKiAgICAgV2hlbiBhIHBhZ2UgaXMgcHVzaGVkIG9uIHRvcCBvZiB0aGUgc3RhY2sgaXQgaXMgZGlzcGxheWVkIHdpdGggYSB0cmFuc2l0aW9uIGFuaW1hdGlvbi4gV2hlbiB0aGUgdXNlciByZXR1cm5zIHRvIHRoZSBwcmV2aW91cyBwYWdlIHRoZSB0b3AgcGFnZSB3aWxsIGJlIHBvcHBlZCBmcm9tIHRoZSB0b3Agb2YgdGhlIHN0YWNrIGFuZCBoaWRkZW4gd2l0aCBhbiBvcHBvc2l0ZSB0cmFuc2l0aW9uIGFuaW1hdGlvbi5cbiAqICAgWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAY29kZXBlbiB5cmh0dlxuICogQHR1dG9yaWFsIHZhbmlsbGEvUmVmZXJlbmNlL25hdmlnYXRvclxuICogQGd1aWRlIGxpZmVjeWNsZS5odG1sI2V2ZW50c1xuICogICBbZW5dT3ZlcnZpZXcgb2YgcGFnZSBldmVudHNbL2VuXVxuICogICBbamFdT3ZlcnZpZXcgb2YgcGFnZSBldmVudHNbL2phXVxuICogQHNlZWFsc28gb25zLXRvb2xiYXJcbiAqICAgW2VuXVRoZSBgPG9ucy10b29sYmFyPmAgY29tcG9uZW50IGlzIHVzZWQgdG8gZGlzcGxheSBhIHRvb2xiYXIgb24gdGhlIHRvcCBvZiBhIHBhZ2UuWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAc2VlYWxzbyBvbnMtYmFjay1idXR0b25cbiAqICAgW2VuXVRoZSBgPG9ucy1iYWNrLWJ1dHRvbj5gIGNvbXBvbmVudCBsZXRzIHRoZSB1c2VyIHJldHVybiB0byB0aGUgcHJldmlvdXMgcGFnZS5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBleGFtcGxlXG4gKiA8b25zLW5hdmlnYXRvciBpZD1cIm5hdmlnYXRvclwiPlxuICogICA8b25zLXBhZ2U+XG4gKiAgICAgPG9ucy10b29sYmFyPlxuICogICAgICAgPGRpdiBjbGFzcz1cImNlbnRlclwiPlxuICogICAgICAgICBUaXRsZVxuICogICAgICAgPC9kaXY+XG4gKiAgICAgPC9vbnMtdG9vbGJhcj5cbiAqICAgICA8cD5cbiAqICAgICAgIDxvbnMtYnV0dG9uXG4gKiAgICAgICAgIG9uY2xpY2s9XCJkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbmF2aWdhdG9yJykucHVzaFBhZ2UoJ3BhZ2UuaHRtbCcpXCI+XG4gKiAgICAgICAgIFB1c2ggcGFnZVxuICogICAgICAgPC9vbnMtYnV0dG9uPlxuICogICAgIDwvcD5cbiAqICAgPC9vbnMtcGFnZT5cbiAqIDwvb25zLW5hdmlnYXRvcj5cbiAqXG4gKiA8dGVtcGxhdGUgaWQ9XCJwYWdlLmh0bWxcIj5cbiAqICAgPG9ucy1wYWdlPlxuICogICAgIDxvbnMtdG9vbGJhcj5cbiAqICAgICAgIDxkaXYgY2xhc3M9XCJsZWZ0XCI+XG4gKiAgICAgICAgIDxvbnMtYmFjay1idXR0b24+QmFjazwvb25zLWJhY2stYnV0dG9uPlxuICogICAgICAgPC9kaXY+XG4gKiAgICAgICA8ZGl2IGNsYXNzPVwiY2VudGVyXCI+XG4gKiAgICAgICAgIEFub3RoZXIgcGFnZVxuICogICAgICAgPC9kaXY+XG4gKiAgICAgPC9vbnMtdG9vbGJhcj5cbiAqICAgPC9vbnMtcGFnZT5cbiAqIDwvdGVtcGxhdGU+XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE5hdmlnYXRvckVsZW1lbnQgZXh0ZW5kcyBCYXNlRWxlbWVudCB7XG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgcGFnZVxuICAgKiBAaW5pdG9ubHlcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUZpcnN0IHBhZ2UgdG8gc2hvdyB3aGVuIG5hdmlnYXRvciBpcyBpbml0aWFsaXplZC5bL2VuXVxuICAgKiAgIFtqYV3jg4rjg5PjgrLjg7zjgr/jg7zjgYzliJ3mnJ/ljJbjgZXjgozjgZ/mmYLjgavooajnpLrjgZnjgovjg5rjg7zjgrjjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBzd2lwZWFibGVcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1FbmFibGUgaU9TIFwic3dpcGUgdG8gcG9wXCIgZmVhdHVyZS5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBzd2lwZS10YXJnZXQtd2lkdGhcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlZmF1bHQgMjBweFxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dVGhlIHdpZHRoIG9mIHN3aXBlYWJsZSBhcmVhIGNhbGN1bGF0ZWQgZnJvbSB0aGUgZWRnZSAoaW4gcGl4ZWxzKS4gVXNlIHRoaXMgdG8gZW5hYmxlIHN3aXBlIG9ubHkgd2hlbiB0aGUgZmluZ2VyIHRvdWNoIG9uIHRoZSBzY3JlZW4gZWRnZS5bL2VuXVxuICAgKiAgIFtqYV3jgrnjg6/jgqTjg5fjga7liKTlrprpoJjln5/jgpLjg5Tjgq/jgrvjg6vljZjkvY3jgafmjIflrprjgZfjgb7jgZnjgILnlLvpnaLjga7nq6/jgYvjgonmjIflrprjgZfjgZ/ot53pm6LjgavpgZTjgZnjgovjgajjg5rjg7zjgrjjgYzooajnpLrjgZXjgozjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBzd2lwZS10aHJlc2hvbGRcbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQGRlZmF1bHQgMC4yXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXVNwZWNpZnkgaG93IG11Y2ggdGhlIHBhZ2UgbmVlZHMgdG8gYmUgc3dpcGVkIGJlZm9yZSBwb3BwaW5nLiBBIHZhbHVlIGJldHdlZW4gYDBgIGFuZCBgMWAuWy9lbl1cbiAgICogIFtqYV1bL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBhbmltYXRpb25cbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlZmF1bHQgZGVmYXVsdFxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dXG4gICAqICAgICBBbmltYXRpb24gbmFtZS4gQXZhaWxhYmxlIGFuaW1hdGlvbnMgYXJlIGBcInNsaWRlXCJgLCBgXCJsaWZ0XCJgLCBgXCJmYWRlXCJgIGFuZCBgXCJub25lXCJgLlxuICAgKlxuICAgKiAgICAgVGhlc2UgYXJlIHBsYXRmb3JtIGJhc2VkIGFuaW1hdGlvbnMuIEZvciBmaXhlZCBhbmltYXRpb25zLCBhZGQgYFwiLWlvc1wiYCBvciBgXCItbWRcImAgc3VmZml4IHRvIHRoZSBhbmltYXRpb24gbmFtZS4gRS5nLiBgXCJsaWZ0LWlvc1wiYCwgYFwibGlmdC1tZFwiYC4gRGVmYXVsdHMgdmFsdWVzIGFyZSBgXCJzbGlkZS1pb3NcImAgYW5kIGBcImZhZGUtbWRcImAgZGVwZW5kaW5nIG9uIHRoZSBwbGF0Zm9ybS5cbiAgICogICBbL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBhbmltYXRpb24tb3B0aW9uc1xuICAgKiBAdHlwZSB7RXhwcmVzc2lvbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dU3BlY2lmeSB0aGUgYW5pbWF0aW9uJ3MgZHVyYXRpb24sIHRpbWluZyBhbmQgZGVsYXkgd2l0aCBhbiBvYmplY3QgbGl0ZXJhbC4gRS5nLiBge2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAxLCB0aW1pbmc6ICdlYXNlLWluJ31gWy9lbl1cbiAgICogIFtqYV3jgqLjg4vjg6Hjg7zjgrfjg6fjg7PmmYLjga5kdXJhdGlvbiwgdGltaW5nLCBkZWxheeOCkuOCquODluOCuOOCp+OCr+ODiOODquODhuODqeODq+OBp+aMh+WumuOBl+OBvuOBmeOAgmUuZy4gYHtkdXJhdGlvbjogMC4yLCBkZWxheTogMSwgdGltaW5nOiAnZWFzZS1pbid9YFsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAZXZlbnQgcHJlcHVzaFxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dRmlyZWQganVzdCBiZWZvcmUgYSBwYWdlIGlzIHB1c2hlZC5bL2VuXVxuICAgKiAgIFtqYV1wYWdl44GMcHVzaOOBleOCjOOCi+ebtOWJjeOBq+eZuueBq+OBleOCjOOBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCBbZW5dRXZlbnQgb2JqZWN0LlsvZW5dXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5uYXZpZ2F0b3JcbiAgICogICBbZW5dQ29tcG9uZW50IG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgrPjg7Pjg53jg7zjg43jg7Pjg4jjga7jgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQuY3VycmVudFBhZ2VcbiAgICogICBbZW5dQ3VycmVudCBwYWdlIG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3nj77lnKjjga5wYWdl44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZXZlbnQuY2FuY2VsXG4gICAqICAgW2VuXUNhbGwgdGhpcyBmdW5jdGlvbiB0byBjYW5jZWwgdGhlIHB1c2guWy9lbl1cbiAgICogICBbamFd44GT44Gu6Zai5pWw44KS5ZG844Gz5Ye644GZ44Go44CBcHVzaOWHpueQhuOBjOOCreODo+ODs+OCu+ODq+OBleOCjOOBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAZXZlbnQgcHJlcG9wXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1GaXJlZCBqdXN0IGJlZm9yZSBhIHBhZ2UgaXMgcG9wcGVkLlsvZW5dXG4gICAqICAgW2phXXBhZ2XjgYxwb3DjgZXjgozjgovnm7TliY3jgavnmbrngavjgZXjgozjgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgW2VuXUV2ZW50IG9iamVjdC5bL2VuXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQubmF2aWdhdG9yXG4gICAqICAgW2VuXUNvbXBvbmVudCBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Kz44Oz44Od44O844ON44Oz44OI44Gu44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50LmN1cnJlbnRQYWdlXG4gICAqICAgW2VuXUN1cnJlbnQgcGFnZSBvYmplY3QuWy9lbl1cbiAgICogICBbamFd54++5Zyo44GucGFnZeOCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGV2ZW50LmNhbmNlbFxuICAgKiAgIFtlbl1DYWxsIHRoaXMgZnVuY3Rpb24gdG8gY2FuY2VsIHRoZSBwb3AuWy9lbl1cbiAgICogICBbamFd44GT44Gu6Zai5pWw44KS5ZG844Gz5Ye644GZ44Go44CBcGFnZeOBrnBvcOOBjOOCreODo+ODs+OCu+ODq+OBleOCjOOBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAZXZlbnQgcG9zdHB1c2hcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUZpcmVkIGp1c3QgYWZ0ZXIgYSBwYWdlIGlzIHB1c2hlZC5bL2VuXVxuICAgKiAgIFtqYV1wYWdl44GMcHVzaOOBleOCjOOBpuOCouODi+ODoeODvOOCt+ODp+ODs+OBjOe1guS6huOBl+OBpuOBi+OCieeZuueBq+OBleOCjOOBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCBbZW5dRXZlbnQgb2JqZWN0LlsvZW5dXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5uYXZpZ2F0b3JcbiAgICogICBbZW5dQ29tcG9uZW50IG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgrPjg7Pjg53jg7zjg43jg7Pjg4jjga7jgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQuZW50ZXJQYWdlXG4gICAqICAgW2VuXU9iamVjdCBvZiB0aGUgbmV4dCBwYWdlLlsvZW5dXG4gICAqICAgW2phXXB1c2jjgZXjgozjgZ9wYWdl44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50LmxlYXZlUGFnZVxuICAgKiAgIFtlbl1PYmplY3Qgb2YgdGhlIHByZXZpb3VzIHBhZ2UuWy9lbl1cbiAgICogICBbamFd5Lul5YmN44GucGFnZeOCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAZXZlbnQgcG9zdHBvcFxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dRmlyZWQganVzdCBhZnRlciBhIHBhZ2UgaXMgcG9wcGVkLlsvZW5dXG4gICAqICAgW2phXXBhZ2XjgYxwb3DjgZXjgozjgabjgqLjg4vjg6Hjg7zjgrfjg6fjg7PjgYzntYLjgo/jgaPjgZ/lvozjgavnmbrngavjgZXjgozjgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgW2VuXUV2ZW50IG9iamVjdC5bL2VuXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQubmF2aWdhdG9yXG4gICAqICAgW2VuXUNvbXBvbmVudCBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Kz44Oz44Od44O844ON44Oz44OI44Gu44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50LmVudGVyUGFnZVxuICAgKiAgIFtlbl1PYmplY3Qgb2YgdGhlIG5leHQgcGFnZS5bL2VuXVxuICAgKiAgIFtqYV1wb3DjgZXjgozjgabooajnpLrjgZXjgozjgovjg5rjg7zjgrjjga7jgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQubGVhdmVQYWdlXG4gICAqICAgW2VuXU9iamVjdCBvZiB0aGUgcHJldmlvdXMgcGFnZS5bL2VuXVxuICAgKiAgIFtqYV1wb3DjgZXjgozjgabmtojjgYjjgovjg5rjg7zjgrjjga7jgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKi9cblxuICBnZXQgYW5pbWF0b3JGYWN0b3J5KCkge1xuICAgIHJldHVybiB0aGlzLl9hbmltYXRvckZhY3Rvcnk7XG4gIH1cblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgdGhpcy5faXNSdW5uaW5nID0gZmFsc2U7XG4gICAgdGhpcy5faW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9wYWdlTG9hZGVyID0gZGVmYXVsdFBhZ2VMb2FkZXI7XG4gICAgdGhpcy5fcGFnZU1hcCA9IG5ldyBXZWFrTWFwKCk7XG5cbiAgICB0aGlzLl91cGRhdGVBbmltYXRvckZhY3RvcnkoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgcGFnZUxvYWRlclxuICAgKiBAdHlwZSB7UGFnZUxvYWRlcn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVBhZ2VMb2FkZXIgaW5zdGFuY2UuIEl0IGNhbiBiZSBvdmVycmlkZW4gdG8gY2hhbmdlIHRoZSB3YXkgcGFnZXMgYXJlIGxvYWRlZCBieSB0aGlzIGVsZW1lbnQuIFVzZWZ1bCBmb3IgbGliIGRldmVsb3BlcnMuWy9lbl1cbiAgICogICBbamFdUGFnZUxvYWRlcuOCpOODs+OCueOCv+ODs+OCueOCkuagvOe0jeOBl+OBpuOBhOOBvuOBmeOAglsvamFdXG4gICAqL1xuICBnZXQgcGFnZUxvYWRlcigpIHtcbiAgICByZXR1cm4gdGhpcy5fcGFnZUxvYWRlcjtcbiAgfVxuXG4gIHNldCBwYWdlTG9hZGVyKHBhZ2VMb2FkZXIpIHtcbiAgICBpZiAoIShwYWdlTG9hZGVyIGluc3RhbmNlb2YgUGFnZUxvYWRlcikpIHtcbiAgICAgIHV0aWwudGhyb3dQYWdlTG9hZGVyKCk7XG4gICAgfVxuICAgIHRoaXMuX3BhZ2VMb2FkZXIgPSBwYWdlTG9hZGVyO1xuICB9XG5cbiAgX2dldFBhZ2VUYXJnZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BhZ2UgfHwgdGhpcy5nZXRBdHRyaWJ1dGUoJ3BhZ2UnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgcGFnZVxuICAgKiBAdHlwZSB7Kn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVNwZWNpZnkgdGhlIHBhZ2UgdG8gYmUgbG9hZGVkIGR1cmluZyBpbml0aWFsaXphdGlvbi4gVGhpcyB2YWx1ZSB0YWtlcyBwcmVjZWRlbmNlIG92ZXIgdGhlIGBwYWdlYCBhdHRyaWJ1dGUuIFVzZWZ1bCBmb3IgbGliIGRldmVsb3BlcnMuWy9lbl1cbiAgICogICBbamFd5Yid5pyf5YyW5pmC44Gr6Kqt44G/6L6844KA44Oa44O844K444KS5oyH5a6a44GX44G+44GZ44CCYHBhZ2Vg5bGe5oCn44Gn5oyH5a6a44GX44Gf5YCk44KI44KK44KCYHBhZ2Vg44OX44Ot44OR44OG44Kj44Gr5oyH5a6a44GX44Gf5YCk44KS5YSq5YWI44GX44G+44GZ44CCWy9qYV1cbiAgICovXG4gIGdldCBwYWdlKCkge1xuICAgIHJldHVybiB0aGlzLl9wYWdlO1xuICB9XG5cbiAgc2V0IHBhZ2UocGFnZSkge1xuICAgIHRoaXMuX3BhZ2UgPSBwYWdlO1xuICB9XG5cbiAgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgdGhpcy5vbkRldmljZUJhY2tCdXR0b24gPSB0aGlzLl9vbkRldmljZUJhY2tCdXR0b24uYmluZCh0aGlzKTtcblxuICAgIGlmICghcGxhdGZvcm0uaXNBbmRyb2lkKCkgfHwgdGhpcy5nZXRBdHRyaWJ1dGUoJ3N3aXBlYWJsZScpID09PSAnZm9yY2UnKSB7XG4gICAgICBsZXQgc3dpcGVBbmltYXRvcjtcblxuICAgICAgdGhpcy5fc3dpcGUgPSBuZXcgU3dpcGVSZXZlYWwoe1xuICAgICAgICBlbGVtZW50OiB0aGlzLFxuICAgICAgICBnZXRUaHJlc2hvbGQ6ICgpID0+IE1hdGgubWF4KDAuMiwgcGFyc2VGbG9hdCh0aGlzLmdldEF0dHJpYnV0ZSgnc3dpcGUtdGhyZXNob2xkJykpIHx8IDApLFxuXG4gICAgICAgIHN3aXBlTWF4OiAoKSA9PiB7XG4gICAgICAgICAgdGhpcy5fb25Td2lwZSAmJiB0aGlzLl9vblN3aXBlKDEsIHsgZHVyYXRpb246IHN3aXBlQW5pbWF0b3IuZHVyYXRpb25Td2lwZSwgdGltaW5nOiBzd2lwZUFuaW1hdG9yLnRpbWluZ1N3aXBlIH0pO1xuICAgICAgICAgIHRoaXNbdGhpcy5zd2lwZU1heCA/ICdzd2lwZU1heCcgOiAncG9wUGFnZSddKHsgYW5pbWF0b3I6IHN3aXBlQW5pbWF0b3IgfSk7XG4gICAgICAgICAgc3dpcGVBbmltYXRvciA9IG51bGw7XG4gICAgICAgIH0sXG4gICAgICAgIHN3aXBlTWlkOiAoZGlzdGFuY2UsIHdpZHRoKSA9PiB7XG4gICAgICAgICAgdGhpcy5fb25Td2lwZSAmJiB0aGlzLl9vblN3aXBlKGRpc3RhbmNlL3dpZHRoKTtcbiAgICAgICAgICBzd2lwZUFuaW1hdG9yLnRyYW5zbGF0ZShkaXN0YW5jZSwgd2lkdGgsIHRoaXMudG9wUGFnZS5wcmV2aW91c0VsZW1lbnRTaWJsaW5nLCB0aGlzLnRvcFBhZ2UpO1xuICAgICAgICB9LFxuICAgICAgICBzd2lwZU1pbjogKCkgPT4ge1xuICAgICAgICAgIHRoaXMuX29uU3dpcGUgJiYgdGhpcy5fb25Td2lwZSgwLCB7IGR1cmF0aW9uOiBzd2lwZUFuaW1hdG9yLmR1cmF0aW9uUmVzdG9yZSwgdGltaW5nOiBzd2lwZUFuaW1hdG9yLnRpbWluZ1N3aXBlIH0pO1xuICAgICAgICAgIHN3aXBlQW5pbWF0b3IucmVzdG9yZSh0aGlzLnRvcFBhZ2UucHJldmlvdXNFbGVtZW50U2libGluZywgdGhpcy50b3BQYWdlKTtcbiAgICAgICAgICBzd2lwZUFuaW1hdG9yID0gbnVsbDtcbiAgICAgICAgfSxcblxuICAgICAgICBpZ25vcmVTd2lwZTogKGV2ZW50LCBkaXN0YW5jZSkgPT4ge1xuICAgICAgICAgIC8vIEJhc2ljIGNvbmRpdGlvbnNcbiAgICAgICAgICBpZiAoIXRoaXMuX2lzUnVubmluZyAmJiB0aGlzLmNoaWxkcmVuLmxlbmd0aCA+IDEpIHtcblxuICAgICAgICAgICAgLy8gQXJlYSBvciBkaXJlY3Rpb25hbCBpc3N1ZXNcbiAgICAgICAgICAgIGNvbnN0IGFyZWEgPSBwYXJzZUludCh0aGlzLmdldEF0dHJpYnV0ZSgnc3dpcGUtdGFyZ2V0LXdpZHRoJykgfHwgMjUsIDEwKTtcbiAgICAgICAgICAgIGlmIChldmVudC5nZXN0dXJlLmRpcmVjdGlvbiA9PT0gICdyaWdodCcgJiYgYXJlYSA+IGRpc3RhbmNlKSB7XG5cbiAgICAgICAgICAgICAgLy8gU3dpcGVzIG9uIG9ucy1iYWNrLWJ1dHRvbiBhbmQgaXRzIGNoaWxkcmVuXG4gICAgICAgICAgICAgIGNvbnN0IGlzQkIgPSBlbCA9PiAvb25zLWJhY2stYnV0dG9uL2kudGVzdChlbC50YWdOYW1lKTtcbiAgICAgICAgICAgICAgaWYgKCFpc0JCKGV2ZW50LnRhcmdldCkgJiYgIXV0aWwuZmluZFBhcmVudChldmVudC50YXJnZXQsIGlzQkIsIHAgPT4gL29ucy1wYWdlL2kudGVzdChwLnRhZ05hbWUpKSkge1xuXG4gICAgICAgICAgICAgICAgLy8gQW5pbWF0b3IgaXMgc3dpcGVhYmxlXG4gICAgICAgICAgICAgICAgY29uc3QgYW5pbWF0aW9uID0gKHRoaXMudG9wUGFnZS5wdXNoZWRPcHRpb25zIHx8IHt9KS5hbmltYXRpb24gfHwgdGhpcy5hbmltYXRvckZhY3RvcnkuX2FuaW1hdGlvbjtcbiAgICAgICAgICAgICAgICBjb25zdCBBbmltYXRvciA9IF9hbmltYXRvckRpY3RbYW5pbWF0aW9uXSBpbnN0YW5jZW9mIEZ1bmN0aW9uXG4gICAgICAgICAgICAgICAgICA/IF9hbmltYXRvckRpY3RbYW5pbWF0aW9uXS5jYWxsKClcbiAgICAgICAgICAgICAgICAgIDogX2FuaW1hdG9yRGljdFthbmltYXRpb25dO1xuXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBBbmltYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgQW5pbWF0b3Iuc3dpcGVhYmxlKSB7XG4gICAgICAgICAgICAgICAgICBzd2lwZUFuaW1hdG9yID0gbmV3IEFuaW1hdG9yKCk7IC8vIFByZXBhcmUgZm9yIHRoZSBzd2lwZVxuICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB0cnVlOyAvLyBJZ25vcmUgc3dpcGVcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIHRoaXMuYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKCdzd2lwZWFibGUnKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5faW5pdGlhbGl6ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLl9pbml0aWFsaXplZCA9IHRydWU7XG5cbiAgICBjb25zdCBkZWZlcnJlZCA9IHV0aWwuZGVmZXIoKTtcbiAgICB0aGlzLmxvYWRlZCA9IGRlZmVycmVkLnByb21pc2U7XG5cbiAgICByZXdyaXRhYmxlcy5yZWFkeSh0aGlzLCAoKSA9PiB7XG4gICAgICBjb25zdCBzaG93ID0gIXV0aWwuaGFzQW55Q29tcG9uZW50QXNQYXJlbnQodGhpcyk7XG4gICAgICBjb25zdCBvcHRpb25zID0geyBhbmltYXRpb246ICdub25lJywgc2hvdyB9O1xuXG4gICAgICBpZiAodGhpcy5wYWdlcy5sZW5ndGggPT09IDAgJiYgdGhpcy5fZ2V0UGFnZVRhcmdldCgpKSB7XG4gICAgICAgIHRoaXMucHVzaFBhZ2UodGhpcy5fZ2V0UGFnZVRhcmdldCgpLCBvcHRpb25zKS50aGVuKCgpID0+IGRlZmVycmVkLnJlc29sdmUoKSk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMucGFnZXMubGVuZ3RoID4gMCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucGFnZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2ZXJpZnlQYWdlRWxlbWVudCh0aGlzLnBhZ2VzW2ldKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLnRvcFBhZ2UpIHtcbiAgICAgICAgICBjb250ZW50UmVhZHkodGhpcy50b3BQYWdlLCAoKSA9PlxuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUoKTtcbiAgICAgICAgICAgICAgc2hvdyAmJiB0aGlzLnRvcFBhZ2UuX3Nob3coKTtcbiAgICAgICAgICAgICAgdGhpcy5fdXBkYXRlTGFzdFBhZ2VCYWNrQnV0dG9uKCk7XG4gICAgICAgICAgICB9LCAwKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB7XG4gICAgICAgICAgaWYgKHRoaXMucGFnZXMubGVuZ3RoID09PSAwICYmIHRoaXMuX2dldFBhZ2VUYXJnZXQoKSkge1xuICAgICAgICAgICAgdGhpcy5wdXNoUGFnZSh0aGlzLl9nZXRQYWdlVGFyZ2V0KCksIG9wdGlvbnMpLnRoZW4oKCkgPT4gZGVmZXJyZWQucmVzb2x2ZSgpKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBfdXBkYXRlQW5pbWF0b3JGYWN0b3J5KCkge1xuICAgIHRoaXMuX2FuaW1hdG9yRmFjdG9yeSA9IG5ldyBBbmltYXRvckZhY3Rvcnkoe1xuICAgICAgYW5pbWF0b3JzOiBfYW5pbWF0b3JEaWN0LFxuICAgICAgYmFzZUNsYXNzOiBOYXZpZ2F0b3JBbmltYXRvcixcbiAgICAgIGJhc2VDbGFzc05hbWU6ICdOYXZpZ2F0b3JBbmltYXRvcicsXG4gICAgICBkZWZhdWx0QW5pbWF0aW9uOiB0aGlzLmdldEF0dHJpYnV0ZSgnYW5pbWF0aW9uJylcbiAgICB9KTtcbiAgfVxuXG4gIGRpc2Nvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIHRoaXMuX2JhY2tCdXR0b25IYW5kbGVyLmRlc3Ryb3koKTtcbiAgICB0aGlzLl9iYWNrQnV0dG9uSGFuZGxlciA9IG51bGw7XG5cbiAgICB0aGlzLl9zd2lwZSAmJiB0aGlzLl9zd2lwZS5kaXNwb3NlKCk7XG4gICAgdGhpcy5fc3dpcGUgPSBudWxsO1xuICB9XG5cbiAgc3RhdGljIGdldCBvYnNlcnZlZEF0dHJpYnV0ZXMoKSB7XG4gICAgcmV0dXJuIFsnYW5pbWF0aW9uJywgJ3N3aXBlYWJsZSddO1xuICB9XG5cbiAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIGxhc3QsIGN1cnJlbnQpIHtcbiAgICBzd2l0Y2ggKG5hbWUpIHtcbiAgICAgIGNhc2UgJ2FuaW1hdGlvbic6XG4gICAgICAgIHRoaXMuX3VwZGF0ZUFuaW1hdG9yRmFjdG9yeSgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3N3aXBlYWJsZSc6XG4gICAgICAgIHRoaXMuX3N3aXBlICYmIHRoaXMuX3N3aXBlLnVwZGF0ZSgpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBwb3BQYWdlXG4gICAqIEBzaWduYXR1cmUgcG9wUGFnZShbb3B0aW9uc10pXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogICBbZW5dUGFyYW1ldGVyIG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgqrjg5fjgrfjg6fjg7PjgpLmjIflrprjgZnjgovjgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuYW5pbWF0aW9uXVxuICAgKiAgIFtlbl1cbiAgICogICAgIEFuaW1hdGlvbiBuYW1lLiBBdmFpbGFibGUgYW5pbWF0aW9ucyBhcmUgYFwic2xpZGVcImAsIGBcImxpZnRcImAsIGBcImZhZGVcImAgYW5kIGBcIm5vbmVcImAuXG4gICAqXG4gICAqICAgICBUaGVzZSBhcmUgcGxhdGZvcm0gYmFzZWQgYW5pbWF0aW9ucy4gRm9yIGZpeGVkIGFuaW1hdGlvbnMsIGFkZCBgXCItaW9zXCJgIG9yIGBcIi1tZFwiYCBzdWZmaXggdG8gdGhlIGFuaW1hdGlvbiBuYW1lLiBFLmcuIGBcImxpZnQtaW9zXCJgLCBgXCJsaWZ0LW1kXCJgLiBEZWZhdWx0cyB2YWx1ZXMgYXJlIGBcInNsaWRlLWlvc1wiYCBhbmQgYFwiZmFkZS1tZFwiYC5cbiAgICogICBbL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuYW5pbWF0aW9uT3B0aW9uc11cbiAgICogICBbZW5dU3BlY2lmeSB0aGUgYW5pbWF0aW9uJ3MgZHVyYXRpb24sIGRlbGF5IGFuZCB0aW1pbmcuIEUuZy4gYHtkdXJhdGlvbjogMC4yLCBkZWxheTogMC40LCB0aW1pbmc6ICdlYXNlLWluJ31gLlsvZW5dXG4gICAqICAgW2phXeOCouODi+ODoeODvOOCt+ODp+ODs+aZguOBrmR1cmF0aW9uLCBkZWxheSwgdGltaW5n44KS5oyH5a6a44GX44G+44GZ44CCZS5nLiB7ZHVyYXRpb246IDAuMiwgZGVsYXk6IDAuNCwgdGltaW5nOiAnZWFzZS1pbid9Wy9qYV1cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuY2FsbGJhY2tdXG4gICAqICAgW2VuXUZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIHdoZW4gdGhlIHRyYW5zaXRpb24gaGFzIGVuZGVkLlsvZW5dXG4gICAqICAgW2phXeOBk+OBruODoeOCveODg+ODieOBq+OCiOOCi+eUu+mdoumBt+enu+OBjOe1guS6huOBl+OBn+mam+OBq+WRvOOBs+WHuuOBleOCjOOCi+mWouaVsOOCquODluOCuOOCp+OCr+ODiOOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5kYXRhXVxuICAgKiAgIFtlbl1DdXN0b20gZGF0YSB0aGF0IHdpbGwgYmUgc3RvcmVkIGluIHRoZSBuZXcgcGFnZSBlbGVtZW50LlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy50aW1lc11cbiAgICogICBbZW5dTnVtYmVyIG9mIHBhZ2VzIHRvIGJlIHBvcHBlZC4gT25seSBvbmUgYW5pbWF0aW9uIHdpbGwgYmUgc2hvd24uWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICogICBbZW5dUHJvbWlzZSB3aGljaCByZXNvbHZlcyB0byB0aGUgcmV2ZWFsZWQgcGFnZS5bL2VuXVxuICAgKiAgIFtqYV3mmI7jgonjgYvjgavjgZfjgZ/jg5rjg7zjgrjjgpLop6PmsbrjgZnjgotQcm9taXNl44KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVBvcHMgdGhlIGN1cnJlbnQgcGFnZSBmcm9tIHRoZSBwYWdlIHN0YWNrLiBUaGUgcHJldmlvdXMgcGFnZSB3aWxsIGJlIGRpc3BsYXllZC5bL2VuXVxuICAgKiAgIFtqYV3nj77lnKjooajnpLrkuK3jga7jg5rjg7zjgrjjgpLjg5rjg7zjgrjjgrnjgr/jg4Pjgq/jgYvjgonlj5bjgorpmaTjgY3jgb7jgZnjgILkuIDjgaTliY3jga7jg5rjg7zjgrjjgavmiLvjgorjgb7jgZnjgIJbL2phXVxuICAgKi9cbiAgcG9wUGFnZShvcHRpb25zID0ge30pIHtcbiAgICAoe29wdGlvbnN9ID0gdGhpcy5fcHJlcGFyZVBhZ2VBbmRPcHRpb25zKG51bGwsIG9wdGlvbnMpKTtcblxuICAgIGlmICh1dGlsLmlzSW50ZWdlcihvcHRpb25zLnRpbWVzKSAmJiBvcHRpb25zLnRpbWVzID4gMSkge1xuICAgICAgdGhpcy5fcmVtb3ZlUGFnZXMob3B0aW9ucy50aW1lcyk7XG4gICAgfVxuXG4gICAgY29uc3QgcG9wVXBkYXRlID0gKCkgPT4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgIHRoaXMuX3BhZ2VMb2FkZXIudW5sb2FkKHRoaXMucGFnZXNbdGhpcy5wYWdlcy5sZW5ndGggLSAxXSk7XG4gICAgICByZXNvbHZlKCk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gdGhpcy5fcG9wUGFnZShvcHRpb25zLCBwb3BVcGRhdGUpO1xuICB9XG5cbiAgX3BvcFBhZ2Uob3B0aW9ucywgdXBkYXRlID0gKCkgPT4gUHJvbWlzZS5yZXNvbHZlKCkpIHtcbiAgICBpZiAodGhpcy5faXNSdW5uaW5nKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoJ3BvcFBhZ2UgaXMgYWxyZWFkeSBydW5uaW5nLicpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnBhZ2VzLmxlbmd0aCA8PSAxKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoJ29ucy1uYXZpZ2F0b3JcXCdzIHBhZ2Ugc3RhY2sgaXMgZW1wdHkuJyk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2VtaXRQcmVQb3BFdmVudCgpKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoJ0NhbmNlbGVkIGluIHByZXBvcCBldmVudC4nKTtcbiAgICB9XG5cbiAgICBjb25zdCBsZW5ndGggPSB0aGlzLnBhZ2VzLmxlbmd0aDtcblxuICAgIHRoaXMuX2lzUnVubmluZyA9IHRydWU7XG5cbiAgICB0aGlzLnBhZ2VzW2xlbmd0aCAtIDJdLnVwZGF0ZUJhY2tCdXR0b24oKGxlbmd0aCAtIDIpID4gMCk7XG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICBjb25zdCBsZWF2ZVBhZ2UgPSB0aGlzLnBhZ2VzW2xlbmd0aCAtIDFdO1xuICAgICAgY29uc3QgZW50ZXJQYWdlID0gdGhpcy5wYWdlc1tsZW5ndGggLSAyXTtcblxuICAgICAgb3B0aW9ucyA9IHV0aWwuZXh0ZW5kKHt9LCB0aGlzLm9wdGlvbnMgfHwge30sIGxlYXZlUGFnZS5wdXNoZWRPcHRpb25zIHx8IHt9LCBvcHRpb25zKTtcblxuICAgICAgaWYgKG9wdGlvbnMuZGF0YSkge1xuICAgICAgICBlbnRlclBhZ2UuZGF0YSA9IHV0aWwuZXh0ZW5kKHt9LCBlbnRlclBhZ2UuZGF0YSB8fCB7fSwgb3B0aW9ucy5kYXRhIHx8IHt9KTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgZG9uZSA9ICgpID0+IHtcbiAgICAgICAgdXBkYXRlKCkudGhlbigoKSA9PiB7XG4gICAgICAgICAgdGhpcy5faXNSdW5uaW5nID0gZmFsc2U7XG5cbiAgICAgICAgICBlbnRlclBhZ2UuX3Nob3coKTtcbiAgICAgICAgICB1dGlsLnRyaWdnZXJFbGVtZW50RXZlbnQodGhpcywgJ3Bvc3Rwb3AnLCB7bGVhdmVQYWdlLCBlbnRlclBhZ2UsIG5hdmlnYXRvcjogdGhpc30pO1xuXG4gICAgICAgICAgb3B0aW9ucy5jYWxsYmFjayAmJiBvcHRpb25zLmNhbGxiYWNrKGVudGVyUGFnZSk7XG5cbiAgICAgICAgICByZXNvbHZlKGVudGVyUGFnZSk7XG4gICAgICAgIH0pO1xuICAgICAgfTtcblxuICAgICAgbGVhdmVQYWdlLl9oaWRlKCk7XG4gICAgICBlbnRlclBhZ2Uuc3R5bGUuZGlzcGxheSA9ICcnO1xuXG4gICAgICBjb25zdCBhbmltYXRvciA9IG9wdGlvbnMuYW5pbWF0b3IgfHwgdGhpcy5fYW5pbWF0b3JGYWN0b3J5Lm5ld0FuaW1hdG9yKG9wdGlvbnMpO1xuICAgICAgYW5pbWF0b3IucG9wKHRoaXMucGFnZXNbbGVuZ3RoIC0gMl0sIHRoaXMucGFnZXNbbGVuZ3RoIC0gMV0sIGRvbmUpO1xuICAgIH0pLmNhdGNoKCgpID0+IHRoaXMuX2lzUnVubmluZyA9IGZhbHNlKTtcbiAgfVxuXG5cbiAgLyoqXG4gICAqIEBtZXRob2QgcHVzaFBhZ2VcbiAgICogQHNpZ25hdHVyZSBwdXNoUGFnZShwYWdlLCBbb3B0aW9uc10pXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwYWdlXG4gICAqICAgW2VuXVBhZ2UgVVJMLiBDYW4gYmUgZWl0aGVyIGEgSFRNTCBkb2N1bWVudCBvciBhIHRlbXBsYXRlIGRlZmluZWQgd2l0aCB0aGUgYDx0ZW1wbGF0ZT5gIHRhZy5bL2VuXVxuICAgKiAgIFtqYV1wYWdl44GuVVJM44GL44CB44KC44GX44GP44GvYDx0ZW1wbGF0ZT5g44Gn5a6j6KiA44GX44Gf44OG44Oz44OX44Os44O844OI44GuaWTlsZ7mgKfjga7lgKTjgpLmjIflrprjgafjgY3jgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqICAgW2VuXVBhcmFtZXRlciBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Kq44OX44K344On44Oz44KS5oyH5a6a44GZ44KL44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLnBhZ2VdXG4gICAqICAgW2VuXVBhZ2UgVVJMLiBPbmx5IG5lY2Vzc2FyeSBpZiBgcGFnZWAgcGFyYW1ldGVyIGlzIG51bGwgb3IgdW5kZWZpbmVkLlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5wYWdlSFRNTF1cbiAgICogICBbZW5dSFRNTCBjb2RlIHRoYXQgd2lsbCBiZSBjb21wdXRlZCBhcyBhIG5ldyBwYWdlLiBPdmVyd3JpdGVzIGBwYWdlYCBwYXJhbWV0ZXIuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmFuaW1hdGlvbl1cbiAgICogICBbZW5dXG4gICAqICAgICBBbmltYXRpb24gbmFtZS4gQXZhaWxhYmxlIGFuaW1hdGlvbnMgYXJlIGBcInNsaWRlXCJgLCBgXCJsaWZ0XCJgLCBgXCJmYWRlXCJgIGFuZCBgXCJub25lXCJgLlxuICAgKlxuICAgKiAgICAgVGhlc2UgYXJlIHBsYXRmb3JtIGJhc2VkIGFuaW1hdGlvbnMuIEZvciBmaXhlZCBhbmltYXRpb25zLCBhZGQgYFwiLWlvc1wiYCBvciBgXCItbWRcImAgc3VmZml4IHRvIHRoZSBhbmltYXRpb24gbmFtZS4gRS5nLiBgXCJsaWZ0LWlvc1wiYCwgYFwibGlmdC1tZFwiYC4gRGVmYXVsdHMgdmFsdWVzIGFyZSBgXCJzbGlkZS1pb3NcImAgYW5kIGBcImZhZGUtbWRcImAuXG4gICAqICAgWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmFuaW1hdGlvbk9wdGlvbnNdXG4gICAqICAgW2VuXVNwZWNpZnkgdGhlIGFuaW1hdGlvbidzIGR1cmF0aW9uLCBkZWxheSBhbmQgdGltaW5nLiBFLmcuIGB7ZHVyYXRpb246IDAuMiwgZGVsYXk6IDAuNCwgdGltaW5nOiAnZWFzZS1pbid9YFsvZW5dXG4gICAqICAgW2phXeOCouODi+ODoeODvOOCt+ODp+ODs+aZguOBrmR1cmF0aW9uLCBkZWxheSwgdGltaW5n44KS5oyH5a6a44GX44G+44GZ44CCZS5nLiBge2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAwLjQsIHRpbWluZzogJ2Vhc2UtaW4nfWAgWy9qYV1cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuY2FsbGJhY2tdXG4gICAqICAgW2VuXUZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIHdoZW4gdGhlIHRyYW5zaXRpb24gaGFzIGVuZGVkLlsvZW5dXG4gICAqICAgW2phXXB1c2hQYWdlKCnjgavjgojjgovnlLvpnaLpgbfnp7vjgYzntYLkuobjgZfjgZ/mmYLjgavlkbzjgbPlh7rjgZXjgozjgovplqLmlbDjgqrjg5bjgrjjgqfjgq/jg4jjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuZGF0YV1cbiAgICogICBbZW5dQ3VzdG9tIGRhdGEgdGhhdCB3aWxsIGJlIHN0b3JlZCBpbiB0aGUgbmV3IHBhZ2UgZWxlbWVudC5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKiAgIFtlbl1Qcm9taXNlIHdoaWNoIHJlc29sdmVzIHRvIHRoZSBwdXNoZWQgcGFnZS5bL2VuXVxuICAgKiAgIFtqYV3ov73liqDjgZfjgZ/jg5rjg7zjgrjjgpLop6PmsbrjgZnjgotQcm9taXNl44KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVB1c2hlcyB0aGUgc3BlY2lmaWVkIHBhZ2UgaW50byB0aGUgc3RhY2suWy9lbl1cbiAgICogICBbamFd5oyH5a6a44GX44GfcGFnZeOCkuaWsOOBl+OBhOODmuODvOOCuOOCueOCv+ODg+OCr+OBq+i/veWKoOOBl+OBvuOBmeOAguaWsOOBl+OBhOODmuODvOOCuOOBjOihqOekuuOBleOCjOOBvuOBmeOAglsvamFdXG4gICAqL1xuICBwdXNoUGFnZShwYWdlLCBvcHRpb25zID0ge30pIHtcbiAgICAoe3BhZ2UsIG9wdGlvbnN9ID0gdGhpcy5fcHJlcGFyZVBhZ2VBbmRPcHRpb25zKHBhZ2UsIG9wdGlvbnMpKTtcblxuICAgIGNvbnN0IHByZXBhcmUgPSBwYWdlRWxlbWVudCA9PiB7XG4gICAgICB2ZXJpZnlQYWdlRWxlbWVudChwYWdlRWxlbWVudCk7XG4gICAgICB0aGlzLl9wYWdlTWFwLnNldChwYWdlRWxlbWVudCwgcGFnZSk7XG4gICAgICBwYWdlRWxlbWVudCA9IHV0aWwuZXh0ZW5kKHBhZ2VFbGVtZW50LCB7XG4gICAgICAgIGRhdGE6IG9wdGlvbnMuZGF0YVxuICAgICAgfSk7XG4gICAgICBwYWdlRWxlbWVudC5zdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbic7XG4gICAgfTtcblxuICAgIGlmIChvcHRpb25zLnBhZ2VIVE1MKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcHVzaFBhZ2Uob3B0aW9ucywgKCkgPT4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgIGluc3RhbnRQYWdlTG9hZGVyLmxvYWQoe3BhZ2U6IG9wdGlvbnMucGFnZUhUTUwsIHBhcmVudDogdGhpcywgcGFyYW1zOiBvcHRpb25zLmRhdGF9LCBwYWdlRWxlbWVudCA9PiB7XG4gICAgICAgICAgcHJlcGFyZShwYWdlRWxlbWVudCk7XG4gICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICB9KTtcbiAgICAgIH0pKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fcHVzaFBhZ2Uob3B0aW9ucywgKCkgPT4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICB0aGlzLl9wYWdlTG9hZGVyLmxvYWQoe3BhZ2UsIHBhcmVudDogdGhpcywgcGFyYW1zOiBvcHRpb25zLmRhdGF9LCBwYWdlRWxlbWVudCA9PiB7XG4gICAgICAgIHByZXBhcmUocGFnZUVsZW1lbnQpO1xuICAgICAgICByZXNvbHZlKCk7XG4gICAgICB9KTtcbiAgICB9KSk7XG4gIH1cblxuICBfcHVzaFBhZ2Uob3B0aW9ucyA9IHt9LCB1cGRhdGUgPSAoKSA9PiBQcm9taXNlLnJlc29sdmUoKSkge1xuICAgIGlmICh0aGlzLl9pc1J1bm5pbmcpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdCgncHVzaFBhZ2UgaXMgYWxyZWFkeSBydW5uaW5nLicpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9lbWl0UHJlUHVzaEV2ZW50KCkpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdCgnQ2FuY2VsZWQgaW4gcHJlcHVzaCBldmVudC4nKTtcbiAgICB9XG5cbiAgICB0aGlzLl9pc1J1bm5pbmcgPSB0cnVlO1xuXG4gICAgY29uc3QgYW5pbWF0aW9uT3B0aW9ucyA9IEFuaW1hdG9yRmFjdG9yeS5wYXJzZUFuaW1hdGlvbk9wdGlvbnNTdHJpbmcodGhpcy5nZXRBdHRyaWJ1dGUoJ2FuaW1hdGlvbi1vcHRpb25zJykpO1xuICAgIG9wdGlvbnMgPSB1dGlsLmV4dGVuZCh7fSwgdGhpcy5vcHRpb25zIHx8IHt9LCB7YW5pbWF0aW9uT3B0aW9uc30sIG9wdGlvbnMpO1xuXG4gICAgY29uc3QgYW5pbWF0b3IgPSB0aGlzLl9hbmltYXRvckZhY3RvcnkubmV3QW5pbWF0b3Iob3B0aW9ucyk7XG5cbiAgICByZXR1cm4gdXBkYXRlKCkudGhlbigoKSA9PiB7XG4gICAgICBjb25zdCBwYWdlTGVuZ3RoID0gdGhpcy5wYWdlcy5sZW5ndGg7XG5cbiAgICAgIGNvbnN0IGVudGVyUGFnZSAgPSB0aGlzLnBhZ2VzW3BhZ2VMZW5ndGggLSAxXTtcbiAgICAgIGNvbnN0IGxlYXZlUGFnZSA9IG9wdGlvbnMubGVhdmVQYWdlIHx8IHRoaXMucGFnZXNbcGFnZUxlbmd0aCAtIDJdO1xuXG4gICAgICB2ZXJpZnlQYWdlRWxlbWVudChlbnRlclBhZ2UpO1xuXG4gICAgICBlbnRlclBhZ2UudXBkYXRlQmFja0J1dHRvbihwYWdlTGVuZ3RoID4gKG9wdGlvbnMuX3JlcGxhY2VQYWdlID8gMiA6IDEpKTtcblxuICAgICAgZW50ZXJQYWdlLnB1c2hlZE9wdGlvbnMgPSB1dGlsLmV4dGVuZCh7fSwgZW50ZXJQYWdlLnB1c2hlZE9wdGlvbnMgfHwge30sIG9wdGlvbnMgfHwge30pO1xuICAgICAgZW50ZXJQYWdlLmRhdGEgPSB1dGlsLmV4dGVuZCh7fSwgZW50ZXJQYWdlLmRhdGEgfHwge30sIG9wdGlvbnMuZGF0YSB8fCB7fSk7XG4gICAgICBlbnRlclBhZ2UudW5sb2FkID0gZW50ZXJQYWdlLnVubG9hZCB8fCBvcHRpb25zLnVubG9hZDtcblxuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgICBjb25zdCBkb25lID0gKCkgPT4ge1xuICAgICAgICAgIHRoaXMuX2lzUnVubmluZyA9IGZhbHNlO1xuXG4gICAgICAgICAgb3B0aW9ucy5zaG93ICE9PSBmYWxzZSAmJiBzZXRJbW1lZGlhdGUoKCkgPT4gZW50ZXJQYWdlLl9zaG93KCkpO1xuICAgICAgICAgIHV0aWwudHJpZ2dlckVsZW1lbnRFdmVudCh0aGlzLCAncG9zdHB1c2gnLCB7bGVhdmVQYWdlLCBlbnRlclBhZ2UsIG5hdmlnYXRvcjogdGhpc30pO1xuXG4gICAgICAgICAgaWYgKGxlYXZlUGFnZSkge1xuICAgICAgICAgICAgbGVhdmVQYWdlLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgb3B0aW9ucy5jYWxsYmFjayAmJiBvcHRpb25zLmNhbGxiYWNrKGVudGVyUGFnZSk7XG5cbiAgICAgICAgICByZXNvbHZlKGVudGVyUGFnZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgZW50ZXJQYWdlLnN0eWxlLnZpc2liaWxpdHkgPSAnJztcbiAgICAgICAgaWYgKGxlYXZlUGFnZSkge1xuICAgICAgICAgIGxlYXZlUGFnZS5faGlkZSgpO1xuICAgICAgICAgIGFuaW1hdG9yLnB1c2goZW50ZXJQYWdlLCBsZWF2ZVBhZ2UsIGRvbmUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSkuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICB0aGlzLl9pc1J1bm5pbmcgPSBmYWxzZTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgcmVwbGFjZVBhZ2VcbiAgICogQHNpZ25hdHVyZSByZXBsYWNlUGFnZShwYWdlLCBbb3B0aW9uc10pXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqICAgW2VuXVByb21pc2Ugd2hpY2ggcmVzb2x2ZXMgdG8gdGhlIG5ldyBwYWdlLlsvZW5dXG4gICAqICAgW2phXeaWsOOBl+OBhOODmuODvOOCuOOCkuino+axuuOBmeOCi1Byb21pc2XjgpLov5TjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dUmVwbGFjZXMgdGhlIGN1cnJlbnQgdG9wIHBhZ2Ugd2l0aCB0aGUgc3BlY2lmaWVkIG9uZS4gRXh0ZW5kcyBgcHVzaFBhZ2UoKWAgcGFyYW1ldGVycy5bL2VuXVxuICAgKiAgIFtqYV3nj77lnKjooajnpLrkuK3jga7jg5rjg7zjgrjjgpLjgpLmjIflrprjgZfjgZ/jg5rjg7zjgrjjgavnva7jgY3mj5vjgYjjgb7jgZnjgIJbL2phXVxuICAgKi9cbiAgcmVwbGFjZVBhZ2UocGFnZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgcmV0dXJuIHRoaXMucHVzaFBhZ2UocGFnZSwgb3B0aW9ucylcbiAgICAgIC50aGVuKHJlc29sdmVkVmFsdWUgPT4ge1xuICAgICAgICBpZiAodGhpcy5wYWdlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgdGhpcy5fcGFnZUxvYWRlci51bmxvYWQodGhpcy5wYWdlc1t0aGlzLnBhZ2VzLmxlbmd0aCAtIDJdKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl91cGRhdGVMYXN0UGFnZUJhY2tCdXR0b24oKTtcblxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlc29sdmVkVmFsdWUpO1xuICAgICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBpbnNlcnRQYWdlXG4gICAqIEBzaWduYXR1cmUgaW5zZXJ0UGFnZShpbmRleCwgcGFnZSwgW29wdGlvbnNdKVxuICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXhcbiAgICogICBbZW5dVGhlIGluZGV4IHdoZXJlIGl0IHNob3VsZCBiZSBpbnNlcnRlZC5bL2VuXVxuICAgKiAgIFtqYV3jgrnjgr/jg4Pjgq/jgavmjL/lhaXjgZnjgovkvY3nva7jga7jgqTjg7Pjg4fjg4Pjgq/jgrnjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKiAgIFtlbl1Qcm9taXNlIHdoaWNoIHJlc29sdmVzIHRvIHRoZSBpbnNlcnRlZCBwYWdlLlsvZW5dXG4gICAqICAgW2phXeaMh+WumuOBl+OBn+ODmuODvOOCuOOCkuino+axuuOBmeOCi1Byb21pc2XjgpLov5TjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dSW5zZXJ0IHRoZSBzcGVjaWZpZWQgcGFnZSBpbnRvIHRoZSBzdGFjayB3aXRoIGF0IGEgcG9zaXRpb24gZGVmaW5lZCBieSB0aGUgYGluZGV4YCBhcmd1bWVudC4gRXh0ZW5kcyBgcHVzaFBhZ2UoKWAgcGFyYW1ldGVycy5bL2VuXVxuICAgKiAgIFtqYV3mjIflrprjgZfjgZ9wYWdl44KS44Oa44O844K444K544K/44OD44Kv44GuaW5kZXjjgafmjIflrprjgZfjgZ/kvY3nva7jgavov73liqDjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cbiAgaW5zZXJ0UGFnZShpbmRleCwgcGFnZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgKHtwYWdlLCBvcHRpb25zfSA9IHRoaXMuX3ByZXBhcmVQYWdlQW5kT3B0aW9ucyhwYWdlLCBvcHRpb25zKSk7XG4gICAgaW5kZXggPSB0aGlzLl9ub3JtYWxpemVJbmRleChpbmRleCk7XG5cbiAgICBpZiAoaW5kZXggPj0gdGhpcy5wYWdlcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB0aGlzLnB1c2hQYWdlKHBhZ2UsIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIHBhZ2UgPSB0eXBlb2Ygb3B0aW9ucy5wYWdlSFRNTCA9PT0gJ3N0cmluZycgPyBvcHRpb25zLnBhZ2VIVE1MIDogcGFnZTtcbiAgICBjb25zdCBsb2FkZXIgPSB0eXBlb2Ygb3B0aW9ucy5wYWdlSFRNTCA9PT0gJ3N0cmluZycgPyBpbnN0YW50UGFnZUxvYWRlciA6IHRoaXMuX3BhZ2VMb2FkZXI7XG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICBsb2FkZXIubG9hZCh7cGFnZSwgcGFyZW50OiB0aGlzfSwgcGFnZUVsZW1lbnQgPT4ge1xuICAgICAgICB2ZXJpZnlQYWdlRWxlbWVudChwYWdlRWxlbWVudCk7XG4gICAgICAgIHRoaXMuX3BhZ2VNYXAuc2V0KHBhZ2VFbGVtZW50LCBwYWdlKTtcbiAgICAgICAgcGFnZUVsZW1lbnQgPSB1dGlsLmV4dGVuZChwYWdlRWxlbWVudCwge1xuICAgICAgICAgIGRhdGE6IG9wdGlvbnMuZGF0YSxcbiAgICAgICAgICBwdXNoZWRPcHRpb25zOiBvcHRpb25zXG4gICAgICAgIH0pO1xuXG4gICAgICAgIG9wdGlvbnMuYW5pbWF0aW9uT3B0aW9ucyA9IHV0aWwuZXh0ZW5kKFxuICAgICAgICAgIHt9LFxuICAgICAgICAgIEFuaW1hdG9yRmFjdG9yeS5wYXJzZUFuaW1hdGlvbk9wdGlvbnNTdHJpbmcodGhpcy5nZXRBdHRyaWJ1dGUoJ2FuaW1hdGlvbi1vcHRpb25zJykpLFxuICAgICAgICAgIG9wdGlvbnMuYW5pbWF0aW9uT3B0aW9ucyB8fCB7fVxuICAgICAgICApO1xuXG4gICAgICAgIHBhZ2VFbGVtZW50LnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgIHRoaXMuaW5zZXJ0QmVmb3JlKHBhZ2VFbGVtZW50LCB0aGlzLnBhZ2VzW2luZGV4XSk7XG4gICAgICAgIHRoaXMudG9wUGFnZS51cGRhdGVCYWNrQnV0dG9uKHRydWUpO1xuXG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIHBhZ2VFbGVtZW50ID0gbnVsbDtcbiAgICAgICAgICByZXNvbHZlKHRoaXMucGFnZXNbaW5kZXhdKTtcbiAgICAgICAgfSwgMTAwMCAvIDYwKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgcmVtb3ZlUGFnZVxuICAgKiBAc2lnbmF0dXJlIHJlbW92ZVBhZ2UoaW5kZXgsIFtvcHRpb25zXSlcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4XG4gICAqICAgW2VuXVRoZSBpbmRleCB3aGVyZSBpdCBzaG91bGQgYmUgcmVtb3ZlZC5bL2VuXVxuICAgKiAgIFtqYV3jgrnjgr/jg4Pjgq/jgYvjgonliYrpmaTjgZnjgovjg5rjg7zjgrjjga7jgqTjg7Pjg4fjg4Pjgq/jgrnjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKiAgIFtlbl1Qcm9taXNlIHdoaWNoIHJlc29sdmVzIHRvIHRoZSByZXZlYWxlZCBwYWdlLlsvZW5dXG4gICAqICAgW2phXeWJiumZpOOBq+OCiOOBo+OBpuihqOekuuOBleOCjOOBn+ODmuODvOOCuOOCkuino+axuuOBmeOCi1Byb21pc2XjgpLov5TjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dUmVtb3ZlIHRoZSBzcGVjaWZpZWQgcGFnZSBhdCBhIHBvc2l0aW9uIGluIHRoZSBzdGFjayBkZWZpbmVkIGJ5IHRoZSBgaW5kZXhgIGFyZ3VtZW50LiBFeHRlbmRzIGBwb3BQYWdlKClgIHBhcmFtZXRlcnMuWy9lbl1cbiAgICogICBbamFd5oyH5a6a44GX44Gf44Kk44Oz44OH44OD44Kv44K544Gr44GC44KL44Oa44O844K444KS5YmK6Zmk44GX44G+44GZ44CCWy9qYV1cbiAgICovXG4gIHJlbW92ZVBhZ2UoaW5kZXgsIG9wdGlvbnMgPSB7fSkge1xuICAgIGluZGV4ID0gdGhpcy5fbm9ybWFsaXplSW5kZXgoaW5kZXgpO1xuXG4gICAgaWYgKGluZGV4IDwgdGhpcy5wYWdlcy5sZW5ndGggLSAxKSB7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgIGNvbnN0IGxlYXZlUGFnZSA9IHRoaXMucGFnZXNbaW5kZXhdO1xuICAgICAgICBjb25zdCBlbnRlclBhZ2UgPSB0aGlzLnRvcFBhZ2U7XG5cbiAgICAgICAgdGhpcy5fcGFnZU1hcC5kZWxldGUobGVhdmVQYWdlKTtcbiAgICAgICAgdGhpcy5fcGFnZUxvYWRlci51bmxvYWQobGVhdmVQYWdlKTtcbiAgICAgICAgaWYgKHRoaXMucGFnZXMubGVuZ3RoID09PSAxKSB7IC8vIGVkZ2UgY2FzZVxuICAgICAgICAgIHRoaXMudG9wUGFnZS51cGRhdGVCYWNrQnV0dG9uKGZhbHNlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc29sdmUoZW50ZXJQYWdlKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5wb3BQYWdlKG9wdGlvbnMpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIHJlc2V0VG9QYWdlXG4gICAqIEBzaWduYXR1cmUgcmVzZXRUb1BhZ2UocGFnZSwgW29wdGlvbnNdKVxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKiAgIFtlbl1Qcm9taXNlIHdoaWNoIHJlc29sdmVzIHRvIHRoZSBuZXcgdG9wIHBhZ2UuWy9lbl1cbiAgICogICBbamFd5paw44GX44GE44OI44OD44OX44Oa44O844K444KS6Kej5rG644GZ44KLUHJvbWlzZeOCkui/lOOBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMucG9wXVxuICAgKiAgIFtlbl1QZXJmb3JtcyAncG9wJyBlZmZlY3QgaWYgYHRydWVgIGluc3RlYWQgb2YgJ3B1c2gnIG9yIG5vbmUuIFRoaXMgYWxzbyBzZXRzIGBvcHRpb25zLmFuaW1hdGlvbmAgdmFsdWUgdG8gYGRlZmF1bHRgIGluc3RlYWQgb2YgYG5vbmVgLlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1DbGVhcnMgcGFnZSBzdGFjayBhbmQgYWRkcyB0aGUgc3BlY2lmaWVkIHBhZ2UgdG8gdGhlIHN0YWNrLiBFeHRlbmRzIGBwdXNoUGFnZSgpYCBwYXJhbWV0ZXJzLlsvZW5dXG4gICAqICAgW2phXeODmuODvOOCuOOCueOCv+ODg+OCr+OCkuODquOCu+ODg+ODiOOBl+OAgeaMh+WumuOBl+OBn+ODmuODvOOCuOOCkuihqOekuuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuICByZXNldFRvUGFnZShwYWdlLCBvcHRpb25zID0ge30pIHtcbiAgICAoe3BhZ2UsIG9wdGlvbnN9ID0gdGhpcy5fcHJlcGFyZVBhZ2VBbmRPcHRpb25zKHBhZ2UsIG9wdGlvbnMpKTtcblxuICAgIGlmICghb3B0aW9ucy5hbmltYXRvciAmJiAhb3B0aW9ucy5hbmltYXRpb24gJiYgIW9wdGlvbnMucG9wKSB7XG4gICAgICBvcHRpb25zLmFuaW1hdGlvbiA9ICdub25lJztcbiAgICB9XG5cbiAgICBpZiAoIW9wdGlvbnMucGFnZSAmJiAhb3B0aW9ucy5wYWdlSFRNTCAmJiB0aGlzLl9nZXRQYWdlVGFyZ2V0KCkpIHtcbiAgICAgIHBhZ2UgPSBvcHRpb25zLnBhZ2UgPSB0aGlzLl9nZXRQYWdlVGFyZ2V0KCk7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMucG9wKSB7XG4gICAgICB0aGlzLl9yZW1vdmVQYWdlcygpXG4gICAgICByZXR1cm4gdGhpcy5pbnNlcnRQYWdlKDAsIHBhZ2UsIHsgZGF0YTogb3B0aW9ucy5kYXRhIH0pXG4gICAgICAgIC50aGVuKCgpID0+IHRoaXMucG9wUGFnZShvcHRpb25zKSk7XG4gICAgfVxuXG4gICAgLy8gVGlwOiBjYWxsYmFjayBydW5zIGJlZm9yZSByZXNvbHZlZCBwcm9taXNlXG4gICAgY29uc3QgY2FsbGJhY2sgPSBvcHRpb25zLmNhbGxiYWNrO1xuICAgIG9wdGlvbnMuY2FsbGJhY2sgPSBuZXdQYWdlID0+IHtcbiAgICAgIHRoaXMuX3JlbW92ZVBhZ2VzKClcbiAgICAgIG5ld1BhZ2UudXBkYXRlQmFja0J1dHRvbihmYWxzZSk7XG4gICAgICBjYWxsYmFjayAmJiBjYWxsYmFjayhuZXdQYWdlKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIHRoaXMucHVzaFBhZ2UocGFnZSwgb3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBicmluZ1BhZ2VUb3BcbiAgICogQHNpZ25hdHVyZSBicmluZ1BhZ2VUb3AoaXRlbSwgW29wdGlvbnNdKVxuICAgKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ9IGl0ZW1cbiAgICogICBbZW5dUGFnZSBVUkwgb3IgaW5kZXggb2YgYW4gZXhpc3RpbmcgcGFnZSBpbiBuYXZpZ2F0b3IncyBzdGFjay5bL2VuXVxuICAgKiAgIFtqYV3jg5rjg7zjgrjjga5VUkzjgYvjgoLjgZfjgY/jga9vbnMtbmF2aWdhdG9y44Gu44Oa44O844K444K544K/44OD44Kv44Gu44Kk44Oz44OH44OD44Kv44K55YCk44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICogICBbZW5dUHJvbWlzZSB3aGljaCByZXNvbHZlcyB0byB0aGUgbmV3IHRvcCBwYWdlLlsvZW5dXG4gICAqICAgW2phXeaWsOOBl+OBhOODiOODg+ODl+ODmuODvOOCuOOCkuino+axuuOBmeOCi1Byb21pc2XjgpLov5TjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dQnJpbmdzIHRoZSBnaXZlbiBwYWdlIHRvIHRoZSB0b3Agb2YgdGhlIHBhZ2Ugc3RhY2sgaWYgaXQgYWxyZWFkeSBleGlzdHMgb3IgcHVzaGVzIGl0IGludG8gdGhlIHN0YWNrIGlmIGRvZXNuJ3QuIEV4dGVuZHMgYHB1c2hQYWdlKClgIHBhcmFtZXRlcnMuWy9lbl1cbiAgICogICBbamFd5oyH5a6a44GX44Gf44Oa44O844K444KS44Oa44O844K444K544K/44OD44Kv44Gu5LiA55Wq5LiK44Gr56e75YuV44GX44G+44GZ44CC44KC44GX5oyH5a6a44GX44Gf44Oa44O844K444GM54Sh44GL44Gj44Gf5aC05ZCI5paw44GX44GPcHVzaOOBleOCjOOBvuOBmeOAglsvamFdXG4gICAqL1xuICBicmluZ1BhZ2VUb3AoaXRlbSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgaWYgKFsnbnVtYmVyJywgJ3N0cmluZyddLmluZGV4T2YodHlwZW9mIGl0ZW0pID09PSAtMSkge1xuICAgICAgdXRpbC50aHJvdygnRmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIHBhZ2UgbmFtZSBvciB0aGUgaW5kZXggb2YgYW4gZXhpc3RpbmcgcGFnZS4gWW91IHN1cHBsaWVkICcgKyBpdGVtKTtcbiAgICB9XG4gICAgY29uc3QgaW5kZXggPSB0eXBlb2YgaXRlbSA9PT0gJ251bWJlcicgPyB0aGlzLl9ub3JtYWxpemVJbmRleChpdGVtKSA6IHRoaXMuX2xhc3RJbmRleE9mUGFnZShpdGVtKTtcbiAgICBjb25zdCBwYWdlID0gdGhpcy5wYWdlc1tpbmRleF07XG5cbiAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICByZXR1cm4gdGhpcy5wdXNoUGFnZShpdGVtLCBvcHRpb25zKTtcbiAgICB9XG4gICAgKHtvcHRpb25zfSA9IHRoaXMuX3ByZXBhcmVQYWdlQW5kT3B0aW9ucyhwYWdlLCBvcHRpb25zKSk7XG5cbiAgICBpZiAoaW5kZXggPT09IHRoaXMucGFnZXMubGVuZ3RoIC0gMSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShwYWdlKTtcbiAgICB9XG4gICAgaWYgKCFwYWdlKSB7XG4gICAgICB1dGlsLnRocm93KCdGYWlsZWQgdG8gZmluZCBpdGVtICcgKyBpdGVtKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX2lzUnVubmluZykge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KCdwdXNoUGFnZSBpcyBhbHJlYWR5IHJ1bm5pbmcuJyk7XG4gICAgfVxuICAgIGlmICh0aGlzLl9lbWl0UHJlUHVzaEV2ZW50KCkpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdCgnQ2FuY2VsZWQgaW4gcHJlcHVzaCBldmVudC4nKTtcbiAgICB9XG5cbiAgICBwYWdlLnN0eWxlLmRpc3BsYXkgPSAnJztcbiAgICBwYWdlLnN0eWxlLnZpc2liaWxpdHkgPSAnaGlkZGVuJztcbiAgICBwYWdlLnBhcmVudE5vZGUuYXBwZW5kQ2hpbGQocGFnZSk7XG4gICAgcmV0dXJuIHRoaXMuX3B1c2hQYWdlKG9wdGlvbnMpO1xuICB9XG5cbiAgX3ByZXBhcmVQYWdlQW5kT3B0aW9ucyhwYWdlLCBvcHRpb25zID0ge30pIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgIT0gJ29iamVjdCcpIHtcbiAgICAgIHV0aWwudGhyb3coJ29wdGlvbnMgbXVzdCBiZSBhbiBvYmplY3QuIFlvdSBzdXBwbGllZCAnICsgb3B0aW9ucyk7XG4gICAgfVxuXG4gICAgaWYgKChwYWdlID09PSBudWxsIHx8IHBhZ2UgPT09IHVuZGVmaW5lZCkgJiYgb3B0aW9ucy5wYWdlKSB7XG4gICAgICBwYWdlID0gb3B0aW9ucy5wYWdlO1xuICAgIH1cblxuICAgIG9wdGlvbnMgPSB1dGlsLmV4dGVuZCh7fSwgdGhpcy5vcHRpb25zIHx8IHt9LCBvcHRpb25zLCB7cGFnZX0pO1xuXG4gICAgcmV0dXJuIHtwYWdlLCBvcHRpb25zfTtcbiAgfVxuXG4gIF9yZW1vdmVQYWdlcyh0aW1lcykge1xuICAgIGNvbnN0IHBhZ2VzID0gdGhpcy5wYWdlcztcbiAgICBsZXQgdW50aWwgPSB0aW1lcyA9PT0gdW5kZWZpbmVkID8gMCA6IHBhZ2VzLmxlbmd0aCAtIHRpbWVzO1xuICAgIHVudGlsID0gdW50aWwgPCAwID8gMSA6IHVudGlsO1xuXG4gICAgZm9yIChsZXQgaSA9IHBhZ2VzLmxlbmd0aCAtIDI7IGkgPj0gdW50aWw7IGktLSkge1xuICAgICAgdGhpcy5fcGFnZU1hcC5kZWxldGUocGFnZXNbaV0pO1xuICAgICAgdGhpcy5fcGFnZUxvYWRlci51bmxvYWQocGFnZXNbaV0pO1xuICAgIH1cbiAgfVxuXG4gIF91cGRhdGVMYXN0UGFnZUJhY2tCdXR0b24oKSB7XG4gICAgY29uc3QgaW5kZXggPSB0aGlzLnBhZ2VzLmxlbmd0aCAtIDE7XG4gICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgIHRoaXMucGFnZXNbaW5kZXhdLnVwZGF0ZUJhY2tCdXR0b24oaW5kZXggPiAwKTtcbiAgICB9XG4gIH1cblxuICBfbm9ybWFsaXplSW5kZXgoaW5kZXgpIHtcbiAgICByZXR1cm4gaW5kZXggPj0gMCA/IGluZGV4IDogTWF0aC5hYnModGhpcy5wYWdlcy5sZW5ndGggKyBpbmRleCkgJSB0aGlzLnBhZ2VzLmxlbmd0aDtcbiAgfVxuXG4gIF9vbkRldmljZUJhY2tCdXR0b24oZXZlbnQpIHtcbiAgICBpZiAodGhpcy5wYWdlcy5sZW5ndGggPiAxKSB7XG4gICAgICB0aGlzLnBvcFBhZ2UoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXZlbnQuY2FsbFBhcmVudEhhbmRsZXIoKTtcbiAgICB9XG4gIH1cblxuICBfbGFzdEluZGV4T2ZQYWdlKHBhZ2VOYW1lKSB7XG4gICAgbGV0IGluZGV4O1xuICAgIGZvciAoaW5kZXggPSB0aGlzLnBhZ2VzLmxlbmd0aCAtIDE7IGluZGV4ID49IDA7IGluZGV4LS0pIHtcbiAgICAgIGlmIChwYWdlTmFtZSA9PT0gdGhpcy5fcGFnZU1hcC5nZXQodGhpcy5wYWdlc1tpbmRleF0pKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaW5kZXg7XG4gIH1cblxuICBfZW1pdFByZUV2ZW50KG5hbWUsIGRhdGEgPSB7fSkge1xuICAgIGxldCBpc0NhbmNlbGVkID0gZmFsc2U7XG5cbiAgICB1dGlsLnRyaWdnZXJFbGVtZW50RXZlbnQodGhpcywgJ3ByZScgKyBuYW1lLCB1dGlsLmV4dGVuZCh7XG4gICAgICBuYXZpZ2F0b3I6IHRoaXMsXG4gICAgICBjdXJyZW50UGFnZTogdGhpcy5wYWdlc1t0aGlzLnBhZ2VzLmxlbmd0aCAtIDFdLFxuICAgICAgY2FuY2VsOiAoKSA9PiBpc0NhbmNlbGVkID0gdHJ1ZVxuICAgIH0sIGRhdGEpKTtcblxuICAgIHJldHVybiBpc0NhbmNlbGVkO1xuICB9XG5cbiAgX2VtaXRQcmVQdXNoRXZlbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2VtaXRQcmVFdmVudCgncHVzaCcpO1xuICB9XG5cbiAgX2VtaXRQcmVQb3BFdmVudCgpIHtcbiAgICBjb25zdCBsID0gdGhpcy5wYWdlcy5sZW5ndGg7XG4gICAgcmV0dXJuIHRoaXMuX2VtaXRQcmVFdmVudCgncG9wJywge1xuICAgICAgbGVhdmVQYWdlOiB0aGlzLnBhZ2VzW2wgLSAxXSxcbiAgICAgIGVudGVyUGFnZTogdGhpcy5wYWdlc1tsIC0gMl1cbiAgICB9KTtcbiAgfVxuXG4gIC8vIFRPRE86IOabuOOBjeebtOOBmVxuICBfY3JlYXRlUGFnZUVsZW1lbnQodGVtcGxhdGVIVE1MKSB7XG4gICAgY29uc3QgcGFnZUVsZW1lbnQgPSB1dGlsLmNyZWF0ZUVsZW1lbnQoaW50ZXJuYWwubm9ybWFsaXplUGFnZUhUTUwodGVtcGxhdGVIVE1MKSk7XG4gICAgdmVyaWZ5UGFnZUVsZW1lbnQocGFnZUVsZW1lbnQpO1xuICAgIHJldHVybiBwYWdlRWxlbWVudDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgb25EZXZpY2VCYWNrQnV0dG9uXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1CYWNrLWJ1dHRvbiBoYW5kbGVyLlsvZW5dXG4gICAqICAgW2phXeODkOODg+OCr+ODnOOCv+ODs+ODj+ODs+ODieODqeOAglsvamFdXG4gICAqL1xuICBnZXQgb25EZXZpY2VCYWNrQnV0dG9uKCkge1xuICAgIHJldHVybiB0aGlzLl9iYWNrQnV0dG9uSGFuZGxlcjtcbiAgfVxuXG4gIHNldCBvbkRldmljZUJhY2tCdXR0b24oY2FsbGJhY2spIHtcbiAgICBpZiAodGhpcy5fYmFja0J1dHRvbkhhbmRsZXIpIHtcbiAgICAgIHRoaXMuX2JhY2tCdXR0b25IYW5kbGVyLmRlc3Ryb3koKTtcbiAgICB9XG5cbiAgICB0aGlzLl9iYWNrQnV0dG9uSGFuZGxlciA9IGRldmljZUJhY2tCdXR0b25EaXNwYXRjaGVyLmNyZWF0ZUhhbmRsZXIodGhpcywgY2FsbGJhY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSB0b3BQYWdlXG4gICAqIEByZWFkb25seVxuICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1DdXJyZW50IHRvcCBwYWdlIGVsZW1lbnQuIFVzZSB0aGlzIG1ldGhvZCB0byBhY2Nlc3Mgb3B0aW9ucyBwYXNzZWQgYnkgYHB1c2hQYWdlKClgLWxpa2UgbWV0aG9kcy5bL2VuXVxuICAgKiAgIFtqYV3nj77lnKjjga7jg5rjg7zjgrjjgpLlj5blvpfjgZfjgb7jgZnjgIJwdXNoUGFnZSgp44KEcmVzZXRUb1BhZ2UoKeODoeOCveODg+ODieOBruW8leaVsOOCkuWPluW+l+OBp+OBjeOBvuOBmeOAglsvamFdXG4gICAqL1xuICBnZXQgdG9wUGFnZSgpIHtcbiAgICBsZXQgbGFzdCA9IHRoaXMubGFzdEVsZW1lbnRDaGlsZDtcbiAgICB3aGlsZSAobGFzdCAmJiBsYXN0LnRhZ05hbWUgIT09ICdPTlMtUEFHRScpIHsgbGFzdCA9IGxhc3QucHJldmlvdXNFbGVtZW50U2libGluZzsgfVxuICAgIHJldHVybiBsYXN0O1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBwYWdlc1xuICAgKiBAcmVhZG9ubHlcbiAgICogQHR5cGUge0FycmF5fVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dQ29weSBvZiB0aGUgbmF2aWdhdG9yJ3MgcGFnZSBzdGFjay5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cbiAgZ2V0IHBhZ2VzKCkge1xuICAgIHJldHVybiB1dGlsLmFycmF5RnJvbSh0aGlzLmNoaWxkcmVuKVxuICAgICAgLmZpbHRlcihlbGVtZW50ID0+IGVsZW1lbnQudGFnTmFtZSA9PT0gJ09OUy1QQUdFJyk7XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IG9uU3dpcGVcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dSG9vayBjYWxsZWQgd2hlbmV2ZXIgdGhlIHVzZXIgc2xpZGVzIHRoZSBuYXZpZ2F0b3IgKHN3aXBlLXRvLXBvcCkuIEl0IGdldHMgYSBkZWNpbWFsIHJhdGlvICgwLTEpIGFuZCBhbiBhbmltYXRpb25PcHRpb25zIG9iamVjdCBhcyBhcmd1bWVudHMuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG4gIGdldCBvblN3aXBlKCkge1xuICAgIHJldHVybiB0aGlzLl9vblN3aXBlO1xuICB9XG5cbiAgc2V0IG9uU3dpcGUodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgJiYgISh2YWx1ZSBpbnN0YW5jZW9mIEZ1bmN0aW9uKSkge1xuICAgICAgdXRpbC50aHJvdygnXCJvblN3aXBlXCIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gICAgfVxuICAgIHRoaXMuX29uU3dpcGUgPSB2YWx1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgb3B0aW9uc1xuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dRGVmYXVsdCBvcHRpb25zIG9iamVjdC4gQXR0cmlidXRlcyBoYXZlIHByaW9yaXR5IG92ZXIgdGhpcyBwcm9wZXJ0eS5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQHByb3BlcnR5IG9wdGlvbnMuYW5pbWF0aW9uXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1cbiAgICogICAgIEFuaW1hdGlvbiBuYW1lLiBBdmFpbGFibGUgYW5pbWF0aW9ucyBhcmUgYFwic2xpZGVcImAsIGBcImxpZnRcImAsIGBcImZhZGVcImAgYW5kIGBcIm5vbmVcImAuXG4gICAqICAgICBUaGVzZSBhcmUgcGxhdGZvcm0gYmFzZWQgYW5pbWF0aW9ucy4gRm9yIGZpeGVkIGFuaW1hdGlvbnMsIGFkZCBgXCItaW9zXCJgIG9yIGBcIi1tZFwiYCBzdWZmaXggdG8gdGhlIGFuaW1hdGlvbiBuYW1lLiBFLmcuIGBcImxpZnQtaW9zXCJgLCBgXCJsaWZ0LW1kXCJgLiBEZWZhdWx0cyB2YWx1ZXMgYXJlIGBcInNsaWRlLWlvc1wiYCBhbmQgYFwiZmFkZS1tZFwiYC5cbiAgICogICBbL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQHByb3BlcnR5IG9wdGlvbnMuYW5pbWF0aW9uT3B0aW9uc1xuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dU3BlY2lmeSB0aGUgYW5pbWF0aW9uJ3MgZHVyYXRpb24sIGRlbGF5IGFuZCB0aW1pbmcuIEUuZy4gYHtkdXJhdGlvbjogMC4yLCBkZWxheTogMC40LCB0aW1pbmc6ICdlYXNlLWluJ31gLlsvZW5dXG4gICAqICAgW2phXeOCouODi+ODoeODvOOCt+ODp+ODs+aZguOBrmR1cmF0aW9uLCBkZWxheSwgdGltaW5n44KS5oyH5a6a44GX44G+44GZ44CCZS5nLiBge2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAwLjQsIHRpbWluZzogJ2Vhc2UtaW4nfWAgWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBvcHRpb25zLmNhbGxiYWNrXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1GdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCB3aGVuIHRoZSB0cmFuc2l0aW9uIGhhcyBlbmRlZC5bL2VuXVxuICAgKiAgIFtqYV3jgZPjga7jg6Hjgr3jg4Pjg4njgavjgojjgovnlLvpnaLpgbfnp7vjgYzntYLkuobjgZfjgZ/pmpvjgavlkbzjgbPlh7rjgZXjgozjgovplqLmlbDjgqrjg5bjgrjjgqfjgq/jg4jjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICBnZXQgb3B0aW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy5fb3B0aW9ucztcbiAgfVxuICBzZXQgb3B0aW9ucyhvYmplY3QpIHtcbiAgICB0aGlzLl9vcHRpb25zID0gb2JqZWN0O1xuICB9XG5cbiAgc2V0IF9pc1J1bm5pbmcodmFsdWUpIHtcbiAgICB0aGlzLnNldEF0dHJpYnV0ZSgnX2lzLXJ1bm5pbmcnLCB2YWx1ZSA/ICd0cnVlJyA6ICdmYWxzZScpO1xuICB9XG4gIGdldCBfaXNSdW5uaW5nKCkge1xuICAgcmV0dXJuIEpTT04ucGFyc2UodGhpcy5nZXRBdHRyaWJ1dGUoJ19pcy1ydW5uaW5nJykpO1xuICB9XG5cbiAgX3Nob3coKSB7XG4gICAgdGhpcy5sb2FkZWQudGhlbigoKSA9PiB0aGlzLnRvcFBhZ2UgJiYgdGhpcy50b3BQYWdlLl9zaG93KCkpXG4gIH1cblxuICBfaGlkZSgpIHtcbiAgICB0aGlzLnRvcFBhZ2UgJiYgdGhpcy50b3BQYWdlLl9oaWRlKClcbiAgfVxuXG4gIF9kZXN0cm95KCkge1xuICAgIGZvciAobGV0IGkgPSB0aGlzLnBhZ2VzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB0aGlzLl9wYWdlTG9hZGVyLnVubG9hZCh0aGlzLnBhZ2VzW2ldKTtcbiAgICB9XG5cbiAgICB0aGlzLnJlbW92ZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IEFuaW1hdG9yXG4gICAqL1xuICBzdGF0aWMgcmVnaXN0ZXJBbmltYXRvcihuYW1lLCBBbmltYXRvcikge1xuICAgIGlmICghKEFuaW1hdG9yLnByb3RvdHlwZSBpbnN0YW5jZW9mIE5hdmlnYXRvckFuaW1hdG9yKSkge1xuICAgICAgdXRpbC50aHJvd0FuaW1hdG9yKCdOYXZpZ2F0b3InKTtcbiAgICB9XG5cbiAgICBfYW5pbWF0b3JEaWN0W25hbWVdID0gQW5pbWF0b3I7XG4gIH1cblxuICBzdGF0aWMgZ2V0IGFuaW1hdG9ycygpIHtcbiAgICByZXR1cm4gX2FuaW1hdG9yRGljdDtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgTmF2aWdhdG9yQW5pbWF0b3IoKSB7XG4gICAgcmV0dXJuIE5hdmlnYXRvckFuaW1hdG9yO1xuICB9XG5cbiAgc3RhdGljIGdldCBldmVudHMoKSB7XG4gICAgcmV0dXJuIFsncHJlcHVzaCcsICdwb3N0cHVzaCcsICdwcmVwb3AnLCAncG9zdHBvcCddO1xuICB9XG5cbiAgc3RhdGljIGdldCByZXdyaXRhYmxlcygpIHtcbiAgICByZXR1cm4gcmV3cml0YWJsZXM7XG4gIH1cbn1cblxub25zRWxlbWVudHMuTmF2aWdhdG9yID0gTmF2aWdhdG9yRWxlbWVudDtcbmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnb25zLW5hdmlnYXRvcicsIE5hdmlnYXRvckVsZW1lbnQpO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IG9uc0VsZW1lbnRzIGZyb20gJy4uL29ucy9lbGVtZW50cyc7XG5pbXBvcnQgdXRpbCBmcm9tICcuLi9vbnMvdXRpbCc7XG5pbXBvcnQgaW50ZXJuYWwgZnJvbSAnLi4vb25zL2ludGVybmFsJztcbmltcG9ydCBhdXRvU3R5bGUgZnJvbSAnLi4vb25zL2F1dG9zdHlsZSc7XG5pbXBvcnQgTW9kaWZpZXJVdGlsIGZyb20gJy4uL29ucy9pbnRlcm5hbC9tb2RpZmllci11dGlsJztcbmltcG9ydCBCYXNlRWxlbWVudCBmcm9tICcuL2Jhc2UvYmFzZS1lbGVtZW50JztcbmltcG9ydCBjb250ZW50UmVhZHkgZnJvbSAnLi4vb25zL2NvbnRlbnQtcmVhZHknO1xuXG5jb25zdCBkZWZhdWx0Q2xhc3NOYW1lID0gJ3Rvb2xiYXInO1xuXG5jb25zdCBzY2hlbWUgPSB7XG4gICcnOiAndG9vbGJhci0tKicsXG4gICcudG9vbGJhcl9fbGVmdCc6ICd0b29sYmFyLS0qX19sZWZ0JyxcbiAgJy50b29sYmFyX19jZW50ZXInOiAndG9vbGJhci0tKl9fY2VudGVyJyxcbiAgJy50b29sYmFyX19yaWdodCc6ICd0b29sYmFyLS0qX19yaWdodCdcbn07XG5cbi8qKlxuICogQGVsZW1lbnQgb25zLXRvb2xiYXJcbiAqIEBjYXRlZ29yeSBwYWdlXG4gKiBAbW9kaWZpZXIgbWF0ZXJpYWxcbiAqICAgW2VuXU1hdGVyaWFsIERlc2lnbiB0b29sYmFyLlsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQG1vZGlmaWVyIHRyYW5zcGFyZW50XG4gKiAgIFtlbl1UcmFuc3BhcmVudCB0b29sYmFyLlsvZW5dXG4gKiAgIFtqYV3pgI/mmI7jgarog4zmma/jgpLmjIHjgaTjg4Tjg7zjg6vjg5Djg7zjgpLooajnpLrjgZfjgb7jgZnjgIJbL2phXVxuICogQG1vZGlmaWVyIGNvdmVyLWNvbnRlbnRcbiAqICAgW2VuXURpc3BsYXlzIHRoZSB0b29sYmFyIG9uIHRvcCBvZiB0aGUgcGFnZSdzIGNvbnRlbnQuIFNob3VsZCBiZSBjb21iaW5lZCB3aXRoIGB0cmFuc3BhcmVudGAgbW9kaWZpZXIuWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAbW9kaWZpZXIgbm9zaGFkb3dcbiAqICAgW2VuXVRvb2xiYXIgd2l0aG91dCBzaGFkb3cuWy9lbl1cbiAqICAgW2phXeODhOODvOODq+ODkOODvOOBq+W9seOCkuS7mOOBkeOBmuOBq+ihqOekuuOBl+OBvuOBmeOAglsvamFdXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXVxuICogICAgIFRvb2xiYXIgY29tcG9uZW50IHRoYXQgY2FuIGJlIHVzZWQgd2l0aCBuYXZpZ2F0aW9uLlxuICpcbiAqICAgICBMZWZ0LCBjZW50ZXIgYW5kIHJpZ2h0IGNvbnRhaW5lcnMgY2FuIGJlIHNwZWNpZmllZCBieSBjbGFzcyBuYW1lcy5cbiAqXG4gKiAgICAgVGhpcyBjb21wb25lbnQgd2lsbCBhdXRvbWF0aWNhbGx5IGRpc3BsYXkgYXMgYSBNYXRlcmlhbCBEZXNpZ24gdG9vbGJhciB3aGVuIHJ1bm5pbmcgb24gQW5kcm9pZCBkZXZpY2VzLlxuICogICBbL2VuXVxuICogICBbamFd44OK44OT44Ky44O844K344On44Oz44Gn5L2/55So44GZ44KL44OE44O844Or44OQ44O855So44Kz44Oz44Od44O844ON44Oz44OI44Gn44GZ44CC44Kv44Op44K55ZCN44Gr44KI44KK44CB5bem44CB5Lit5aSu44CB5Y+z44Gu44Kz44Oz44OG44OK44KS5oyH5a6a44Gn44GN44G+44GZ44CCWy9qYV1cbiAqIEBjb2RlcGVuIGFIbUdMXG4gKiBAdHV0b3JpYWwgdmFuaWxsYS9SZWZlcmVuY2UvdG9vbGJhclxuICogQGd1aWRlIGNvbXBpbGF0aW9uLmh0bWwjdG9vbGJhci1jb21waWxhdGlvbiBbZW5dQWRkaW5nIGEgdG9vbGJhclsvZW5dW2phXeODhOODvOODq+ODkOODvOOBrui/veWKoFsvamFdXG4gKiBAc2VlYWxzbyBvbnMtYm90dG9tLXRvb2xiYXJcbiAqICAgW2VuXVRoZSBgPG9ucy1ib3R0b20tdG9vbGJhcj5gIGRpc3BsYXlzIGEgdG9vbGJhciBvbiB0aGUgYm90dG9tIG9mIHRoZSBwYWdlLlsvZW5dXG4gKiAgIFtqYV1vbnMtYm90dG9tLXRvb2xiYXLjgrPjg7Pjg53jg7zjg43jg7Pjg4hbL2phXVxuICogQHNlZWFsc28gb25zLWJhY2stYnV0dG9uXG4gKiAgIFtlbl1UaGUgYDxvbnMtYmFjay1idXR0b24+YCBjb21wb25lbnQgZGlzcGxheXMgYSBiYWNrIGJ1dHRvbiBpbnNpZGUgdGhlIHRvb2xiYXIuWy9lbl1cbiAqICAgW2phXW9ucy1iYWNrLWJ1dHRvbuOCs+ODs+ODneODvOODjeODs+ODiFsvamFdXG4gKiBAc2VlYWxzbyBvbnMtdG9vbGJhci1idXR0b25cbiAqICAgW2VuXVRoZSBgPG9ucy10b29sYmFyLWJ1dHRvbj5gIGNvbXBvbmVudCBkaXNwbGF5cyBhIHRvb2xiYXIgYnV0dG9uIGluc2lkZSB0aGUgdG9vbGJhci5bL2VuXVxuICogICBbamFdb25zLXRvb2xiYXItYnV0dG9u44Kz44Oz44Od44O844ON44Oz44OIWy9qYV1cbiAqIEBleGFtcGxlXG4gKiA8b25zLXBhZ2U+XG4gKiAgIDxvbnMtdG9vbGJhcj5cbiAqICAgICA8ZGl2IGNsYXNzPVwibGVmdFwiPlxuICogICAgICAgPG9ucy1iYWNrLWJ1dHRvbj5cbiAqICAgICAgICAgQmFja1xuICogICAgICAgPC9vbnMtYmFjay1idXR0b24+XG4gKiAgICAgPC9kaXY+XG4gKiAgICAgPGRpdiBjbGFzcz1cImNlbnRlclwiPlxuICogICAgICAgVGl0bGVcbiAqICAgICA8L2Rpdj5cbiAqICAgICA8ZGl2IGNsYXNzPVwicmlnaHRcIj5cbiAqICAgICAgIDxvbnMtdG9vbGJhci1idXR0b24+XG4gKiAgICAgICAgIDxvbnMtaWNvbiBpY29uPVwibWQtbWVudVwiPjwvb25zLWljb24+XG4gKiAgICAgICA8L29ucy10b29sYmFyLWJ1dHRvbj5cbiAqICAgICA8L2Rpdj5cbiAqICAgPC9vbnMtdG9vbGJhcj5cbiAqIDwvb25zLXBhZ2U+XG4gKi9cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVG9vbGJhckVsZW1lbnQgZXh0ZW5kcyBCYXNlRWxlbWVudCB7XG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgaW5saW5lXG4gICAqIEBpbml0b25seVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dRGlzcGxheSB0aGUgdG9vbGJhciBhcyBhbiBpbmxpbmUgZWxlbWVudC5bL2VuXVxuICAgKiAgIFtqYV3jg4Tjg7zjg6vjg5Djg7zjgpLjgqTjg7Pjg6njgqTjg7Pjgavnva7jgY3jgb7jgZnjgILjgrnjgq/jg63jg7zjg6vpoJjln5/lhoXjgavjgZ3jga7jgb7jgb7ooajnpLrjgZXjgozjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBzdGF0aWNcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVN0YXRpYyB0b29sYmFycyBhcmUgbm90IGFuaW1hdGVkIGJ5IGBvbnMtbmF2aWdhdG9yYCB3aGVuIHB1c2hpbmcgb3IgcG9wcGluZyBwYWdlcy4gVGhpcyBjYW4gYmUgdXNlZnVsIHRvIGltcHJvdmUgcGVyZm9ybWFuY2UgaW4gc29tZSBzaXR1YXRpb25zLlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIG1vZGlmaWVyXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1UaGUgYXBwZWFyYW5jZSBvZiB0aGUgdG9vbGJhci5bL2VuXVxuICAgKiAgIFtqYV3jg4Tjg7zjg6vjg5Djg7zjga7ooajnj77jgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHtcbiAgICAgIHRoaXMuX2NvbXBpbGUoKTtcbiAgICB9KTtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgb2JzZXJ2ZWRBdHRyaWJ1dGVzKCkge1xuICAgIHJldHVybiBbJ21vZGlmaWVyJywgJ2NsYXNzJ107XG4gIH1cblxuICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgbGFzdCwgY3VycmVudCkge1xuICAgIHN3aXRjaCAobmFtZSkge1xuICAgICAgY2FzZSAnY2xhc3MnOlxuICAgICAgICB1dGlsLnJlc3RvcmVDbGFzcyh0aGlzLCBkZWZhdWx0Q2xhc3NOYW1lLCBzY2hlbWUpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ21vZGlmaWVyJzpcbiAgICAgICAgTW9kaWZpZXJVdGlsLm9uTW9kaWZpZXJDaGFuZ2VkKGxhc3QsIGN1cnJlbnQsIHRoaXMsIHNjaGVtZSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIHNldFZpc2liaWxpdHlcbiAgICogQHNpZ25hdHVyZSBzZXRWaXNpYmlsaXR5KHZpc2libGUpXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmlzaWJsZVxuICAgKiAgIFtlbl1TZXQgdG8gdHJ1ZSB0byBzaG93IHRoZSB0b29sYmFyLCBmYWxzZSB0byBoaWRlIGl0Wy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVNob3dzIHRoZSB0b29sYmFyIGlmIHZpc2libGUgaXMgdHJ1ZSwgb3RoZXJ3aXNlIGhpZGVzIGl0LlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuICBzZXRWaXNpYmlsaXR5KHZpc2libGUpIHtcbiAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4ge1xuICAgICAgdGhpcy5zdHlsZS5kaXNwbGF5ID0gdmlzaWJsZSA/ICcnIDogJ25vbmUnO1xuXG4gICAgICBpZiAodGhpcy5wYXJlbnROb2RlKSB7XG4gICAgICAgIGNvbnN0IHNpYmxpbmdCYWNrZ3JvdW5kID0gdXRpbC5maW5kQ2hpbGQodGhpcy5wYXJlbnROb2RlLCAnLnBhZ2VfX2JhY2tncm91bmQnKTtcbiAgICAgICAgaWYgKHNpYmxpbmdCYWNrZ3JvdW5kKSB7XG4gICAgICAgICAgc2libGluZ0JhY2tncm91bmQuc3R5bGUudG9wID0gdmlzaWJsZSA/IG51bGwgOiAwO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgc2libGluZ0NvbnRlbnQgPSB1dGlsLmZpbmRDaGlsZCh0aGlzLnBhcmVudE5vZGUsICcucGFnZV9fY29udGVudCcpO1xuICAgICAgICBpZiAoc2libGluZ0NvbnRlbnQpIHtcbiAgICAgICAgICBzaWJsaW5nQ29udGVudC5zdHlsZS50b3AgPSB2aXNpYmxlID8gbnVsbCA6IDA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIHNob3dcbiAgICogQHNpZ25hdHVyZSBzaG93KClcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVNob3cgdGhlIHRvb2xiYXIuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG4gIHNob3coKSB7XG4gICAgdGhpcy5zZXRWaXNpYmlsaXR5KHRydWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgaGlkZVxuICAgKiBAc2lnbmF0dXJlIGhpZGUoKVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dSGlkZSB0aGUgdG9vbGJhci5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cbiAgaGlkZSgpIHtcbiAgICB0aGlzLnNldFZpc2liaWxpdHkoZmFsc2UpO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0hUTUxFbGVtZW50fVxuICAgKi9cbiAgX2dldFRvb2xiYXJMZWZ0SXRlbXNFbGVtZW50KCkge1xuICAgIHJldHVybiB0aGlzLnF1ZXJ5U2VsZWN0b3IoJy5sZWZ0JykgfHwgaW50ZXJuYWwubnVsbEVsZW1lbnQ7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7SFRNTEVsZW1lbnR9XG4gICAqL1xuICBfZ2V0VG9vbGJhckNlbnRlckl0ZW1zRWxlbWVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5xdWVyeVNlbGVjdG9yKCcuY2VudGVyJykgfHwgaW50ZXJuYWwubnVsbEVsZW1lbnQ7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7SFRNTEVsZW1lbnR9XG4gICAqL1xuICBfZ2V0VG9vbGJhclJpZ2h0SXRlbXNFbGVtZW50KCkge1xuICAgIHJldHVybiB0aGlzLnF1ZXJ5U2VsZWN0b3IoJy5yaWdodCcpIHx8IGludGVybmFsLm51bGxFbGVtZW50O1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0hUTUxFbGVtZW50fVxuICAgKi9cbiAgX2dldFRvb2xiYXJCYWNrQnV0dG9uTGFiZWxFbGVtZW50KCkge1xuICAgIHJldHVybiB0aGlzLnF1ZXJ5U2VsZWN0b3IoJ29ucy1iYWNrLWJ1dHRvbiAuYmFjay1idXR0b25fX2xhYmVsJykgfHwgaW50ZXJuYWwubnVsbEVsZW1lbnQ7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7SFRNTEVsZW1lbnR9XG4gICAqL1xuICBfZ2V0VG9vbGJhckJhY2tCdXR0b25JY29uRWxlbWVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5xdWVyeVNlbGVjdG9yKCdvbnMtYmFjay1idXR0b24gLmJhY2stYnV0dG9uX19pY29uJykgfHwgaW50ZXJuYWwubnVsbEVsZW1lbnQ7XG4gIH1cblxuICBfY29tcGlsZSgpIHtcbiAgICBhdXRvU3R5bGUucHJlcGFyZSh0aGlzKTtcbiAgICB0aGlzLmNsYXNzTGlzdC5hZGQoZGVmYXVsdENsYXNzTmFtZSk7XG4gICAgdGhpcy5fZW5zdXJlVG9vbGJhckl0ZW1FbGVtZW50cygpO1xuICAgIE1vZGlmaWVyVXRpbC5pbml0TW9kaWZpZXIodGhpcywgc2NoZW1lKTtcbiAgfVxuXG4gIF9lbnN1cmVUb29sYmFySXRlbUVsZW1lbnRzKCkge1xuICAgIGZvciAobGV0IGkgPSB0aGlzLmNoaWxkTm9kZXMubGVuZ3RoIC0gMTsgaSA+PSAwIDsgaS0tKSB7XG4gICAgICAvLyBjYXNlIG9mIG5vdCBlbGVtZW50XG4gICAgICBpZiAodGhpcy5jaGlsZE5vZGVzW2ldLm5vZGVUeXBlICE9IDEpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVDaGlsZCh0aGlzLmNoaWxkTm9kZXNbaV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGNlbnRlciA9IHRoaXMuX2Vuc3VyZVRvb2xiYXJFbGVtZW50KCdjZW50ZXInKTtcbiAgICBjZW50ZXIuY2xhc3NMaXN0LmFkZCgndG9vbGJhcl9fdGl0bGUnKTtcblxuICAgIGlmICh0aGlzLmNoaWxkcmVuLmxlbmd0aCAhPT0gMSB8fCAhdGhpcy5jaGlsZHJlblswXS5jbGFzc0xpc3QuY29udGFpbnMoJ2NlbnRlcicpKSB7XG4gICAgICBjb25zdCBsZWZ0ID0gdGhpcy5fZW5zdXJlVG9vbGJhckVsZW1lbnQoJ2xlZnQnKTtcbiAgICAgIGNvbnN0IHJpZ2h0ID0gdGhpcy5fZW5zdXJlVG9vbGJhckVsZW1lbnQoJ3JpZ2h0Jyk7XG5cbiAgICAgIGlmICh0aGlzLmNoaWxkcmVuWzBdICE9PSBsZWZ0IHx8IHRoaXMuY2hpbGRyZW5bMV0gIT09IGNlbnRlciB8fCB0aGlzLmNoaWxkcmVuWzJdICE9PSByaWdodCkge1xuICAgICAgICB0aGlzLmFwcGVuZENoaWxkKGxlZnQpO1xuICAgICAgICB0aGlzLmFwcGVuZENoaWxkKGNlbnRlcik7XG4gICAgICAgIHRoaXMuYXBwZW5kQ2hpbGQocmlnaHQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIF9lbnN1cmVUb29sYmFyRWxlbWVudChuYW1lKSB7XG4gICAgaWYgKHV0aWwuZmluZENoaWxkKHRoaXMsICcudG9vbGJhcl9fJyArIG5hbWUpKSB7XG4gICAgICBjb25zdCBlbGVtZW50ID0gdXRpbC5maW5kQ2hpbGQodGhpcywgJy50b29sYmFyX18nICsgbmFtZSk7XG4gICAgICBlbGVtZW50LmNsYXNzTGlzdC5hZGQobmFtZSk7XG4gICAgICByZXR1cm4gZWxlbWVudDtcbiAgICB9XG5cbiAgICBjb25zdCBlbGVtZW50ID0gdXRpbC5maW5kQ2hpbGQodGhpcywgJy4nICsgbmFtZSkgfHwgdXRpbC5jcmVhdGUoJy4nICsgbmFtZSk7XG4gICAgZWxlbWVudC5jbGFzc0xpc3QuYWRkKCd0b29sYmFyX18nICsgbmFtZSk7XG5cbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxufVxuXG5vbnNFbGVtZW50cy5Ub29sYmFyID0gVG9vbGJhckVsZW1lbnQ7XG5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ29ucy10b29sYmFyJywgVG9vbGJhckVsZW1lbnQpO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IG9uc0VsZW1lbnRzIGZyb20gJy4uL29ucy9lbGVtZW50cyc7XG5pbXBvcnQgdXRpbCBmcm9tICcuLi9vbnMvdXRpbCc7XG5pbXBvcnQgaW50ZXJuYWwgZnJvbSAnLi4vb25zL2ludGVybmFsJztcbmltcG9ydCBhdXRvU3R5bGUgZnJvbSAnLi4vb25zL2F1dG9zdHlsZSc7XG5pbXBvcnQgTW9kaWZpZXJVdGlsIGZyb20gJy4uL29ucy9pbnRlcm5hbC9tb2RpZmllci11dGlsJztcbmltcG9ydCBCYXNlRWxlbWVudCBmcm9tICcuL2Jhc2UvYmFzZS1lbGVtZW50JztcbmltcG9ydCBkZXZpY2VCYWNrQnV0dG9uRGlzcGF0Y2hlciBmcm9tICcuLi9vbnMvaW50ZXJuYWwvZGV2aWNlLWJhY2stYnV0dG9uLWRpc3BhdGNoZXInO1xuaW1wb3J0IGNvbnRlbnRSZWFkeSBmcm9tICcuLi9vbnMvY29udGVudC1yZWFkeSc7XG5cbmltcG9ydCAnLi9vbnMtdG9vbGJhcic7IC8vIGVuc3VyZXMgdGhhdCAnb25zLXRvb2xiYXInIGVsZW1lbnQgaXMgcmVnaXN0ZXJlZFxuXG5jb25zdCBkZWZhdWx0Q2xhc3NOYW1lID0gJ3BhZ2UnO1xuY29uc3Qgc2NoZW1lID0ge1xuICAnJzogJ3BhZ2UtLSonLFxuICAnLnBhZ2VfX2NvbnRlbnQnOiAncGFnZS0tKl9fY29udGVudCcsXG4gICcucGFnZV9fYmFja2dyb3VuZCc6ICdwYWdlLS0qX19iYWNrZ3JvdW5kJ1xufTtcblxuLyoqXG4gKiBAZWxlbWVudCBvbnMtcGFnZVxuICogQGNhdGVnb3J5IHBhZ2VcbiAqIEBtb2RpZmllciBtYXRlcmlhbFxuICogICBbZW5dTWF0ZXJpYWwgRGVzaWduIHN0eWxlWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXVxuICogICAgIFRoaXMgY29tcG9uZW50IGRlZmluZXMgdGhlIHJvb3Qgb2YgZWFjaCBwYWdlLiBJZiB0aGUgY29udGVudCBpcyBsYXJnZSBpdCB3aWxsIGJlY29tZSBzY3JvbGxhYmxlLlxuICpcbiAqICAgICBBIG5hdmlnYXRpb24gYmFyIGNhbiBiZSBhZGRlZCB0byB0aGUgdG9wIG9mIHRoZSBwYWdlIHVzaW5nIHRoZSBgPG9ucy10b29sYmFyPmAgZWxlbWVudC5cbiAqICAgWy9lbl1cbiAqICAgW2phXeODmuODvOOCuOWumue+qeOBruOBn+OCgeOBruOCs+ODs+ODneODvOODjeODs+ODiOOBp+OBmeOAguOBk+OBruOCs+ODs+ODneODvOODjeODs+ODiOOBruWGheWuueOBr+OCueOCr+ODreODvOODq+OBjOioseWPr+OBleOCjOOBvuOBmeOAglsvamFdXG4gKiBAdHV0b3JpYWwgdmFuaWxsYS9SZWZlcmVuY2UvcGFnZVxuICogQGd1aWRlIGxpZmVjeWNsZS5odG1sI2V2ZW50c1xuICogICBbZW5dT3ZlcnZpZXcgb2YgcGFnZSBldmVudHNbL2VuXVxuICogICBbamFdT3ZlcnZpZXcgb2YgcGFnZSBldmVudHNbL2phXVxuICogQGd1aWRlIGZ1bmRhbWVudGFscy5odG1sI21hbmFnaW5nLXBhZ2VzXG4gKiAgIFtlbl1NYW5hZ2luZyBtdWx0aXBsZSBwYWdlc1svZW5dXG4gKiAgIFtqYV3opIfmlbDjga7jg5rjg7zjgrjjgpLnrqHnkIbjgZnjgotbL2phXVxuICogQGd1aWRlIHRoZW1pbmcuaHRtbCNtb2RpZmllcnMgW2VuXU1vcmUgZGV0YWlscyBhYm91dCB0aGUgYG1vZGlmaWVyYCBhdHRyaWJ1dGVbL2VuXVtqYV1tb2RpZmllcuWxnuaAp+OBruS9v+OBhOaWuVsvamFdXG4gKiBAc2VlYWxzbyBvbnMtdG9vbGJhclxuICogICBbZW5dVXNlIHRoZSBgPG9ucy10b29sYmFyPmAgZWxlbWVudCB0byBhZGQgYSBuYXZpZ2F0aW9uIGJhciB0byB0aGUgdG9wIG9mIHRoZSBwYWdlLlsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQGV4YW1wbGVcbiAqIDxvbnMtcGFnZT5cbiAqICAgPG9ucy10b29sYmFyPlxuICogICAgIDxkaXYgY2xhc3M9XCJsZWZ0XCI+XG4gKiAgICAgICA8b25zLWJhY2stYnV0dG9uPkJhY2s8L29ucy1iYWNrLWJ1dHRvbj5cbiAqICAgICA8L2Rpdj5cbiAqICAgICA8ZGl2IGNsYXNzPVwiY2VudGVyXCI+VGl0bGU8L2Rpdj5cbiAqICAgICA8ZGl2IGNsYXNzPVwicmlnaHRcIj5cbiAqICAgICAgIDxvbnMtdG9vbGJhci1idXR0b24+XG4gKiAgICAgICAgIDxvbnMtaWNvbiBpY29uPVwibWQtbWVudVwiPjwvb25zLWljb24+XG4gKiAgICAgICA8L29ucy10b29sYmFyLWJ1dHRvbj5cbiAqICAgICA8L2Rpdj5cbiAqICAgPC9vbnMtdG9vbGJhcj5cbiAqXG4gKiAgIDxwPlBhZ2UgY29udGVudDwvcD5cbiAqIDwvb25zLXBhZ2U+XG4gKlxuICogQGV4YW1wbGVcbiAqIDxzY3JpcHQ+XG4gKiAgIG15QXBwLmhhbmRsZXIgPSBmdW5jdGlvbihkb25lKSB7XG4gKiAgICAgbG9hZE1vcmUoKS50aGVuKGRvbmUpO1xuICogICB9XG4gKiA8L3NjcmlwdD5cbiAqXG4gKiA8b25zLXBhZ2Ugb24taW5maW5pdGUtc2Nyb2xsPVwibXlBcHAuaGFuZGxlclwiPlxuICogICA8b25zLXRvb2xiYXI+XG4gKiAgICAgPGRpdiBjbGFzcz1cImNlbnRlclwiPkxpc3Q8L2Rpdj5cbiAqICAgPC9vbnMtdG9vbGJhcj5cbiAqXG4gKiAgIDxvbnMtbGlzdD5cbiAqICAgICA8b25zLWxpc3QtaXRlbT4jMTwvb25zLWxpc3QtaXRlbT5cbiAqICAgICA8b25zLWxpc3QtaXRlbT4jMjwvb25zLWxpc3QtaXRlbT5cbiAqICAgICA8b25zLWxpc3QtaXRlbT4jMzwvb25zLWxpc3QtaXRlbT5cbiAqICAgICAuLi5cbiAqICAgPC9vbnMtbGlzdD5cbiAqIDwvb25zLXBhZ2U+XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFBhZ2VFbGVtZW50IGV4dGVuZHMgQmFzZUVsZW1lbnQge1xuXG4gIC8qKlxuICAgKiBAZXZlbnQgaW5pdFxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dRmlyZWQgcmlnaHQgYWZ0ZXIgdGhlIHBhZ2UgaXMgYXR0YWNoZWQuWy9lbl1cbiAgICogICBbamFd44Oa44O844K444GM44Ki44K/44OD44OB44GV44KM44Gf5b6M44Gr55m654Gr44GX44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IFtlbl1FdmVudCBvYmplY3QuWy9lbl1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBldmVudCBzaG93XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1GaXJlZCByaWdodCBhZnRlciB0aGUgcGFnZSBpcyBzaG93bi5bL2VuXVxuICAgKiAgIFtqYV3jg5rjg7zjgrjjgYzooajnpLrjgZXjgozjgZ/lvozjgavnmbrngavjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgW2VuXUV2ZW50IG9iamVjdC5bL2VuXVxuICAgKi9cblxuICAvKipcbiAgICogQGV2ZW50IGhpZGVcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUZpcmVkIHJpZ2h0IGFmdGVyIHRoZSBwYWdlIGlzIGhpZGRlbi5bL2VuXVxuICAgKiAgIFtqYV3jg5rjg7zjgrjjgYzpmqDjgozjgZ/lvozjgavnmbrngavjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgW2VuXUV2ZW50IG9iamVjdC5bL2VuXVxuICAgKi9cblxuICAvKipcbiAgICogQGV2ZW50IGRlc3Ryb3lcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUZpcmVkIHJpZ2h0IGJlZm9yZSB0aGUgcGFnZSBpcyBkZXN0cm95ZWQuWy9lbl1cbiAgICogICBbamFd44Oa44O844K444GM56C05qOE44GV44KM44KL5YmN44Gr55m654Gr44GX44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IFtlbl1FdmVudCBvYmplY3QuWy9lbl1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgbW9kaWZpZXJcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVNwZWNpZnkgbW9kaWZpZXIgbmFtZSB0byBzcGVjaWZ5IGN1c3RvbSBzdHlsZXMuWy9lbl1cbiAgICogICBbamFd44K544K/44Kk44Or5a6a576p44KS44Kr44K544K/44Oe44Kk44K644GZ44KL44Gf44KB44Gu5ZCN5YmN44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgb24taW5maW5pdGUtc2Nyb2xsXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1QYXRoIG9mIHRoZSBmdW5jdGlvbiB0byBiZSBleGVjdXRlZCBvbiBpbmZpbml0ZSBzY3JvbGxpbmcuIEV4YW1wbGU6IGBhcHAubG9hZERhdGFgLiBUaGUgZnVuY3Rpb24gcmVjZWl2ZXMgYSBkb25lIGNhbGxiYWNrIHRoYXQgbXVzdCBiZSBjYWxsZWQgd2hlbiBpdCdzIGZpbmlzaGVkLlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG5cbiAgICB0aGlzLl9kZXJpdmVIb29rcygpO1xuXG4gICAgdGhpcy5fZGVmYXVsdENsYXNzTmFtZSA9IGRlZmF1bHRDbGFzc05hbWU7XG4gICAgdGhpcy5jbGFzc0xpc3QuYWRkKGRlZmF1bHRDbGFzc05hbWUpO1xuXG4gICAgdGhpcy5faW5pdGlhbGl6ZWQgPSBmYWxzZTtcblxuICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB7XG4gICAgICB0aGlzLl9jb21waWxlKCk7XG5cbiAgICAgIHRoaXMuX2lzU2hvd24gPSBmYWxzZTtcbiAgICAgIHRoaXMuX2NvbnRlbnRFbGVtZW50ID0gdGhpcy5fZ2V0Q29udGVudEVsZW1lbnQoKTtcbiAgICAgIHRoaXMuX2JhY2tncm91bmRFbGVtZW50ID0gdGhpcy5fZ2V0QmFja2dyb3VuZEVsZW1lbnQoKTtcbiAgICB9KTtcbiAgfVxuXG4gIF9jb21waWxlKCkge1xuICAgIGF1dG9TdHlsZS5wcmVwYXJlKHRoaXMpO1xuXG4gICAgY29uc3QgdG9vbGJhciA9IHV0aWwuZmluZENoaWxkKHRoaXMsICdvbnMtdG9vbGJhcicpO1xuXG4gICAgY29uc3QgYmFja2dyb3VuZCA9IHV0aWwuZmluZENoaWxkKHRoaXMsICcucGFnZV9fYmFja2dyb3VuZCcpIHx8IHV0aWwuZmluZENoaWxkKHRoaXMsICcuYmFja2dyb3VuZCcpIHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGJhY2tncm91bmQuY2xhc3NMaXN0LmFkZCgncGFnZV9fYmFja2dyb3VuZCcpO1xuICAgIHRoaXMuaW5zZXJ0QmVmb3JlKGJhY2tncm91bmQsICF0b29sYmFyICYmIHRoaXMuZmlyc3RDaGlsZCB8fCB0b29sYmFyICYmIHRvb2xiYXIubmV4dFNpYmxpbmcpO1xuXG4gICAgY29uc3QgY29udGVudCA9IHV0aWwuZmluZENoaWxkKHRoaXMsICcucGFnZV9fY29udGVudCcpIHx8IHV0aWwuZmluZENoaWxkKHRoaXMsICcuY29udGVudCcpIHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGNvbnRlbnQuY2xhc3NMaXN0LmFkZCgncGFnZV9fY29udGVudCcpO1xuICAgIGlmICghY29udGVudC5wYXJlbnRFbGVtZW50KSB7XG4gICAgICB1dGlsLmFycmF5RnJvbSh0aGlzLmNoaWxkTm9kZXMpLmZvckVhY2gobm9kZSA9PiB7XG4gICAgICAgIGlmIChub2RlLm5vZGVUeXBlICE9PSAxIHx8IHRoaXMuX2VsZW1lbnRTaG91bGRCZU1vdmVkKG5vZGUpKSB7XG4gICAgICAgICAgY29udGVudC5hcHBlbmRDaGlsZChub2RlKTsgLy8gQ2FuIHRyaWdnZXIgZGV0YWNoZWQgY29ubmVjdGVkQ2FsbGJhY2tzXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHRoaXMuX3RyeVRvRmlsbFN0YXR1c0Jhcihjb250ZW50KTsgLy8gTXVzdCBydW4gYmVmb3JlIGNoaWxkIHBhZ2VzIHRyeSB0byBmaWxsIHN0YXR1cyBiYXIuXG4gICAgdGhpcy5pbnNlcnRCZWZvcmUoY29udGVudCwgYmFja2dyb3VuZC5uZXh0U2libGluZyk7IC8vIENhbiB0cmlnZ2VyIGF0dGFjaGVkIGNvbm5lY3RlZENhbGxiYWNrc1xuXG4gICAgaWYgKCghdG9vbGJhciB8fCAhdXRpbC5oYXNNb2RpZmllcih0b29sYmFyLCAndHJhbnNwYXJlbnQnKSlcbiAgICAgICYmIGNvbnRlbnQuY2hpbGRyZW4ubGVuZ3RoID09PSAxXG4gICAgICAmJiB1dGlsLmlzUGFnZUNvbnRyb2woY29udGVudC5jaGlsZHJlblswXSlcbiAgICApIHtcbiAgICAgIHRoaXMuX2RlZmF1bHRDbGFzc05hbWUgKz0gJyBwYWdlLS13cmFwcGVyJztcbiAgICAgIHRoaXMuYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKCdjbGFzcycpO1xuICAgIH1cblxuICAgIGNvbnN0IGJvdHRvbVRvb2xiYXIgPSB1dGlsLmZpbmRDaGlsZCh0aGlzLCAnb25zLWJvdHRvbS10b29sYmFyJyk7XG4gICAgaWYgKGJvdHRvbVRvb2xiYXIpIHtcbiAgICAgIHRoaXMuX2RlZmF1bHRDbGFzc05hbWUgKz0gJyBwYWdlLXdpdGgtYm90dG9tLXRvb2xiYXInO1xuICAgICAgdGhpcy5hdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2soJ2NsYXNzJyk7XG4gICAgfVxuXG4gICAgTW9kaWZpZXJVdGlsLmluaXRNb2RpZmllcih0aGlzLCBzY2hlbWUpO1xuICB9XG5cbiAgX2VsZW1lbnRTaG91bGRCZU1vdmVkKGVsKSB7XG4gICAgaWYgKGVsLmNsYXNzTGlzdC5jb250YWlucygncGFnZV9fYmFja2dyb3VuZCcpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IHRhZ05hbWUgPSBlbC50YWdOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgaWYgKHRhZ05hbWUgPT09ICdvbnMtZmFiJykge1xuICAgICAgcmV0dXJuICFlbC5oYXNBdHRyaWJ1dGUoJ3Bvc2l0aW9uJyk7XG4gICAgfVxuICAgIGNvbnN0IGZpeGVkRWxlbWVudHMgPSBbJ3NjcmlwdCcsICdvbnMtdG9vbGJhcicsICdvbnMtYm90dG9tLXRvb2xiYXInLCAnb25zLW1vZGFsJywgJ29ucy1zcGVlZC1kaWFsJywgJ29ucy1kaWFsb2cnLCAnb25zLWFsZXJ0LWRpYWxvZycsICdvbnMtcG9wb3ZlcicsICdvbnMtYWN0aW9uLXNoZWV0J107XG4gICAgcmV0dXJuIGVsLmhhc0F0dHJpYnV0ZSgnaW5saW5lJykgfHwgZml4ZWRFbGVtZW50cy5pbmRleE9mKHRhZ05hbWUpID09PSAtMTtcbiAgfVxuXG4gIF90cnlUb0ZpbGxTdGF0dXNCYXIoY29udGVudCA9IHRoaXMuX2NvbnRlbnRFbGVtZW50KSB7XG4gICAgaW50ZXJuYWwuYXV0b1N0YXR1c0JhckZpbGwoKCkgPT4ge1xuICAgICAgdXRpbC50b2dnbGVBdHRyaWJ1dGUodGhpcywgJ3N0YXR1cy1iYXItZmlsbCcsXG4gICAgICAgICF1dGlsLmZpbmRQYXJlbnQodGhpcywgZSA9PiBlLmhhc0F0dHJpYnV0ZSgnc3RhdHVzLWJhci1maWxsJykpIC8vIE5vdCBhbHJlYWR5IGZpbGxlZFxuICAgICAgICAmJiAodGhpcy5fY2FuQW5pbWF0ZVRvb2xiYXIoY29udGVudCkgfHwgIXV0aWwuZmluZENoaWxkKGNvbnRlbnQsIHV0aWwuaXNQYWdlQ29udHJvbCkpIC8vIEhhcyB0b29sYmFyIG9yIGNhbm5vdCBkZWxlZ2F0ZVxuICAgICAgKTtcbiAgICB9KTtcbiAgfVxuXG4gIF9jYW5BbmltYXRlVG9vbGJhcihjb250ZW50ID0gdGhpcy5fY29udGVudEVsZW1lbnQpIHtcbiAgICBpZiAodXRpbC5maW5kQ2hpbGQodGhpcywgJ29ucy10b29sYmFyJykpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiAhIXV0aWwuZmluZENoaWxkKGNvbnRlbnQsIGVsID0+IHtcbiAgICAgIHJldHVybiB1dGlsLm1hdGNoKGVsLCAnb25zLXRvb2xiYXInKSAmJiAhZWwuaGFzQXR0cmlidXRlKCdpbmxpbmUnKTtcbiAgICB9KTtcbiAgfVxuXG4gIGNvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIGlmICghdXRpbC5pc0F0dGFjaGVkKHRoaXMpKSB7IC8vIEF2b2lkIGRldGFjaGVkIGNhbGxzXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHtcbiAgICAgIHRoaXMuX3RyeVRvRmlsbFN0YXR1c0JhcigpOyAvLyBFbnN1cmUgc3RhdHVzIGJhciB3aGVuIHRoZSBlbGVtZW50IHdhcyBjb21waWxlZCBiZWZvcmUgY29ubmVjdGVkXG5cbiAgICAgIGlmICh0aGlzLmhhc0F0dHJpYnV0ZSgnb24taW5maW5pdGUtc2Nyb2xsJykpIHtcbiAgICAgICAgdGhpcy5hdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2soJ29uLWluZmluaXRlLXNjcm9sbCcsIG51bGwsIHRoaXMuZ2V0QXR0cmlidXRlKCdvbi1pbmZpbml0ZS1zY3JvbGwnKSk7XG4gICAgICB9XG5cbiAgICAgIGlmICghdGhpcy5faW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgdGhpcy5faW5pdGlhbGl6ZWQgPSB0cnVlO1xuXG4gICAgICAgIHNldEltbWVkaWF0ZSgoKSA9PiB7XG4gICAgICAgICAgdGhpcy5vbkluaXQgJiYgdGhpcy5vbkluaXQoKTtcbiAgICAgICAgICB1dGlsLnRyaWdnZXJFbGVtZW50RXZlbnQodGhpcywgJ2luaXQnKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKCF1dGlsLmhhc0FueUNvbXBvbmVudEFzUGFyZW50KHRoaXMpKSB7XG4gICAgICAgICAgc2V0SW1tZWRpYXRlKCgpID0+IHRoaXMuX3Nob3coKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHVwZGF0ZUJhY2tCdXR0b24oc2hvdykge1xuICAgIGlmICh0aGlzLmJhY2tCdXR0b24pIHtcbiAgICAgIHNob3cgPyB0aGlzLmJhY2tCdXR0b24uc2hvdygpIDogdGhpcy5iYWNrQnV0dG9uLmhpZGUoKTtcbiAgICB9XG4gIH1cblxuICBzZXQgbmFtZShzdHIpIHtcbiAgICB0aGlzLnNldEF0dHJpYnV0ZSgnbmFtZScsIHN0cik7XG4gIH1cblxuICBnZXQgbmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRBdHRyaWJ1dGUoJ25hbWUnKTtcbiAgfVxuXG4gIGdldCBiYWNrQnV0dG9uKCkge1xuICAgIHJldHVybiB0aGlzLnF1ZXJ5U2VsZWN0b3IoJ29ucy1iYWNrLWJ1dHRvbicpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBvbkluZmluaXRlU2Nyb2xsXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXUZ1bmN0aW9uIHRvIGJlIGV4ZWN1dGVkIHdoZW4gc2Nyb2xsaW5nIHRvIHRoZSBib3R0b20gb2YgdGhlIHBhZ2UuIFRoZSBmdW5jdGlvbiByZWNlaXZlcyBhIGRvbmUgY2FsbGJhY2sgYXMgYW4gYXJndW1lbnQgdGhhdCBtdXN0IGJlIGNhbGxlZCB3aGVuIGl0J3MgZmluaXNoZWQuWy9lbl1cbiAgICogIFtqYV1bL2phXVxuICAgKi9cbiAgc2V0IG9uSW5maW5pdGVTY3JvbGwodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgJiYgISh2YWx1ZSBpbnN0YW5jZW9mIEZ1bmN0aW9uKSkge1xuICAgICAgdXRpbC50aHJvdygnXCJvbkluZmluaXRlU2Nyb2xsXCIgbXVzdCBiZSBmdW5jdGlvbiBvciBudWxsJyk7XG4gICAgfVxuXG4gICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHtcbiAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgdGhpcy5fY29udGVudEVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgdGhpcy5fYm91bmRPblNjcm9sbCk7XG4gICAgICB9IGVsc2UgaWYgKCF0aGlzLl9vbkluZmluaXRlU2Nyb2xsKSB7XG4gICAgICAgIHRoaXMuX2luZmluaXRlU2Nyb2xsTGltaXQgPSAwLjk7XG4gICAgICAgIHRoaXMuX2JvdW5kT25TY3JvbGwgPSB0aGlzLl9vblNjcm9sbC5iaW5kKHRoaXMpO1xuICAgICAgICBzZXRJbW1lZGlhdGUoKCkgPT4gdGhpcy5fY29udGVudEVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgdGhpcy5fYm91bmRPblNjcm9sbCkpO1xuICAgICAgfVxuICAgICAgdGhpcy5fb25JbmZpbml0ZVNjcm9sbCA9IHZhbHVlO1xuICAgIH0pO1xuICB9XG5cbiAgZ2V0IG9uSW5maW5pdGVTY3JvbGwoKSB7XG4gICAgcmV0dXJuIHRoaXMuX29uSW5maW5pdGVTY3JvbGw7XG4gIH1cblxuICBfb25TY3JvbGwoKSB7XG4gICAgY29uc3QgYyA9IHRoaXMuX2NvbnRlbnRFbGVtZW50LFxuICAgICAgb3ZlckxpbWl0ID0gKGMuc2Nyb2xsVG9wICsgYy5jbGllbnRIZWlnaHQpIC8gYy5zY3JvbGxIZWlnaHQgPj0gdGhpcy5faW5maW5pdGVTY3JvbGxMaW1pdDtcblxuICAgIGlmICh0aGlzLl9vbkluZmluaXRlU2Nyb2xsICYmICF0aGlzLl9sb2FkaW5nQ29udGVudCAmJiBvdmVyTGltaXQpIHtcbiAgICAgIHRoaXMuX2xvYWRpbmdDb250ZW50ID0gdHJ1ZTtcbiAgICAgIHRoaXMuX29uSW5maW5pdGVTY3JvbGwoKCkgPT4gdGhpcy5fbG9hZGluZ0NvbnRlbnQgPSBmYWxzZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBvbkRldmljZUJhY2tCdXR0b25cbiAgICogQHR5cGUge09iamVjdH1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUJhY2stYnV0dG9uIGhhbmRsZXIuWy9lbl1cbiAgICogICBbamFd44OQ44OD44Kv44Oc44K/44Oz44OP44Oz44OJ44Op44CCWy9qYV1cbiAgICovXG4gIGdldCBvbkRldmljZUJhY2tCdXR0b24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2JhY2tCdXR0b25IYW5kbGVyO1xuICB9XG5cbiAgc2V0IG9uRGV2aWNlQmFja0J1dHRvbihjYWxsYmFjaykge1xuICAgIGlmICh0aGlzLl9iYWNrQnV0dG9uSGFuZGxlcikge1xuICAgICAgdGhpcy5fYmFja0J1dHRvbkhhbmRsZXIuZGVzdHJveSgpO1xuICAgIH1cblxuICAgIHRoaXMuX2JhY2tCdXR0b25IYW5kbGVyID0gZGV2aWNlQmFja0J1dHRvbkRpc3BhdGNoZXIuY3JlYXRlSGFuZGxlcih0aGlzLCBjYWxsYmFjayk7XG4gIH1cblxuICBnZXQgc2Nyb2xsVG9wKCkge1xuICAgIHJldHVybiB0aGlzLl9jb250ZW50RWxlbWVudC5zY3JvbGxUb3A7XG4gIH1cblxuICBzZXQgc2Nyb2xsVG9wKG5ld1ZhbHVlKSB7XG4gICAgdGhpcy5fY29udGVudEVsZW1lbnQuc2Nyb2xsVG9wID0gbmV3VmFsdWU7XG4gIH1cblxuICBfZ2V0Q29udGVudEVsZW1lbnQoKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gdXRpbC5maW5kQ2hpbGQodGhpcywgJy5wYWdlX19jb250ZW50Jyk7XG4gICAgaWYgKHJlc3VsdCkge1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgdXRpbC50aHJvdygnRmFpbCB0byBnZXQgXCIucGFnZV9fY29udGVudFwiIGVsZW1lbnQnKTtcbiAgfVxuXG4gIF9nZXRCYWNrZ3JvdW5kRWxlbWVudCgpIHtcbiAgICBjb25zdCByZXN1bHQgPSB1dGlsLmZpbmRDaGlsZCh0aGlzLCAnLnBhZ2VfX2JhY2tncm91bmQnKTtcbiAgICBpZiAocmVzdWx0KSB7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICB1dGlsLnRocm93KCdGYWlsIHRvIGdldCBcIi5wYWdlX19iYWNrZ3JvdW5kXCIgZWxlbWVudCcpO1xuICB9XG5cbiAgX2dldEJvdHRvbVRvb2xiYXJFbGVtZW50KCkge1xuICAgIHJldHVybiB1dGlsLmZpbmRDaGlsZCh0aGlzLCAnb25zLWJvdHRvbS10b29sYmFyJykgfHwgaW50ZXJuYWwubnVsbEVsZW1lbnQ7XG4gIH1cblxuICBfZ2V0VG9vbGJhckVsZW1lbnQoKSB7XG4gICAgcmV0dXJuIHV0aWwuZmluZENoaWxkKHRoaXMsICdvbnMtdG9vbGJhcicpIHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ29ucy10b29sYmFyJyk7XG4gIH1cblxuICBzdGF0aWMgZ2V0IG9ic2VydmVkQXR0cmlidXRlcygpIHtcbiAgICByZXR1cm4gWydtb2RpZmllcicsICdvbi1pbmZpbml0ZS1zY3JvbGwnLCAnY2xhc3MnXTtcbiAgfVxuXG4gIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBsYXN0LCBjdXJyZW50KSB7XG4gICAgc3dpdGNoIChuYW1lKSB7XG4gICAgICBjYXNlICdjbGFzcyc6XG4gICAgICAgIHV0aWwucmVzdG9yZUNsYXNzKHRoaXMsIHRoaXMuX2RlZmF1bHRDbGFzc05hbWUsIHNjaGVtZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnbW9kaWZpZXInOlxuICAgICAgICBNb2RpZmllclV0aWwub25Nb2RpZmllckNoYW5nZWQobGFzdCwgY3VycmVudCwgdGhpcywgc2NoZW1lKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdvbi1pbmZpbml0ZS1zY3JvbGwnOlxuICAgICAgICBpZiAoY3VycmVudCA9PT0gbnVsbCkge1xuICAgICAgICAgIHRoaXMub25JbmZpbml0ZVNjcm9sbCA9IG51bGw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5vbkluZmluaXRlU2Nyb2xsID0gKGRvbmUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGYgPSB1dGlsLmZpbmRGcm9tUGF0aChjdXJyZW50KTtcbiAgICAgICAgICAgIHRoaXMub25JbmZpbml0ZVNjcm9sbCA9IGY7XG4gICAgICAgICAgICBmKGRvbmUpO1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgX3Nob3coKSB7XG4gICAgaWYgKCF0aGlzLl9pc1Nob3duICYmIHV0aWwuaXNBdHRhY2hlZCh0aGlzKSkge1xuICAgICAgdGhpcy5faXNTaG93biA9IHRydWU7XG4gICAgICB0aGlzLnNldEF0dHJpYnV0ZSgnc2hvd24nLCAnJyk7XG4gICAgICB0aGlzLm9uU2hvdyAmJiB0aGlzLm9uU2hvdygpO1xuICAgICAgdXRpbC50cmlnZ2VyRWxlbWVudEV2ZW50KHRoaXMsICdzaG93Jyk7XG4gICAgICB1dGlsLnByb3BhZ2F0ZUFjdGlvbih0aGlzLCAnX3Nob3cnKTtcbiAgICB9XG4gIH1cblxuICBfaGlkZSgpIHtcbiAgICBpZiAodGhpcy5faXNTaG93bikge1xuICAgICAgdGhpcy5faXNTaG93biA9IGZhbHNlO1xuICAgICAgdGhpcy5yZW1vdmVBdHRyaWJ1dGUoJ3Nob3duJyk7XG4gICAgICB0aGlzLm9uSGlkZSAmJiB0aGlzLm9uSGlkZSgpO1xuICAgICAgdXRpbC50cmlnZ2VyRWxlbWVudEV2ZW50KHRoaXMsICdoaWRlJyk7XG4gICAgICB1dGlsLnByb3BhZ2F0ZUFjdGlvbih0aGlzLCAnX2hpZGUnKTtcbiAgICB9XG4gIH1cblxuICBfZGVzdHJveSgpIHtcbiAgICB0aGlzLl9oaWRlKCk7XG5cbiAgICB0aGlzLm9uRGVzdHJveSAmJiB0aGlzLm9uRGVzdHJveSgpO1xuICAgIHV0aWwudHJpZ2dlckVsZW1lbnRFdmVudCh0aGlzLCAnZGVzdHJveScpO1xuXG4gICAgaWYgKHRoaXMub25EZXZpY2VCYWNrQnV0dG9uKSB7XG4gICAgICB0aGlzLm9uRGV2aWNlQmFja0J1dHRvbi5kZXN0cm95KCk7XG4gICAgfVxuXG4gICAgdXRpbC5wcm9wYWdhdGVBY3Rpb24odGhpcywgJ19kZXN0cm95Jyk7XG5cbiAgICB0aGlzLnJlbW92ZSgpO1xuICB9XG5cbiAgX2Rlcml2ZUhvb2tzKCkge1xuICAgIHRoaXMuY29uc3RydWN0b3IuZXZlbnRzLmZvckVhY2goZXZlbnQgPT4ge1xuICAgICAgY29uc3Qga2V5ID0gJ29uJyArIGV2ZW50LmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgZXZlbnQuc2xpY2UoMSk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywga2V5LCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiAoKSA9PiB0aGlzW2BfJHtrZXl9YF0sXG4gICAgICAgIHNldDogdmFsdWUgPT4ge1xuICAgICAgICAgIGlmICghKHZhbHVlIGluc3RhbmNlb2YgRnVuY3Rpb24pKSB7XG4gICAgICAgICAgICB1dGlsLnRocm93KGBcIiR7a2V5fVwiIGhvb2sgbXVzdCBiZSBhIGZ1bmN0aW9uYCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXNbYF8ke2tleX1gXSA9IHZhbHVlLmJpbmQodGhpcyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgc3RhdGljIGdldCBldmVudHMoKSB7XG4gICAgcmV0dXJuIFsnaW5pdCcsICdzaG93JywgJ2hpZGUnLCAnZGVzdHJveSddO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBkYXRhXG4gICAqIEB0eXBlIHsqfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dVXNlcidzIGN1c3RvbSBkYXRhIHBhc3NlZCB0byBgcHVzaFBhZ2UoKWAtbGlrZSBtZXRob2RzLlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xufVxuXG5vbnNFbGVtZW50cy5QYWdlID0gUGFnZUVsZW1lbnQ7XG5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ29ucy1wYWdlJywgUGFnZUVsZW1lbnQpO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cbmltcG9ydCB1dGlsIGZyb20gJy4uLy4uL29ucy91dGlsJztcbmltcG9ydCBhbmltaXQgZnJvbSAnLi4vLi4vb25zL2FuaW1pdCc7XG5pbXBvcnQgQmFzZUFuaW1hdG9yIGZyb20gJy4uLy4uL29ucy9iYXNlLWFuaW1hdG9yJztcblxuZXhwb3J0IGNsYXNzIFBvcG92ZXJBbmltYXRvciBleHRlbmRzIEJhc2VBbmltYXRvciB7XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBvcHRpb25zLnRpbWluZ1xuICAgKiBAcGFyYW0ge051bWJlcn0gb3B0aW9ucy5kdXJhdGlvblxuICAgKiBAcGFyYW0ge051bWJlcn0gb3B0aW9ucy5kZWxheVxuICAgKi9cbiAgY29uc3RydWN0b3Ioe3RpbWluZyA9ICdjdWJpYy1iZXppZXIoLjEsIC43LCAuNCwgMSknLCBkZWxheSA9IDAsIGR1cmF0aW9uID0gMC4yfSA9IHt9KSB7XG4gICAgc3VwZXIoeyB0aW1pbmcsIGRlbGF5LCBkdXJhdGlvbiB9KTtcbiAgfVxuXG4gIHNob3cocG9wb3ZlciwgY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjaygpO1xuICB9XG5cbiAgaGlkZShwb3BvdmVyLCBjYWxsYmFjaykge1xuICAgIGNhbGxiYWNrKCk7XG4gIH1cblxuICBfYW5pbWF0ZShlbGVtZW50LCB7ZnJvbSwgdG8sIG9wdGlvbnMsIGNhbGxiYWNrLCByZXN0b3JlID0gZmFsc2UsIGFuaW1hdGlvbn0pIHtcbiAgICBvcHRpb25zID0gdXRpbC5leHRlbmQoe30sIHRoaXMub3B0aW9ucywgb3B0aW9ucyk7XG5cbiAgICBpZiAoYW5pbWF0aW9uKSB7XG4gICAgICBmcm9tID0gYW5pbWF0aW9uLmZyb207XG4gICAgICB0byA9IGFuaW1hdGlvbi50bztcbiAgICB9XG5cbiAgICBhbmltYXRpb24gPSBhbmltaXQoZWxlbWVudCk7XG4gICAgaWYgKHJlc3RvcmUpIHtcbiAgICAgIGFuaW1hdGlvbiA9IGFuaW1hdGlvbi5zYXZlU3R5bGUoKTtcbiAgICB9XG4gICAgYW5pbWF0aW9uID0gYW5pbWF0aW9uLnF1ZXVlKGZyb20pLndhaXQodGhpcy5kZWxheSkucXVldWUoe1xuICAgICAgY3NzOiB0byxcbiAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgIH0pO1xuICAgIGlmIChyZXN0b3JlKSB7XG4gICAgICBhbmltYXRpb24gPSBhbmltYXRpb24ucmVzdG9yZVN0eWxlKCk7XG4gICAgfVxuICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgYW5pbWF0aW9uID0gYW5pbWF0aW9uLnF1ZXVlKChkb25lKSA9PiB7XG4gICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgIGRvbmUoKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gYW5pbWF0aW9uO1xuICB9XG5cbiAgX2FuaW1hdGVBbGwoZWxlbWVudCwgYW5pbWF0aW9ucykge1xuICAgIE9iamVjdC5rZXlzKGFuaW1hdGlvbnMpLmZvckVhY2goa2V5ID0+IHRoaXMuX2FuaW1hdGUoZWxlbWVudFtrZXldLCBhbmltYXRpb25zW2tleV0pLnBsYXkoKSk7XG4gIH1cblxufVxuXG5jb25zdCBmYWRlID0ge1xuICBvdXQ6IHtcbiAgICBmcm9tOiB7b3BhY2l0eTogMS4wfSxcbiAgICB0bzoge29wYWNpdHk6IDB9XG4gIH0sXG4gIGluOiB7XG4gICAgZnJvbToge29wYWNpdHk6IDB9LFxuICAgIHRvOiB7b3BhY2l0eTogMS4wfVxuICB9XG59O1xuXG5leHBvcnQgY2xhc3MgTURGYWRlUG9wb3ZlckFuaW1hdG9yIGV4dGVuZHMgUG9wb3ZlckFuaW1hdG9yIHtcbiAgc2hvdyhwb3BvdmVyLCBjYWxsYmFjaykge1xuICAgIHRoaXMuX2FuaW1hdGVBbGwocG9wb3Zlciwge1xuICAgICAgX21hc2s6IGZhZGUuaW4sXG4gICAgICBfcG9wb3Zlcjoge2FuaW1hdGlvbjogZmFkZS5pbiwgcmVzdG9yZTogdHJ1ZSwgY2FsbGJhY2t9XG4gICAgfSk7XG4gIH1cblxuICBoaWRlKHBvcG92ZXIsIGNhbGxiYWNrKSB7XG4gICAgdGhpcy5fYW5pbWF0ZUFsbChwb3BvdmVyLCB7XG4gICAgICBfbWFzazogZmFkZS5vdXQsXG4gICAgICBfcG9wb3Zlcjoge2FuaW1hdGlvbjogZmFkZS5vdXQsIHJlc3RvcmU6IHRydWUsIGNhbGxiYWNrfVxuICAgIH0pO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBJT1NGYWRlUG9wb3ZlckFuaW1hdG9yIGV4dGVuZHMgTURGYWRlUG9wb3ZlckFuaW1hdG9yIHtcbiAgc2hvdyhwb3BvdmVyLCBjYWxsYmFjaykge1xuICAgIHRoaXMuX2FuaW1hdGVBbGwocG9wb3Zlciwge1xuICAgICAgX21hc2s6IGZhZGUuaW4sXG4gICAgICBfcG9wb3Zlcjoge1xuICAgICAgICBmcm9tOiB7XG4gICAgICAgICAgdHJhbnNmb3JtOiAnc2NhbGUzZCgxLjMsIDEuMywgMS4wKScsXG4gICAgICAgICAgb3BhY2l0eTogMFxuICAgICAgICB9LFxuICAgICAgICB0bzoge1xuICAgICAgICAgIHRyYW5zZm9ybTogJ3NjYWxlM2QoMS4wLCAxLjAsICAxLjApJyxcbiAgICAgICAgICBvcGFjaXR5OiAxLjBcbiAgICAgICAgfSxcbiAgICAgICAgcmVzdG9yZTogdHJ1ZSxcbiAgICAgICAgY2FsbGJhY2tcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IG9uc0VsZW1lbnRzIGZyb20gJy4uLy4uL29ucy9lbGVtZW50cyc7XG5pbXBvcnQgdXRpbCBmcm9tICcuLi8uLi9vbnMvdXRpbCc7XG5pbXBvcnQgYXV0b1N0eWxlIGZyb20gJy4uLy4uL29ucy9hdXRvc3R5bGUnO1xuaW1wb3J0IE1vZGlmaWVyVXRpbCBmcm9tICcuLi8uLi9vbnMvaW50ZXJuYWwvbW9kaWZpZXItdXRpbCc7XG5pbXBvcnQgQW5pbWF0b3JGYWN0b3J5IGZyb20gJy4uLy4uL29ucy9pbnRlcm5hbC9hbmltYXRvci1mYWN0b3J5JztcbmltcG9ydCB7IFBvcG92ZXJBbmltYXRvciwgSU9TRmFkZVBvcG92ZXJBbmltYXRvciwgTURGYWRlUG9wb3ZlckFuaW1hdG9yIH0gZnJvbSAnLi9hbmltYXRvcic7XG5pbXBvcnQgcGxhdGZvcm0gZnJvbSAnLi4vLi4vb25zL3BsYXRmb3JtJztcbmltcG9ydCBpUGhvbmVYUGF0Y2ggZnJvbSAnLi4vLi4vb25zL2lwaG9uZXgtcGF0Y2gnO1xuaW1wb3J0IEJhc2VEaWFsb2dFbGVtZW50IGZyb20gJy4uL2Jhc2UvYmFzZS1kaWFsb2cnO1xuaW1wb3J0IGNvbnRlbnRSZWFkeSBmcm9tICcuLi8uLi9vbnMvY29udGVudC1yZWFkeSc7XG5cbmNvbnN0IHNjaGVtZSA9IHtcbiAgJy5wb3BvdmVyJzogJ3BvcG92ZXItLSonLFxuICAnLnBvcG92ZXItbWFzayc6ICdwb3BvdmVyLW1hc2stLSonLFxuICAnLnBvcG92ZXJfX2NvbnRlbnQnOiAncG9wb3Zlci0tKl9fY29udGVudCcsXG4gICcucG9wb3Zlcl9fYXJyb3cnOiAncG9wb3Zlci0tKl9fYXJyb3cnXG59O1xuXG5jb25zdCBfYW5pbWF0b3JEaWN0ID0ge1xuICAnZGVmYXVsdCc6ICgpID0+IHBsYXRmb3JtLmlzQW5kcm9pZCgpID8gTURGYWRlUG9wb3ZlckFuaW1hdG9yIDogSU9TRmFkZVBvcG92ZXJBbmltYXRvcixcbiAgJ25vbmUnOiBQb3BvdmVyQW5pbWF0b3IsXG4gICdmYWRlLWlvcyc6IElPU0ZhZGVQb3BvdmVyQW5pbWF0b3IsXG4gICdmYWRlLW1kJzogTURGYWRlUG9wb3ZlckFuaW1hdG9yXG59O1xuXG5jb25zdCBwb3NpdGlvbnMgPSB7XG4gIHVwOiAnYm90dG9tJyxcbiAgbGVmdDogJ3JpZ2h0JyxcbiAgZG93bjogJ3RvcCcsXG4gIHJpZ2h0OiAnbGVmdCdcbn07XG5cbmNvbnN0IGRpcmVjdGlvbnMgPSBPYmplY3Qua2V5cyhwb3NpdGlvbnMpO1xuLyoqXG4gKiBAZWxlbWVudCBvbnMtcG9wb3ZlclxuICogQGNhdGVnb3J5IGRpYWxvZ1xuICogQGRlc2NyaXB0aW9uXG4gKiAgW2VuXVxuICogICAgQSBjb21wb25lbnQgdGhhdCBkaXNwbGF5cyBhIHBvcG92ZXIgbmV4dCB0byBhbiBlbGVtZW50LiBUaGUgcG9wb3ZlciBjYW4gYmUgdXNlZCB0byBkaXNwbGF5IGV4dHJhIGluZm9ybWF0aW9uIGFib3V0IGEgY29tcG9uZW50IG9yIGEgdG9vbHRpcC5cbiAqXG4gKiAgICBUbyB1c2UgdGhlIGVsZW1lbnQgaXQgY2FuIGVpdGhlciBiZSBhdHRhY2hlZCBkaXJlY3RseSB0byB0aGUgYDxib2R5PmAgZWxlbWVudCBvciBkeW5hbWljYWxseSBjcmVhdGVkIGZyb20gYSB0ZW1wbGF0ZSB1c2luZyB0aGUgYG9ucy5jcmVhdGVQb3BvdmVyKHRlbXBsYXRlKWAgdXRpbGl0eSBmdW5jdGlvbiBhbmQgdGhlIGA8dGVtcGxhdGU+YCB0YWcuXG4gKlxuICogICAgQW5vdGhlciBjb21tb24gd2F5IHRvIHVzZSB0aGUgcG9wb3ZlciBpcyB0byBkaXNwbGF5IGEgbWVudSB3aGVuIGEgYnV0dG9uIG9uIHRoZSBzY3JlZW4gaXMgdGFwcGVkLiBGb3IgTWF0ZXJpYWwgRGVzaWduLCBwb3BvdmVyIGxvb2tzIGV4YWN0bHkgYXMgYSBkcm9wZG93biBtZW51LlxuICogIFsvZW5dXG4gKiAgW2phXeOBguOCi+imgee0oOOCkuWvvuixoeOBqOOBmeOCi+ODneODg+ODl+OCquODvOODkOODvOOCkuihqOekuuOBmeOCi+OCs+ODs+ODneODvOODjeODs+ODiOOBp+OBmeOAglsvamFdXG4gKiBAY29kZXBlbiBaWVlSS29cbiAqIEB0dXRvcmlhbCB2YW5pbGxhL1JlZmVyZW5jZS9wb3BvdmVyXG4gKiBAZ3VpZGUgdGhlbWluZy5odG1sI21vZGlmaWVycyBbZW5dTW9yZSBkZXRhaWxzIGFib3V0IHRoZSBgbW9kaWZpZXJgIGF0dHJpYnV0ZVsvZW5dW2phXW1vZGlmaWVy5bGe5oCn44Gu5L2/44GE5pa5Wy9qYV1cbiAqIEBleGFtcGxlXG4gKiA8b25zLWJ1dHRvbiBvbmNsaWNrPVwic2hvd1BvcG92ZXIodGhpcylcIj5cbiAqICAgQ2xpY2sgbWUhXG4gKiA8L29ucy1idXR0b24+XG4gKlxuICogPG9ucy1wb3BvdmVyIGRpcmVjdGlvbj1cImRvd25cIiBpZD1cInBvcG92ZXJcIj5cbiAqICAgPHA+VGhpcyBpcyBhIHBvcG92ZXIhPC9wPlxuICogPC9vbnMtcG9wb3Zlcj5cbiAqXG4gKiA8c2NyaXB0PlxuICogICB2YXIgc2hvd1BvcG92ZXIgPSBmdW5jdGlvbihlbGVtZW50KSB7XG4gKiAgICAgdmFyIHBvcG92ZXIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncG9wb3ZlcicpO1xuICogICAgIHBvcG92ZXIuc2hvdyhlbGVtZW50KTtcbiAqICAgfTtcbiAqIDwvc2NyaXB0PlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQb3BvdmVyRWxlbWVudCBleHRlbmRzIEJhc2VEaWFsb2dFbGVtZW50IHtcblxuICAvKipcbiAgICogQGV2ZW50IHByZXNob3dcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUZpcmVkIGp1c3QgYmVmb3JlIHRoZSBwb3BvdmVyIGlzIGRpc3BsYXllZC5bL2VuXVxuICAgKiAgIFtqYV3jg53jg4Pjg5fjgqrjg7zjg5Djg7zjgYzooajnpLrjgZXjgozjgovnm7TliY3jgavnmbrngavjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgW2VuXUV2ZW50IG9iamVjdC5bL2VuXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQucG9wb3ZlclxuICAgKiAgIFtlbl1Db21wb25lbnQgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCs+ODs+ODneODvOODjeODs+ODiOOBruOCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGV2ZW50LmNhbmNlbFxuICAgKiAgIFtlbl1DYWxsIHRoaXMgZnVuY3Rpb24gdG8gc3RvcCB0aGUgcG9wb3ZlciBmcm9tIGJlaW5nIHNob3duLlsvZW5dXG4gICAqICAgW2phXeOBk+OBrumWouaVsOOCkuWRvOOBs+WHuuOBmeOBqOOAgeODneODg+ODl+OCquODvOODkOODvOOBruihqOekuuOBjOOCreODo+ODs+OCu+ODq+OBleOCjOOBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAZXZlbnQgcG9zdHNob3dcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUZpcmVkIGp1c3QgYWZ0ZXIgdGhlIHBvcG92ZXIgaXMgZGlzcGxheWVkLlsvZW5dXG4gICAqICAgW2phXeODneODg+ODl+OCquODvOODkOODvOOBjOihqOekuuOBleOCjOOBn+ebtOW+jOOBq+eZuueBq+OBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCBbZW5dRXZlbnQgb2JqZWN0LlsvZW5dXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5wb3BvdmVyXG4gICAqICAgW2VuXUNvbXBvbmVudCBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Kz44Oz44Od44O844ON44Oz44OI44Gu44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBldmVudCBwcmVoaWRlXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1GaXJlZCBqdXN0IGJlZm9yZSB0aGUgcG9wb3ZlciBpcyBoaWRkZW4uWy9lbl1cbiAgICogICBbamFd44Od44OD44OX44Kq44O844OQ44O844GM6Zqg44KM44KL55u05YmN44Gr55m654Gr44GX44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IFtlbl1FdmVudCBvYmplY3QuWy9lbl1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50LnBvcG92ZXJcbiAgICogICBbZW5dQ29tcG9uZW50IG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgrPjg7Pjg53jg7zjg43jg7Pjg4jjga7jgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBldmVudC5jYW5jZWxcbiAgICogICBbZW5dQ2FsbCB0aGlzIGZ1bmN0aW9uIHRvIHN0b3AgdGhlIHBvcG92ZXIgZnJvbSBiZWluZyBoaWRkZW4uWy9lbl1cbiAgICogICBbamFd44GT44Gu6Zai5pWw44KS5ZG844Gz5Ye644GZ44Go44CB44Od44OD44OX44Kq44O844OQ44O844GM6Zqg44KM44KL5Yem55CG44KS44Kt44Oj44Oz44K744Or44GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBldmVudCBwb3N0aGlkZVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dRmlyZWQganVzdCBhZnRlciB0aGUgcG9wb3ZlciBpcyBoaWRkZW4uWy9lbl1cbiAgICogICBbamFd44Od44OD44OX44Kq44O844OQ44O844GM6Zqg44KM44Gf5b6M44Gr55m654Gr44GX44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IFtlbl1FdmVudCBvYmplY3QuWy9lbl1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50LnBvcG92ZXJcbiAgICogICBbZW5dQ29tcG9uZW50IG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgrPjg7Pjg53jg7zjg43jg7Pjg4jjga7jgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBtb2RpZmllclxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFtlbl1UaGUgYXBwZWFyYW5jZSBvZiB0aGUgcG9wb3Zlci5bL2VuXVxuICAgKiAgW2phXeODneODg+ODl+OCquODvOODkOODvOOBruihqOePvuOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGRpcmVjdGlvblxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFtlbl1cbiAgICogICAgQSBzcGFjZSBzZXBhcmF0ZWQgbGlzdCBvZiBkaXJlY3Rpb25zLiBJZiBtb3JlIHRoYW4gb25lIGRpcmVjdGlvbiBpcyBzcGVjaWZpZWQsXG4gICAqICAgIGl0IHdpbGwgYmUgY2hvc2VuIGF1dG9tYXRpY2FsbHkuIFZhbGlkIGRpcmVjdGlvbnMgYXJlIGBcInVwXCJgLCBgXCJkb3duXCJgLCBgXCJsZWZ0XCJgIGFuZCBgXCJyaWdodFwiYC5cbiAgICogIFsvZW5dXG4gICAqICBbamFdXG4gICAqICAgIOODneODg+ODl+OCquODvOODkOODvOOCkuihqOekuuOBmeOCi+aWueWQkeOCkuepuueZveWMuuWIh+OCiuOBp+ikh+aVsOaMh+WumuOBp+OBjeOBvuOBmeOAglxuICAgKiAgICDmjIflrprjgafjgY3jgovmlrnlkJHjga/jgIFcInVwXCIsIFwiZG93blwiLCBcImxlZnRcIiwgXCJyaWdodFwi44GuNOOBpOOBp+OBmeOAguepuueZveWMuuWIh+OCiuOBp+ikh+aVsOaMh+WumuOBmeOCi+OBk+OBqOOCguOBp+OBjeOBvuOBmeOAglxuICAgKiAgICDopIfmlbDmjIflrprjgZXjgozjgZ/loLTlkIjjgIHlr77osaHjgajjgZnjgovopoHntKDjgavlkIjjgo/jgZvjgabmjIflrprjgZfjgZ/lgKTjgYvjgonoh6rli5XnmoTjgavpgbjmip7jgZXjgozjgb7jgZnjgIJcbiAgICogIFsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGNhbmNlbGFibGVcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUlmIHRoaXMgYXR0cmlidXRlIGlzIHNldCB0aGUgcG9wb3ZlciBjYW4gYmUgY2xvc2VkIGJ5IHRhcHBpbmcgdGhlIGJhY2tncm91bmQgb3IgYnkgcHJlc3NpbmcgdGhlIGJhY2sgYnV0dG9uLlsvZW5dXG4gICAqICAgW2phXeOBk+OBruWxnuaAp+OBjOOBguOCi+OBqOOAgeODneODg+ODl+OCquODvOODkOODvOOBjOihqOekuuOBleOCjOOBn+aZguOBq+OAgeiDjOaZr+OChOODkOODg+OCr+ODnOOCv+ODs+OCkuOCv+ODg+ODl+OBl+OBn+aZguOBq+OCkuODneODg+ODl+OCquODvOODkOODvOmWieOBmOOBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGNvdmVyLXRhcmdldFxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dSWYgc2V0IHRoZSBwb3BvdmVyIHdpbGwgY292ZXIgdGhlIHRhcmdldCBvbiB0aGUgc2NyZWVuLlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGFuaW1hdGlvblxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dVGhlIGFuaW1hdGlvbiB1c2VkIHdoZW4gc2hvd2luZyBhbiBoaWRpbmcgdGhlIHBvcG92ZXIuIENhbiBiZSBlaXRoZXIgYFwibm9uZVwiYCwgYFwiZGVmYXVsdFwiYCwgYFwiZmFkZS1pb3NcImAgb3IgYFwiZmFkZS1tZFwiYC5bL2VuXVxuICAgKiAgIFtqYV3jg53jg4Pjg5fjgqrjg7zjg5Djg7zjgpLooajnpLrjgZnjgovpmpvjga7jgqLjg4vjg6Hjg7zjgrfjg6fjg7PlkI3jgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBhbmltYXRpb24tb3B0aW9uc1xuICAgKiBAdHlwZSB7RXhwcmVzc2lvbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dU3BlY2lmeSB0aGUgYW5pbWF0aW9uJ3MgZHVyYXRpb24sIHRpbWluZyBhbmQgZGVsYXkgd2l0aCBhbiBvYmplY3QgbGl0ZXJhbC4gRS5nLiBge2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAxLCB0aW1pbmc6ICdlYXNlLWluJ31gLlsvZW5dXG4gICAqICBbamFd44Ki44OL44Oh44O844K344On44Oz5pmC44GuZHVyYXRpb24sIHRpbWluZywgZGVsYXnjgpLjgqrjg5bjgrjjgqfjgq/jg4jjg6rjg4bjg6njg6vjgafmjIflrprjgZfjgb7jgZnjgIJlLmcuIHtkdXJhdGlvbjogMC4yLCBkZWxheTogMSwgdGltaW5nOiAnZWFzZS1pbid9Wy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgbWFzay1jb2xvclxuICAgKiBAdHlwZSB7Q29sb3J9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1Db2xvciBvZiB0aGUgYmFja2dyb3VuZCBtYXNrLiBEZWZhdWx0IGlzIGBcInJnYmEoMCwgMCwgMCwgMC4yKVwiYC5bL2VuXVxuICAgKiAgIFtqYV3og4zmma/jga7jg57jgrnjgq/jga7oibLjgpLmjIflrprjgZfjgb7jgZnjgILjg4fjg5Xjgqnjg6vjg4jjga9cInJnYmEoMCwgMCwgMCwgMC4yKVwi44Gn44GZ44CCWy9qYV1cbiAgICovXG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIHRoaXMuX2JvdW5kT25DaGFuZ2UgPSB0aGlzLl9vbkNoYW5nZS5iaW5kKHRoaXMpO1xuXG4gICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHtcbiAgICAgIHRoaXMuX2NvbXBpbGUoKTtcbiAgICAgIHRoaXMuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICB9KTtcbiAgfVxuXG4gIGdldCBfc2NoZW1lKCkge1xuICAgIHJldHVybiBzY2hlbWU7XG4gIH1cblxuICBnZXQgX21hc2soKSB7XG4gICAgcmV0dXJuIHV0aWwuZmluZENoaWxkKHRoaXMsICcucG9wb3Zlci1tYXNrJyk7XG4gIH1cblxuICBnZXQgX3BvcG92ZXIoKSB7XG4gICAgcmV0dXJuIHV0aWwuZmluZENoaWxkKHRoaXMsICcucG9wb3ZlcicpO1xuICB9XG5cbiAgZ2V0IF9jb250ZW50KCkge1xuICAgIHJldHVybiB1dGlsLmZpbmRDaGlsZCh0aGlzLl9wb3BvdmVyLCAnLnBvcG92ZXJfX2NvbnRlbnQnKTtcbiAgfVxuXG4gIGdldCBfYXJyb3coKSB7XG4gICAgcmV0dXJuIHV0aWwuZmluZENoaWxkKHRoaXMuX3BvcG92ZXIsICcucG9wb3Zlcl9fYXJyb3cnKTtcbiAgfVxuXG4gIF91cGRhdGVBbmltYXRvckZhY3RvcnkoKSB7XG4gICAgcmV0dXJuIG5ldyBBbmltYXRvckZhY3Rvcnkoe1xuICAgICAgYW5pbWF0b3JzOiBfYW5pbWF0b3JEaWN0LFxuICAgICAgYmFzZUNsYXNzOiBQb3BvdmVyQW5pbWF0b3IsXG4gICAgICBiYXNlQ2xhc3NOYW1lOiAnUG9wb3ZlckFuaW1hdG9yJyxcbiAgICAgIGRlZmF1bHRBbmltYXRpb246IHRoaXMuZ2V0QXR0cmlidXRlKCdhbmltYXRpb24nKSB8fCAnZGVmYXVsdCdcbiAgICB9KTtcbiAgfVxuXG4gIF90b2dnbGVTdHlsZShzaG91bGRTaG93LCBvcHRpb25zID0ge30pIHtcbiAgICBpZiAoc2hvdWxkU2hvdykge1xuICAgICAgdGhpcy5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICAgIHRoaXMuX2N1cnJlbnRUYXJnZXQgPSBvcHRpb25zLnRhcmdldDtcbiAgICAgIHRoaXMuX3Bvc2l0aW9uUG9wb3ZlcihvcHRpb25zLnRhcmdldCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgIHRoaXMuX2NsZWFyU3R5bGVzKCk7XG4gICAgfVxuICB9XG5cbiAgX3Bvc2l0aW9uUG9wb3Zlcih0YXJnZXQpIHtcbiAgICBjb25zdCB7X3JhZGl1czogcmFkaXVzLCBfY29udGVudDogY29udGVudEVsZW1lbnQsIF9tYXJnaW46IG1hcmdpbn0gPSB0aGlzO1xuICAgIGNvbnN0IHNhZmVBcmVhTGVuZ3RocyA9IGlQaG9uZVhQYXRjaC5nZXRTYWZlQXJlYUxlbmd0aHMoKTtcbiAgICBjb25zdCBzYWZlQXJlYVJlY3QgPSBpUGhvbmVYUGF0Y2guZ2V0U2FmZUFyZWFET01SZWN0KCk7XG4gICAgY29uc3QgdGFyZ2V0UmVjdCA9IHRhcmdldC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBjb25zdCBpc01EID0gdXRpbC5oYXNNb2RpZmllcih0aGlzLCAnbWF0ZXJpYWwnKTtcbiAgICBjb25zdCBjb3ZlciA9IGlzTUQgJiYgdGhpcy5oYXNBdHRyaWJ1dGUoJ2NvdmVyLXRhcmdldCcpO1xuICAgIGNvbnN0IHBhcmVudCA9IHV0aWwuZmluZFBhcmVudCh0aGlzLCAnb25zLXBhZ2UnKSB8fCBkb2N1bWVudC5ib2R5O1xuICAgIGNvbnN0IHBhcmVudERpbWVuc2lvbnMgPSBwYXJlbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgY29uc3QgbWF4UG9zaXRpb25zID0ge1xuICAgICAgdG9wOiBNYXRoLm1heChwYXJlbnREaW1lbnNpb25zLnRvcCwgc2FmZUFyZWFSZWN0LnRvcCksXG4gICAgICBsZWZ0OiBNYXRoLm1heChwYXJlbnREaW1lbnNpb25zLmxlZnQsIHNhZmVBcmVhUmVjdC5sZWZ0KSxcbiAgICAgIGJvdHRvbTogTWF0aC5taW4ocGFyZW50RGltZW5zaW9ucy5ib3R0b20sIHNhZmVBcmVhUmVjdC5ib3R0b20pLFxuICAgICAgcmlnaHQ6IE1hdGgubWluKHBhcmVudERpbWVuc2lvbnMucmlnaHQsIHNhZmVBcmVhUmVjdC5yaWdodCksXG4gICAgfTtcblxuICAgIC8vIERpc3RhbmNlIGZyb20gZWFjaCBzaWRlIG9mIHRoZSBzYWZlIGFyZWEgKHdpdGggbWFyZ2luKSB0byB0aGUgdGFyZ2V0IGVsZW1lbnRcbiAgICBjb25zdCB0YXJnZXREaXN0YW5jZSA9IHtcbiAgICAgIHRvcDogdGFyZ2V0UmVjdC50b3AgLSAobWF4UG9zaXRpb25zLnRvcCArIG1hcmdpbiksXG4gICAgICBsZWZ0OiB0YXJnZXRSZWN0LmxlZnQgLSAobWF4UG9zaXRpb25zLmxlZnQgKyBtYXJnaW4pLFxuICAgICAgYm90dG9tOiAobWF4UG9zaXRpb25zLmJvdHRvbSAtIG1hcmdpbikgLSB0YXJnZXRSZWN0LmJvdHRvbSxcbiAgICAgIHJpZ2h0OiAobWF4UG9zaXRpb25zLnJpZ2h0IC0gbWFyZ2luKSAtIHRhcmdldFJlY3QucmlnaHRcbiAgICB9O1xuXG4gICAgLy8gRGlzdGFuY2UgZnJvbSBlYWNoIHNpZGUgb2YgdGhlIHNhZmUgYXJlYSAod2l0aCBtYXJnaW4pIHRvIHRoZSBnZW9tZXRyaWMgY2VudGVyIG9mIHRoZSB0YXJnZXQgZWxlbWVudFxuICAgIGNvbnN0IHRhcmdldENlbnRlckRpc3RhbmNlRnJvbSA9IHtcbiAgICAgIHRvcDogdGFyZ2V0UmVjdC50b3AgKyBNYXRoLnJvdW5kKHRhcmdldFJlY3QuaGVpZ2h0IC8gMikgLSAobWF4UG9zaXRpb25zLnRvcCArIG1hcmdpbiksXG4gICAgICBsZWZ0OiB0YXJnZXRSZWN0LmxlZnQgKyBNYXRoLnJvdW5kKHRhcmdldFJlY3Qud2lkdGggLyAyKSAtIChtYXhQb3NpdGlvbnMubGVmdCArIG1hcmdpbiksXG4gICAgICBib3R0b206IChtYXhQb3NpdGlvbnMuYm90dG9tIC0gbWFyZ2luKSAtIHRhcmdldFJlY3QuYm90dG9tICsgTWF0aC5yb3VuZCh0YXJnZXRSZWN0LmhlaWdodCAvIDIpLFxuICAgICAgcmlnaHQ6IChtYXhQb3NpdGlvbnMucmlnaHQgLSBtYXJnaW4pIC0gdGFyZ2V0UmVjdC5yaWdodCArIE1hdGgucm91bmQodGFyZ2V0UmVjdC53aWR0aCAvIDIpXG4gICAgfTtcblxuICAgIGNvbnN0IHt2ZXJ0aWNhbCwgcHJpbWFyeTogcHJpbWFyeURpcmVjdGlvbiwgc2Vjb25kYXJ5OiBzZWNvbmRhcnlEaXJlY3Rpb259ID0gdGhpcy5fY2FsY3VsYXRlRGlyZWN0aW9ucyh0YXJnZXREaXN0YW5jZSk7XG4gICAgdGhpcy5fY3VycmVudERpcmVjdGlvbiA9IHByaW1hcnlEaXJlY3Rpb247XG4gICAgdXRpbC5hZGRNb2RpZmllcih0aGlzLCBwcmltYXJ5RGlyZWN0aW9uKTtcblxuICAgIGNvbnN0IHNpemVOYW1lID0gdmVydGljYWwgPyAnd2lkdGgnIDogJ2hlaWdodCc7XG4gICAgLy8gR2V0IC5wb3BvdmVyX19jb250ZW50IHNpemVcbiAgICBjb25zdCBjb250ZW50U2l6ZSA9IChzdHlsZSA9PiAoe1xuICAgICAgd2lkdGg6IHBhcnNlSW50KHN0eWxlLmdldFByb3BlcnR5VmFsdWUoJ3dpZHRoJyksIDEwKSxcbiAgICAgIGhlaWdodDogcGFyc2VJbnQoc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZSgnaGVpZ2h0JyksIDEwKVxuICAgIH0pKSh3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShjb250ZW50RWxlbWVudCkpO1xuXG4gICAgLy8gU2V0dGluZyAucG9wb3ZlciBwb3NpdGlvbi5cbiAgICBjb25zdCB0YXJnZXRBbmRBcnJvd0xlbmd0aCA9IGNvdmVyID8gMCA6ICh2ZXJ0aWNhbCA/IHRhcmdldFJlY3QuaGVpZ2h0IDogdGFyZ2V0UmVjdC53aWR0aCkgKyAoaXNNRCA/IDAgOiAxNCk7XG4gICAgY29uc3QgcHJpbWFyeU9mZnNldCA9IE1hdGgubWF4KFxuICAgICAgc2FmZUFyZWFMZW5ndGhzW3ByaW1hcnlEaXJlY3Rpb25dICsgbWFyZ2luLFxuICAgICAgc2FmZUFyZWFMZW5ndGhzW3ByaW1hcnlEaXJlY3Rpb25dICsgbWFyZ2luICsgdGFyZ2V0RGlzdGFuY2VbcHJpbWFyeURpcmVjdGlvbl0gKyB0YXJnZXRBbmRBcnJvd0xlbmd0aFxuICAgICk7XG4gICAgY29uc3Qgc2Vjb25kYXJ5T2Zmc2V0ID0gTWF0aC5tYXgoXG4gICAgICBzYWZlQXJlYUxlbmd0aHNbc2Vjb25kYXJ5RGlyZWN0aW9uXSArIG1hcmdpbixcbiAgICAgIHNhZmVBcmVhTGVuZ3Roc1tzZWNvbmRhcnlEaXJlY3Rpb25dICsgbWFyZ2luICsgdGFyZ2V0Q2VudGVyRGlzdGFuY2VGcm9tW3NlY29uZGFyeURpcmVjdGlvbl0gLSAoY29udGVudFNpemVbc2l6ZU5hbWVdIC8gMilcbiAgICApO1xuICAgIHRoaXMuX3BvcG92ZXIuc3R5bGVbcHJpbWFyeURpcmVjdGlvbl0gPSBwcmltYXJ5T2Zmc2V0ICsgJ3B4JztcbiAgICB0aGlzLl9wb3BvdmVyLnN0eWxlW3NlY29uZGFyeURpcmVjdGlvbl0gPSBzZWNvbmRhcnlPZmZzZXQgKyAncHgnO1xuXG4gICAgLy8gU2V0dGluZyAucG9wb3Zlcl9fYXJyb3cgcG9zaXRpb24uXG4gICAgdGhpcy5fYXJyb3cuc3R5bGVbc2Vjb25kYXJ5RGlyZWN0aW9uXSA9IE1hdGgubWF4KFxuICAgICAgcmFkaXVzLFxuICAgICAgKHNhZmVBcmVhTGVuZ3Roc1tzZWNvbmRhcnlEaXJlY3Rpb25dICsgbWFyZ2luKSArIHRhcmdldENlbnRlckRpc3RhbmNlRnJvbVtzZWNvbmRhcnlEaXJlY3Rpb25dIC0gc2Vjb25kYXJ5T2Zmc2V0XG4gICAgKSArICdweCc7XG4gIH1cblxuICBfY2FsY3VsYXRlRGlyZWN0aW9ucyhkaXN0YW5jZSkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSAodGhpcy5nZXRBdHRyaWJ1dGUoJ2RpcmVjdGlvbicpIHx8ICd1cCBkb3duIGxlZnQgcmlnaHQnKS5zcGxpdCgvXFxzKy8pLm1hcChlID0+IHBvc2l0aW9uc1tlXSk7XG4gICAgY29uc3QgcHJpbWFyeSA9IG9wdGlvbnMuc29ydCgoYSwgYikgPT4gZGlzdGFuY2VbYV0gLSBkaXN0YW5jZVtiXSlbMF07XG4gICAgY29uc3QgdmVydGljYWwgPSAndG9wJyA9PSBwcmltYXJ5IHx8ICdib3R0b20nID09IHByaW1hcnk7XG4gICAgbGV0IHNlY29uZGFyeTtcblxuICAgIGlmICh2ZXJ0aWNhbCkge1xuICAgICAgc2Vjb25kYXJ5ID0gZGlzdGFuY2UubGVmdCA8IGRpc3RhbmNlLnJpZ2h0ID8gJ2xlZnQnIDogJ3JpZ2h0JztcbiAgICB9IGVsc2Uge1xuICAgICAgc2Vjb25kYXJ5ID0gZGlzdGFuY2UudG9wIDwgZGlzdGFuY2UuYm90dG9tID8gJ3RvcCcgOiAnYm90dG9tJztcbiAgICB9XG5cbiAgICByZXR1cm4ge3ZlcnRpY2FsLCBwcmltYXJ5LCBzZWNvbmRhcnl9O1xuICB9XG5cbiAgX2NsZWFyU3R5bGVzKCkge1xuICAgIHRoaXMuX2N1cnJlbnREaXJlY3Rpb24gPSBudWxsO1xuICAgIFsndG9wJywgJ2JvdHRvbScsICdsZWZ0JywgJ3JpZ2h0J10uZm9yRWFjaChlID0+IHtcbiAgICAgIHRoaXMuX2Fycm93LnN0eWxlW2VdID0gdGhpcy5fY29udGVudC5zdHlsZVtlXSA9IHRoaXMuX3BvcG92ZXIuc3R5bGVbZV0gPSAnJztcbiAgICAgIHV0aWwucmVtb3ZlTW9kaWZpZXIodGhpcywgZSk7XG4gICAgfSk7XG4gIH1cblxuICBfb25DaGFuZ2UoKSB7XG4gICAgc2V0SW1tZWRpYXRlKCgpID0+IHtcbiAgICAgIGlmICh0aGlzLl9jdXJyZW50VGFyZ2V0KSB7XG4gICAgICAgIHRoaXMuX3Bvc2l0aW9uUG9wb3Zlcih0aGlzLl9jdXJyZW50VGFyZ2V0KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIF9jb21waWxlKCkge1xuICAgIGF1dG9TdHlsZS5wcmVwYXJlKHRoaXMpO1xuXG4gICAgaWYgKHRoaXMuX3BvcG92ZXIgJiYgdGhpcy5fbWFzaykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGhhc0RlZmF1bHRDb250YWluZXIgPSB0aGlzLl9wb3BvdmVyICYmIHRoaXMuX2NvbnRlbnQ7XG5cbiAgICBpZiAoaGFzRGVmYXVsdENvbnRhaW5lcikge1xuXG4gICAgICBpZiAoIXRoaXMuX21hc2spIHtcbiAgICAgICAgY29uc3QgbWFzayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBtYXNrLmNsYXNzTGlzdC5hZGQoJ3BvcG92ZXItbWFzaycpO1xuICAgICAgICB0aGlzLmluc2VydEJlZm9yZShtYXNrLCB0aGlzLmZpcnN0Q2hpbGQpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXRoaXMuX2Fycm93KSB7XG4gICAgICAgIGNvbnN0IGFycm93ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIGFycm93LmNsYXNzTGlzdC5hZGQoJ3BvcG92ZXJfX2Fycm93Jyk7XG4gICAgICAgIHRoaXMuX3BvcG92ZXIuYXBwZW5kQ2hpbGQoYXJyb3cpO1xuICAgICAgfVxuXG4gICAgfSBlbHNlIHtcblxuICAgICAgY29uc3QgdGVtcGxhdGUgPSB1dGlsLmNyZWF0ZUZyYWdtZW50KGBcbiAgICAgICAgPGRpdiBjbGFzcz1cInBvcG92ZXItbWFza1wiPjwvZGl2PlxuICAgICAgICA8ZGl2IGNsYXNzPVwicG9wb3ZlclwiPlxuICAgICAgICAgIDxkaXYgY2xhc3M9XCJwb3BvdmVyX19jb250ZW50XCI+PC9kaXY+XG4gICAgICAgICAgPGRpdiBjbGFzcz1cInBvcG92ZXJfX2Fycm93XCI+PC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICAgYCk7XG4gICAgICBjb25zdCBjb250ZW50ID0gdGVtcGxhdGUucXVlcnlTZWxlY3RvcignLnBvcG92ZXJfX2NvbnRlbnQnKTtcblxuICAgICAgd2hpbGUgKHRoaXMuY2hpbGROb2Rlc1swXSkge1xuICAgICAgICBjb250ZW50LmFwcGVuZENoaWxkKHRoaXMuY2hpbGROb2Rlc1swXSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuYXBwZW5kQ2hpbGQodGVtcGxhdGUpO1xuICAgIH1cblxuICAgIC8vIEZJWE1FIVxuICAgIGlmICh0aGlzLmhhc0F0dHJpYnV0ZSgnc3R5bGUnKSkge1xuICAgICAgdGhpcy5fcG9wb3Zlci5zZXRBdHRyaWJ1dGUoJ3N0eWxlJywgdGhpcy5nZXRBdHRyaWJ1dGUoJ3N0eWxlJykpO1xuICAgICAgdGhpcy5yZW1vdmVBdHRyaWJ1dGUoJ3N0eWxlJyk7XG4gICAgfVxuXG4gICAgTW9kaWZpZXJVdGlsLmluaXRNb2RpZmllcih0aGlzLCB0aGlzLl9zY2hlbWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2Qgc2hvd1xuICAgKiBAc2lnbmF0dXJlIHNob3codGFyZ2V0LCBbb3B0aW9uc10pXG4gICAqIEBwYXJhbSB7U3RyaW5nfEV2ZW50fEhUTUxFbGVtZW50fSB0YXJnZXRcbiAgICogICBbZW5dVGFyZ2V0IGVsZW1lbnQuIENhbiBiZSBlaXRoZXIgYSBDU1Mgc2VsZWN0b3IsIGFuIGV2ZW50IG9iamVjdCBvciBhIERPTSBlbGVtZW50LiBJdCBjYW4gYmUgYWxzbyBwcm92aWRlZCBhcyAnb3B0aW9ucy50YXJnZXQnIGluc3RlYWQuIFsvZW5dXG4gICAqICAgW2phXeODneODg+ODl+OCquODvOODkOODvOOBruOCv+ODvOOCsuODg+ODiOOBqOOBquOCi+imgee0oOOCkuaMh+WumuOBl+OBvuOBmeOAgkNTU+OCu+ODrOOCr+OCv+OBi2V2ZW5044Kq44OW44K444Kn44Kv44OI44GLRE9N6KaB57Sg44Gu44GE44Ga44KM44GL44KS5rih44Gb44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiAgIFtlbl1QYXJhbWV0ZXIgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCquODl+OCt+ODp+ODs+OCkuaMh+WumuOBmeOCi+OCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5hbmltYXRpb25dXG4gICAqICAgW2VuXUFuaW1hdGlvbiBuYW1lLiAgVXNlIG9uZSBvZiBgXCJmYWRlLWlvc1wiYCwgYFwiZmFkZS1tZFwiYCwgYFwibm9uZVwiYCBhbmQgYFwiZGVmYXVsdFwiYC5bL2VuXVxuICAgKiAgIFtqYV3jgqLjg4vjg6Hjg7zjgrfjg6fjg7PlkI3jgpLmjIflrprjgZfjgb7jgZnjgIJcImZhZGUtaW9zXCIsIFwiZmFkZS1tZFwiLCBcIm5vbmVcIiwgXCJkZWZhdWx0XCLjga7jgYTjgZrjgozjgYvjgpLmjIflrprjgafjgY3jgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuYW5pbWF0aW9uT3B0aW9uc11cbiAgICogICBbZW5dU3BlY2lmeSB0aGUgYW5pbWF0aW9uJ3MgZHVyYXRpb24sIGRlbGF5IGFuZCB0aW1pbmcuIEUuZy4gYHtkdXJhdGlvbjogMC4yLCBkZWxheTogMC40LCB0aW1pbmc6ICdlYXNlLWluJ31gLlsvZW5dXG4gICAqICAgW2phXeOCouODi+ODoeODvOOCt+ODp+ODs+aZguOBrmR1cmF0aW9uLCBkZWxheSwgdGltaW5n44KS5oyH5a6a44GX44G+44GZ44CCZS5nLiB7ZHVyYXRpb246IDAuMiwgZGVsYXk6IDAuNCwgdGltaW5nOiAnZWFzZS1pbid9Wy9qYV1cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuY2FsbGJhY2tdXG4gICAqICAgW2VuXVRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIGFmdGVyIHRoZSBwb3BvdmVyIGhhcyBiZWVuIHJldmVhbGVkLlsvZW5dXG4gICAqICAgW2phXeODneODg+ODl+OCquODvOODkOODvOOBjOihqOekuuOBleOCjOe1guOCj+OBo+OBn+W+jOOBq+WRvOOBs+WHuuOBleOCjOOCi+mWouaVsOOCquODluOCuOOCp+OCr+ODiOOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1PcGVuIHRoZSBwb3BvdmVyIGFuZCBwb2ludCBpdCBhdCBhIHRhcmdldC4gVGhlIHRhcmdldCBjYW4gYmUgZWl0aGVyIGFuIGV2ZW50LCBhIENTUyBzZWxlY3RvciBvciBhIERPTSBlbGVtZW50Li5bL2VuXVxuICAgKiAgIFtqYV3lr77osaHjgajjgZnjgovopoHntKDjgavjg53jg4Pjg5fjgqrjg7zjg5Djg7zjgpLooajnpLrjgZfjgb7jgZnjgIJ0YXJnZXTlvJXmlbDjgavjga/jgIEkZXZlbnTjgqrjg5bjgrjjgqfjgq/jg4jjgoRET03jgqjjg6zjg6Hjg7Pjg4jjgoRDU1Pjgrvjg6zjgq/jgr/jgpLmuKHjgZnjgZPjgajjgYzlh7rmnaXjgb7jgZnjgIJbL2phXVxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKiAgIFtlbl1SZXNvbHZlcyB0byB0aGUgZGlzcGxheWVkIGVsZW1lbnRbL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cbiAgc2hvdyh0YXJnZXQsIG9wdGlvbnMgPSB7fSkge1xuICAgIC8vIENvcHkgb3B0aW9ucyBhbmQgaW5jbHVkZSBvcHRpb25zLnRhcmdldFxuICAgIGlmICh0YXJnZXQgJiYgdHlwZW9mIHRhcmdldCA9PT0gJ29iamVjdCcgJiYgISh0YXJnZXQgaW5zdGFuY2VvZiBFdmVudCkgJiYgISh0YXJnZXQgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkpIHtcbiAgICAgIG9wdGlvbnMgPSB7IC4uLnRhcmdldCB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBvcHRpb25zID0geyAuLi5vcHRpb25zLCB0YXJnZXQgfTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMudGFyZ2V0ID09PSAnc3RyaW5nJykge1xuICAgICAgb3B0aW9ucy50YXJnZXQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKG9wdGlvbnMudGFyZ2V0KTtcbiAgICB9IGVsc2UgaWYgKG9wdGlvbnMudGFyZ2V0IGluc3RhbmNlb2YgRXZlbnQpIHtcbiAgICAgIG9wdGlvbnMudGFyZ2V0ID0gb3B0aW9ucy50YXJnZXQudGFyZ2V0O1xuICAgIH1cblxuICAgIGlmICghKG9wdGlvbnMudGFyZ2V0IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpKSB7XG4gICAgIHV0aWwudGhyb3coJ0ludmFsaWQgdGFyZ2V0IHR5cGUgb3IgdW5kZWZpbmVkJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN1cGVyLnNob3cob3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBoaWRlXG4gICAqIEBzaWduYXR1cmUgaGlkZShbb3B0aW9uc10pXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogICBbZW5dUGFyYW1ldGVyIG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgqrjg5fjgrfjg6fjg7PjgpLmjIflrprjgZnjgovjgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuYW5pbWF0aW9uXVxuICAgKiAgIFtlbl1BbmltYXRpb24gbmFtZS4gIFVzZSBvbmUgb2YgYFwiZmFkZS1pb3NcImAsIGBcImZhZGUtbWRcImAsIGBcIm5vbmVcImAgYW5kIGBcImRlZmF1bHRcImAuWy9lbl1cbiAgICogICBbamFd44Ki44OL44Oh44O844K344On44Oz5ZCN44KS5oyH5a6a44GX44G+44GZ44CCXCJmYWRlLWlvc1wiLCBcImZhZGUtbWRcIiwgXCJub25lXCIsIFwiZGVmYXVsdFwi44Gu44GE44Ga44KM44GL44KS5oyH5a6a44Gn44GN44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmFuaW1hdGlvbk9wdGlvbnNdXG4gICAqICAgW2VuXVNwZWNpZnkgdGhlIGFuaW1hdGlvbidzIGR1cmF0aW9uLCBkZWxheSBhbmQgdGltaW5nLiBFLmcuIGB7ZHVyYXRpb246IDAuMiwgZGVsYXk6IDAuNCwgdGltaW5nOiAnZWFzZS1pbid9YC5bL2VuXVxuICAgKiAgIFtqYV3jgqLjg4vjg6Hjg7zjgrfjg6fjg7PmmYLjga5kdXJhdGlvbiwgZGVsYXksIHRpbWluZ+OCkuaMh+WumuOBl+OBvuOBmeOAgmUuZy4ge2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAwLjQsIHRpbWluZzogJ2Vhc2UtaW4nfVsvamFdXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmNhbGxiYWNrXVxuICAgKiAgIFtlbl1UaGlzIGZ1bmN0aW9ucyBpcyBjYWxsZWQgYWZ0ZXIgdGhlIHBvcG92ZXIgaGFzIGJlZW4gaGlkZGVuLlsvZW5dXG4gICAqICAgW2phXeODneODg+ODl+OCquODvOODkOODvOOBjOmaoOOCjOOBn+W+jOOBq+WRvOOBs+WHuuOBleOCjOOCi+mWouaVsOOCquODluOCuOOCp+OCr+ODiOOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1DbG9zZSB0aGUgcG9wb3Zlci5bL2VuXVxuICAgKiAgIFtqYV3jg53jg4Pjg5fjgqrjg7zjg5Djg7zjgpLplonjgZjjgb7jgZnjgIJbL2phXVxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKiAgIFtlbl1SZXNvbHZlcyB0byB0aGUgaGlkZGVuIGVsZW1lbnRbL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQHByb3BlcnR5IHZpc2libGVcbiAgICogQHJlYWRvbmx5XG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dV2hldGhlciB0aGUgZWxlbWVudCBpcyB2aXNpYmxlIG9yIG5vdC5bL2VuXVxuICAgKiAgIFtqYV3opoHntKDjgYzopovjgYjjgovloLTlkIjjgatgdHJ1ZWDjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQHByb3BlcnR5IGNhbmNlbGFibGVcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1cbiAgICogICAgIEEgYm9vbGVhbiB2YWx1ZSB0aGF0IHNwZWNpZmllcyB3aGV0aGVyIHRoZSBwb3BvdmVyIGlzIGNhbmNlbGFibGUgb3Igbm90LlxuICAgKlxuICAgKiAgICAgV2hlbiB0aGUgcG9wb3ZlciBpcyBjYW5jZWxhYmxlIGl0IGNhbiBiZSBjbG9zZWQgYnkgdGFwcGluZyB0aGUgYmFja2dyb3VuZCBvciBieSBwcmVzc2luZyB0aGUgYmFjayBidXR0b24gb24gQW5kcm9pZCBkZXZpY2VzLlxuICAgKiAgIFsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgb25EZXZpY2VCYWNrQnV0dG9uXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1CYWNrLWJ1dHRvbiBoYW5kbGVyLlsvZW5dXG4gICAqICAgW2phXeODkOODg+OCr+ODnOOCv+ODs+ODj+ODs+ODieODqeOAglsvamFdXG4gICAqL1xuXG4gIGNvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIHN1cGVyLmNvbm5lY3RlZENhbGxiYWNrKCk7XG5cbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcy5fYm91bmRPbkNoYW5nZSwgZmFsc2UpO1xuICAgIHRoaXMuX21hcmdpbiA9IHRoaXMuX21hcmdpbiB8fCBwYXJzZUludCh3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzKS5nZXRQcm9wZXJ0eVZhbHVlKCd0b3AnKSk7XG4gICAgdGhpcy5fbWFyZ2luID0gdGhpcy5fbWFyZ2luIHx8IDY7IC8vIEZpeCBmb3IgaWZyYW1lc1xuXG4gICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHtcbiAgICAgIHRoaXMuX3JhZGl1cyA9IHBhcnNlSW50KHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHRoaXMuX2NvbnRlbnQpLmdldFByb3BlcnR5VmFsdWUoJ2JvcmRlci10b3AtbGVmdC1yYWRpdXMnKSk7XG4gICAgfSk7XG4gIH1cblxuICBkaXNjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICBzdXBlci5kaXNjb25uZWN0ZWRDYWxsYmFjaygpO1xuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLl9ib3VuZE9uQ2hhbmdlLCBmYWxzZSk7XG4gIH1cblxuICBzdGF0aWMgZ2V0IG9ic2VydmVkQXR0cmlidXRlcygpIHtcbiAgICByZXR1cm4gWy4uLnN1cGVyLm9ic2VydmVkQXR0cmlidXRlcywgJ2RpcmVjdGlvbiddO1xuICB9XG5cbiAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIGxhc3QsIGN1cnJlbnQpIHtcbiAgICBpZiAobmFtZSA9PT0gJ2RpcmVjdGlvbicpIHtcbiAgICAgIHJldHVybiB0aGlzLl9ib3VuZE9uQ2hhbmdlKCk7XG4gICAgfSBlbHNlIGlmIChuYW1lID09PSAnbW9kaWZpZXInKSB7XG4gICAgICB0aGlzLl9jdXJyZW50RGlyZWN0aW9uICYmIHV0aWwuYWRkTW9kaWZpZXIodGhpcywgdGhpcy5fY3VycmVudERpcmVjdGlvbik7XG4gICAgfVxuICAgIHN1cGVyLmF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBsYXN0LCBjdXJyZW50KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICAgKiBAcGFyYW0ge1BvcG92ZXJBbmltYXRvcn0gQW5pbWF0b3JcbiAgICovXG4gIHN0YXRpYyByZWdpc3RlckFuaW1hdG9yKG5hbWUsIEFuaW1hdG9yKSB7XG4gICAgaWYgKCEoQW5pbWF0b3IucHJvdG90eXBlIGluc3RhbmNlb2YgUG9wb3ZlckFuaW1hdG9yKSkge1xuICAgICAgdXRpbC50aHJvd0FuaW1hdG9yKCdQb3BvdmVyJyk7XG4gICAgfVxuICAgIF9hbmltYXRvckRpY3RbbmFtZV0gPSBBbmltYXRvcjtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgYW5pbWF0b3JzKCkge1xuICAgIHJldHVybiBfYW5pbWF0b3JEaWN0O1xuICB9XG5cbiAgc3RhdGljIGdldCBQb3BvdmVyQW5pbWF0b3IoKSB7XG4gICAgcmV0dXJuIFBvcG92ZXJBbmltYXRvcjtcbiAgfVxufVxuXG5vbnNFbGVtZW50cy5Qb3BvdmVyID0gUG9wb3ZlckVsZW1lbnQ7XG5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ29ucy1wb3BvdmVyJywgUG9wb3ZlckVsZW1lbnQpO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IG9uc0VsZW1lbnRzIGZyb20gJy4uL29ucy9lbGVtZW50cyc7XG5pbXBvcnQgdXRpbCBmcm9tICcuLi9vbnMvdXRpbCc7XG5pbXBvcnQgYXV0b1N0eWxlIGZyb20gJy4uL29ucy9hdXRvc3R5bGUnO1xuaW1wb3J0IE1vZGlmaWVyVXRpbCBmcm9tICcuLi9vbnMvaW50ZXJuYWwvbW9kaWZpZXItdXRpbCc7XG5pbXBvcnQgQmFzZUVsZW1lbnQgZnJvbSAnLi9iYXNlL2Jhc2UtZWxlbWVudCc7XG5pbXBvcnQgY29udGVudFJlYWR5IGZyb20gJy4uL29ucy9jb250ZW50LXJlYWR5JztcblxuY29uc3Qgc2NoZW1lID0ge1xuICAnLnByb2dyZXNzLWJhcic6ICdwcm9ncmVzcy1iYXItLSonLFxuICAnLnByb2dyZXNzLWJhcl9fcHJpbWFyeSc6ICdwcm9ncmVzcy1iYXItLSpfX3ByaW1hcnknLFxuICAnLnByb2dyZXNzLWJhcl9fc2Vjb25kYXJ5JzogJ3Byb2dyZXNzLWJhci0tKl9fc2Vjb25kYXJ5J1xufTtcblxuY29uc3QgdGVtcGxhdGUgPSB1dGlsLmNyZWF0ZUVsZW1lbnQoYFxuICA8ZGl2IGNsYXNzPVwicHJvZ3Jlc3MtYmFyXCI+XG4gICAgPGRpdiBjbGFzcz1cInByb2dyZXNzLWJhcl9fc2Vjb25kYXJ5XCI+PC9kaXY+XG4gICAgPGRpdiBjbGFzcz1cInByb2dyZXNzLWJhcl9fcHJpbWFyeVwiPjwvZGl2PlxuICA8L2Rpdj5cbmApO1xuXG5jb25zdCBJTkRFVCA9ICdpbmRldGVybWluYXRlJztcblxuLyoqXG4gKiBAZWxlbWVudCBvbnMtcHJvZ3Jlc3MtYmFyXG4gKiBAY2F0ZWdvcnkgdmlzdWFsXG4gKiBAbW9kaWZpZXIgbWF0ZXJpYWxcbiAqICAgW2VuXURpc3BsYXkgYSBNYXRlcmlhbCBEZXNpZ24gcHJvZ3Jlc3MgYmFyLlsvZW5dXG4gKiAgIFtqYV3jg57jg4bjg6rjgqLjg6vjg4fjgrbjgqTjg7Pjga7jgrnjgr/jgqTjg6vjgafjg5fjg63jgrDjg6zjgrnjg5Djg7zjgpLooajnpLrjgZfjgb7jgZnjgIJbL2phXVxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1cbiAqICAgICBUaGUgY29tcG9uZW50IGlzIHVzZWQgdG8gZGlzcGxheSBhIGxpbmVhciBwcm9ncmVzcyBiYXIuIEl0IGNhbiBlaXRoZXIgZGlzcGxheSBhIHByb2dyZXNzIGJhciB0aGF0IHNob3dzIHRoZSB1c2VyIGhvdyBtdWNoIG9mIGEgdGFzayBoYXMgYmVlbiBjb21wbGV0ZWQuIEluIHRoZSBjYXNlIHdoZXJlIHRoZSBwZXJjZW50YWdlIGlzIG5vdCBrbm93biBpdCBjYW4gYmUgdXNlZCB0byBkaXNwbGF5IGFuIGFuaW1hdGVkIHByb2dyZXNzIGJhciBzbyB0aGUgdXNlciBjYW4gc2VlIHRoYXQgYW4gb3BlcmF0aW9uIGlzIGluIHByb2dyZXNzLlxuICogICBbL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBjb2RlcGVuIHp2UWJHalxuICogQHR1dG9yaWFsIHZhbmlsbGEvUmVmZXJlbmNlL3Byb2dyZXNzXG4gKiBAc2VlYWxzbyBvbnMtcHJvZ3Jlc3MtY2lyY3VsYXJcbiAqICAgW2VuXVRoZSBgPG9ucy1wcm9ncmVzcy1jaXJjdWxhcj5gIGNvbXBvbmVudCBkaXNwbGF5cyBhIGNpcmN1bGFyIHByb2dyZXNzIGluZGljYXRvci5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBleGFtcGxlXG4gKiA8b25zLXByb2dyZXNzLWJhclxuICogIHZhbHVlPVwiNTVcIlxuICogIHNlY29uZGFyeS12YWx1ZT1cIjg3XCI+XG4gKiA8L29ucy1wcm9ncmVzcy1iYXI+XG4gKlxuICogPG9ucy1wcm9ncmVzcy1iYXJcbiAqICBpbmRldGVybWluYXRlPlxuICogPC9vbnMtcHJvZ3Jlc3MtYmFyPlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQcm9ncmVzc0JhckVsZW1lbnQgZXh0ZW5kcyBCYXNlRWxlbWVudCB7XG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgbW9kaWZpZXJcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUNoYW5nZSB0aGUgYXBwZWFyYW5jZSBvZiB0aGUgcHJvZ3Jlc3MgaW5kaWNhdG9yLlsvZW5dXG4gICAqICAgW2phXeODl+ODreOCsOODrOOCueOCpOODs+OCuOOCseODvOOCv+OBruimi+OBn+ebruOCkuWkieabtOOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIHZhbHVlXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1DdXJyZW50IHByb2dyZXNzLiBTaG91bGQgYmUgYSB2YWx1ZSBiZXR3ZWVuIDAgYW5kIDEwMC5bL2VuXVxuICAgKiAgIFtqYV3nj77lnKjjga7pgLLooYznirbms4Hjga7lgKTjgpLmjIflrprjgZfjgb7jgZnjgIIw44GL44KJMTAw44Gu6ZaT44Gu5YCk44KS5oyH5a6a44GX44Gm5LiL44GV44GE44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgc2Vjb25kYXJ5LXZhbHVlXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1DdXJyZW50IHNlY29uZGFyeSBwcm9ncmVzcy4gU2hvdWxkIGJlIGEgdmFsdWUgYmV0d2VlbiAwIGFuZCAxMDAuWy9lbl1cbiAgICogICBbamFd54++5Zyo44Gu77yS55Wq55uu44Gu6YCy6KGM54q25rOB44Gu5YCk44KS5oyH5a6a44GX44G+44GZ44CCMOOBi+OCiTEwMOOBrumWk+OBruWApOOCkuaMh+WumuOBl+OBpuS4i+OBleOBhOOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGluZGV0ZXJtaW5hdGVcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUlmIHRoaXMgYXR0cmlidXRlIGlzIHNldCwgYW4gaW5maW5pdGUgbG9vcGluZyBhbmltYXRpb24gd2lsbCBiZSBzaG93bi5bL2VuXVxuICAgKiAgIFtqYV3jgZPjga7lsZ7mgKfjgYzoqK3lrprjgZXjgozjgZ/loLTlkIjjgIHjg6vjg7zjg5fjgZnjgovjgqLjg4vjg6Hjg7zjgrfjg6fjg7PjgYzooajnpLrjgZXjgozjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHRoaXMuX2NvbXBpbGUoKSk7XG4gIH1cblxuICBfY29tcGlsZSgpIHtcbiAgICBpZiAoIXRoaXMuX2lzQ29tcGlsZWQoKSkge1xuICAgICAgdGhpcy5fdGVtcGxhdGUgPSB0ZW1wbGF0ZS5jbG9uZU5vZGUodHJ1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3RlbXBsYXRlID0gdXRpbC5maW5kQ2hpbGQodGhpcywgJy5wcm9ncmVzcy1iYXInKTtcbiAgICB9XG5cbiAgICB0aGlzLl9wcmltYXJ5ID0gdXRpbC5maW5kQ2hpbGQodGhpcy5fdGVtcGxhdGUsICcucHJvZ3Jlc3MtYmFyX19wcmltYXJ5Jyk7XG4gICAgdGhpcy5fc2Vjb25kYXJ5ID0gdXRpbC5maW5kQ2hpbGQodGhpcy5fdGVtcGxhdGUsICcucHJvZ3Jlc3MtYmFyX19zZWNvbmRhcnknKTtcblxuICAgIHRoaXMuX3VwZGF0ZURldGVybWluYXRlKCk7XG4gICAgdGhpcy5fdXBkYXRlVmFsdWUoKTtcblxuICAgIHRoaXMuYXBwZW5kQ2hpbGQodGhpcy5fdGVtcGxhdGUpO1xuXG4gICAgYXV0b1N0eWxlLnByZXBhcmUodGhpcyk7XG4gICAgTW9kaWZpZXJVdGlsLmluaXRNb2RpZmllcih0aGlzLCBzY2hlbWUpO1xuICB9XG5cbiAgX2lzQ29tcGlsZWQoKSB7XG4gICAgaWYgKCF1dGlsLmZpbmRDaGlsZCh0aGlzLCAnLnByb2dyZXNzLWJhcicpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgY29uc3QgYmFyRWxlbWVudCA9IHV0aWwuZmluZENoaWxkKHRoaXMsICcucHJvZ3Jlc3MtYmFyJyk7XG5cbiAgICBpZiAoIXV0aWwuZmluZENoaWxkKGJhckVsZW1lbnQsICcucHJvZ3Jlc3MtYmFyX19zZWNvbmRhcnknKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmICghdXRpbC5maW5kQ2hpbGQoYmFyRWxlbWVudCwgJy5wcm9ncmVzcy1iYXJfX3ByaW1hcnknKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgc3RhdGljIGdldCBvYnNlcnZlZEF0dHJpYnV0ZXMoKSB7XG4gICAgcmV0dXJuIFsnbW9kaWZpZXInLCAndmFsdWUnLCAnc2Vjb25kYXJ5LXZhbHVlJywgSU5ERVRdO1xuICB9XG5cbiAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIGxhc3QsIGN1cnJlbnQpIHtcbiAgICBpZiAobmFtZSA9PT0gJ21vZGlmaWVyJykge1xuICAgICAgTW9kaWZpZXJVdGlsLm9uTW9kaWZpZXJDaGFuZ2VkKGxhc3QsIGN1cnJlbnQsIHRoaXMsIHNjaGVtZSk7XG4gICAgICB0aGlzLmhhc0F0dHJpYnV0ZShJTkRFVCkgJiYgdGhpcy5fdXBkYXRlRGV0ZXJtaW5hdGUoKTtcbiAgICB9IGVsc2UgaWYgKG5hbWUgPT09ICd2YWx1ZScgfHwgbmFtZSA9PT0gJ3NlY29uZGFyeS12YWx1ZScpIHtcbiAgICAgIHRoaXMuX3VwZGF0ZVZhbHVlKCk7XG4gICAgfSBlbHNlIGlmIChuYW1lID09PSBJTkRFVCkge1xuICAgICAgdGhpcy5fdXBkYXRlRGV0ZXJtaW5hdGUoKTtcbiAgICB9XG4gIH1cblxuICBfdXBkYXRlRGV0ZXJtaW5hdGUoKSB7XG4gICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHV0aWwudG9nZ2xlTW9kaWZpZXIodGhpcywgSU5ERVQsIHsgZm9yY2U6IHRoaXMuaGFzQXR0cmlidXRlKElOREVUKSB9KSk7XG4gIH1cblxuICBfdXBkYXRlVmFsdWUoKSB7XG4gICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHtcbiAgICAgIHRoaXMuX3ByaW1hcnkuc3R5bGUud2lkdGggPSAodGhpcy5oYXNBdHRyaWJ1dGUoJ3ZhbHVlJykpID8gdGhpcy5nZXRBdHRyaWJ1dGUoJ3ZhbHVlJykgKyAnJScgOiAnMCUnO1xuICAgICAgdGhpcy5fc2Vjb25kYXJ5LnN0eWxlLndpZHRoID0gdGhpcy5oYXNBdHRyaWJ1dGUoJ3NlY29uZGFyeS12YWx1ZScpID8gdGhpcy5nZXRBdHRyaWJ1dGUoJ3NlY29uZGFyeS12YWx1ZScpICsgJyUnIDogJzAlJztcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgdmFsdWVcbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUN1cnJlbnQgcHJvZ3Jlc3MuIFNob3VsZCBiZSBhIHZhbHVlIGJldHdlZW4gMCBhbmQgMTAwLlsvZW5dXG4gICAqICAgW2phXeePvuWcqOOBrumAsuihjOeKtuazgeOBruWApOOCkuaMh+WumuOBl+OBvuOBmeOAgjDjgYvjgokxMDDjga7plpPjga7lgKTjgpLmjIflrprjgZfjgabkuIvjgZXjgYTjgIJbL2phXVxuICAgKi9cbiAgc2V0IHZhbHVlKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ251bWJlcicgfHwgdmFsdWUgPCAwIHx8IHZhbHVlID4gMTAwKSB7XG4gICAgICB1dGlsLnRocm93KCdJbnZhbGlkIHZhbHVlJyk7XG4gICAgfVxuXG4gICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ3ZhbHVlJywgTWF0aC5mbG9vcih2YWx1ZSkpO1xuICB9XG5cbiAgZ2V0IHZhbHVlKCkge1xuICAgIHJldHVybiBwYXJzZUludCh0aGlzLmdldEF0dHJpYnV0ZSgndmFsdWUnKSB8fCAnMCcpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBzZWNvbmRhcnlWYWx1ZVxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dQ3VycmVudCBzZWNvbmRhcnkgcHJvZ3Jlc3MuIFNob3VsZCBiZSBhIHZhbHVlIGJldHdlZW4gMCBhbmQgMTAwLlsvZW5dXG4gICAqICAgW2phXeePvuWcqOOBru+8kueVquebruOBrumAsuihjOeKtuazgeOBruWApOOCkuaMh+WumuOBl+OBvuOBmeOAgjDjgYvjgokxMDDjga7plpPjga7lgKTjgpLmjIflrprjgZfjgabkuIvjgZXjgYTjgIJbL2phXVxuICAgKi9cbiAgc2V0IHNlY29uZGFyeVZhbHVlKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ251bWJlcicgfHwgdmFsdWUgPCAwIHx8IHZhbHVlID4gMTAwKSB7XG4gICAgICB1dGlsLnRocm93KCdJbnZhbGlkIHZhbHVlJyk7XG4gICAgfVxuXG4gICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ3NlY29uZGFyeS12YWx1ZScsIE1hdGguZmxvb3IodmFsdWUpKTtcbiAgfVxuXG4gIGdldCBzZWNvbmRhcnlWYWx1ZSgpIHtcbiAgICByZXR1cm4gcGFyc2VJbnQodGhpcy5nZXRBdHRyaWJ1dGUoJ3NlY29uZGFyeS12YWx1ZScpIHx8ICcwJyk7XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IGluZGV0ZXJtaW5hdGVcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1JZiB0aGlzIHByb3BlcnR5IGlzIGB0cnVlYCwgYW4gaW5maW5pdGUgbG9vcGluZyBhbmltYXRpb24gd2lsbCBiZSBzaG93bi5bL2VuXVxuICAgKiAgIFtqYV3jgZPjga7lsZ7mgKfjgYzoqK3lrprjgZXjgozjgZ/loLTlkIjjgIHjg6vjg7zjg5fjgZnjgovjgqLjg4vjg6Hjg7zjgrfjg6fjg7PjgYzooajnpLrjgZXjgozjgb7jgZnjgIJbL2phXVxuICAgKi9cbiAgc2V0IGluZGV0ZXJtaW5hdGUodmFsdWUpIHtcbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIHRoaXMuc2V0QXR0cmlidXRlKElOREVULCAnJyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGhpcy5yZW1vdmVBdHRyaWJ1dGUoSU5ERVQpO1xuICAgIH1cbiAgfVxuXG4gIGdldCBpbmRldGVybWluYXRlKCkge1xuICAgIHJldHVybiB0aGlzLmhhc0F0dHJpYnV0ZShJTkRFVCk7XG4gIH1cbn1cblxub25zRWxlbWVudHMuUHJvZ3Jlc3NCYXIgPSBQcm9ncmVzc0JhckVsZW1lbnQ7XG5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ29ucy1wcm9ncmVzcy1iYXInLCBQcm9ncmVzc0JhckVsZW1lbnQpO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IG9uc0VsZW1lbnRzIGZyb20gJy4uL29ucy9lbGVtZW50cyc7XG5pbXBvcnQgdXRpbCBmcm9tICcuLi9vbnMvdXRpbCc7XG5pbXBvcnQgYXV0b1N0eWxlIGZyb20gJy4uL29ucy9hdXRvc3R5bGUnO1xuaW1wb3J0IE1vZGlmaWVyVXRpbCBmcm9tICcuLi9vbnMvaW50ZXJuYWwvbW9kaWZpZXItdXRpbCc7XG5pbXBvcnQgQmFzZUVsZW1lbnQgZnJvbSAnLi9iYXNlL2Jhc2UtZWxlbWVudCc7XG5pbXBvcnQgY29udGVudFJlYWR5IGZyb20gJy4uL29ucy9jb250ZW50LXJlYWR5JztcblxuY29uc3Qgc2NoZW1lID0ge1xuICAnLnByb2dyZXNzLWNpcmN1bGFyJzogJ3Byb2dyZXNzLWNpcmN1bGFyLS0qJyxcbiAgJy5wcm9ncmVzcy1jaXJjdWxhcl9fYmFja2dyb3VuZCc6ICdwcm9ncmVzcy1jaXJjdWxhci0tKl9fYmFja2dyb3VuZCcsXG4gICcucHJvZ3Jlc3MtY2lyY3VsYXJfX3ByaW1hcnknOiAncHJvZ3Jlc3MtY2lyY3VsYXItLSpfX3ByaW1hcnknLFxuICAnLnByb2dyZXNzLWNpcmN1bGFyX19zZWNvbmRhcnknOiAncHJvZ3Jlc3MtY2lyY3VsYXItLSpfX3NlY29uZGFyeSdcbn07XG5cbmNvbnN0IHRlbXBsYXRlID0gdXRpbC5jcmVhdGVFbGVtZW50KGBcbiAgPHN2ZyBjbGFzcz1cInByb2dyZXNzLWNpcmN1bGFyXCI+XG4gICAgPGNpcmNsZSBjbGFzcz1cInByb2dyZXNzLWNpcmN1bGFyX19iYWNrZ3JvdW5kXCIgLz5cbiAgICA8Y2lyY2xlIGNsYXNzPVwicHJvZ3Jlc3MtY2lyY3VsYXJfX3NlY29uZGFyeVwiIGN4PVwiNTAlXCIgY3k9XCI1MCVcIiByPVwiNDAlXCIgLz5cbiAgICA8Y2lyY2xlIGNsYXNzPVwicHJvZ3Jlc3MtY2lyY3VsYXJfX3ByaW1hcnlcIiBjeD1cIjUwJVwiIGN5PVwiNTAlXCIgcj1cIjQwJVwiIC8+XG4gIDwvc3ZnPlxuYCk7XG5cbmNvbnN0IElOREVUID0gJ2luZGV0ZXJtaW5hdGUnO1xuXG4vKipcbiAqIEBlbGVtZW50IG9ucy1wcm9ncmVzcy1jaXJjdWxhclxuICogQGNhdGVnb3J5IHZpc3VhbFxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1cbiAqICAgICBUaGlzIGNvbXBvbmVudCBkaXNwbGF5cyBhIGNpcmN1bGFyIHByb2dyZXNzIGluZGljYXRvci4gSXQgY2FuIGVpdGhlciBiZSB1c2VkIHRvIHNob3cgaG93IG11Y2ggb2YgYSB0YXNrIGhhcyBiZWVuIGNvbXBsZXRlZCBvciB0byBzaG93IGEgbG9vcGluZyBhbmltYXRpb24gdG8gaW5kaWNhdGUgdGhhdCBhbiBvcGVyYXRpb24gaXMgY3VycmVudGx5IHJ1bm5pbmcuXG4gKiAgIFsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQGNvZGVwZW4gRVZ6TWpSXG4gKiBAdHV0b3JpYWwgdmFuaWxsYS9SZWZlcmVuY2UvcHJvZ3Jlc3MtY2lyY3VsYXJcbiAqIEBzZWVhbHNvIG9ucy1wcm9ncmVzcy1iYXJcbiAqICAgW2VuXVRoZSBgPG9ucy1wcm9ncmVzcy1iYXI+YCBjb21wb25lbnQgZGlzcGxheXMgYSBiYXIgcHJvZ3Jlc3MgaW5kaWNhdG9yLlsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQGV4YW1wbGVcbiAqIDxvbnMtcHJvZ3Jlc3MtY2lyY3VsYXJcbiAqICB2YWx1ZT1cIjU1XCJcbiAqICBzZWNvbmRhcnktdmFsdWU9XCI4N1wiPlxuICogPC9vbnMtcHJvZ3Jlc3MtY2lyY3VsYXI+XG4gKlxuICogPG9ucy1wcm9ncmVzcy1jaXJjdWxhclxuICogIGluZGV0ZXJtaW5hdGU+XG4gKiA8L29ucy1wcm9ncmVzcy1jaXJjdWxhcj5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUHJvZ3Jlc3NDaXJjdWxhckVsZW1lbnQgZXh0ZW5kcyBCYXNlRWxlbWVudCB7XG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgbW9kaWZpZXJcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUNoYW5nZSB0aGUgYXBwZWFyYW5jZSBvZiB0aGUgcHJvZ3Jlc3MgaW5kaWNhdG9yLlsvZW5dXG4gICAqICAgW2phXeODl+ODreOCsOODrOOCueOCpOODs+OCuOOCseODvOOCv+OBruimi+OBn+ebruOCkuWkieabtOOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIHZhbHVlXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1DdXJyZW50IHByb2dyZXNzLiBTaG91bGQgYmUgYSB2YWx1ZSBiZXR3ZWVuIDAgYW5kIDEwMC5bL2VuXVxuICAgKiAgIFtqYV3nj77lnKjjga7pgLLooYznirbms4Hjga7lgKTjgpLmjIflrprjgZfjgb7jgZnjgIIw44GL44KJMTAw44Gu6ZaT44Gu5YCk44KS5oyH5a6a44GX44Gm5LiL44GV44GE44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgc2Vjb25kYXJ5LXZhbHVlXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1DdXJyZW50IHNlY29uZGFyeSBwcm9ncmVzcy4gU2hvdWxkIGJlIGEgdmFsdWUgYmV0d2VlbiAwIGFuZCAxMDAuWy9lbl1cbiAgICogICBbamFd54++5Zyo44Gu77yS55Wq55uu44Gu6YCy6KGM54q25rOB44Gu5YCk44KS5oyH5a6a44GX44G+44GZ44CCMOOBi+OCiTEwMOOBrumWk+OBruWApOOCkuaMh+WumuOBl+OBpuS4i+OBleOBhOOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGluZGV0ZXJtaW5hdGVcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUlmIHRoaXMgYXR0cmlidXRlIGlzIHNldCwgYW4gaW5maW5pdGUgbG9vcGluZyBhbmltYXRpb24gd2lsbCBiZSBzaG93bi5bL2VuXVxuICAgKiAgIFtqYV3jgZPjga7lsZ7mgKfjgYzoqK3lrprjgZXjgozjgZ/loLTlkIjjgIHjg6vjg7zjg5fjgZnjgovjgqLjg4vjg6Hjg7zjgrfjg6fjg7PjgYzooajnpLrjgZXjgozjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHRoaXMuX2NvbXBpbGUoKSk7XG4gIH1cblxuICBzdGF0aWMgZ2V0IG9ic2VydmVkQXR0cmlidXRlcygpIHtcbiAgICByZXR1cm4gWydtb2RpZmllcicsICd2YWx1ZScsICdzZWNvbmRhcnktdmFsdWUnLCBJTkRFVF07XG4gIH1cblxuICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgbGFzdCwgY3VycmVudCkge1xuICAgIGlmIChuYW1lID09PSAnbW9kaWZpZXInKSB7XG4gICAgICBNb2RpZmllclV0aWwub25Nb2RpZmllckNoYW5nZWQobGFzdCwgY3VycmVudCwgdGhpcywgc2NoZW1lKTtcbiAgICAgIHRoaXMuaGFzQXR0cmlidXRlKElOREVUKSAmJiB0aGlzLl91cGRhdGVEZXRlcm1pbmF0ZSgpO1xuICAgIH0gZWxzZSBpZiAobmFtZSA9PT0gJ3ZhbHVlJyB8fCBuYW1lID09PSAnc2Vjb25kYXJ5LXZhbHVlJykge1xuICAgICAgdGhpcy5fdXBkYXRlVmFsdWUoKTtcbiAgICB9IGVsc2UgaWYgKG5hbWUgPT09IElOREVUKSB7XG4gICAgICB0aGlzLl91cGRhdGVEZXRlcm1pbmF0ZSgpO1xuICAgIH1cbiAgfVxuXG4gIF91cGRhdGVEZXRlcm1pbmF0ZSgpIHtcbiAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4gdXRpbC50b2dnbGVNb2RpZmllcih0aGlzLCBJTkRFVCwgeyBmb3JjZTogdGhpcy5oYXNBdHRyaWJ1dGUoSU5ERVQpIH0pKTtcbiAgfVxuXG4gIF91cGRhdGVWYWx1ZSgpIHtcbiAgICBpZiAodGhpcy5oYXNBdHRyaWJ1dGUoJ3ZhbHVlJykpIHtcbiAgICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHBlciA9IE1hdGguY2VpbCh0aGlzLmdldEF0dHJpYnV0ZSgndmFsdWUnKSAqIDI1MS4zMiAqIDAuMDEpO1xuICAgICAgICB0aGlzLl9wcmltYXJ5LnN0eWxlWydzdHJva2UtZGFzaGFycmF5J10gPSBwZXIgKyAnJSwgMjUxLjMyJSc7XG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHRoaXMuaGFzQXR0cmlidXRlKCdzZWNvbmRhcnktdmFsdWUnKSkge1xuICAgICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHtcbiAgICAgICAgY29uc3QgcGVyID0gIE1hdGguY2VpbCh0aGlzLmdldEF0dHJpYnV0ZSgnc2Vjb25kYXJ5LXZhbHVlJykgKiAyNTEuMzIgKiAwLjAxKTtcbiAgICAgICAgdGhpcy5fc2Vjb25kYXJ5LnN0eWxlLmRpc3BsYXkgPSBudWxsO1xuICAgICAgICB0aGlzLl9zZWNvbmRhcnkuc3R5bGVbJ3N0cm9rZS1kYXNoYXJyYXknXSA9IHBlciArICclLCAyNTEuMzIlJztcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4ge1xuICAgICAgICB0aGlzLl9zZWNvbmRhcnkuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgdmFsdWVcbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUN1cnJlbnQgcHJvZ3Jlc3MuIFNob3VsZCBiZSBhIHZhbHVlIGJldHdlZW4gMCBhbmQgMTAwLlsvZW5dXG4gICAqICAgW2phXeePvuWcqOOBrumAsuihjOeKtuazgeOBruWApOOCkuaMh+WumuOBl+OBvuOBmeOAgjDjgYvjgokxMDDjga7plpPjga7lgKTjgpLmjIflrprjgZfjgabkuIvjgZXjgYTjgIJbL2phXVxuICAgKi9cbiAgc2V0IHZhbHVlKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ251bWJlcicgfHwgdmFsdWUgPCAwIHx8IHZhbHVlID4gMTAwKSB7XG4gICAgICB1dGlsLnRocm93KCdJbnZhbGlkIHZhbHVlJyk7XG4gICAgfVxuXG4gICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ3ZhbHVlJywgTWF0aC5mbG9vcih2YWx1ZSkpO1xuICB9XG5cbiAgZ2V0IHZhbHVlKCkge1xuICAgIHJldHVybiBwYXJzZUludCh0aGlzLmdldEF0dHJpYnV0ZSgndmFsdWUnKSB8fCAnMCcpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBzZWNvbmRhcnlWYWx1ZVxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dQ3VycmVudCBzZWNvbmRhcnkgcHJvZ3Jlc3MuIFNob3VsZCBiZSBhIHZhbHVlIGJldHdlZW4gMCBhbmQgMTAwLlsvZW5dXG4gICAqICAgW2phXeePvuWcqOOBru+8kueVquebruOBrumAsuihjOeKtuazgeOBruWApOOCkuaMh+WumuOBl+OBvuOBmeOAgjDjgYvjgokxMDDjga7plpPjga7lgKTjgpLmjIflrprjgZfjgabkuIvjgZXjgYTjgIJbL2phXVxuICAgKi9cbiAgc2V0IHNlY29uZGFyeVZhbHVlKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ251bWJlcicgfHwgdmFsdWUgPCAwIHx8IHZhbHVlID4gMTAwKSB7XG4gICAgICB1dGlsLnRocm93KCdJbnZhbGlkIHZhbHVlJyk7XG4gICAgfVxuXG4gICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ3NlY29uZGFyeS12YWx1ZScsIE1hdGguZmxvb3IodmFsdWUpKTtcbiAgfVxuXG4gIGdldCBzZWNvbmRhcnlWYWx1ZSgpIHtcbiAgICByZXR1cm4gcGFyc2VJbnQodGhpcy5nZXRBdHRyaWJ1dGUoJ3NlY29uZGFyeS12YWx1ZScpIHx8ICcwJyk7XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IGluZGV0ZXJtaW5hdGVcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1JZiB0aGlzIHByb3BlcnR5IGlzIGB0cnVlYCwgYW4gaW5maW5pdGUgbG9vcGluZyBhbmltYXRpb24gd2lsbCBiZSBzaG93bi5bL2VuXVxuICAgKiAgIFtqYV3jgZPjga7lsZ7mgKfjgYzoqK3lrprjgZXjgozjgZ/loLTlkIjjgIHjg6vjg7zjg5fjgZnjgovjgqLjg4vjg6Hjg7zjgrfjg6fjg7PjgYzooajnpLrjgZXjgozjgb7jgZnjgIJbL2phXVxuICAgKi9cbiAgc2V0IGluZGV0ZXJtaW5hdGUodmFsdWUpIHtcbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIHRoaXMuc2V0QXR0cmlidXRlKElOREVULCAnJyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGhpcy5yZW1vdmVBdHRyaWJ1dGUoSU5ERVQpO1xuICAgIH1cbiAgfVxuXG4gIGdldCBpbmRldGVybWluYXRlKCkge1xuICAgIHJldHVybiB0aGlzLmhhc0F0dHJpYnV0ZShJTkRFVCk7XG4gIH1cblxuICBfY29tcGlsZSgpIHtcbiAgICBpZiAodGhpcy5faXNDb21waWxlZCgpKSB7XG4gICAgICB0aGlzLl90ZW1wbGF0ZSA9IHV0aWwuZmluZENoaWxkKHRoaXMsICcucHJvZ3Jlc3MtY2lyY3VsYXInKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fdGVtcGxhdGUgPSB0ZW1wbGF0ZS5jbG9uZU5vZGUodHJ1ZSk7XG4gICAgfVxuXG4gICAgdGhpcy5fcHJpbWFyeSA9IHV0aWwuZmluZENoaWxkKHRoaXMuX3RlbXBsYXRlLCAnLnByb2dyZXNzLWNpcmN1bGFyX19wcmltYXJ5Jyk7XG4gICAgdGhpcy5fc2Vjb25kYXJ5ID0gdXRpbC5maW5kQ2hpbGQodGhpcy5fdGVtcGxhdGUsICcucHJvZ3Jlc3MtY2lyY3VsYXJfX3NlY29uZGFyeScpO1xuXG4gICAgdGhpcy5fdXBkYXRlRGV0ZXJtaW5hdGUoKTtcbiAgICB0aGlzLl91cGRhdGVWYWx1ZSgpO1xuXG4gICAgdGhpcy5hcHBlbmRDaGlsZCh0aGlzLl90ZW1wbGF0ZSk7XG5cbiAgICBhdXRvU3R5bGUucHJlcGFyZSh0aGlzKTtcbiAgICBNb2RpZmllclV0aWwuaW5pdE1vZGlmaWVyKHRoaXMsIHNjaGVtZSk7XG4gIH1cblxuICBfaXNDb21waWxlZCgpIHtcbiAgICBpZiAoIXV0aWwuZmluZENoaWxkKHRoaXMsICcucHJvZ3Jlc3MtY2lyY3VsYXInKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGNvbnN0IHN2ZyA9IHV0aWwuZmluZENoaWxkKHRoaXMsICcucHJvZ3Jlc3MtY2lyY3VsYXInKTtcblxuICAgIGlmICghdXRpbC5maW5kQ2hpbGQoc3ZnLCAnLnByb2dyZXNzLWNpcmN1bGFyX19zZWNvbmRhcnknKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmICghdXRpbC5maW5kQ2hpbGQoc3ZnLCAnLnByb2dyZXNzLWNpcmN1bGFyX19wcmltYXJ5JykpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufVxuXG5vbnNFbGVtZW50cy5Qcm9ncmVzc0NpcmN1bGFyID0gUHJvZ3Jlc3NDaXJjdWxhckVsZW1lbnQ7XG5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ29ucy1wcm9ncmVzcy1jaXJjdWxhcicsIFByb2dyZXNzQ2lyY3VsYXJFbGVtZW50KTtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCBvbnNFbGVtZW50cyBmcm9tICcuLi9vbnMvZWxlbWVudHMnO1xuaW1wb3J0IHV0aWwgZnJvbSAnLi4vb25zL3V0aWwnO1xuaW1wb3J0IHN0eWxlciBmcm9tICcuLi9vbnMvc3R5bGVyJztcbmltcG9ydCBwbGF0Zm9ybSBmcm9tICcuLi9vbnMvcGxhdGZvcm0nO1xuaW1wb3J0IEJhc2VFbGVtZW50IGZyb20gJy4vYmFzZS9iYXNlLWVsZW1lbnQnO1xuaW1wb3J0IEdlc3R1cmVEZXRlY3RvciBmcm9tICcuLi9vbnMvZ2VzdHVyZS1kZXRlY3Rvcic7XG5pbXBvcnQgYW5pbWl0IGZyb20gJy4uL29ucy9hbmltaXQnO1xuXG5jb25zdCBTVEFURV9JTklUSUFMID0gJ2luaXRpYWwnO1xuY29uc3QgU1RBVEVfUFJFQUNUSU9OID0gJ3ByZWFjdGlvbic7XG5jb25zdCBTVEFURV9BQ1RJT04gPSAnYWN0aW9uJztcblxuY29uc3QgdGhyb3dUeXBlID0gKGVsLCB0eXBlKSA9PiB1dGlsLnRocm93KGBcIiR7ZWx9XCIgbXVzdCBiZSAke3R5cGV9YCk7XG5cbi8qKlxuICogQGVsZW1lbnQgb25zLXB1bGwtaG9va1xuICogQGNhdGVnb3J5IGNvbnRyb2xcbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dXG4gKiAgICAgQ29tcG9uZW50IHRoYXQgYWRkcyAqKlB1bGwgdG8gcmVmcmVzaCoqIGZ1bmN0aW9uYWxpdHkgdG8gYW4gYDxvbnMtcGFnZT5gIGVsZW1lbnQuXG4gKlxuICogICAgIEl0IGNhbiBiZSB1c2VkIHRvIHBlcmZvcm0gYSB0YXNrIHdoZW4gdGhlIHVzZXIgcHVsbHMgZG93biBhdCB0aGUgdG9wIG9mIHRoZSBwYWdlLiBBIGNvbW1vbiB1c2FnZSBpcyB0byByZWZyZXNoIHRoZSBkYXRhIGRpc3BsYXllZCBpbiBhIHBhZ2UuXG4gKiAgIFsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQGNvZGVwZW4gV2JKb2dNXG4gKiBAdHV0b3JpYWwgdmFuaWxsYS9SZWZlcmVuY2UvcHVsbC1ob29rXG4gKiBAZXhhbXBsZVxuICogPG9ucy1wYWdlPlxuICogICA8b25zLXB1bGwtaG9vaz5cbiAqICAgICBSZWxlYXNlIHRvIHJlZnJlc2hcbiAqICAgPC9vbnMtcHVsbC1ob29rPlxuICogPC9vbnMtcGFnZT5cbiAqXG4gKiA8c2NyaXB0PlxuICogICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdvbnMtcHVsbC1ob29rJykub25BY3Rpb24gPSBmdW5jdGlvbihkb25lKSB7XG4gKiAgICAgc2V0VGltZW91dChkb25lLCAxMDAwKTtcbiAqICAgfTtcbiAqIDwvc2NyaXB0PlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQdWxsSG9va0VsZW1lbnQgZXh0ZW5kcyBCYXNlRWxlbWVudCB7XG5cbiAgLyoqXG4gICAqIEBldmVudCBjaGFuZ2VzdGF0ZVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dRmlyZWQgd2hlbiB0aGUgc3RhdGUgaXMgY2hhbmdlZC4gVGhlIHN0YXRlIGNhbiBiZSBlaXRoZXIgXCJpbml0aWFsXCIsIFwicHJlYWN0aW9uXCIgb3IgXCJhY3Rpb25cIi5bL2VuXVxuICAgKiAgIFtqYV3jgrPjg7Pjg53jg7zjg43jg7Pjg4jjga7nirbmhYvjgYzlpInjgo/jgaPjgZ/loLTlkIjjgavnmbrngavjgZfjgb7jgZnjgILnirbmhYvjga/jgIFcImluaXRpYWxcIiwgXCJwcmVhY3Rpb25cIiwgXCJhY3Rpb25cIuOBruOBhOOBmuOCjOOBi+OBp+OBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudFxuICAgKiAgIFtlbl1FdmVudCBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Kk44OZ44Oz44OI44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50LnB1bGxIb29rXG4gICAqICAgW2VuXUNvbXBvbmVudCBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Kz44Oz44Od44O844ON44Oz44OI44Gu44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50LnN0YXRlXG4gICAqICAgW2VuXUN1cnJlbnQgc3RhdGUuWy9lbl1cbiAgICogICBbamFd54++5Zyo44Gu54q25oWL5ZCN44KS5Y+C54Wn44Gn44GN44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgZGlzYWJsZWRcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUlmIHRoaXMgYXR0cmlidXRlIGlzIHNldCB0aGUgXCJwdWxsLXRvLXJlZnJlc2hcIiBmdW5jdGlvbmFsaXR5IGlzIGRpc2FibGVkLlsvZW5dXG4gICAqICAgW2phXeOBk+OBruWxnuaAp+OBjOOBguOCi+aZguOAgWRpc2FibGVk54q25oWL44Gr44Gq44KK44Ki44Kv44K344On44Oz44GM5a6f6KGM44GV44KM44Gq44GP44Gq44KK44G+44GZWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgaGVpZ2h0XG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1TcGVjaWZ5IHRoZSBoZWlnaHQgb2YgdGhlIGNvbXBvbmVudC4gV2hlbiBwdWxsZWQgZG93biBmdXJ0aGVyIHRoYW4gdGhpcyB2YWx1ZSBpdCB3aWxsIHN3aXRjaCB0byB0aGUgXCJwcmVhY3Rpb25cIiBzdGF0ZS4gVGhlIGRlZmF1bHQgdmFsdWUgaXMgXCI2NHB4XCIuWy9lbl1cbiAgICogICBbamFd44Kz44Oz44Od44O844ON44Oz44OI44Gu6auY44GV44KS5oyH5a6a44GX44G+44GZ44CC44GT44Gu6auY44GV5Lul5LiK44GrcHVsbCBkb3du44GZ44KL44GoXCJwcmVhY3Rpb25cIueKtuaFi+OBq+enu+ihjOOBl+OBvuOBmeOAguODh+ODleOCqeODq+ODiOOBruWApOOBr1wiNjRweFwi44Gn44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgdGhyZXNob2xkLWhlaWdodFxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dU3BlY2lmeSB0aGUgdGhyZXNob2xkIGhlaWdodC4gVGhlIGNvbXBvbmVudCBhdXRvbWF0aWNhbGx5IHN3aXRjaGVzIHRvIHRoZSBcImFjdGlvblwiIHN0YXRlIHdoZW4gcHVsbGVkIGZ1cnRoZXIgdGhhbiB0aGlzIHZhbHVlLiBUaGUgZGVmYXVsdCB2YWx1ZSBpcyBcIjk2cHhcIi4gQSBuZWdhdGl2ZSB2YWx1ZSB3aWxsIGRpc2FibGUgdGhpcyBwcm9wZXJ0eS4gSWYgdGhpcyB2YWx1ZSBpcyBsb3dlciB0aGFuIHRoZSBoZWlnaHQsIGl0IHdpbGwgc2tpcCBcInByZWFjdGlvblwiIHN0YXRlLlsvZW5dXG4gICAqICAgW2phXemWvuWApOOBqOOBquOCi+mrmOOBleOCkuaMh+WumuOBl+OBvuOBmeOAguOBk+OBruWApOOBp+aMh+WumuOBl+OBn+mrmOOBleOCiOOCiuOCgnB1bGwgZG93buOBmeOCi+OBqOOAgeOBk+OBruOCs+ODs+ODneODvOODjeODs+ODiOOBr+iHquWLleeahOOBq1wiYWN0aW9uXCLnirbmhYvjgavnp7vooYzjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBmaXhlZC1jb250ZW50XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1JZiB0aGlzIGF0dHJpYnV0ZSBpcyBzZXQgdGhlIGNvbnRlbnQgb2YgdGhlIHBhZ2Ugd2lsbCBub3QgbW92ZSB3aGVuIHB1bGxpbmcuWy9lbl1cbiAgICogICBbamFd44GT44Gu5bGe5oCn44GM44GC44KL5pmC44CB44OX44Or44OV44OD44Kv44GM5byV44GN5Ye644GV44KM44Gm44GE44KL5pmC44Gr44KC44Kz44Oz44OG44Oz44OE44Gv5YuV44GN44G+44Gb44KT44CCWy9qYV1cbiAgICovXG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIHRoaXMuX3Nob3VsZEZpeFNjcm9sbCA9IHV0aWwuZ2xvYmFscy5pc1VJV2ViVmlldztcblxuICAgIHRoaXMuX29uRHJhZyA9IHRoaXMuX29uRHJhZy5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX29uRHJhZ1N0YXJ0ID0gdGhpcy5fb25EcmFnU3RhcnQuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9vbkRyYWdFbmQgPSB0aGlzLl9vbkRyYWdFbmQuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9vblNjcm9sbCA9IHRoaXMuX29uU2Nyb2xsLmJpbmQodGhpcyk7XG5cbiAgICB0aGlzLl9zZXRTdGF0ZShTVEFURV9JTklUSUFMLCB0cnVlKTtcbiAgICB0aGlzLl9oaWRlKCk7IC8vIEZpeCBmb3IgdHJhbnNwYXJlbnQgdG9vbGJhciB0cmFuc2l0aW9uc1xuICB9XG5cbiAgX3NldFN0eWxlKCkge1xuICAgIGNvbnN0IGhlaWdodCA9IHRoaXMuaGVpZ2h0ICsgJ3B4JztcbiAgICBzdHlsZXIodGhpcywgeyBoZWlnaHQsIGxpbmVIZWlnaHQ6IGhlaWdodCB9KTtcbiAgICB0aGlzLnN0eWxlLmRpc3BsYXkgPT09ICcnICYmIHRoaXMuX3Nob3coKTtcbiAgfVxuXG4gIF9vblNjcm9sbChldmVudCkge1xuICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLl9wYWdlRWxlbWVudDtcblxuICAgIGlmIChlbGVtZW50LnNjcm9sbFRvcCA8IDApIHtcbiAgICAgIGVsZW1lbnQuc2Nyb2xsVG9wID0gMDtcbiAgICB9XG4gIH1cblxuICBfY2FuQ29uc3VtZUdlc3R1cmUoZ2VzdHVyZSkge1xuICAgIHJldHVybiBnZXN0dXJlLmRpcmVjdGlvbiA9PT0gJ3VwJyB8fCBnZXN0dXJlLmRpcmVjdGlvbiA9PT0gJ2Rvd24nO1xuICB9XG5cbiAgX29uRHJhZ1N0YXJ0KGV2ZW50KSB7XG4gICAgaWYgKCFldmVudC5nZXN0dXJlIHx8IHRoaXMuZGlzYWJsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCB0YXBZID0gZXZlbnQuZ2VzdHVyZS5jZW50ZXIuY2xpZW50WSArIHRoaXMuX3BhZ2VFbGVtZW50LnNjcm9sbFRvcDtcbiAgICBjb25zdCBtYXhZID0gd2luZG93LmlubmVySGVpZ2h0O1xuICAgIC8vIE9ubHkgdXNlIGRyYWdzIHRoYXQgc3RhcnQgbmVhciB0aGUgcHVsbEhvb2sgdG8gcmVkdWNlIGZsaWNrZXJpbmdzXG4gICAgY29uc3QgZHJhZ2dhYmxlQXJlYVJhdGlvID0gdGhpcy5fc2hvdWxkRml4U2Nyb2xsID8gLjggOiAxO1xuXG4gICAgdGhpcy5faWdub3JlRHJhZyA9IGV2ZW50LmNvbnN1bWVkIHx8ICh0YXBZID4gbWF4WSAqIGRyYWdnYWJsZUFyZWFSYXRpbyk7XG5cbiAgICBpZiAoIXRoaXMuX2lnbm9yZURyYWcpIHtcbiAgICAgIGNvbnN0IGNvbnN1bWUgPSBldmVudC5jb25zdW1lO1xuICAgICAgZXZlbnQuY29uc3VtZSA9ICgpID0+IHtcbiAgICAgICAgY29uc3VtZSAmJiBjb25zdW1lKCk7XG4gICAgICAgIHRoaXMuX2lnbm9yZURyYWcgPSB0cnVlO1xuICAgICAgICAvLyBUaGlzIGVsZW1lbnRzIHJlc2l6ZXMgLnBhZ2VfX2NvbnRlbnQgc28gaXQgaXMgc2FmZXJcbiAgICAgICAgLy8gdG8gaGlkZSBpdCB3aGVuIG90aGVyIGNvbXBvbmVudHMgYXJlIGRyYWdnZWQuXG4gICAgICAgIHRoaXMuX2hpZGUoKTtcbiAgICAgIH07XG5cbiAgICAgIGlmICh0aGlzLl9jYW5Db25zdW1lR2VzdHVyZShldmVudC5nZXN0dXJlKSkge1xuICAgICAgICBjb25zdW1lICYmIGNvbnN1bWUoKTtcbiAgICAgICAgZXZlbnQuY29uc3VtZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLl9zaG93KCk7IC8vIE5vdCBlbm91Z2ggZHVlIHRvICdkcmFnTG9ja0F4aXMnXG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5fc3RhcnRTY3JvbGwgPSB0aGlzLl9wYWdlRWxlbWVudC5zY3JvbGxUb3A7XG4gIH1cblxuICBfb25EcmFnKGV2ZW50KSB7XG4gICAgaWYgKCFldmVudC5nZXN0dXJlIHx8IHRoaXMuZGlzYWJsZWQgfHwgdGhpcy5faWdub3JlRHJhZyB8fCAhdGhpcy5fY2FuQ29uc3VtZUdlc3R1cmUoZXZlbnQuZ2VzdHVyZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBOZWNlc3NhcnkgZHVlIHRvICdkcmFnTG9ja0F4aXMnICgyNXB4KVxuICAgIGlmICh0aGlzLnN0eWxlLmRpc3BsYXkgPT09ICdub25lJykge1xuICAgICAgdGhpcy5fc2hvdygpO1xuICAgIH1cblxuICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXG4gICAgY29uc3QgdGFwWSA9IGV2ZW50Lmdlc3R1cmUuY2VudGVyLmNsaWVudFkgKyB0aGlzLl9wYWdlRWxlbWVudC5zY3JvbGxUb3A7XG4gICAgY29uc3QgbWF4WSA9IHdpbmRvdy5pbm5lckhlaWdodDtcblxuICAgIC8vIEhhY2sgdG8gbWFrZSBpdCB3b3JrIG9uIEFuZHJvaWQgNC40IFdlYlZpZXcgYW5kIGlPUyBVSVdlYlZpZXcuIFNjcm9sbHMgbWFudWFsbHlcbiAgICAvLyBuZWFyIHRoZSB0b3Agb2YgdGhlIHBhZ2Ugc28gdGhlcmUgd2lsbCBiZSBubyBpbmVydGlhbCBzY3JvbGwgd2hlbiBzY3JvbGxpbmcgZG93bi5cbiAgICAvLyBBbGxvd2luZyBkZWZhdWx0IHNjcm9sbGluZyB3aWxsIGtpbGwgYWxsICd0b3VjaG1vdmUnIGV2ZW50cy5cbiAgICBpZiAodGhpcy5fc2hvdWxkRml4U2Nyb2xsKSB7XG4gICAgICB0aGlzLl9wYWdlRWxlbWVudC5zY3JvbGxUb3AgPSB0aGlzLl9zdGFydFNjcm9sbCAtIGV2ZW50Lmdlc3R1cmUuZGVsdGFZO1xuICAgICAgLy8gQWxsb3cgaW5lcnRpYSB3aGVuIHNjcm9sbGluZyBkb3duIGJlbG93IDUwJSBvZiB0aGUgdmlldyB0byByZWR1Y2UgZmxpY2tlcmluZ3NcbiAgICAgIGlmIChldmVudC5nZXN0dXJlLmludGVyaW1EaXJlY3Rpb24gIT09ICd1cCcgfHwgKHRhcFkgPD0gbWF4WSAqIC41KSkge1xuICAgICAgICBldmVudC5nZXN0dXJlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3Qgc2Nyb2xsID0gTWF0aC5tYXgoZXZlbnQuZ2VzdHVyZS5kZWx0YVkgLSB0aGlzLl9zdGFydFNjcm9sbCwgMCk7XG4gICAgaWYgKHNjcm9sbCAhPT0gdGhpcy5fY3VycmVudFRyYW5zbGF0aW9uKSB7XG5cbiAgICAgIGNvbnN0IHRoID0gdGhpcy50aHJlc2hvbGRIZWlnaHQ7XG4gICAgICBpZiAodGggPiAwICYmIHNjcm9sbCA+PSB0aCkge1xuICAgICAgICBldmVudC5nZXN0dXJlLnN0b3BEZXRlY3QoKTtcbiAgICAgICAgc2V0SW1tZWRpYXRlKCgpID0+IHRoaXMuX2ZpbmlzaCgpKTtcblxuICAgICAgfSBlbHNlIGlmIChzY3JvbGwgPj0gdGhpcy5oZWlnaHQpIHtcbiAgICAgICAgdGhpcy5fc2V0U3RhdGUoU1RBVEVfUFJFQUNUSU9OKTtcblxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fc2V0U3RhdGUoU1RBVEVfSU5JVElBTCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3RyYW5zbGF0ZVRvKHNjcm9sbCk7XG4gICAgfVxuICB9XG5cbiAgX29uRHJhZ0VuZChldmVudCkge1xuICAgIGlmICghZXZlbnQuZ2VzdHVyZSB8fCB0aGlzLmRpc2FibGVkIHx8IHRoaXMuX2lnbm9yZURyYWcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblxuICAgIGlmICh0aGlzLl9jdXJyZW50VHJhbnNsYXRpb24gPiAwKSB7XG4gICAgICBjb25zdCBzY3JvbGwgPSB0aGlzLl9jdXJyZW50VHJhbnNsYXRpb247XG5cbiAgICAgIGlmIChzY3JvbGwgPiB0aGlzLmhlaWdodCkge1xuICAgICAgICB0aGlzLl9maW5pc2goKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3RyYW5zbGF0ZVRvKDAsIHthbmltYXRlOiB0cnVlfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBvbkFjdGlvblxuICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1UaGlzIHdpbGwgYmUgY2FsbGVkIGluIHRoZSBgYWN0aW9uYCBzdGF0ZSBpZiBpdCBleGlzdHMuIFRoZSBmdW5jdGlvbiB3aWxsIGJlIGdpdmVuIGEgYGRvbmVgIGNhbGxiYWNrIGFzIGl0J3MgZmlyc3QgYXJndW1lbnQuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG4gIGdldCBvbkFjdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fb25BY3Rpb247XG4gIH1cblxuICBzZXQgb25BY3Rpb24odmFsdWUpIHtcbiAgICBpZiAodmFsdWUgJiYgISh2YWx1ZSBpbnN0YW5jZW9mIEZ1bmN0aW9uKSkge1xuICAgICAgdGhyb3dUeXBlKCdvbkFjdGlvbicsICdmdW5jdGlvbiBvciBudWxsJyk7XG4gICAgfVxuICAgIHRoaXMuX29uQWN0aW9uID0gdmFsdWU7XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IG9uUHVsbFxuICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1Ib29rIGNhbGxlZCB3aGVuZXZlciB0aGUgdXNlciBwdWxscyB0aGUgZWxlbWVudC4gSXQgZ2V0cyB0aGUgcHVsbGVkIGRpc3RhbmNlIHJhdGlvIChzY3JvbGwgLyBoZWlnaHQpIGFuZCBhbiBhbmltYXRpb25PcHRpb25zIG9iamVjdCBhcyBhcmd1bWVudHMuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG4gIGdldCBvblB1bGwoKSB7XG4gICAgcmV0dXJuIHRoaXMuX29uUHVsbDtcbiAgfVxuXG4gIHNldCBvblB1bGwodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgJiYgISh2YWx1ZSBpbnN0YW5jZW9mIEZ1bmN0aW9uKSkge1xuICAgICAgdGhyb3dUeXBlKCdvblB1bGwnLCAnZnVuY3Rpb24gb3IgbnVsbCcpO1xuICAgIH1cbiAgICB0aGlzLl9vblB1bGwgPSB2YWx1ZTtcbiAgfVxuXG4gIF9maW5pc2goKSB7XG4gICAgdGhpcy5fc2V0U3RhdGUoU1RBVEVfQUNUSU9OKTtcbiAgICB0aGlzLl90cmFuc2xhdGVUbyh0aGlzLmhlaWdodCwge2FuaW1hdGU6IHRydWV9KTtcbiAgICBjb25zdCBhY3Rpb24gPSB0aGlzLm9uQWN0aW9uIHx8IChkb25lID0+IGRvbmUoKSk7XG4gICAgYWN0aW9uKCgpID0+IHtcbiAgICAgIHRoaXMuX3RyYW5zbGF0ZVRvKDAsIHthbmltYXRlOiB0cnVlfSk7XG4gICAgICB0aGlzLl9zZXRTdGF0ZShTVEFURV9JTklUSUFMKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgaGVpZ2h0XG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1UaGUgaGVpZ2h0IG9mIHRoZSBwdWxsIGhvb2sgaW4gcGl4ZWxzLiBUaGUgZGVmYXVsdCB2YWx1ZSBpcyBgNjRweGAuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG4gIHNldCBoZWlnaHQodmFsdWUpIHtcbiAgICBpZiAoIXV0aWwuaXNJbnRlZ2VyKHZhbHVlKSkge1xuICAgICAgdGhyb3dUeXBlKCdoZWlnaHQnLCAnaW50ZWdlcicpO1xuICAgIH1cblxuICAgIHRoaXMuc2V0QXR0cmlidXRlKCdoZWlnaHQnLCBgJHt2YWx1ZX1weGApO1xuICB9XG5cbiAgZ2V0IGhlaWdodCgpIHtcbiAgICByZXR1cm4gcGFyc2VJbnQodGhpcy5nZXRBdHRyaWJ1dGUoJ2hlaWdodCcpIHx8ICc2NCcsIDEwKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgdGhyZXNob2xkSGVpZ2h0XG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1UaGUgdGhyZXNob2xkSGVpZ2h0IG9mIHRoZSBwdWxsIGhvb2sgaW4gcGl4ZWxzLiBUaGUgZGVmYXVsdCB2YWx1ZSBpcyBgOTZweGAuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG4gIHNldCB0aHJlc2hvbGRIZWlnaHQodmFsdWUpIHtcbiAgICBpZiAoIXV0aWwuaXNJbnRlZ2VyKHZhbHVlKSkge1xuICAgICAgdGhyb3dUeXBlKCd0aHJlc2hvbGRIZWlnaHQnLCAnaW50ZWdlcicpO1xuICAgIH1cblxuICAgIHRoaXMuc2V0QXR0cmlidXRlKCd0aHJlc2hvbGQtaGVpZ2h0JywgYCR7dmFsdWV9cHhgKTtcbiAgfVxuXG4gIGdldCB0aHJlc2hvbGRIZWlnaHQoKSB7XG4gICAgcmV0dXJuIHBhcnNlSW50KHRoaXMuZ2V0QXR0cmlidXRlKCd0aHJlc2hvbGQtaGVpZ2h0JykgfHwgJzk2JywgMTApO1xuICB9XG5cbiAgX3NldFN0YXRlKHN0YXRlLCBub0V2ZW50KSB7XG4gICAgY29uc3QgbGFzdFN0YXRlID0gdGhpcy5zdGF0ZTtcblxuICAgIHRoaXMuc2V0QXR0cmlidXRlKCdzdGF0ZScsIHN0YXRlKTtcblxuICAgIGlmICghbm9FdmVudCAmJiBsYXN0U3RhdGUgIT09IHRoaXMuc3RhdGUpIHtcbiAgICAgIHV0aWwudHJpZ2dlckVsZW1lbnRFdmVudCh0aGlzLCAnY2hhbmdlc3RhdGUnLCB7XG4gICAgICAgIHB1bGxIb29rOiB0aGlzLFxuICAgICAgICBzdGF0ZTogc3RhdGUsXG4gICAgICAgIGxhc3RTdGF0ZTogbGFzdFN0YXRlXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IHN0YXRlXG4gICAqIEByZWFkb25seVxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dQ3VycmVudCBzdGF0ZSBvZiB0aGUgZWxlbWVudC5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cbiAgZ2V0IHN0YXRlKCkge1xuICAgIHJldHVybiB0aGlzLmdldEF0dHJpYnV0ZSgnc3RhdGUnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgcHVsbERpc3RhbmNlXG4gICAqIEByZWFkb25seVxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dVGhlIGN1cnJlbnQgbnVtYmVyIG9mIHBpeGVscyB0aGUgcHVsbCBob29rIGhhcyBtb3ZlZC5bL2VuXVxuICAgKiAgIFtqYV3nj77lnKjjga7jg5fjg6vjg5Xjg4Pjgq/jgYzlvJXjgY3lh7rjgZXjgozjgZ/ot53pm6LjgpLjg5Tjgq/jgrvjg6vmlbDjgIJbL2phXVxuICAgKi9cbiAgZ2V0IHB1bGxEaXN0YW5jZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fY3VycmVudFRyYW5zbGF0aW9uO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBkaXNhYmxlZFxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgZGlzYWJsZWQgb3Igbm90LlsvZW5dXG4gICAqICAgW2phXeeEoeWKueWMluOBleOCjOOBpuOBhOOCi+WgtOWQiOOBq2B0cnVlYOOAglsvamFdXG4gICAqL1xuICBzZXQgZGlzYWJsZWQodmFsdWUpIHtcbiAgICByZXR1cm4gdXRpbC50b2dnbGVBdHRyaWJ1dGUodGhpcywgJ2Rpc2FibGVkJywgdmFsdWUpO1xuICB9XG5cbiAgZ2V0IGRpc2FibGVkKCkge1xuICAgIHJldHVybiB0aGlzLmhhc0F0dHJpYnV0ZSgnZGlzYWJsZWQnKTtcbiAgfVxuXG4gIF9zaG93KCkge1xuICAgIC8vIFJ1biBhc3luY3Job25vdXNseSB0byBhdm9pZCBjb25mbGljdHMgd2l0aCBBbmltaXQncyBzdHlsZSBjbGVhblxuICAgIHNldEltbWVkaWF0ZSgoKSA9PiB7XG4gICAgICB0aGlzLnN0eWxlLmRpc3BsYXkgPSAnJztcbiAgICAgIGlmICh0aGlzLl9wYWdlRWxlbWVudCkge1xuICAgICAgICB0aGlzLl9wYWdlRWxlbWVudC5zdHlsZS5tYXJnaW5Ub3AgPSBgLSR7dGhpcy5oZWlnaHR9cHhgO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgX2hpZGUoKSB7XG4gICAgdGhpcy5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgIGlmICh0aGlzLl9wYWdlRWxlbWVudCkge1xuICAgICAgdGhpcy5fcGFnZUVsZW1lbnQuc3R5bGUubWFyZ2luVG9wID0gJyc7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBzY3JvbGxcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuY2FsbGJhY2tdXG4gICAqL1xuICBfdHJhbnNsYXRlVG8oc2Nyb2xsLCBvcHRpb25zID0ge30pIHtcbiAgICBpZiAodGhpcy5fY3VycmVudFRyYW5zbGF0aW9uID09IDAgJiYgc2Nyb2xsID09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLl9jdXJyZW50VHJhbnNsYXRpb24gPSBzY3JvbGw7XG4gICAgY29uc3Qgb3B0ID0gb3B0aW9ucy5hbmltYXRlID8geyBkdXJhdGlvbjogLjMsIHRpbWluZzogJ2N1YmljLWJlemllciguMSwgLjcsIC4xLCAxKScgfSA6IHt9O1xuICAgIHRoaXMuX29uUHVsbCAmJiB0aGlzLl9vblB1bGwoKHNjcm9sbCAvIHRoaXMuaGVpZ2h0KS50b0ZpeGVkKDIpLCBvcHQpO1xuICAgIGNvbnN0IHNjcm9sbEVsZW1lbnQgPSAgdGhpcy5oYXNBdHRyaWJ1dGUoJ2ZpeGVkLWNvbnRlbnQnKSA/IHRoaXMgOiB0aGlzLl9wYWdlRWxlbWVudDtcblxuICAgIGFuaW1pdChzY3JvbGxFbGVtZW50KVxuICAgICAgLnF1ZXVlKHsgdHJhbnNmb3JtOiBgdHJhbnNsYXRlM2QoMHB4LCAke3Njcm9sbH1weCwgMHB4KWAgfSwgb3B0KVxuICAgICAgLnBsYXkoKCkgPT4ge1xuICAgICAgICBzY3JvbGwgPT09IDAgJiYgc3R5bGVyLmNsZWFyKHNjcm9sbEVsZW1lbnQsICd0cmFuc2l0aW9uIHRyYW5zZm9ybScpO1xuICAgICAgICBvcHRpb25zLmNhbGxiYWNrIGluc3RhbmNlb2YgRnVuY3Rpb24gJiYgb3B0aW9ucy5jYWxsYmFjaygpO1xuICAgIH0pO1xuICB9XG5cbiAgX2Rpc2FibGVEcmFnTG9jaygpIHsgLy8gZTJlIHRlc3RzIG5lZWQgaXRcbiAgICB0aGlzLl9kcmFnTG9ja0Rpc2FibGVkID0gdHJ1ZTtcbiAgICB0aGlzLl9zZXR1cExpc3RlbmVycyh0cnVlKTtcbiAgfVxuXG4gIF9zZXR1cExpc3RlbmVycyhhZGQpIHtcbiAgICBjb25zdCBzY3JvbGxUb2dnbGUgPSBhY3Rpb24gPT4gdGhpcy5fcGFnZUVsZW1lbnRbYCR7YWN0aW9ufUV2ZW50TGlzdGVuZXJgXSgnc2Nyb2xsJywgdGhpcy5fb25TY3JvbGwsIGZhbHNlKTtcbiAgICBjb25zdCBnZFRvZ2dsZSA9IGFjdGlvbiA9PiB7XG4gICAgICBjb25zdCBwYXNzaXZlID0geyBwYXNzaXZlOiB0cnVlIH07XG4gICAgICB0aGlzLl9nZXN0dXJlRGV0ZWN0b3JbYWN0aW9uXSgnZHJhZycsIHRoaXMuX29uRHJhZywgcGFzc2l2ZSk7XG4gICAgICB0aGlzLl9nZXN0dXJlRGV0ZWN0b3JbYWN0aW9uXSgnZHJhZ3N0YXJ0JywgdGhpcy5fb25EcmFnU3RhcnQsIHBhc3NpdmUpO1xuICAgICAgdGhpcy5fZ2VzdHVyZURldGVjdG9yW2FjdGlvbl0oJ2RyYWdlbmQnLCB0aGlzLl9vbkRyYWdFbmQsIHBhc3NpdmUpO1xuICAgIH07XG5cbiAgICBpZiAodGhpcy5fZ2VzdHVyZURldGVjdG9yKSB7XG4gICAgICBnZFRvZ2dsZSgnb2ZmJyk7XG4gICAgICB0aGlzLl9nZXN0dXJlRGV0ZWN0b3IuZGlzcG9zZSgpO1xuICAgICAgdGhpcy5fZ2VzdHVyZURldGVjdG9yID0gbnVsbDtcbiAgICB9XG4gICAgc2Nyb2xsVG9nZ2xlKCdyZW1vdmUnKTtcblxuICAgIGlmIChhZGQpIHtcbiAgICAgIHRoaXMuX2dlc3R1cmVEZXRlY3RvciA9IG5ldyBHZXN0dXJlRGV0ZWN0b3IodGhpcy5fcGFnZUVsZW1lbnQsIHtcbiAgICAgICAgZHJhZ01pbkRpc3RhbmNlOiAxLFxuICAgICAgICBkcmFnRGlzdGFuY2VDb3JyZWN0aW9uOiBmYWxzZSxcbiAgICAgICAgZHJhZ0xvY2tUb0F4aXM6ICF0aGlzLl9kcmFnTG9ja0Rpc2FibGVkLFxuICAgICAgICBwYXNzaXZlOiAhdGhpcy5fc2hvdWxkRml4U2Nyb2xsXG4gICAgICB9KTtcblxuICAgICAgZ2RUb2dnbGUoJ29uJyk7XG4gICAgICBzY3JvbGxUb2dnbGUoJ2FkZCcpO1xuICAgIH1cbiAgfVxuXG4gIGNvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIHRoaXMuX2N1cnJlbnRUcmFuc2xhdGlvbiA9IDA7XG4gICAgdGhpcy5fcGFnZUVsZW1lbnQgPSB0aGlzLnBhcmVudE5vZGU7XG5cbiAgICB0aGlzLl9zZXR1cExpc3RlbmVycyh0cnVlKTtcbiAgICB0aGlzLl9zZXRTdHlsZSgpO1xuICB9XG5cbiAgZGlzY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgdGhpcy5faGlkZSgpO1xuICAgIHRoaXMuX3NldHVwTGlzdGVuZXJzKGZhbHNlKTtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgb2JzZXJ2ZWRBdHRyaWJ1dGVzKCkge1xuICAgIHJldHVybiBbJ2hlaWdodCddO1xuICB9XG5cbiAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIGxhc3QsIGN1cnJlbnQpIHtcbiAgICBpZiAobmFtZSA9PT0gJ2hlaWdodCcgJiYgdGhpcy5fcGFnZUVsZW1lbnQpIHtcbiAgICAgIHRoaXMuX3NldFN0eWxlKCk7XG4gICAgfVxuICB9XG5cbiAgc3RhdGljIGdldCBldmVudHMoKSB7XG4gICAgcmV0dXJuIFsnY2hhbmdlc3RhdGUnXVxuICB9XG59XG5cbm9uc0VsZW1lbnRzLlB1bGxIb29rID0gUHVsbEhvb2tFbGVtZW50O1xuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdvbnMtcHVsbC1ob29rJywgUHVsbEhvb2tFbGVtZW50KTtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5pbXBvcnQgb25zRWxlbWVudHMgZnJvbSAnLi4vb25zL2VsZW1lbnRzJztcbmltcG9ydCB1dGlsIGZyb20gJy4uL29ucy91dGlsJztcbmltcG9ydCBCYXNlSW5wdXRFbGVtZW50IGZyb20gJy4vYmFzZS9iYXNlLWlucHV0JztcblxuY29uc3Qgc2NoZW1lID0ge1xuICAnJzogJ3JhbmdlLS0qJyxcbiAgJy5yYW5nZV9faW5wdXQnOiAncmFuZ2UtLSpfX2lucHV0JyxcbiAgJy5yYW5nZV9fZm9jdXMtcmluZyc6ICdyYW5nZS0tKl9fZm9jdXMtcmluZydcbn07XG5cbmNvbnN0IGFjdGl2ZUNsYXNzVG9rZW4gPSAncmFuZ2VfX2lucHV0LS1hY3RpdmUnO1xuXG4vKipcbiAqIEBlbGVtZW50IG9ucy1yYW5nZVxuICogQGNhdGVnb3J5IGZvcm1cbiAqIEBtb2RpZmllciBtYXRlcmlhbFxuICogICBbZW5dTWF0ZXJpYWwgRGVzaWduIHNsaWRlclsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1cbiAqICAgICBSYW5nZSBpbnB1dCBjb21wb25lbnQuIFVzZWQgdG8gZGlzcGxheSBhIGRyYWdnYWJsZSBzbGlkZXIuXG4gKlxuICogICAgIFdvcmtzIHZlcnkgc2ltaWxhciB0byB0aGUgYDxpbnB1dCB0eXBlPVwicmFuZ2VcIj5gIGVsZW1lbnQuXG4gKiAgIFsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQGNvZGVwZW4geFpRb21NXG4gKiBAdHV0b3JpYWwgdmFuaWxsYS9SZWZlcmVuY2UvcmFuZ2VcbiAqIEBndWlkZSB0aGVtaW5nLmh0bWwjbW9kaWZpZXJzIFtlbl1Nb3JlIGRldGFpbHMgYWJvdXQgdGhlIGBtb2RpZmllcmAgYXR0cmlidXRlWy9lbl1bamFdbW9kaWZpZXLlsZ7mgKfjga7kvb/jgYTmlrlbL2phXVxuICogQHNlZWFsc28gb25zLWlucHV0XG4gKiAgIFtlbl1UaGUgYDxvbnMtaW5wdXQ+YCBjb21wb25lbnQgaXMgdXNlZCB0byBkaXNwbGF5IHRleHQgaW5wdXRzLCByYWRpbyBidXR0b25zIGFuZCBjaGVja2JveGVzLlsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQGV4YW1wbGVcbiAqIDxvbnMtcmFuZ2UgdmFsdWU9XCIyMFwiPjwvb25zLXJhbmdlPlxuICogPG9ucy1yYW5nZSBtb2RpZmllcj1cIm1hdGVyaWFsXCIgdmFsdWU9XCIxMFwiPjwvcmFuZ2U+XG4gKi9cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUmFuZ2VFbGVtZW50IGV4dGVuZHMgQmFzZUlucHV0RWxlbWVudCB7XG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIHRoaXMuX29uTW91c2VEb3duID0gdGhpcy5fb25Nb3VzZURvd24uYmluZCh0aGlzKTtcbiAgICB0aGlzLl9vbk1vdXNlVXAgPSB0aGlzLl9vbk1vdXNlVXAuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9vblRvdWNoU3RhcnQgPSB0aGlzLl9vblRvdWNoU3RhcnQuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9vblRvdWNoRW5kID0gdGhpcy5fb25Ub3VjaEVuZC5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX29uSW5wdXQgPSB0aGlzLl91cGRhdGUuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9vbkRyYWdzdGFydCA9IHRoaXMuX29uRHJhZ3N0YXJ0LmJpbmQodGhpcyk7XG4gICAgdGhpcy5fb25EcmFnZW5kID0gdGhpcy5fb25EcmFnZW5kLmJpbmQodGhpcyk7XG4gIH1cblxuICBfY29tcGlsZSgpIHtcbiAgICBzdXBlci5fY29tcGlsZSgpO1xuICAgIHRoaXMuX3VwZGF0ZURpc2FibGVkKHRoaXMuaGFzQXR0cmlidXRlKCdkaXNhYmxlZCcpKTtcbiAgfVxuXG4gIC8qIEluaGVyaXRlZCBwcm9wcyAqL1xuXG4gIF91cGRhdGUoKSB7XG4gICAgY29uc3QgaW5wdXQgPSB0aGlzLl9pbnB1dDtcbiAgICBjb25zdCBmb2N1c1JpbmcgPSB0aGlzLl9mb2N1c1Jpbmc7XG5cbiAgICBpbnB1dC5zdHlsZS5iYWNrZ3JvdW5kU2l6ZSA9IGAkezEwMCAqIHRoaXMuX3JhdGlvfSUgMnB4YDtcbiAgICBmb2N1c1JpbmcudmFsdWUgPSB0aGlzLnZhbHVlO1xuXG4gICAgLy8gTk9URTogXCJfemVyb1wiIGF0dHJpYnV0ZSBpcyB1c2VkIGZvciBDU1Mgc3R5bGluZy5cbiAgICBpZiAoKGlucHV0Lm1pbiA9PT0gJycgJiYgaW5wdXQudmFsdWUgPT09ICcwJykgfHwgaW5wdXQubWluID09PSBpbnB1dC52YWx1ZSkge1xuICAgICAgaW5wdXQuc2V0QXR0cmlidXRlKCdfemVybycsICcnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaW5wdXQucmVtb3ZlQXR0cmlidXRlKCdfemVybycpO1xuICAgIH1cblxuICAgIFsnbWluJywgJ21heCddLmZvckVhY2goYXR0ciA9PiBmb2N1c1JpbmdbYXR0cl0gPSBpbnB1dFthdHRyXSk7XG4gIH1cblxuICBnZXQgX3NjaGVtZSgpIHtcbiAgICByZXR1cm4gc2NoZW1lO1xuICB9XG5cbiAgZ2V0IF90ZW1wbGF0ZSgpIHtcbiAgICByZXR1cm4gYFxuICAgICAgPGlucHV0IHR5cGU9XCIke3RoaXMudHlwZX1cIiBjbGFzcz1cIiR7dGhpcy5fZGVmYXVsdENsYXNzTmFtZX1fX2lucHV0XCI+XG4gICAgICA8aW5wdXQgdHlwZT1cInJhbmdlXCIgY2xhc3M9XCJyYW5nZV9fZm9jdXMtcmluZ1wiIHRhYkluZGV4PVwiLTFcIj5cbiAgICBgO1xuICB9XG5cbiAgZ2V0IF9kZWZhdWx0Q2xhc3NOYW1lKCkge1xuICAgIHJldHVybiAncmFuZ2UnO1xuICB9XG5cbiAgZ2V0IHR5cGUoKSB7XG4gICAgcmV0dXJuICdyYW5nZSc7XG4gIH1cblxuICAvKiBPd24gcHJvcHMgKi9cblxuICBfb25Nb3VzZURvd24oZSkge1xuICAgIHRoaXMuX2lucHV0LmNsYXNzTGlzdC5hZGQoYWN0aXZlQ2xhc3NUb2tlbik7XG4gICAgc2V0SW1tZWRpYXRlKCgpID0+IHRoaXMuX2lucHV0LmZvY3VzKCkpO1xuICB9XG5cbiAgX29uVG91Y2hTdGFydChlKSB7XG4gICAgdGhpcy5fb25Nb3VzZURvd24oKTtcbiAgfVxuXG4gIF9vbk1vdXNlVXAoZSkge1xuICAgIHRoaXMuX2lucHV0LmNsYXNzTGlzdC5yZW1vdmUoYWN0aXZlQ2xhc3NUb2tlbik7XG4gIH1cblxuICBfb25Ub3VjaEVuZChlKSB7XG4gICAgdGhpcy5fb25Nb3VzZVVwKGUpO1xuICB9XG5cbiAgX29uRHJhZ3N0YXJ0KGUpIHtcbiAgICBlLmNvbnN1bWVkID0gdHJ1ZTtcbiAgICBlLmdlc3R1cmUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgdGhpcy5faW5wdXQuY2xhc3NMaXN0LmFkZChhY3RpdmVDbGFzc1Rva2VuKTtcbiAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ2RyYWcnLCB0aGlzLl9vbkRyYWcpO1xuICB9XG5cbiAgX29uRHJhZyhlKSB7XG4gICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgfVxuXG4gIF9vbkRyYWdlbmQoZSkge1xuICAgIHRoaXMuX2lucHV0LmNsYXNzTGlzdC5yZW1vdmUoYWN0aXZlQ2xhc3NUb2tlbik7XG4gICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCdkcmFnJywgdGhpcy5fb25EcmFnKTtcbiAgfVxuXG4gIGdldCBfZm9jdXNSaW5nKCkge1xuICAgIHJldHVybiB0aGlzLmNoaWxkcmVuWzFdO1xuICB9XG5cbiAgZ2V0IF9yYXRpbygpIHtcbiAgICAvLyBSZXR1cm5zIHRoZSBjdXJyZW50IHJhdGlvLlxuICAgIGNvbnN0IG1pbiA9IHRoaXMuX2lucHV0Lm1pbiA9PT0gJycgPyAwIDogcGFyc2VJbnQodGhpcy5faW5wdXQubWluKTtcbiAgICBjb25zdCBtYXggPSB0aGlzLl9pbnB1dC5tYXggPT09ICcnID8gMTAwIDogcGFyc2VJbnQodGhpcy5faW5wdXQubWF4KTtcblxuICAgIHJldHVybiAodGhpcy52YWx1ZSAtIG1pbikgLyAobWF4IC0gbWluKTtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgb2JzZXJ2ZWRBdHRyaWJ1dGVzKCkge1xuICAgIHJldHVybiBbJ2Rpc2FibGVkJywgLi4uQmFzZUlucHV0RWxlbWVudC5vYnNlcnZlZEF0dHJpYnV0ZXNdO1xuICB9XG5cbiAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIGxhc3QsIGN1cnJlbnQpIHtcbiAgICBpZiAobmFtZSA9PT0gJ2Rpc2FibGVkJykge1xuICAgICAgdGhpcy5fdXBkYXRlRGlzYWJsZWQoY3VycmVudCk7XG4gICAgfVxuICAgIHN1cGVyLmF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBsYXN0LCBjdXJyZW50KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGRpc2FibGVkXG4gICAqL1xuICBfdXBkYXRlRGlzYWJsZWQoZGlzYWJsZWQpIHtcbiAgICBpZiAoZGlzYWJsZWQpIHtcbiAgICAgIHRoaXMuY2xhc3NMaXN0LmFkZCgncmFuZ2UtLWRpc2FibGVkJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY2xhc3NMaXN0LnJlbW92ZSgncmFuZ2UtLWRpc2FibGVkJyk7XG4gICAgfVxuICB9XG5cbiAgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgdGhpcy5fc2V0dXBMaXN0ZW5lcnModHJ1ZSk7XG4gIH1cblxuICBkaXNjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICB0aGlzLl9zZXR1cExpc3RlbmVycyhmYWxzZSk7XG4gIH1cblxuICBfc2V0dXBMaXN0ZW5lcnMoYWRkKSB7XG4gICAgY29uc3QgYWN0aW9uID0gKGFkZCA/ICdhZGQnIDogJ3JlbW92ZScpICsgJ0V2ZW50TGlzdGVuZXInO1xuICAgIHV0aWxbYWN0aW9uXSh0aGlzLCAndG91Y2hzdGFydCcsIHRoaXMuX29uVG91Y2hTdGFydCwgeyBwYXNzaXZlOiB0cnVlIH0pO1xuICAgIHRoaXNbYWN0aW9uXSgnbW91c2Vkb3duJywgdGhpcy5fb25Nb3VzZURvd24pO1xuICAgIHRoaXNbYWN0aW9uXSgnbW91c2V1cCcsIHRoaXMuX29uTW91c2VVcCk7XG4gICAgdGhpc1thY3Rpb25dKCd0b3VjaGVuZCcsIHRoaXMuX29uVG91Y2hFbmQpO1xuICAgIHRoaXNbYWN0aW9uXSgnZHJhZ3N0YXJ0JywgdGhpcy5fb25EcmFnc3RhcnQpO1xuICAgIHRoaXNbYWN0aW9uXSgnZHJhZ2VuZCcsIHRoaXMuX29uRHJhZ2VuZCk7XG4gICAgdGhpc1thY3Rpb25dKCdpbnB1dCcsIHRoaXMuX29uSW5wdXQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgZGlzYWJsZWRcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgZGlzYWJsZWQgb3Igbm90LlsvZW5dXG4gICAqICAgW2phXeeEoeWKueWMluOBleOCjOOBpuOBhOOCi+WgtOWQiOOBq2B0cnVlYOOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgZGlzYWJsZWRcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1XaGV0aGVyIHRoZSBlbGVtZW50IGlzIGRpc2FibGVkIG9yIG5vdC5bL2VuXVxuICAgKiAgIFtqYV3nhKHlirnljJbjgZXjgozjgabjgYTjgovloLTlkIjjgatgdHJ1ZWDjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQHByb3BlcnR5IHZhbHVlXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1DdXJyZW50IHZhbHVlLlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xufVxuXG5vbnNFbGVtZW50cy5SYW5nZSA9IFJhbmdlRWxlbWVudDtcbmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnb25zLXJhbmdlJywgUmFuZ2VFbGVtZW50KTtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE2IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCBpbnRlcm5hbCBmcm9tICcuLi8uLi9vbnMvaW50ZXJuYWwnO1xuXG4vKipcbiAqIEBjbGFzcyBBbmltYXRvckNTUyAtIGltcGxlbWVudGF0aW9uIG9mIEFuaW1hdG9yIGNsYXNzIHVzaW5nIGNzcyB0cmFuc2l0aW9uc1xuICovXG5jbGFzcyBBbmltYXRvckNTUyB7XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgYW5pbWF0ZVxuICAgKiBAZGVzYyBtYWluIGFuaW1hdGlvbiBmdW5jdGlvblxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnRcbiAgICogQHBhcmFtIHtPYmplY3R9IGZpbmFsQ1NTXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbZHVyYXRpb249MjAwXSAtIGR1cmF0aW9uIGluIG1pbGxpc2Vjb25kc1xuICAgKiBAcmV0dXJuIHtPYmplY3R9IHJlc3VsdFxuICAgKiBAcmV0dXJuIHtGdW5jdGlvbn0gcmVzdWx0LnRoZW4oY2FsbGJhY2spIC0gc2V0cyBhIGNhbGxiYWNrIHRvIGJlIGV4ZWN1dGVkIGFmdGVyIHRoZSBhbmltYXRpb24gaGFzIHN0b3BwZWRcbiAgICogQHJldHVybiB7RnVuY3Rpb259IHJlc3VsdC5zdG9wKG9wdGlvbnMpIC0gc3RvcHMgdGhlIGFuaW1hdGlvbjsgaWYgb3B0aW9ucy5zdG9wTmV4dCBpcyB0cnVlIHRoZW4gaXQgZG9lc24ndCBjYWxsIHRoZSBjYWxsYmFja1xuICAgKiBAcmV0dXJuIHtGdW5jdGlvbn0gcmVzdWx0LmZpbmlzaChtcykgLSBmaW5pc2hlcyB0aGUgYW5pbWF0aW9uIGluIHRoZSBzcGVjaWZpZWQgdGltZSBpbiBtaWxsaXNlY29uZHNcbiAgICogQHJldHVybiB7RnVuY3Rpb259IHJlc3VsdC5zcGVlZChtcykgLSBzZXRzIHRoZSBhbmltYXRpb24gc3BlZWQgc28gdGhhdCBpdCBmaW5pc2hlcyBhcyBpZiB0aGUgb3JpZ2luYWwgZHVyYXRpb24gd2FzIHRoZSBvbmUgc3BlY2lmaWVkIGhlcmVcbiAgICogQGV4YW1wbGVcbiAgICogYGBgYFxuICAgKiAgdmFyIHJlc3VsdCA9IGFuaW1hdG9yLmFuaW1hdGUoZWwsIHtvcGFjaXR5OiAwLjV9LCAxMDAwKTtcbiAgICpcbiAgICogIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24oZSl7XG4gICAqICAgIHJlc3VsdC5zcGVlZCgyMDApLnRoZW4oZnVuY3Rpb24oKXtcbiAgICogICAgICBjb25zb2xlLmxvZygnZG9uZScpO1xuICAgKiAgICB9KTtcbiAgICogIH0sIDMwMCk7XG4gICAqIGBgYGBcbiAgICovXG4gIGFuaW1hdGUoZWwsIGZpbmFsLCBkdXJhdGlvbiA9IDIwMCkge1xuICAgIHZhciBzdGFydCA9IChuZXcgRGF0ZSgpKS5nZXRUaW1lKCksXG4gICAgICAgIGluaXRpYWwgPSB7fSxcbiAgICAgICAgc3RvcHBlZCA9IGZhbHNlLFxuICAgICAgICBuZXh0ID0gZmFsc2UsXG4gICAgICAgIHRpbWVvdXQgPSBmYWxzZSxcbiAgICAgICAgcHJvcGVydGllcyA9IE9iamVjdC5rZXlzKGZpbmFsKTtcblxuICAgIHZhciB1cGRhdGVTdHlsZXMgPSAoKSA9PiB7XG4gICAgICBsZXQgcyA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsKTtcbiAgICAgIHByb3BlcnRpZXMuZm9yRWFjaChzLmdldFByb3BlcnR5VmFsdWUuYmluZChzKSk7XG4gICAgICBzID0gZWwub2Zmc2V0SGVpZ2h0O1xuICAgIH07XG5cbiAgICB2YXIgcmVzdWx0ID0ge1xuICAgICAgc3RvcDogKG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgICAgICB0aW1lb3V0ICYmIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgdmFyIGsgPSBNYXRoLm1pbigxLCAoKG5ldyBEYXRlKCkpLmdldFRpbWUoKSAtIHN0YXJ0KSAvIGR1cmF0aW9uKTtcbiAgICAgICAgcHJvcGVydGllcy5mb3JFYWNoKGkgPT4ge1xuICAgICAgICAgIGVsLnN0eWxlW2ldID0gKDEgLSBrKSAqIGluaXRpYWxbaV0gKyBrICogZmluYWxbaV0gKyAoaSA9PSAnb3BhY2l0eScgPyAnJyA6ICdweCcpO1xuICAgICAgICB9KTtcbiAgICAgICAgZWwuc3R5bGUudHJhbnNpdGlvbkR1cmF0aW9uID0gJzBzJztcblxuICAgICAgICBpZiAob3B0aW9ucy5zdG9wTmV4dCkge1xuICAgICAgICAgIG5leHQgPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIGlmICghc3RvcHBlZCkge1xuICAgICAgICAgIHN0b3BwZWQgPSB0cnVlO1xuICAgICAgICAgIG5leHQgJiYgbmV4dCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9LFxuICAgICAgdGhlbjogKGNiKSA9PiB7XG4gICAgICAgIG5leHQgPSBjYjtcbiAgICAgICAgaWYgKHN0b3BwZWQpIHtcbiAgICAgICAgICBuZXh0ICYmIG5leHQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfSxcbiAgICAgIHNwZWVkOiAobmV3RHVyYXRpb24pID0+IHtcbiAgICAgICAgaWYgKGludGVybmFsLmNvbmZpZy5hbmltYXRpb25zRGlzYWJsZWQpIHtcbiAgICAgICAgICBuZXdEdXJhdGlvbiA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFzdG9wcGVkKSB7XG4gICAgICAgICAgdGltZW91dCAmJiBjbGVhclRpbWVvdXQodGltZW91dCk7XG5cbiAgICAgICAgICBjb25zdCBwYXNzZWQgPSAobmV3IERhdGUoKSkuZ2V0VGltZSgpIC0gc3RhcnQ7XG4gICAgICAgICAgY29uc3QgIGsgPSBwYXNzZWQgLyBkdXJhdGlvbjtcbiAgICAgICAgICBjb25zdCByZW1haW5pbmcgPSBuZXdEdXJhdGlvbiAqICgxIC0gayk7XG5cbiAgICAgICAgICBwcm9wZXJ0aWVzLmZvckVhY2goaSA9PiB7XG4gICAgICAgICAgICBlbC5zdHlsZVtpXSA9ICgxIC0gaykgKiBpbml0aWFsW2ldICsgayAqIGZpbmFsW2ldICsgKGkgPT0gJ29wYWNpdHknID8gJycgOiAncHgnKTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHVwZGF0ZVN0eWxlcygpO1xuXG4gICAgICAgICAgc3RhcnQgPSBlbC5zcGVlZFVwVGltZTtcbiAgICAgICAgICBkdXJhdGlvbiA9IHJlbWFpbmluZztcblxuICAgICAgICAgIGVsLnN0eWxlLnRyYW5zaXRpb25EdXJhdGlvbiA9IGR1cmF0aW9uIC8gMTAwMCArICdzJztcblxuICAgICAgICAgIHByb3BlcnRpZXMuZm9yRWFjaChpID0+IHtcbiAgICAgICAgICAgIGVsLnN0eWxlW2ldID0gZmluYWxbaV0gKyAoaSA9PSAnb3BhY2l0eScgPyAnJyA6ICdweCcpO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQocmVzdWx0LnN0b3AsIHJlbWFpbmluZyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH0sXG4gICAgICBmaW5pc2g6IChtaWxsaXNlY29uZHMgPSA1MCkgPT4ge1xuICAgICAgICB2YXIgayA9ICgobmV3IERhdGUoKSkuZ2V0VGltZSgpIC0gc3RhcnQpIC8gZHVyYXRpb247XG5cbiAgICAgICAgcmVzdWx0LnNwZWVkKG1pbGxpc2Vjb25kcyAvICgxIC0gaykpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgIH07XG5cbiAgICBpZiAoZWwuaGFzQXR0cmlidXRlKCdkaXNhYmxlZCcpIHx8IHN0b3BwZWQgfHwgaW50ZXJuYWwuY29uZmlnLmFuaW1hdGlvbnNEaXNhYmxlZCkge1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICB2YXIgc3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbCk7XG4gICAgcHJvcGVydGllcy5mb3JFYWNoKGUgPT4ge1xuICAgICAgY29uc3QgdiA9IHBhcnNlRmxvYXQoc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZShlKSk7XG4gICAgICBpbml0aWFsW2VdID0gaXNOYU4odikgPyAwIDogdjtcbiAgICB9KTtcblxuXG4gICAgaWYgKCFzdG9wcGVkKSB7XG4gICAgICBlbC5zdHlsZS50cmFuc2l0aW9uUHJvcGVydHkgPSBwcm9wZXJ0aWVzLmpvaW4oJywnKTtcbiAgICAgIGVsLnN0eWxlLnRyYW5zaXRpb25EdXJhdGlvbiA9IGR1cmF0aW9uIC8gMTAwMCArICdzJztcblxuICAgICAgcHJvcGVydGllcy5mb3JFYWNoKGUgPT4ge1xuICAgICAgICBlbC5zdHlsZVtlXSA9IGZpbmFsW2VdICsgKGUgPT0gJ29wYWNpdHknID8gJycgOiAncHgnKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KHJlc3VsdC5zdG9wLCBkdXJhdGlvbik7XG4gICAgdGhpcy5fb25TdG9wQW5pbWF0aW9ucyhlbCwgcmVzdWx0LnN0b3ApO1xuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuX3F1ZXVlID0gW107XG4gICAgdGhpcy5faW5kZXggPSAwO1xuICB9XG5cbiAgX29uU3RvcEFuaW1hdGlvbnMoZWwsIGxpc3RlbmVyKSB7XG4gICAgdmFyIHF1ZXVlID0gdGhpcy5fcXVldWU7XG4gICAgdmFyIGkgPSB0aGlzLl9pbmRleCsrO1xuICAgIHF1ZXVlW2VsXSA9IHF1ZXVlW2VsXSB8fCBbXTtcbiAgICBxdWV1ZVtlbF1baV0gPSAob3B0aW9ucykgPT4ge1xuICAgICAgZGVsZXRlIHF1ZXVlW2VsXVtpXTtcbiAgICAgIGlmIChxdWV1ZVtlbF0gJiYgcXVldWVbZWxdLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgIGRlbGV0ZSBxdWV1ZVtlbF07XG4gICAgICB9XG4gICAgICByZXR1cm4gbGlzdGVuZXIob3B0aW9ucyk7XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAqIEBtZXRob2Qgc3RvcEFuaW1hdGlvbnNcbiAgKiBAZGVzYyBzdG9wcyBhY3RpdmUgYW5pbWF0aW9ucyBvbiBhIHNwZWNpZmllZCBlbGVtZW50XG4gICogQHBhcmFtIHtFbGVtZW50fEFycmF5fSBlbGVtZW50IC0gZWxlbWVudCBvciBhcnJheSBvZiBlbGVtZW50c1xuICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV1cbiAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnN0b3BOZXh0XSAtIHRoZSBjYWxsYmFja3MgYWZ0ZXIgdGhlIGFuaW1hdGlvbnMgd29uJ3QgYmUgY2FsbGVkIGlmIHRoaXMgb3B0aW9uIGlzIHRydWVcbiAgKi9cbiAgc3RvcEFuaW1hdGlvbnMoZWwsIG9wdGlvbnMgPSB7fSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGVsKSkge1xuICAgICAgcmV0dXJuIGVsLmZvckVhY2goZWwgPT4ge1xuICAgICAgICB0aGlzLnN0b3BBbmltYXRpb25zKGVsLCBvcHRpb25zKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgICh0aGlzLl9xdWV1ZVtlbF0gfHwgW10pLmZvckVhY2goZSA9PiB7IGUob3B0aW9ucyB8fCB7fSk7IH0pO1xuICB9XG5cbiAgLyoqXG4gICogQG1ldGhvZCBzdG9wQWxsXG4gICogQGRlc2Mgc3RvcHMgYWxsIGFjdGl2ZSBhbmltYXRpb25zXG4gICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XVxuICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuc3RvcE5leHRdIC0gdGhlIGNhbGxiYWNrcyBhZnRlciB0aGUgYW5pbWF0aW9ucyB3b24ndCBiZSBjYWxsZWQgaWYgdGhpcyBvcHRpb24gaXMgdHJ1ZVxuICAqL1xuICBzdG9wQWxsKG9wdGlvbnMgPSB7fSkge1xuICAgIHRoaXMuc3RvcEFuaW1hdGlvbnMoT2JqZWN0LmtleXModGhpcy5fcXVldWUpLCBvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAqIEBtZXRob2QgZmFkZVxuICAqIEBkZXNjIGZhZGVzIHRoZSBlbGVtZW50IChzaG9ydCB2ZXJzaW9uIGZvciBhbmltYXRlKGVsLCB7b3BhY2l0eTogMH0pKVxuICAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxuICAqIEBwYXJhbSB7bnVtYmVyfSBbZHVyYXRpb249MjAwXVxuICAqL1xuICBmYWRlKGVsLCBkdXJhdGlvbiA9IDIwMCkge1xuICAgIHJldHVybiB0aGlzLmFuaW1hdGUoZWwsIHtvcGFjaXR5OiAwfSwgZHVyYXRpb24pO1xuICB9XG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgQW5pbWF0b3JDU1M7XG5cbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCBvbnNFbGVtZW50cyBmcm9tICcuLi8uLi9vbnMvZWxlbWVudHMnO1xuaW1wb3J0IHV0aWwgZnJvbSAnLi4vLi4vb25zL3V0aWwnO1xuaW1wb3J0IGludGVybmFsIGZyb20gJy4uLy4uL29ucy9pbnRlcm5hbCc7XG5pbXBvcnQgQmFzZUVsZW1lbnQgZnJvbSAnLi4vYmFzZS9iYXNlLWVsZW1lbnQnO1xuaW1wb3J0IEFuaW1hdG9yIGZyb20gJy4vYW5pbWF0b3ItY3NzJztcbmltcG9ydCBjb250ZW50UmVhZHkgZnJvbSAnLi4vLi4vb25zL2NvbnRlbnQtcmVhZHknO1xuaW1wb3J0IE1vZGlmaWVyVXRpbCBmcm9tICcuLi8uLi9vbnMvaW50ZXJuYWwvbW9kaWZpZXItdXRpbCc7XG5cbmNvbnN0IGRlZmF1bHRDbGFzc05hbWUgPSAncmlwcGxlJztcbmNvbnN0IHNjaGVtZSA9IHtcbiAgJyc6ICdyaXBwbGUtLSonLFxuICAnLnJpcHBsZV9fd2F2ZSc6ICdyaXBwbGUtLSpfX3dhdmUnLFxuICAnLnJpcHBsZV9fYmFja2dyb3VuZCc6ICdyaXBwbGUtLSpfX2JhY2tncm91bmQnLFxufTtcblxuLyoqXG4gKiBAZWxlbWVudCBvbnMtcmlwcGxlXG4gKiBAY2F0ZWdvcnkgdmlzdWFsXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXVxuICogICAgIEFkZHMgYSBNYXRlcmlhbCBEZXNpZ24gXCJyaXBwbGVcIiBlZmZlY3QgdG8gYW4gZWxlbWVudC4gVGhlIHJpcHBsZSBlZmZlY3Qgd2lsbCBzcHJlYWQgZnJvbSB0aGUgcG9zaXRpb24gd2hlcmUgdGhlIHVzZXIgdGFwcy5cbiAqXG4gKiAgICAgU29tZSBlbGVtZW50cyBzdWNoIGFzIGA8b25zLWJ1dHRvbj5gIGFuZCBgPG9ucy1mYWI+YCAgc3VwcG9ydCBhIGByaXBwbGVgIGF0dHJpYnV0ZS5cbiAqICAgWy9lbl1cbiAqICAgW2phXeODnuODhuODquOCouODq+ODh+OCtuOCpOODs+OBruODquODg+ODl+ODq+WKueaenOOCkkRPTeimgee0oOOBq+i/veWKoOOBl+OBvuOBmeOAglsvamFdXG4gKiBAY29kZXBlbiB3S1FXZFpcbiAqIEB0dXRvcmlhbCB2YW5pbGxhL1JlZmVyZW5jZS9yaXBwbGVcbiAqIEBtb2RpZmllciBsaWdodC1ncmF5XG4gKiAgIFtlbl1DaGFuZ2UgdGhlIGNvbG9yIG9mIGVmZmVjdHMgdG8gbGlnaHQgZ3JheS5bL2VuXVxuICogICBbamFd44Ko44OV44Kn44Kv44OI44Gu6Imy44GM5piO44KL44GE54Gw6Imy44Gr44Gq44KK44G+44GZ44CCWy9qYV1cbiAqIEBndWlkZSB0aGVtaW5nLmh0bWwjY3Jvc3MtcGxhdGZvcm0tc3R5bGluZy1hdXRvc3R5bGluZ1xuICogIFtlbl1Dcm9zcyBwbGF0Zm9ybSBzdHlsaW5nWy9lbl1cbiAqICBbamFdQ3Jvc3MgcGxhdGZvcm0gc3R5bGluZ1svamFdXG4gKiBAZXhhbXBsZVxuICogPGRpdiBjbGFzcz1cIm15LWRpdlwiPlxuICogIDxvbnMtcmlwcGxlPjwvb25zLXJpcHBsZT5cbiAqIDwvZGl2PlxuICpcbiAqIEBleGFtcGxlXG4gKiA8b25zLWJ1dHRvbiByaXBwbGU+Q2xpY2sgbWUhPC9vbnMtYnV0dG9uPlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSaXBwbGVFbGVtZW50IGV4dGVuZHMgQmFzZUVsZW1lbnQge1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGNvbG9yXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1Db2xvciBvZiB0aGUgcmlwcGxlIGVmZmVjdC5bL2VuXVxuICAgKiAgIFtqYV3jg6rjg4Pjg5fjg6vjgqjjg5Xjgqfjgq/jg4jjga7oibLjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBtb2RpZmllclxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dVGhlIGFwcGVhcmFuY2Ugb2YgdGhlIHJpcHBsZSBlZmZlY3QuWy9lbl1cbiAgICogICBbamFd44Ko44OV44Kn44Kv44OI44Gu6KGo54++44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgYmFja2dyb3VuZFxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dQ29sb3Igb2YgdGhlIGJhY2tncm91bmQuWy9lbl1cbiAgICogICBbamFd6IOM5pmv44Gu6Imy44KS6Kit5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgc2l6ZVxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dU2l6aW5nIG9mIHRoZSB3YXZlIG9uIHJpcHBsZSBlZmZlY3QuIFNldCBcImNvdmVyXCIgb3IgXCJjb250YWluXCIuIERlZmF1bHQgaXMgXCJjb3ZlclwiLlsvZW5dXG4gICAqICAgW2phXeOCqOODleOCp+OCr+ODiOOBruOCteOCpOOCuuOCkuaMh+WumuOBl+OBvuOBmeOAglwiY292ZXJcIuOCguOBl+OBj+OBr1wiY29udGFpblwi44KS5oyH5a6a44GX44G+44GZ44CC44OH44OV44Kp44Or44OI44GvXCJjb3Zlclwi44Gn44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgY2VudGVyXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dSWYgdGhpcyBhdHRyaWJ1dGUgcHJlc2VudHMsIGNoYW5nZSB0aGUgcG9zaXRpb24gb2Ygd2F2ZSBlZmZlY3QgdG8gY2VudGVyIG9mIHRoZSB0YXJnZXQgZWxlbWVudC5bL2VuXVxuICAgKiAgIFtqYV3jgZPjga7opoHntKDjgpLoqK3lrprjgZnjgovjgajjgIHjgqjjg5Xjgqfjgq/jg4jjga7kvY3nva7jgYzopoHntKDjga7nnJ/jgpPkuK3jgYvjgonlp4vjgb7jgorjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBkaXNhYmxlZFxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dSWYgdGhpcyBhdHRyaWJ1dGUgaXMgc2V0LCB0aGUgcmlwcGxlIGVmZmVjdCB3aWxsIGJlIGRpc2FibGVkLlsvZW5dXG4gICAqICAgW2phXeOBk+OBruWxnuaAp+OBjOioreWumuOBleOCjOOBn+WgtOWQiOOAgeODquODg+ODl+ODq+OCqOODleOCp+OCr+ODiOOBr+eEoeWKueOBq+OBquOCiuOBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG5cbiAgICB0aGlzLl9vblRhcCA9IHRoaXMuX29uVGFwLmJpbmQodGhpcyk7XG4gICAgdGhpcy5fb25Ib2xkID0gdGhpcy5fb25Ib2xkLmJpbmQodGhpcyk7XG4gICAgdGhpcy5fb25EcmFnU3RhcnQgPSB0aGlzLl9vbkRyYWdTdGFydC5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX29uUmVsZWFzZSA9IHRoaXMuX29uUmVsZWFzZS5iaW5kKHRoaXMpO1xuXG4gICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHRoaXMuX2NvbXBpbGUoKSk7XG5cbiAgICB0aGlzLl9hbmltYXRvciA9IG5ldyBBbmltYXRvcigpO1xuXG4gICAgWydjb2xvcicsICdjZW50ZXInLCAnc3RhcnQtcmFkaXVzJywgJ2JhY2tncm91bmQnLCAnbW9kaWZpZXInXS5mb3JFYWNoKGUgPT4ge1xuICAgICAgdGhpcy5hdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2soZSwgbnVsbCwgdGhpcy5nZXRBdHRyaWJ1dGUoZSkpO1xuICAgIH0pO1xuICB9XG5cbiAgX2NvbXBpbGUoKSB7XG4gICAgdGhpcy5jbGFzc0xpc3QuYWRkKGRlZmF1bHRDbGFzc05hbWUpO1xuXG4gICAgdGhpcy5fd2F2ZSA9IHRoaXMuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSgncmlwcGxlX193YXZlJylbMF07XG4gICAgdGhpcy5fYmFja2dyb3VuZCA9IHRoaXMuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSgncmlwcGxlX19iYWNrZ3JvdW5kJylbMF07XG5cbiAgICBpZiAoISh0aGlzLl9iYWNrZ3JvdW5kICYmIHRoaXMuX3dhdmUpKSB7XG4gICAgICB0aGlzLl93YXZlID0gdXRpbC5jcmVhdGUoJy5yaXBwbGVfX3dhdmUnKTtcbiAgICAgIHRoaXMuX2JhY2tncm91bmQgPSB1dGlsLmNyZWF0ZSgnLnJpcHBsZV9fYmFja2dyb3VuZCcpO1xuXG4gICAgICB0aGlzLmFwcGVuZENoaWxkKHRoaXMuX3dhdmUpO1xuICAgICAgdGhpcy5hcHBlbmRDaGlsZCh0aGlzLl9iYWNrZ3JvdW5kKTtcbiAgICB9XG5cbiAgICBNb2RpZmllclV0aWwuaW5pdE1vZGlmaWVyKHRoaXMsIHNjaGVtZSk7XG4gIH1cblxuICBfZ2V0RWZmZWN0U2l6ZSgpIHtcbiAgICBjb25zdCBzaXplcyA9IFsnY292ZXInLCAnY29udGFpbiddO1xuICAgIGlmICh0aGlzLmhhc0F0dHJpYnV0ZSgnc2l6ZScpKSB7XG4gICAgICBjb25zdCBzaXplID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ3NpemUnKTtcbiAgICAgIGlmIChzaXplcy5pbmRleE9mKHNpemUpICE9PSAtMSkge1xuICAgICAgICByZXR1cm4gc2l6ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gJ2NvdmVyJztcbiAgfVxuXG4gIF9jYWxjdWxhdGVDb29yZHMoZSkge1xuICAgIGxldCB4LCB5LCBoLCB3LCByO1xuICAgIGNvbnN0IGIgPSB0aGlzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGNvbnN0IHNpemUgPSB0aGlzLl9nZXRFZmZlY3RTaXplKCk7XG4gICAgY29uc3QgZXJyb3IgPSAoKSA9PiB1dGlsLnRocm93KCdSaXBwbGUgaW52YWxpZCBzdGF0ZScpO1xuXG4gICAgaWYgKHRoaXMuX2NlbnRlcikge1xuICAgICAgeCA9IGIud2lkdGggLyAyO1xuICAgICAgeSA9IGIuaGVpZ2h0IC8gMjtcblxuICAgICAgaWYgKHNpemUgPT09ICdjb3ZlcicpIHtcbiAgICAgICAgciA9IE1hdGguc3FydCh4ICogeCArIHkgKiB5KTtcbiAgICAgIH0gZWxzZSBpZiAoc2l6ZSA9PT0gJ2NvbnRhaW4nKSB7XG4gICAgICAgIHIgPSBNYXRoLm1pbih4LCB5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVycm9yKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHggPSAodHlwZW9mIGUuY2xpZW50WCA9PT0gJ251bWJlcicgPyBlLmNsaWVudFggOiBlLmNoYW5nZWRUb3VjaGVzWzBdLmNsaWVudFgpIC0gYi5sZWZ0O1xuICAgICAgeSA9ICh0eXBlb2YgZS5jbGllbnRZID09PSAnbnVtYmVyJyA/IGUuY2xpZW50WSA6IGUuY2hhbmdlZFRvdWNoZXNbMF0uY2xpZW50WSkgLSBiLnRvcDtcbiAgICAgIGggPSBNYXRoLm1heCh5LCBiLmhlaWdodCAtIHkpO1xuICAgICAgdyA9IE1hdGgubWF4KHgsIGIud2lkdGggLSB4KTtcblxuICAgICAgaWYgKHNpemUgPT09ICdjb3ZlcicpIHtcbiAgICAgICAgciA9IE1hdGguc3FydChoICogaCArIHcgKiB3KTtcbiAgICAgIH0gZWxzZSBpZiAoc2l6ZSA9PT0gJ2NvbnRhaW4nKSB7XG4gICAgICAgIHIgPSBNYXRoLm1pbihNYXRoLnJvdW5kKGggLyAyKSwgTWF0aC5yb3VuZCh3IC8gMikpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZXJyb3IoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge3gsIHksIHJ9O1xuICB9XG5cbiAgX3JpcHBsZUFuaW1hdGlvbihlLCBkdXJhdGlvbiA9IDMwMCkge1xuICAgIGNvbnN0IHtfYW5pbWF0b3IsIF93YXZlLCBfYmFja2dyb3VuZCwgX21pblJ9ID0gdGhpcztcbiAgICBjb25zdCB7eCwgeSwgcn0gPSB0aGlzLl9jYWxjdWxhdGVDb29yZHMoZSk7XG5cbiAgICBfYW5pbWF0b3Iuc3RvcEFsbCh7c3RvcE5leHQ6IDF9KTtcbiAgICBfYW5pbWF0b3IuYW5pbWF0ZShfYmFja2dyb3VuZCwge29wYWNpdHk6IDF9LCBkdXJhdGlvbik7XG5cbiAgICB1dGlsLmV4dGVuZChfd2F2ZS5zdHlsZSwge1xuICAgICAgb3BhY2l0eTogMSxcbiAgICAgIHRvcDogeSAtIF9taW5SICsgJ3B4JyxcbiAgICAgIGxlZnQ6IHggLSBfbWluUiArICdweCcsXG4gICAgICB3aWR0aDogMiAqIF9taW5SICsgJ3B4JyxcbiAgICAgIGhlaWdodDogMiAqIF9taW5SICsgJ3B4J1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIF9hbmltYXRvci5hbmltYXRlKF93YXZlLCB7XG4gICAgICB0b3A6IHkgLSByLFxuICAgICAgbGVmdDogeCAtIHIsXG4gICAgICBoZWlnaHQ6IDIgKiByLFxuICAgICAgd2lkdGg6IDIgKiByXG4gICAgfSwgZHVyYXRpb24pO1xuICB9XG5cbiAgX3VwZGF0ZVBhcmVudCgpIHtcbiAgICBpZiAoIXRoaXMuX3BhcmVudFVwZGF0ZWQgJiYgdGhpcy5wYXJlbnROb2RlKSB7XG4gICAgICBjb25zdCBjb21wdXRlZFN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUodGhpcy5wYXJlbnROb2RlKTtcbiAgICAgIGlmIChjb21wdXRlZFN0eWxlLmdldFByb3BlcnR5VmFsdWUoJ3Bvc2l0aW9uJykgPT09ICdzdGF0aWMnKSB7XG4gICAgICAgIHRoaXMucGFyZW50Tm9kZS5zdHlsZS5wb3NpdGlvbiA9ICdyZWxhdGl2ZSc7XG4gICAgICB9XG4gICAgICB0aGlzLl9wYXJlbnRVcGRhdGVkID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBfb25UYXAoZSkge1xuICAgIGlmICghdGhpcy5kaXNhYmxlZCAmJiAhZS5yaXBwbGUpIHtcbiAgICAgIGUucmlwcGxlID0gdHJ1ZTtcbiAgICAgIHRoaXMuX3VwZGF0ZVBhcmVudCgpO1xuICAgICAgdGhpcy5fcmlwcGxlQW5pbWF0aW9uKGUuZ2VzdHVyZS5zcmNFdmVudCkudGhlbigoKSA9PiB7XG4gICAgICAgIHRoaXMuX2FuaW1hdG9yLmZhZGUodGhpcy5fd2F2ZSk7XG4gICAgICAgIHRoaXMuX2FuaW1hdG9yLmZhZGUodGhpcy5fYmFja2dyb3VuZCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBfb25Ib2xkKGUpIHtcbiAgICBpZiAoIXRoaXMuZGlzYWJsZWQgJiYgIWUucmlwcGxlKSB7XG4gICAgICBlLnJpcHBsZSA9IHRydWU7XG4gICAgICB0aGlzLl91cGRhdGVQYXJlbnQoKTtcbiAgICAgIHRoaXMuX2hvbGRpbmcgPSB0aGlzLl9yaXBwbGVBbmltYXRpb24oZS5nZXN0dXJlLnNyY0V2ZW50LCAyMDAwKTtcbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3JlbGVhc2UnLCB0aGlzLl9vblJlbGVhc2UpO1xuICAgIH1cbiAgfVxuXG4gIF9vblJlbGVhc2UoZSkge1xuICAgIGlmICh0aGlzLl9ob2xkaW5nICYmICFlLnJpcHBsZSkge1xuICAgICAgZS5yaXBwbGUgPSB0cnVlO1xuICAgICAgdGhpcy5faG9sZGluZy5zcGVlZCgzMDApLnRoZW4oKCkgPT4ge1xuICAgICAgICB0aGlzLl9hbmltYXRvci5zdG9wQWxsKHtzdG9wTmV4dDogdHJ1ZX0pO1xuICAgICAgICB0aGlzLl9hbmltYXRvci5mYWRlKHRoaXMuX3dhdmUpO1xuICAgICAgICB0aGlzLl9hbmltYXRvci5mYWRlKHRoaXMuX2JhY2tncm91bmQpO1xuICAgICAgfSk7XG5cbiAgICAgIHRoaXMuX2hvbGRpbmcgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdyZWxlYXNlJywgdGhpcy5fb25SZWxlYXNlKTtcbiAgfVxuXG4gIF9vbkRyYWdTdGFydChlKSB7XG4gICAgaWYgKHRoaXMuX2hvbGRpbmcpIHtcbiAgICAgIHJldHVybiB0aGlzLl9vblJlbGVhc2UoZSk7XG4gICAgfVxuICAgIGlmIChbJ2xlZnQnLCAncmlnaHQnXS5pbmRleE9mKGUuZ2VzdHVyZS5kaXJlY3Rpb24pICE9IC0xKSB7XG4gICAgICB0aGlzLl9vblRhcChlKTtcbiAgICB9XG4gIH1cblxuICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICB0aGlzLl9wYXJlbnROb2RlID0gdGhpcy5wYXJlbnROb2RlO1xuXG4gICAgaWYgKGludGVybmFsLmNvbmZpZy5hbmltYXRpb25zRGlzYWJsZWQpIHtcbiAgICAgIHRoaXMuZGlzYWJsZWQgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9wYXJlbnROb2RlLmFkZEV2ZW50TGlzdGVuZXIoJ3RhcCcsIHRoaXMuX29uVGFwKTtcbiAgICAgIHRoaXMuX3BhcmVudE5vZGUuYWRkRXZlbnRMaXN0ZW5lcignaG9sZCcsIHRoaXMuX29uSG9sZCk7XG4gICAgICB0aGlzLl9wYXJlbnROb2RlLmFkZEV2ZW50TGlzdGVuZXIoJ2RyYWdzdGFydCcsIHRoaXMuX29uRHJhZ1N0YXJ0KTtcbiAgICB9XG4gIH1cblxuICBkaXNjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICBjb25zdCBwbiA9IHRoaXMuX3BhcmVudE5vZGUgfHwgdGhpcy5wYXJlbnROb2RlO1xuICAgIHBuLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RhcCcsIHRoaXMuX29uVGFwKTtcbiAgICBwbi5yZW1vdmVFdmVudExpc3RlbmVyKCdob2xkJywgdGhpcy5fb25Ib2xkKTtcbiAgICBwbi5yZW1vdmVFdmVudExpc3RlbmVyKCdkcmFnc3RhcnQnLCB0aGlzLl9vbkRyYWdTdGFydCk7XG4gIH1cblxuICBzdGF0aWMgZ2V0IG9ic2VydmVkQXR0cmlidXRlcygpIHtcbiAgICByZXR1cm4gWydzdGFydC1yYWRpdXMnLCAnY29sb3InLCAnYmFja2dyb3VuZCcsICdjZW50ZXInLCAnY2xhc3MnLCAnbW9kaWZpZXInXTtcbiAgfVxuXG4gIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBsYXN0LCBjdXJyZW50KSB7XG4gICAgc3dpdGNoIChuYW1lKSB7XG5cbiAgICAgIGNhc2UgJ2NsYXNzJzpcbiAgICAgICAgdXRpbC5yZXN0b3JlQ2xhc3ModGhpcywgZGVmYXVsdENsYXNzTmFtZSwgc2NoZW1lKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ21vZGlmaWVyJzpcbiAgICAgICAgTW9kaWZpZXJVdGlsLm9uTW9kaWZpZXJDaGFuZ2VkKGxhc3QsIGN1cnJlbnQsIHRoaXMsIHNjaGVtZSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdzdGFydC1yYWRpdXMnOlxuICAgICAgICB0aGlzLl9taW5SID0gTWF0aC5tYXgoMCwgcGFyc2VGbG9hdChjdXJyZW50KSB8fCAwKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ2NvbG9yJzpcbiAgICAgICAgaWYgKGN1cnJlbnQpIHtcbiAgICAgICAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5fd2F2ZS5zdHlsZS5iYWNrZ3JvdW5kID0gY3VycmVudDtcbiAgICAgICAgICAgIGlmICghdGhpcy5oYXNBdHRyaWJ1dGUoJ2JhY2tncm91bmQnKSkge1xuICAgICAgICAgICAgICB0aGlzLl9iYWNrZ3JvdW5kLnN0eWxlLmJhY2tncm91bmQgPSBjdXJyZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdiYWNrZ3JvdW5kJzpcbiAgICAgICAgaWYgKGN1cnJlbnQgfHwgbGFzdCkge1xuICAgICAgICAgIGlmIChjdXJyZW50ID09PSAnbm9uZScpIHtcbiAgICAgICAgICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB7XG4gICAgICAgICAgICAgIHRoaXMuX2JhY2tncm91bmQuc2V0QXR0cmlidXRlKCdkaXNhYmxlZCcsICdkaXNhYmxlZCcpO1xuICAgICAgICAgICAgICB0aGlzLl9iYWNrZ3JvdW5kLnN0eWxlLmJhY2tncm91bmQgPSAndHJhbnNwYXJlbnQnO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB7XG4gICAgICAgICAgICAgIGlmICh0aGlzLl9iYWNrZ3JvdW5kLmhhc0F0dHJpYnV0ZSgnZGlzYWJsZWQnKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2JhY2tncm91bmQucmVtb3ZlQXR0cmlidXRlKCdkaXNhYmxlZCcpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRoaXMuX2JhY2tncm91bmQuc3R5bGUuYmFja2dyb3VuZCA9IGN1cnJlbnQ7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ2NlbnRlcic6XG4gICAgICAgIGlmIChuYW1lID09PSAnY2VudGVyJykge1xuICAgICAgICAgIHRoaXMuX2NlbnRlciA9IGN1cnJlbnQgIT0gbnVsbCAmJiBjdXJyZW50ICE9ICdmYWxzZSc7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG5cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IGRpc2FibGVkXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dV2hldGhlciB0aGUgZWxlbWVudCBpcyBkaXNhYmxlZCBvciBub3QuWy9lbl1cbiAgICogICBbamFd54Sh5Yq55YyW44GV44KM44Gm44GE44KL5aC05ZCI44GrYHRydWVg44CCWy9qYV1cbiAgICovXG4gIHNldCBkaXNhYmxlZCh2YWx1ZSkge1xuICAgIHJldHVybiB1dGlsLnRvZ2dsZUF0dHJpYnV0ZSh0aGlzLCAnZGlzYWJsZWQnLCB2YWx1ZSk7XG4gIH1cblxuICBnZXQgZGlzYWJsZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaGFzQXR0cmlidXRlKCdkaXNhYmxlZCcpO1xuICB9XG59XG5cbm9uc0VsZW1lbnRzLlJpcHBsZSA9IFJpcHBsZUVsZW1lbnQ7XG5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ29ucy1yaXBwbGUnLCBSaXBwbGVFbGVtZW50KTtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCBvbnNFbGVtZW50cyBmcm9tICcuLi9vbnMvZWxlbWVudHMnO1xuaW1wb3J0IEJhc2VFbGVtZW50IGZyb20gJy4vYmFzZS9iYXNlLWVsZW1lbnQnO1xuXG4vKipcbiAqIEBlbGVtZW50IG9ucy1yb3dcbiAqIEBjYXRlZ29yeSBncmlkXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXVJlcHJlc2VudHMgYSByb3cgaW4gdGhlIGdyaWQgc3lzdGVtLiBVc2Ugd2l0aCBgPG9ucy1jb2w+YCB0byBsYXlvdXQgY29tcG9uZW50cy5bL2VuXVxuICogICBbamFd44Kw44Oq44OD44OJ44K344K544OG44Og44Gr44Gm6KGM44KS5a6a576p44GX44G+44GZ44CCb25zLWNvbOOBqOOBqOOCguOBq+S9v+eUqOOBl+OAgeOCs+ODs+ODneODvOODjeODs+ODiOOBrumFjee9ruOBq+S9v+eUqOOBl+OBvuOBmeOAglsvamFdXG4gKiBAY29kZXBlbiBHZ3VqQyB7d2lkZX1cbiAqIEBndWlkZSB0aGVtaW5nLmh0bWxcbiAqICAgW2VuXUxheW91dGluZyBndWlkZVsvZW5dXG4gKiAgIFtqYV3jg6zjgqTjgqLjgqbjg4joqr/mlbRbL2phXVxuICogQHNlZWFsc28gb25zLWNvbFxuICogICBbZW5dVGhlIGA8b25zLWNvbD5gIGNvbXBvbmVudCBpcyB1c2VkIGFzIGNoaWxkcmVuIG9mIGA8b25zLXJvdz5gLlsvZW5dXG4gKiAgIFtqYV1vbnMtY29s44Kz44Oz44Od44O844ON44Oz44OIWy9qYV1cbiAqIEBub3RlXG4gKiAgIFtlbl1Gb3IgQW5kcm9pZCA0LjMgYW5kIGVhcmxpZXIsIGFuZCBpT1M2IGFuZCBlYXJsaWVyLCB3aGVuIHVzaW5nIG1peGVkIGFsaWdubWVudCB3aXRoIG9ucy1yb3cgYW5kIG9ucy1jb2wsIHRoZXkgbWF5IG5vdCBiZSBkaXNwbGF5ZWQgY29ycmVjdGx5LiBZb3UgY2FuIHVzZSBvbmx5IG9uZSB2ZXJ0aWNhbC1hbGlnbi5bL2VuXVxuICogICBbamFdQW5kcm9pZCA0LjPku6XliY3jgIHjgoLjgZfjgY/jga9pT1MgNuS7peWJjeOBrk9T44Gu5aC05ZCI44CBb25zLXJvd+OBqG9ucy1jb2zjgpLntYTjgb/lkIjjgo/jgZvjgabjgZ3jgozjgZ7jgozjga5vbnMtY29s6KaB57Sg44GudmVydGljYWwtYWxpZ27lsZ7mgKfjga7lgKTjgavliKXjgIXjga7lgKTjgpLmjIflrprjgZnjgovjgajjgIHmj4/nlLvjgYzltKnjgozjgovloLTlkIjjgYzjgYLjgorjgb7jgZnjgIJ2ZXJ0aWNhbC1hbGlnbuWxnuaAp+OBruWApOOBq+OBr+S4gOOBpOOBruWApOOBoOOBkeOCkuaMh+WumuOBp+OBjeOBvuOBmeOAglsvamFdXG4gKiBAZXhhbXBsZVxuICogPG9ucy1yb3c+XG4gKiAgIDxvbnMtY29sIHdpZHRoPVwiNTBweFwiPjxvbnMtaWNvbiBpY29uPVwiZmEtdHdpdHRlclwiPjwvb25zLWljb24+PC9vbnMtY29sPlxuICogICA8b25zLWNvbD5UZXh0PC9vbnMtY29sPlxuICogPC9vbnMtcm93PlxuICovXG5cbi8qKlxuICogQGF0dHJpYnV0ZSB2ZXJ0aWNhbC1hbGlnblxuICogQHR5cGUge1N0cmluZ31cbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dU2hvcnQgaGFuZCBhdHRyaWJ1dGUgZm9yIGFsaWduaW5nIHZlcnRpY2FsbHkuIFZhbGlkIHZhbHVlcyBhcmUgdG9wLCBib3R0b20sIGFuZCBjZW50ZXIuWy9lbl1cbiAqICAgW2phXee4puOBq+aVtOWIl+OBmeOCi+OBn+OCgeOBq+aMh+WumuOBl+OBvuOBmeOAgnRvcOOAgWJvdHRvbeOAgWNlbnRlcuOBruOBhOOBmuOCjOOBi+OCkuaMh+WumuOBp+OBjeOBvuOBmeOAglsvamFdXG4gKi9cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUm93RWxlbWVudCBleHRlbmRzIEJhc2VFbGVtZW50IHtcbn1cblxub25zRWxlbWVudHMuUm93ID0gUm93RWxlbWVudDtcbmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnb25zLXJvdycsIFJvd0VsZW1lbnQpO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IG9uc0VsZW1lbnRzIGZyb20gJy4uL29ucy9lbGVtZW50cyc7XG5pbXBvcnQgdXRpbCBmcm9tICcuLi9vbnMvdXRpbCc7XG5pbXBvcnQgYXV0b1N0eWxlIGZyb20gJy4uL29ucy9hdXRvc3R5bGUnO1xuaW1wb3J0IE1vZGlmaWVyVXRpbCBmcm9tICcuLi9vbnMvaW50ZXJuYWwvbW9kaWZpZXItdXRpbCc7XG5pbXBvcnQgQmFzZUVsZW1lbnQgZnJvbSAnLi9iYXNlL2Jhc2UtZWxlbWVudCc7XG5pbXBvcnQgY29udGVudFJlYWR5IGZyb20gJy4uL29ucy9jb250ZW50LXJlYWR5JztcblxuY29uc3QgZGVmYXVsdENsYXNzTmFtZSA9ICdzZWdtZW50JztcbmNvbnN0IHNjaGVtZSA9IHtcbiAgJyc6ICdzZWdtZW50LS0qJyxcbiAgJy5zZWdtZW50X19pdGVtJzogJ3NlZ21lbnQtLSpfX2l0ZW0nLFxuICAnLnNlZ21lbnRfX2lucHV0JzogJ3NlZ21lbnQtLSpfX2lucHV0JyxcbiAgJy5zZWdtZW50X19idXR0b24nOiAnc2VnbWVudC0tKl9fYnV0dG9uJ1xufTtcblxuY29uc3QgZ2VuZXJhdGVJZCA9ICgoKSA9PiB7XG4gIGxldCBpID0gMDtcbiAgcmV0dXJuICgpID0+ICdvbnMtc2VnbWVudC1nZW4tJyArIChpKyspO1xufSkoKTtcblxuLyoqXG4gKiBAZWxlbWVudCBvbnMtc2VnbWVudFxuICogQGNhdGVnb3J5IGNvbnRyb2xcbiAqIEBtb2RpZmllciBtYXRlcmlhbFxuICogICBbZW5dTWF0ZXJpYWwgRGVzaWduIHNlZ21lbnRbL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dXG4gKiAgICAgU2VnbWVudCBjb21wb25lbnQuIFVzZSB0aGlzIGNvbXBvbmVudCB0byBoYXZlIGEgYnV0dG9uIGJhciB3aXRoIGF1dG9tYXRpYyBzdHlsZXMgdGhhdCBzd2l0Y2ggb24gY2xpY2sgb2YgYW5vdGhlciBidXR0b24uXG4gKlxuICogICAgIFdpbGwgYXV0b21hdGljYWxseSBkaXNwbGF5IGFzIGEgTWF0ZXJpYWwgRGVzaWduIHNlZ21lbnQgb24gQW5kcm9pZC5cbiAqICAgWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAY29kZXBlbiBoTGF5eFxuICogQHR1dG9yaWFsIHZhbmlsbGEvUmVmZXJlbmNlL3NlZ21lbnRcbiAqIEBndWlkZSB0aGVtaW5nLmh0bWwjbW9kaWZpZXJzIFtlbl1Nb3JlIGRldGFpbHMgYWJvdXQgdGhlIGBtb2RpZmllcmAgYXR0cmlidXRlWy9lbl1bamFdbW9kaWZpZXLlsZ7mgKfjga7kvb/jgYTmlrlbL2phXVxuICogQGd1aWRlIHRoZW1pbmcuaHRtbCNjcm9zcy1wbGF0Zm9ybS1zdHlsaW5nLWF1dG9zdHlsaW5nIFtlbl1JbmZvcm1hdGlvbiBhYm91dCBjcm9zcyBwbGF0Zm9ybSBzdHlsaW5nWy9lbl1bamFdSW5mb3JtYXRpb24gYWJvdXQgY3Jvc3MgcGxhdGZvcm0gc3R5bGluZ1svamFdXG4gKiBAZXhhbXBsZVxuICogPG9ucy1zZWdtZW50PlxuICogICA8b25zLWJ1dHRvbj5MYWJlbCAxPC9vbnMtYnV0dG9uPlxuICogICA8b25zLWJ1dHRvbj5MYWJlbCAyPC9vbnMtYnV0dG9uPlxuICogICA8b25zLWJ1dHRvbj5MYWJlbCAzPC9vbnMtYnV0dG9uPlxuICogPC9vbnMtc2VnbWVudD5cbiAqL1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTZWdtZW50RWxlbWVudCBleHRlbmRzIEJhc2VFbGVtZW50IHtcblxuICAvKipcbiAgICogQGV2ZW50IHBvc3RjaGFuZ2VcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUZpcmVzIGFmdGVyIHRoZSBhY3RpdmUgYnV0dG9uIGlzIGNoYW5nZWQuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50XG4gICAqICAgW2VuXUV2ZW50IG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKiBAcGFyYW0ge051bWJlcn0gZXZlbnQuaW5kZXhcbiAgICogICBbZW5dVGFwcGVkIGJ1dHRvbiBpbmRleC5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQuc2VnbWVudEl0ZW1cbiAgICogICBbZW5dU2VnbWVudCBpdGVtIG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBtb2RpZmllclxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFtlbl1UaGUgYXBwZWFyYW5jZSBvZiB0aGUgc2VnbWVudC5bL2VuXVxuICAgKiAgW2phXVsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIHRhYmJhci1pZFxuICAgKiBAaW5pdG9ubHlcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dSUQgb2YgdGhlIHRhYmJhciBlbGVtZW50IHRvIFwiY29ubmVjdFwiIHRvIHRoZSBzZWdtZW50LiBNdXN0IGJlIGluc2lkZSB0aGUgc2FtZSBwYWdlLlsvZW5dXG4gICAqICBbamFdWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgYWN0aXZlLWluZGV4XG4gICAqIEBpbml0b25seVxuICAgKiBAZGVmYXVsdCAwXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXUluZGV4IG9mIHRoZSBmaXJzdCBhY3RpdmUgYnV0dG9uLCBvbmx5IHdvcmtzIGlmIHRoZXJlIGlzIG5vIGNvbm5lY3RlZCB0YWJiYXIgKGluIHdoaWNoIGNhc2UgdGhlIGFjdGl2ZSB0YWIgc2V0cyB0aGUgYWN0aXZlIGJ1dHRvbikuWy9lbl1cbiAgICogIFtqYV1bL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBkaXNhYmxlZFxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dU3BlY2lmeSBpZiBzZWdtZW50IHNob3VsZCBiZSBkaXNhYmxlZC5bL2VuXVxuICAgKiAgIFtqYV3jg5zjgr/jg7PjgpLnhKHlirnljJbjgZnjgovloLTlkIjjga/mjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG5cbiAgICB0aGlzLl9zZWdtZW50SWQgPSBnZW5lcmF0ZUlkKCk7XG4gICAgdGhpcy5fdGFiYmFyID0gbnVsbDtcbiAgICB0aGlzLl9vbkNoYW5nZSA9IHRoaXMuX29uQ2hhbmdlLmJpbmQodGhpcyk7XG4gICAgdGhpcy5fb25UYWJiYXJQcmVDaGFuZ2UgPSB0aGlzLl9vblRhYmJhclByZUNoYW5nZS5iaW5kKHRoaXMpO1xuXG4gICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHtcbiAgICAgIHRoaXMuX2NvbXBpbGUoKVxuICAgICAgc2V0SW1tZWRpYXRlKCgpID0+IHRoaXMuX2xhc3RBY3RpdmVJbmRleCA9IHRoaXMuX3RhYmJhciA/IHRoaXMuX3RhYmJhci5nZXRBY3RpdmVUYWJJbmRleCgpIDogdGhpcy5nZXRBY3RpdmVCdXR0b25JbmRleCgpKTtcbiAgICB9KTtcbiAgfVxuXG4gIF9jb21waWxlKCkge1xuICAgIGF1dG9TdHlsZS5wcmVwYXJlKHRoaXMpO1xuICAgIHRoaXMuY2xhc3NMaXN0LmFkZChkZWZhdWx0Q2xhc3NOYW1lKTtcblxuICAgIGZvciAobGV0IGluZGV4ID0gdGhpcy5jaGlsZHJlbi5sZW5ndGggLSAxOyBpbmRleCA+PSAwOyBpbmRleC0tKSB7XG4gICAgICBjb25zdCBpdGVtID0gdGhpcy5jaGlsZHJlbltpbmRleF07XG4gICAgICBpdGVtLmNsYXNzTGlzdC5hZGQoJ3NlZ21lbnRfX2l0ZW0nKTtcblxuICAgICAgY29uc3QgaW5wdXQgPSB1dGlsLmZpbmRDaGlsZChpdGVtLCAnLnNlZ21lbnRfX2lucHV0JykgfHwgdXRpbC5jcmVhdGUoJ2lucHV0LnNlZ21lbnRfX2lucHV0Jyk7XG4gICAgICBpbnB1dC50eXBlID0gJ3JhZGlvJztcbiAgICAgIGlucHV0LnZhbHVlID0gaW5kZXg7XG4gICAgICBpbnB1dC5uYW1lID0gaW5wdXQubmFtZSB8fCB0aGlzLl9zZWdtZW50SWQ7XG4gICAgICBpbnB1dC5jaGVja2VkID0gIXRoaXMuaGFzQXR0cmlidXRlKCd0YWJiYXItaWQnKSAmJiBpbmRleCA9PT0gKHBhcnNlSW50KHRoaXMuZ2V0QXR0cmlidXRlKCdhY3RpdmUtaW5kZXgnKSkgfHwgMCk7XG5cbiAgICAgIGNvbnN0IGJ1dHRvbiA9IHV0aWwuZmluZENoaWxkKGl0ZW0sICcuc2VnbWVudF9fYnV0dG9uJykgfHwgdXRpbC5jcmVhdGUoJy5zZWdtZW50X19idXR0b24nKTtcbiAgICAgIGlmIChidXR0b24ucGFyZW50RWxlbWVudCAhPT0gaXRlbSkge1xuICAgICAgICB3aGlsZSAoaXRlbS5maXJzdENoaWxkKSB7XG4gICAgICAgICAgYnV0dG9uLmFwcGVuZENoaWxkKGl0ZW0uZmlyc3RDaGlsZCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaXRlbS5hcHBlbmRDaGlsZChpbnB1dCk7XG4gICAgICBpdGVtLmFwcGVuZENoaWxkKGJ1dHRvbik7XG4gICAgfVxuXG4gICAgTW9kaWZpZXJVdGlsLmluaXRNb2RpZmllcih0aGlzLCBzY2hlbWUpO1xuICB9XG5cbiAgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHtcbiAgICAgIGlmICh0aGlzLmhhc0F0dHJpYnV0ZSgndGFiYmFyLWlkJykpIHtcbiAgICAgICAgY29uc3QgcGFnZSA9IHV0aWwuZmluZFBhcmVudCh0aGlzLCAnb25zLXBhZ2UnKTtcbiAgICAgICAgdGhpcy5fdGFiYmFyID0gcGFnZSAmJiBwYWdlLnF1ZXJ5U2VsZWN0b3IoJyMnICsgdGhpcy5nZXRBdHRyaWJ1dGUoJ3RhYmJhci1pZCcpKTtcbiAgICAgICAgaWYgKCF0aGlzLl90YWJiYXIgfHwgdGhpcy5fdGFiYmFyLnRhZ05hbWUgIT09ICdPTlMtVEFCQkFSJykge1xuICAgICAgICAgIHV0aWwudGhyb3coYE5vIHRhYmJhciB3aXRoIGlkICR7dGhpcy5nZXRBdHRyaWJ1dGUoJ3RhYmJhci1pZCcpfSB3YXMgZm91bmQuYCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl90YWJiYXIuc2V0QXR0cmlidXRlKCdoaWRlLXRhYnMnLCAnJyk7XG4gICAgICAgIHNldEltbWVkaWF0ZSgoKSA9PiB0aGlzLl9zZXRDaGVja2VkKHRoaXMuX3RhYmJhci5nZXRBY3RpdmVUYWJJbmRleCgpKSk7XG5cbiAgICAgICAgdGhpcy5fdGFiYmFyLmFkZEV2ZW50TGlzdGVuZXIoJ3ByZWNoYW5nZScsIHRoaXMuX29uVGFiYmFyUHJlQ2hhbmdlKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgdGhpcy5fb25DaGFuZ2UpO1xuICB9XG5cbiAgZGlzY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHtcbiAgICAgIGlmICh0aGlzLl90YWJiYXIpIHtcbiAgICAgICAgdGhpcy5fdGFiYmFyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3ByZWNoYW5nZScsIHRoaXMuX29uVGFiYmFyUHJlQ2hhbmdlKTtcbiAgICAgICAgdGhpcy5fdGFiYmFyID0gbnVsbDtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIHRoaXMuX29uQ2hhbmdlKTtcbiAgfVxuXG4gIF9zZXRDaGVja2VkKGluZGV4KSB7XG4gICAgdGhpcy5jaGlsZHJlbltpbmRleF0uZmlyc3RFbGVtZW50Q2hpbGQuY2hlY2tlZCA9IHRydWU7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBzZXRBY3RpdmVCdXR0b25cbiAgICogQHNpZ25hdHVyZSBzZXRBY3RpdmVCdXR0b24oaW5kZXgsIFtvcHRpb25zXSlcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4XG4gICAqICAgW2VuXUJ1dHRvbiBpbmRleC5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqICAgW2VuXVBhcmFtZXRlciBvYmplY3QsIHdvcmtzIG9ubHkgaWYgdGhlcmUgaXMgYSBjb25uZWN0ZWQgdGFiYmFyLiBTdXBwb3J0cyB0aGUgc2FtZSBvcHRpb25zIGFzIGBvbnMtdGFiYmFyYCdzIGBzZXRBY3RpdmVUYWJgIG1ldGhvZC5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dTWFrZSBidXR0b24gd2l0aCB0aGUgc3BlY2lmaWVkIGluZGV4IGFjdGl2ZS4gSWYgdGhlcmUgaXMgYSBjb25uZWN0ZWQgdGFiYmFyIGl0IHNob3dzIHRoZSBjb3JyZXNwb25kaW5nIHRhYiBwYWdlLiBJbiB0aGlzIGNhc2UgYW5pbWF0aW9ucyBhbmQgdGhlaXIgb3B0aW9ucyBjYW4gYmUgc3BlY2lmaWVkIGJ5IHRoZSBzZWNvbmQgcGFyYW1ldGVyLlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqICAgW2VuXVJlc29sdmVzIHRvIHRoZSBzZWxlY3RlZCBpbmRleCBvciB0byB0aGUgbmV3IHBhZ2UgZWxlbWVudCBpZiB0aGVyZSBpcyBhIGNvbm5lY3RlZCB0YWJiYXIuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG4gIHNldEFjdGl2ZUJ1dHRvbihpbmRleCwgb3B0aW9ucykge1xuICAgIGlmICh0aGlzLl90YWJiYXIpIHtcbiAgICAgIHJldHVybiB0aGlzLl90YWJiYXIuc2V0QWN0aXZlVGFiKGluZGV4LCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICB0aGlzLl9zZXRDaGVja2VkKGluZGV4KTtcbiAgICB0aGlzLl9wb3N0Q2hhbmdlKGluZGV4KTtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGluZGV4KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIGdldEFjdGl2ZUJ1dHRvbkluZGV4XG4gICAqIEBzaWduYXR1cmUgZ2V0QWN0aXZlQnV0dG9uSW5kZXgoKVxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAqICAgW2VuXVRoZSBpbmRleCBvZiB0aGUgY3VycmVudGx5IGFjdGl2ZSBidXR0b24uWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVJldHVybnMgYnV0dG9uIGluZGV4IG9mIGN1cnJlbnQgYWN0aXZlIGJ1dHRvbi4gSWYgYWN0aXZlIGJ1dHRvbiBpcyBub3QgZm91bmQsIHJldHVybnMgLTEuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG4gIGdldEFjdGl2ZUJ1dHRvbkluZGV4KCkge1xuICAgIGZvciAobGV0IGkgPSB0aGlzLmNoaWxkcmVuLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7IC8vIEFycmF5LmZpbmRJbmRleFxuICAgICAgaWYgKHRoaXMuY2hpbGRyZW5baV0uZmlyc3RFbGVtZW50Q2hpbGQuY2hlY2tlZCkge1xuICAgICAgICByZXR1cm4gaTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIC0xO1xuICB9XG5cbiAgX29uQ2hhbmdlKGV2ZW50KSB7XG4gICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgdGhpcy5fdGFiYmFyXG4gICAgICA/IHRoaXMuX3RhYmJhci5zZXRBY3RpdmVUYWIodGhpcy5nZXRBY3RpdmVCdXR0b25JbmRleCgpLCB7IHJlamVjdDogZmFsc2UgfSlcbiAgICAgIDogdGhpcy5fcG9zdENoYW5nZSh0aGlzLmdldEFjdGl2ZUJ1dHRvbkluZGV4KCkpO1xuICB9XG5cbiAgX29uVGFiYmFyUHJlQ2hhbmdlKGV2ZW50KSB7XG4gICAgc2V0SW1tZWRpYXRlKCgpID0+IHtcbiAgICAgIGlmICghZXZlbnQuZGV0YWlsLmNhbmNlbGVkKSB7XG4gICAgICAgIHRoaXMuX3NldENoZWNrZWQoZXZlbnQuaW5kZXgpO1xuICAgICAgICB0aGlzLl9wb3N0Q2hhbmdlKGV2ZW50LmluZGV4KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIF9wb3N0Q2hhbmdlKGluZGV4KSB7XG4gICAgdXRpbC50cmlnZ2VyRWxlbWVudEV2ZW50KHRoaXMsICdwb3N0Y2hhbmdlJywge1xuICAgICAgaW5kZXgsXG4gICAgICBhY3RpdmVJbmRleDogaW5kZXgsXG4gICAgICBsYXN0QWN0aXZlSW5kZXg6IHRoaXMuX2xhc3RBY3RpdmVJbmRleCxcbiAgICAgIHNlZ21lbnRJdGVtOiB0aGlzLmNoaWxkcmVuW2luZGV4XVxuICAgIH0pO1xuICAgIHRoaXMuX2xhc3RBY3RpdmVJbmRleCA9IGluZGV4O1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBkaXNhYmxlZFxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVdoZXRoZXIgdGhlIHNlZ21lbnQgaXMgZGlzYWJsZWQgb3Igbm90LlsvZW5dXG4gICAqICAgW2phXeeEoeWKueWMluOBleOCjOOBpuOBhOOCi+WgtOWQiOOBq2B0cnVlYOOAglsvamFdXG4gICAqL1xuICBzZXQgZGlzYWJsZWQodmFsdWUpIHtcbiAgICByZXR1cm4gdXRpbC50b2dnbGVBdHRyaWJ1dGUodGhpcywgJ2Rpc2FibGVkJywgdmFsdWUpO1xuICB9XG5cbiAgZ2V0IGRpc2FibGVkKCkge1xuICAgIHJldHVybiB0aGlzLmhhc0F0dHJpYnV0ZSgnZGlzYWJsZWQnKTtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgb2JzZXJ2ZWRBdHRyaWJ1dGVzKCkge1xuICAgIHJldHVybiBbJ2NsYXNzJywgJ21vZGlmaWVyJ107XG4gIH1cblxuICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgbGFzdCwgY3VycmVudCkge1xuICAgIHN3aXRjaCAobmFtZSkge1xuICAgICAgY2FzZSAnY2xhc3MnOlxuICAgICAgICB1dGlsLnJlc3RvcmVDbGFzcyh0aGlzLCBkZWZhdWx0Q2xhc3NOYW1lLCBzY2hlbWUpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ21vZGlmaWVyJzpcbiAgICAgICAgTW9kaWZpZXJVdGlsLm9uTW9kaWZpZXJDaGFuZ2VkKGxhc3QsIGN1cnJlbnQsIHRoaXMsIHNjaGVtZSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHN0YXRpYyBnZXQgZXZlbnRzKCkge1xuICAgIHJldHVybiBbJ3Bvc3RjaGFuZ2UnXTtcbiAgfVxufVxuXG5vbnNFbGVtZW50cy5TZWdtZW50ID0gU2VnbWVudEVsZW1lbnQ7XG5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ29ucy1zZWdtZW50JywgU2VnbWVudEVsZW1lbnQpO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IG9uc0VsZW1lbnRzIGZyb20gJy4uL29ucy9lbGVtZW50cyc7XG5pbXBvcnQgdXRpbCBmcm9tICcuLi9vbnMvdXRpbCc7XG5pbXBvcnQgYXV0b1N0eWxlIGZyb20gJy4uL29ucy9hdXRvc3R5bGUnO1xuaW1wb3J0IE1vZGlmaWVyVXRpbCBmcm9tICcuLi9vbnMvaW50ZXJuYWwvbW9kaWZpZXItdXRpbCc7XG5pbXBvcnQgQmFzZUVsZW1lbnQgZnJvbSAnLi9iYXNlL2Jhc2UtZWxlbWVudCc7XG5pbXBvcnQgY29udGVudFJlYWR5IGZyb20gJy4uL29ucy9jb250ZW50LXJlYWR5JztcblxuY29uc3Qgc2NoZW1lID0ge1xuICAnJzogJ3NlbGVjdC0qIHNlbGVjdC0tKicsXG4gICcuc2VsZWN0LWlucHV0JzogJ3NlbGVjdC1pbnB1dC0tKidcbn07XG5cbmNvbnN0IGRlZmF1bHRDbGFzc05hbWUgPSAnc2VsZWN0JztcblxuY29uc3QgSU5QVVRfQVRUUklCVVRFUyA9IFtcbiAgJ2F1dG9mb2N1cycsXG4gICdkaXNhYmxlZCcsXG4gICdmb3JtJyxcbiAgJ211bHRpcGxlJyxcbiAgJ25hbWUnLFxuICAncmVxdWlyZWQnLFxuICAnc2l6ZSdcbl07XG5cbi8qKlxuICogQGVsZW1lbnQgb25zLXNlbGVjdFxuICogQGNhdGVnb3J5IGZvcm1cbiAqIEBtb2RpZmllciBtYXRlcmlhbFxuICogIFtlbl1EaXNwbGF5cyBhIE1hdGVyaWFsIERlc2lnbiBzZWxlY3QgaW5wdXQuWy9lbl1cbiAqICBbamFdWy9qYV1cbiAqIEBtb2RpZmllciB1bmRlcmJhclxuICogIFtlbl1EaXNwbGF5cyBhIGhvcml6b250YWwgbGluZSB1bmRlcm5lYXRoIGEgc2VsZWN0IGlucHV0LlsvZW5dXG4gKiAgW2phXVsvamFdXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXVxuICogICAgIFNlbGVjdCBjb21wb25lbnQuIElmIHlvdSB3YW50IHRvIHBsYWNlIGEgc2VsZWN0IHdpdGggYW4gSUQgb2YgYG15LWlkYCBvbiBhIHBhZ2UsIHVzZSBgPG9ucy1zZWxlY3Qgc2VsZWN0LWlkPVwibXktaWRcIj5gLlxuICpcbiAqICAgICBUaGUgY29tcG9uZW50IHdpbGwgYXV0b21hdGljYWxseSBkaXNwbGF5IGFzIGEgTWF0ZXJpYWwgRGVzaWduIHNlbGVjdCBvbiBBbmRyb2lkLlxuICpcbiAqICAgICBNb3N0IGF0dHJpYnV0ZXMgdGhhdCBjYW4gYmUgdXNlZCBmb3IgYSBub3JtYWwgYDxzZWxlY3Q+YCBlbGVtZW50IGNhbiBhbHNvIGJlIHVzZWQgb24gdGhlIGA8b25zLXNlbGVjdD5gIGVsZW1lbnQuXG4gKiAgIFsvZW5dXG4gKiAgIFtqYV3jgrvjg6zjgq/jg4jjg5zjg4Pjgq/jgrnjgpLooajnpLrjgZnjgovjgrPjg7Pjg53jg7zjg43jg7Pjg4jjgafjgZnjgIJgc2VsZWN0YCDopoHntKDjgavkvb/nlKjjgafjgY3jgovlsZ7mgKfjga7lpJrjgY/jgYwgYG9ucy1zZWxlY3RgIOimgee0oOOBp+OCguWIqeeUqOOBp+OBjeOBvuOBmeOAglsvamFdXG4gKiBAY29kZXBlbiBoTGF5eFxuICogQHR1dG9yaWFsIHZhbmlsbGEvUmVmZXJlbmNlL3NlbGVjdFxuICogQGd1aWRlIHRoZW1pbmcuaHRtbCNtb2RpZmllcnMgW2VuXU1vcmUgZGV0YWlscyBhYm91dCB0aGUgYG1vZGlmaWVyYCBhdHRyaWJ1dGVbL2VuXVtqYV1tb2RpZmllcuWxnuaAp+OBruS9v+OBhOaWuVsvamFdXG4gKiBAZ3VpZGUgdGhlbWluZy5odG1sI2Nyb3NzLXBsYXRmb3JtLXN0eWxpbmctYXV0b3N0eWxpbmcgW2VuXUluZm9ybWF0aW9uIGFib3V0IGNyb3NzIHBsYXRmb3JtIHN0eWxpbmdbL2VuXVtqYV1JbmZvcm1hdGlvbiBhYm91dCBjcm9zcyBwbGF0Zm9ybSBzdHlsaW5nWy9qYV1cbiAqIEBleGFtcGxlXG4gKiA8b25zLXNlbGVjdD5cbiAqICAgPG9wdGlvbiB2YWx1ZT1cIjFcIj4xPC9vcHRpb24+XG4gKiAgIDxvcHRpb24gdmFsdWU9XCIyXCI+Mm5kPC9vcHRpb24+XG4gKiAgIDxvcHRpb24gdmFsdWU9XCIzXCI+M3JkIG9wdGlvbjwvb3B0aW9uPlxuICogPC9vbnMtc2VsZWN0PlxuICovXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNlbGVjdEVsZW1lbnQgZXh0ZW5kcyBCYXNlRWxlbWVudCB7XG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgYXV0b2ZvY3VzXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFtlbl1FbGVtZW50IGF1dG9tYXRpY2FsbHkgZ2FpbnMgZm9jdXMgb24gcGFnZSBsb2FkLlsvZW5dXG4gICAqICBbamFd44Oa44O844K444Ot44O844OJ5pmC44Gr44GT44Gu44K744Os44Kv44OI44Oc44OD44Kv44K544Gr44OV44Kp44O844Kr44K544GM56e744KL44KI44GG44Gr44GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgZGlzYWJsZWRcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1TcGVjaWZ5IGlmIHNlbGVjdCBpbnB1dCBzaG91bGQgYmUgZGlzYWJsZWQuWy9lbl1cbiAgICogICBbamFd44GT44Gu44K744Os44Kv44OI44Oc44OD44Kv44K544KS54Sh5Yq55YyW44GZ44KL5aC05ZCI44Gr5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgZm9ybVxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dQXNzb2NpYXRlIGEgc2VsZWN0IGVsZW1lbnQgdG8gYW4gZXhpc3RpbmcgZm9ybSBvbiB0aGUgcGFnZSwgZXZlbiBpZiBub3QgbmVzdGVkLlsvZW5dXG4gICAqICAgW2phXeOBk+OBruOCu+ODrOOCr+ODiOODnOODg+OCr+OCueOCkuOAgeaMh+WumuOBl+OBnyBgZm9ybWAg6KaB57Sg44Gr57SQ5LuY44GR44G+44GZ44CC44K744Os44Kv44OI44Oc44OD44Kv44K544KSIGBmb3JtYCDopoHntKDjga7lpJblgbTjgavphY3nva7jgZnjgovpmpvjgavkvb/nlKjjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBtdWx0aXBsZVxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dSWYgdGhpcyBhdHRyaWJ1dGUgaXMgZGVmaW5lZCwgbXVsdGlwbGUgb3B0aW9ucyBjYW4gYmUgc2VsZWN0ZWQgYXQgb25jZS5bL2VuXVxuICAgKiAgW2phXemBuOaKnuiCouOBruikh+aVsOmBuOaKnuOCkuacieWKueOBq+OBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIG5hbWVcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXU5hbWUgdGhlIHNlbGVjdCBlbGVtZW50LCB1c2VmdWwgZm9yIGluc3RhbmNlIGlmIGl0IGlzIHBhcnQgb2YgYSBmb3JtLlsvZW5dXG4gICAqICAgW2phXeOBk+OBruOCu+ODrOOCr+ODiOODnOODg+OCr+OCueOBruWQjeWJjeOCkuaMh+WumuOBl+OBvuOBmeOAgumAmuW4uCBgZm9ybWAg6KaB57Sg44Go5YWx44Gr5L2/55So44GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgcmVxdWlyZWRcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1NYWtlIHRoZSBzZWxlY3QgaW5wdXQgcmVxdWlyZWQgZm9yIHN1Ym1pdHRpbmcgdGhlIGZvcm0gaXQgaXMgcGFydCBvZi5bL2VuXVxuICAgKiAgIFtqYV3jgZPjga7jgrvjg6zjgq/jg4jjg5zjg4Pjgq/jgrnjgpLlhaXlipvlv4XpoIjjgavjgZnjgovloLTlkIjjgavmjIflrprjgZfjgb7jgZnjgILpgJrluLggYGZvcm1gIOimgee0oOOBqOWFseOBq+S9v+eUqOOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIHNlbGVjdC1pZFxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dSUQgZ2l2ZW4gdG8gdGhlIGlubmVyIHNlbGVjdCwgdXNlZnVsIGZvciBkeW5hbWljIG1hbmlwdWxhdGlvbi5bL2VuXVxuICAgKiAgIFtqYV3jgZPjga7jgrvjg6zjgq/jg4jjg5zjg4Pjgq/jgrnjgYzlhoXpg6jjgavmjIHjgaQgc2VsZWN0IOimgee0oOOBq+S4juOBiOOCiyBJRCDjgpLmjIflrprjgZfjgb7jgZnjgILjgrvjg6zjgq/jg4jjg5zjg4Pjgq/jgrnjga7lhoXlrrnjgpLli5XnmoTjgavlpInmm7TjgZnjgovlv4XopoHjgYzjgYLjgovloLTlkIjjgavkvb/nlKjjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBzaXplXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqIEBkZWZhdWx0IDFcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUhvdyBtYW55IG9wdGlvbnMgYXJlIGRpc3BsYXllZDsgaWYgdGhlcmUgYXJlIG1vcmUgdGhhbiB0aGUgc2l6ZSB0aGVuIGEgc2Nyb2xsIGFwcGVhcnMgdG8gbmF2aWdhdGUgdGhlbS5bL2VuXVxuICAgKiAgIFtqYV3kuIDluqbjgavooajnpLrjgZnjgovpgbjmip7ogqLjga7lgIvmlbDjgpLmjIflrprjgZfjgb7jgZnjgILpgbjmip7ogqLjgYzjgZPjga7lsZ7mgKfjgafmjIflrprjgZfjgZ/lgIvmlbDjgojjgorjgoLlpJrjgYTloLTlkIjjgIHjgrnjgq/jg63jg7zjg6vjgYzmnInlirnjgavjgarjgorjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHRoaXMuX2NvbXBpbGUoKSk7XG5cbiAgICB0aGlzLl9kZXJpdmVHZXR0ZXJzKCk7XG4gIH1cblxuICBzdGF0aWMgZ2V0IG9ic2VydmVkQXR0cmlidXRlcygpIHtcbiAgICByZXR1cm4gWydtb2RpZmllcicsICdjbGFzcycsIC4uLklOUFVUX0FUVFJJQlVURVNdO1xuICB9XG5cbiAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIGxhc3QsIGN1cnJlbnQpIHtcbiAgICBzd2l0Y2ggKG5hbWUpIHtcbiAgICAgIGNhc2UgJ2NsYXNzJzpcbiAgICAgICAgdXRpbC5yZXN0b3JlQ2xhc3ModGhpcywgZGVmYXVsdENsYXNzTmFtZSwgc2NoZW1lKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdtb2RpZmllcic6XG4gICAgICAgIE1vZGlmaWVyVXRpbC5vbk1vZGlmaWVyQ2hhbmdlZChsYXN0LCBjdXJyZW50LCB0aGlzLCBzY2hlbWUpO1xuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICBpZiAoSU5QVVRfQVRUUklCVVRFUy5pbmRleE9mKG5hbWUpID49IDApIHtcbiAgICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB0aGlzLl91cGRhdGVCb3VuZEF0dHJpYnV0ZXMoKSk7XG4gICAgfVxuICB9XG5cbiAgZ2V0IF9zZWxlY3QoKSB7XG4gICAgcmV0dXJuIHRoaXMucXVlcnlTZWxlY3Rvcignc2VsZWN0Jyk7XG4gIH1cblxuICBfdXBkYXRlQm91bmRBdHRyaWJ1dGVzKCkge1xuICAgIElOUFVUX0FUVFJJQlVURVMuZm9yRWFjaCgoYXR0cikgPT4ge1xuICAgICAgaWYgKHRoaXMuaGFzQXR0cmlidXRlKGF0dHIpKSB7XG4gICAgICAgIHRoaXMuX3NlbGVjdC5zZXRBdHRyaWJ1dGUoYXR0ciwgdGhpcy5nZXRBdHRyaWJ1dGUoYXR0cikpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHRoaXMuX3NlbGVjdC5yZW1vdmVBdHRyaWJ1dGUoYXR0cik7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IGxlbmd0aFxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dTnVtYmVyIG9mIG9wdGlvbnMgaW4gdGhlIHNlbGVjdCBib3guWy9lbl1cbiAgICogICBbamFd44GT44Gu44K744Os44Kv44OI44Oc44OD44Kv44K544Gr5ZCr44G+44KM44KL6YG45oqe6IKi44Gu5YCL5pWw44KS6L+U44GX44G+44GZ44CCIGBzZWxlY3RgIOimgee0oFsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgb3B0aW9uc1xuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dU2V2ZXJhbCBvcHRpb25zIGZvciBoYW5kbGluZyB0aGUgc2VsZWN0IERPTSBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44GT44Gu44K744Os44Kv44OI44Oc44OD44Kv44K544Gr5ZCr44G+44KM44KLIGBvcHRpb25gIOimgee0oOOBrumFjeWIl+OCkui/lOOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgc2VsZWN0ZWRJbmRleFxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dSW5kZXggb2YgdGhlIGN1cnJlbnRseSBzZWxlY3RlZCBvcHRpb24uWy9lbl1cbiAgICogICBbamFd54++5Zyo6YG45oqe44GV44KM44Gm44GE44KL6YG45oqe6IKi44Gu44Kk44Oz44OH44OD44Kv44K544KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSB2YWx1ZVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dVmFsdWUgb2YgdGhlIGN1cnJlbnRseSBzZWxlY3RlZCBvcHRpb24uWy9lbl1cbiAgICogICBbamFd54++5Zyo6YG45oqe44GV44KM44Gm44GE44KL6YG45oqe6IKi44Gu5YCk44KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAgICovXG4gIF9jb21waWxlKCkge1xuICAgIGF1dG9TdHlsZS5wcmVwYXJlKHRoaXMpO1xuXG4gICAgdGhpcy5jbGFzc0xpc3QuYWRkKGRlZmF1bHRDbGFzc05hbWUpO1xuICAgIGNvbnN0IHNlbCA9IHRoaXMuX3NlbGVjdCB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzZWxlY3QnKTtcbiAgICBpZiAoIXNlbC5pZCAmJiB0aGlzLmhhc0F0dHJpYnV0ZSgnc2VsZWN0LWlkJykpIHtcbiAgICAgIHNlbC5pZCA9IHRoaXMuZ2V0QXR0cmlidXRlKCdzZWxlY3QtaWQnKTtcbiAgICB9XG4gICAgc2VsLmNsYXNzTGlzdC5hZGQoJ3NlbGVjdC1pbnB1dCcpO1xuICAgIGlmICghdGhpcy5fc2VsZWN0KSB7XG4gICAgICB1dGlsLmFycmF5RnJvbSh0aGlzLmNoaWxkTm9kZXMpLmZvckVhY2goZWxlbWVudCA9PiBzZWwuYXBwZW5kQ2hpbGQoZWxlbWVudCkpO1xuICAgICAgdGhpcy5hcHBlbmRDaGlsZChzZWwpO1xuICAgIH1cblxuICAgIE1vZGlmaWVyVXRpbC5pbml0TW9kaWZpZXIodGhpcywgc2NoZW1lKTtcbiAgfVxuXG4gIF9kZXJpdmVHZXR0ZXJzKCkge1xuICAgIFsnZGlzYWJsZWQnLCAnbGVuZ3RoJywgJ211bHRpcGxlJywgJ25hbWUnLCAnb3B0aW9ucycsICdzZWxlY3RlZEluZGV4JywgJ3NpemUnLCAndmFsdWUnLCAnZm9ybScsICd0eXBlJ11cbiAgICAgIC5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBrZXksIHtcbiAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICBnZXQ6ICgpID0+IHRoaXMuX3NlbGVjdFtrZXldLFxuICAgICAgICAgIHNldDogWydmb3JtJywgJ3R5cGUnXS5pbmRleE9mKGtleSkgPT09IC0xXG4gICAgICAgICAgICA/IHZhbHVlID0+IGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB0aGlzLl9zZWxlY3Rba2V5XSA9IHZhbHVlKVxuICAgICAgICAgICAgOiB1bmRlZmluZWRcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgfVxuXG4gIGFkZChvcHRpb24sIGluZGV4ID0gbnVsbCkge1xuICAgIHRoaXMuX3NlbGVjdC5hZGQob3B0aW9uLCBpbmRleCk7XG4gIH1cblxuICByZW1vdmUoaW5kZXgpIHtcbiAgICB0aGlzLl9zZWxlY3QucmVtb3ZlKGluZGV4KTtcbiAgfVxufVxuXG5vbnNFbGVtZW50cy5TZWxlY3QgPSBTZWxlY3RFbGVtZW50O1xuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdvbnMtc2VsZWN0JywgU2VsZWN0RWxlbWVudCk7XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuaW1wb3J0IG9uc0VsZW1lbnRzIGZyb20gJy4uL29ucy9lbGVtZW50cyc7XG5pbXBvcnQgdXRpbCBmcm9tICcuLi9vbnMvdXRpbCc7XG5pbXBvcnQgYXV0b1N0eWxlIGZyb20gJy4uL29ucy9hdXRvc3R5bGUnO1xuaW1wb3J0IE1vZGlmaWVyVXRpbCBmcm9tICcuLi9vbnMvaW50ZXJuYWwvbW9kaWZpZXItdXRpbCc7XG5pbXBvcnQgQmFzZUVsZW1lbnQgZnJvbSAnLi9iYXNlL2Jhc2UtZWxlbWVudCc7XG5cbmNvbnN0IGRlZmF1bHRDbGFzc05hbWUgPSAnZmFiIGZhYi0tbWluaSBzcGVlZC1kaWFsX19pdGVtJztcblxuY29uc3Qgc2NoZW1lID0ge1xuICAnJzogJ2ZhYi0tKiBzcGVlZC1kaWFsX19pdGVtLS0qJ1xufTtcblxuLyoqXG4gKiBAZWxlbWVudCBvbnMtc3BlZWQtZGlhbC1pdGVtXG4gKiBAY2F0ZWdvcnkgY29udHJvbFxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1cbiAqICAgICBUaGlzIGNvbXBvbmVudCBkaXNwbGF5cyB0aGUgY2hpbGQgZWxlbWVudHMgb2YgdGhlIE1hdGVyaWFsIERlc2lnbiBTcGVlZCBkaWFsIGNvbXBvbmVudC5cbiAqICAgWy9lbl1cbiAqICAgW2phXVxuICogICAgIE1hdGVyaWFsIERlc2lnbuOBrlNwZWVkIGRpYWzjga7lrZDopoHntKDjgpLooajnj77jgZnjgovopoHntKDjgafjgZnjgIJcbiAqICAgWy9qYV1cbiAqIEBjb2RlcGVuIGRZUVlMZ1xuICogQHR1dG9yaWFsIHZhbmlsbGEvUmVmZXJlbmNlL3NwZWVkLWRpYWxcbiAqIEBzZWVhbHNvIG9ucy1zcGVlZC1kaWFsXG4gKiAgIFtlbl1UaGUgYDxvbnMtc3BlZWQtZGlhbD5gIGNvbXBvbmVudC5bL2VuXVxuICogICBbamFdb25zLXNwZWVkLWRpYWzjgrPjg7Pjg53jg7zjg43jg7Pjg4hbL2phXVxuICogQHNlZWFsc28gb25zLWZhYlxuICogICBbZW5db25zLWZhYiBjb21wb25lbnRbL2VuXVxuICogICBbamFdb25zLWZhYuOCs+ODs+ODneODvOODjeODs+ODiFsvamFdXG4gKiBAZXhhbXBsZVxuICogPG9ucy1zcGVlZC1kaWFsIHBvc2l0aW9uPVwibGVmdCBib3R0b21cIj5cbiAqICAgPG9ucy1mYWI+XG4gKiAgICAgPG9ucy1pY29uIGljb249XCJmYS10d2l0dGVyXCI+PC9vbnMtaWNvbj5cbiAqICAgPC9vbnMtZmFiPlxuICogICA8b25zLXNwZWVkLWRpYWwtaXRlbT5BPC9vbnMtc3BlZWQtZGlhbC1pdGVtPlxuICogICA8b25zLXNwZWVkLWRpYWwtaXRlbT5CPC9vbnMtc3BlZWQtZGlhbC1pdGVtPlxuICogICA8b25zLXNwZWVkLWRpYWwtaXRlbT5DPC9vbnMtc3BlZWQtZGlhbC1pdGVtPlxuICogPC9vbnMtc3BlZWQtZGlhbD5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU3BlZWREaWFsSXRlbUVsZW1lbnQgZXh0ZW5kcyBCYXNlRWxlbWVudCB7XG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgbW9kaWZpZXJcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVRoZSBhcHBlYXJhbmNlIG9mIHRoZSBjb21wb25lbnQuWy9lbl1cbiAgICogICBbamFd44GT44Gu44Kz44Oz44Od44O844ON44Oz44OI44Gu6KGo54++44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgcmlwcGxlXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXUlmIHRoaXMgYXR0cmlidXRlIGlzIGRlZmluZWQsIHRoZSBidXR0b24gd2lsbCBoYXZlIGEgcmlwcGxlIGVmZmVjdCB3aGVuIHRhcHBlZC5bL2VuXVxuICAgKiAgW2phXVsvamFdXG4gICAqL1xuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG5cbiAgICB0aGlzLl9jb21waWxlKCk7XG4gICAgdGhpcy5fYm91bmRPbkNsaWNrID0gdGhpcy5fb25DbGljay5iaW5kKHRoaXMpO1xuICB9XG5cbiAgc3RhdGljIGdldCBvYnNlcnZlZEF0dHJpYnV0ZXMoKSB7XG4gICAgcmV0dXJuIFsnbW9kaWZpZXInLCAncmlwcGxlJywgJ2NsYXNzJ107XG4gIH1cblxuICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgbGFzdCwgY3VycmVudCkge1xuICAgIHN3aXRjaCAobmFtZSkge1xuICAgICAgY2FzZSAnY2xhc3MnOlxuICAgICAgICB1dGlsLnJlc3RvcmVDbGFzcyh0aGlzLCBkZWZhdWx0Q2xhc3NOYW1lLCBzY2hlbWUpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ21vZGlmaWVyJzpcbiAgICAgICAgTW9kaWZpZXJVdGlsLm9uTW9kaWZpZXJDaGFuZ2VkKGxhc3QsIGN1cnJlbnQsIHRoaXMsIHNjaGVtZSk7XG4gICAgICAgIHV0aWwuYWRkTW9kaWZpZXIodGhpcywgJ21pbmknKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdyaXBwbGUnOlxuICAgICAgICB0aGlzLl91cGRhdGVSaXBwbGUoKTtcbiAgICB9XG4gIH1cblxuICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5fYm91bmRPbkNsaWNrLCBmYWxzZSk7XG4gIH1cblxuICBkaXNjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5fYm91bmRPbkNsaWNrLCBmYWxzZSk7XG4gIH1cblxuICBfdXBkYXRlUmlwcGxlKCkge1xuICAgIHV0aWwudXBkYXRlUmlwcGxlKHRoaXMpO1xuICB9XG5cbiAgX29uQ2xpY2soZSkge1xuICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gIH1cblxuICBfY29tcGlsZSgpIHtcbiAgICBhdXRvU3R5bGUucHJlcGFyZSh0aGlzKTtcblxuICAgIGRlZmF1bHRDbGFzc05hbWUuc3BsaXQoL1xccysvKS5mb3JFYWNoKHRva2VuID0+IHRoaXMuY2xhc3NMaXN0LmFkZCh0b2tlbikpO1xuXG4gICAgdXRpbC5hZGRNb2RpZmllcih0aGlzLCAnbWluaScpO1xuICAgIHRoaXMuX3VwZGF0ZVJpcHBsZSgpO1xuXG4gICAgTW9kaWZpZXJVdGlsLmluaXRNb2RpZmllcih0aGlzLCBzY2hlbWUpO1xuICB9XG59XG5cbm9uc0VsZW1lbnRzLlNwZWVkRGlhbEl0ZW0gPSBTcGVlZERpYWxJdGVtRWxlbWVudDtcbmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnb25zLXNwZWVkLWRpYWwtaXRlbScsIFNwZWVkRGlhbEl0ZW1FbGVtZW50KTtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5pbXBvcnQgb25zRWxlbWVudHMgZnJvbSAnLi4vb25zL2VsZW1lbnRzJztcbmltcG9ydCB1dGlsIGZyb20gJy4uL29ucy91dGlsJztcbmltcG9ydCBhdXRvU3R5bGUgZnJvbSAnLi4vb25zL2F1dG9zdHlsZSc7XG5pbXBvcnQgTW9kaWZpZXJVdGlsIGZyb20gJy4uL29ucy9pbnRlcm5hbC9tb2RpZmllci11dGlsJztcbmltcG9ydCBCYXNlRWxlbWVudCBmcm9tICcuL2Jhc2UvYmFzZS1lbGVtZW50JztcbmltcG9ydCBjb250ZW50UmVhZHkgZnJvbSAnLi4vb25zL2NvbnRlbnQtcmVhZHknO1xuaW1wb3J0IHN0eWxlciBmcm9tICcuLi9vbnMvc3R5bGVyJztcblxuY29uc3QgZGVmYXVsdENsYXNzTmFtZSA9ICdzcGVlZC1kaWFsJztcbmNvbnN0IHNjaGVtZSA9IHtcbiAgJyc6ICdzcGVlZC1kaWFsLS0qJyxcbn07XG5cbi8qKlxuICogQGVsZW1lbnQgb25zLXNwZWVkLWRpYWxcbiAqIEBjYXRlZ29yeSBjb250cm9sXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXVxuICogICAgIEVsZW1lbnQgdGhhdCBkaXNwbGF5cyBhIE1hdGVyaWFsIERlc2lnbiBTcGVlZCBEaWFsb2cgY29tcG9uZW50LiBJdCBpcyB1c2VmdWwgd2hlbiB0aGVyZSBhcmUgbW9yZSB0aGFuIG9uZSBwcmltYXJ5IGFjdGlvbiB0aGF0IGNhbiBiZSBwZXJmb3JtZWQgaW4gYSBwYWdlLlxuICpcbiAqICAgICBUaGUgU3BlZWQgZGlhbCBsb29rcyBsaWtlIGEgYDxvbnMtZmFiPmAgZWxlbWVudCBidXQgd2lsbCBleHBhbmQgYSBtZW51IHdoZW4gdGFwcGVkLlxuICogICBbL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBjb2RlcGVuIGRZUVlMZ1xuICogQHR1dG9yaWFsIHZhbmlsbGEvUmVmZXJlbmNlL3NwZWVkLWRpYWxcbiAqIEBzZWVhbHNvIG9ucy1zcGVlZC1kaWFsLWl0ZW1cbiAqICAgW2VuXVRoZSBgPG9ucy1zcGVlZC1kaWFsLWl0ZW0+YCByZXByZXNlbnRzIGEgbWVudSBpdGVtLlsvZW5dXG4gKiAgIFtqYV1vbnMtc3BlZWQtZGlhbC1pdGVt44Kz44Oz44Od44O844ON44Oz44OIWy9qYV1cbiAqIEBzZWVhbHNvIG9ucy1mYWJcbiAqICAgW2VuXW9ucy1mYWIgY29tcG9uZW50Wy9lbl1cbiAqICAgW2phXW9ucy1mYWLjgrPjg7Pjg53jg7zjg43jg7Pjg4hbL2phXVxuICogQGV4YW1wbGVcbiAqIDxvbnMtc3BlZWQtZGlhbCBwb3NpdGlvbj1cImxlZnQgYm90dG9tXCI+XG4gKiAgIDxvbnMtZmFiPlxuICogICAgIDxvbnMtaWNvbiBpY29uPVwiZmEtdHdpdHRlclwiPjwvb25zLWljb24+XG4gKiAgIDwvb25zLWZhYj5cbiAqICAgPG9ucy1zcGVlZC1kaWFsLWl0ZW0+QTwvb25zLXNwZWVkLWRpYWwtaXRlbT5cbiAqICAgPG9ucy1zcGVlZC1kaWFsLWl0ZW0+Qjwvb25zLXNwZWVkLWRpYWwtaXRlbT5cbiAqICAgPG9ucy1zcGVlZC1kaWFsLWl0ZW0+Qzwvb25zLXNwZWVkLWRpYWwtaXRlbT5cbiAqIDwvb25zLXNwZWVkLWRpYWw+XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNwZWVkRGlhbEVsZW1lbnQgZXh0ZW5kcyBCYXNlRWxlbWVudCB7XG5cbiAgLyoqXG4gICAqIEBldmVudCBvcGVuXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1GaXJlZCB3aGVuIHRoZSBtZW51IGl0ZW1zIGFyZSBzaG93bi5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGV2ZW50IGNsb3NlXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1GaXJlZCB3aGVuIHRoZSBtZW51IGl0ZW1zIGFyZSBoaWRkZW4uWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgbW9kaWZpZXJcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVRoZSBhcHBlYXJhbmNlIG9mIHRoZSBjb21wb25lbnQuWy9lbl1cbiAgICogICBbamFd44GT44Gu44Kz44Oz44Od44O844ON44Oz44OI44Gu6KGo54++44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgcmlwcGxlXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXUlmIHRoaXMgYXR0cmlidXRlIGlzIGRlZmluZWQsIHRoZSBidXR0b24gd2lsbCBoYXZlIGEgcmlwcGxlIGVmZmVjdCB3aGVuIHRhcHBlZC5bL2VuXVxuICAgKiAgW2phXVsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIHBvc2l0aW9uXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1cbiAgICogICAgIFNwZWNpZnkgdGhlIHZlcnRpY2FsIGFuZCBob3Jpem9udGFsIHBvc2l0aW9uIG9mIHRoZSBjb21wb25lbnQuXG4gICAqICAgICBJLmUuIHRvIGRpc3BsYXkgaXQgaW4gdGhlIHRvcCByaWdodCBjb3JuZXIgc3BlY2lmeSBcInJpZ2h0IHRvcFwiLlxuICAgKiAgICAgQ2hvb3NlIGZyb20gXCJyaWdodFwiLCBcImxlZnRcIiwgXCJ0b3BcIiBhbmQgXCJib3R0b21cIi5cbiAgICogICBbL2VuXVxuICAgKiAgIFtqYV1cbiAgICogICAgIOOBk+OBruimgee0oOOCkuihqOekuuOBmeOCi+W3puWPs+OBqOS4iuS4i+OBruS9jee9ruOCkuaMh+WumuOBl+OBvuOBmeOAglxuICAgKiAgICAg5L6L44GI44Gw44CB5Y+z5LiK44Gr6KGo56S644GZ44KL5aC05ZCI44Gr44GvXCJyaWdodCB0b3BcIuOCkuaMh+WumuOBl+OBvuOBmeOAglxuICAgKiAgICAg5bem5Y+z44Go5LiK5LiL44Gu5L2N572u44Gu5oyH5a6a44Gr44Gv44CBcmlnaHTjgahsZWZ044CBdG9w44GoYm90dG9t44GM44Gd44KM44Ge44KM5oyH5a6a44Gn44GN44G+44GZ44CCXG4gICAqICAgWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgZGlyZWN0aW9uXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1TcGVjaWZ5IHRoZSBkaXJlY3Rpb24gdGhlIGl0ZW1zIGFyZSBkaXNwbGF5ZWQuIFBvc3NpYmxlIHZhbHVlcyBhcmUgXCJ1cFwiLCBcImRvd25cIiwgXCJsZWZ0XCIgYW5kIFwicmlnaHRcIi5bL2VuXVxuICAgKiAgIFtqYV1cbiAgICogICAgIOimgee0oOOBjOihqOekuuOBmeOCi+aWueWQkeOCkuaMh+WumuOBl+OBvuOBmeOAgnVwLCBkb3duLCBsZWZ0LCByaWdodOOBjOaMh+WumuOBp+OBjeOBvuOBmeOAglxuICAgKiAgIFsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGRpc2FibGVkXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1TcGVjaWZ5IGlmIGJ1dHRvbiBzaG91bGQgYmUgZGlzYWJsZWQuWy9lbl1cbiAgICogICBbamFd54Sh5Yq55YyW44GZ44KL5aC05ZCI44Gr5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB7XG4gICAgICB0aGlzLl9jb21waWxlKCk7XG4gICAgfSk7XG5cbiAgICB0aGlzLl9pdGVtU2hvd24gPSBmYWxzZTtcbiAgICB0aGlzLl9ib3VuZE9uQ2xpY2sgPSB0aGlzLl9vbkNsaWNrLmJpbmQodGhpcyk7XG4gIH1cblxuICBfY29tcGlsZSgpIHtcbiAgICB0aGlzLmNsYXNzTGlzdC5hZGQoZGVmYXVsdENsYXNzTmFtZSk7XG4gICAgYXV0b1N0eWxlLnByZXBhcmUodGhpcyk7XG4gICAgdGhpcy5fdXBkYXRlUmlwcGxlKCk7XG4gICAgTW9kaWZpZXJVdGlsLmluaXRNb2RpZmllcih0aGlzLCBzY2hlbWUpO1xuXG4gICAgaWYgKHRoaXMuaGFzQXR0cmlidXRlKCdkaXJlY3Rpb24nKSkge1xuICAgICAgdGhpcy5fdXBkYXRlRGlyZWN0aW9uKHRoaXMuZ2V0QXR0cmlidXRlKCdkaXJlY3Rpb24nKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3VwZGF0ZURpcmVjdGlvbigndXAnKTtcbiAgICB9XG5cbiAgICB0aGlzLl91cGRhdGVQb3NpdGlvbigpO1xuICB9XG5cbiAgc3RhdGljIGdldCBvYnNlcnZlZEF0dHJpYnV0ZXMoKSB7XG4gICAgcmV0dXJuIFsnY2xhc3MnLCAnbW9kaWZpZXInLCAncmlwcGxlJywgJ2RpcmVjdGlvbicsICdwb3NpdGlvbiddO1xuICB9XG5cbiAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIGxhc3QsIGN1cnJlbnQpIHtcbiAgICBzd2l0Y2ggKG5hbWUpIHtcbiAgICAgIGNhc2UgJ2NsYXNzJzpcbiAgICAgICAgdXRpbC5yZXN0b3JlQ2xhc3ModGhpcywgZGVmYXVsdENsYXNzTmFtZSwgc2NoZW1lKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdtb2RpZmllcic6XG4gICAgICAgIE1vZGlmaWVyVXRpbC5vbk1vZGlmaWVyQ2hhbmdlZChsYXN0LCBjdXJyZW50LCB0aGlzLCBzY2hlbWUpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3JpcHBsZSc6XG4gICAgICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB0aGlzLl91cGRhdGVSaXBwbGUoKSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnZGlyZWN0aW9uJzpcbiAgICAgICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHRoaXMuX3VwZGF0ZURpcmVjdGlvbihjdXJyZW50KSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAncG9zaXRpb24nOlxuICAgICAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4gdGhpcy5fdXBkYXRlUG9zaXRpb24oKSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIGNvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLl9ib3VuZE9uQ2xpY2ssIGZhbHNlKTtcbiAgfVxuXG4gIGRpc2Nvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLl9ib3VuZE9uQ2xpY2ssIGZhbHNlKTtcbiAgfVxuXG4gIGdldCBpdGVtcygpIHtcbiAgICByZXR1cm4gdXRpbC5hcnJheUZyb20odGhpcy5xdWVyeVNlbGVjdG9yQWxsKCdvbnMtc3BlZWQtZGlhbC1pdGVtJykpO1xuICB9XG5cbiAgZ2V0IF9mYWIoKSB7XG4gICAgcmV0dXJuIHV0aWwuZmluZENoaWxkKHRoaXMsICdvbnMtZmFiJyk7XG4gIH1cblxuICBfb25DbGljayhlKSB7XG4gICAgaWYgKHRoaXMub25DbGljaykge1xuICAgICAgdGhpcy5vbkNsaWNrLmFwcGx5KHRoaXMpO1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH0gZWxzZSBpZiAoIXRoaXMuZGlzYWJsZWQgJiYgdGhpcy52aXNpYmxlKSB7XG4gICAgICByZXR1cm4gdGhpcy50b2dnbGVJdGVtcygpO1xuICAgIH1cbiAgfVxuXG4gIF9zaG93KCkge1xuICAgIGlmICghdGhpcy5pbmxpbmUpIHtcbiAgICAgIHJldHVybiB0aGlzLnNob3coKTtcbiAgICB9XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICB9XG5cbiAgX2hpZGUoKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgaWYgKCF0aGlzLmlubGluZSkge1xuICAgICAgICBzZXRJbW1lZGlhdGUoKCkgPT4gdGhpcy5oaWRlKCkudGhlbihyZXNvbHZlKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXNvbHZlKCk7XG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIF91cGRhdGVSaXBwbGUoKSB7XG4gICAgaWYgKHRoaXMuX2ZhYikge1xuICAgICAgdGhpcy5oYXNBdHRyaWJ1dGUoJ3JpcHBsZScpID8gdGhpcy5fZmFiLnNldEF0dHJpYnV0ZSgncmlwcGxlJywgJycpIDogdGhpcy5fZmFiLnJlbW92ZUF0dHJpYnV0ZSgncmlwcGxlJyk7XG4gICAgfVxuICB9XG5cbiAgX3VwZGF0ZURpcmVjdGlvbihkaXJlY3Rpb24pIHtcbiAgICBjb25zdCBjaGlsZHJlbiA9IHRoaXMuaXRlbXM7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgc3R5bGVyKGNoaWxkcmVuW2ldLCB7XG4gICAgICAgIHRyYW5zaXRpb25EZWxheTogMjUgKiBpICsgJ21zJyxcbiAgICAgICAgYm90dG9tOiAnYXV0bycsXG4gICAgICAgIHJpZ2h0OiAnYXV0bycsXG4gICAgICAgIHRvcDogJ2F1dG8nLFxuICAgICAgICBsZWZ0OiAnYXV0bydcbiAgICAgIH0pO1xuICAgIH1cbiAgICBzd2l0Y2ggKGRpcmVjdGlvbikge1xuICAgICAgY2FzZSAndXAnOlxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgY2hpbGRyZW5baV0uc3R5bGUuYm90dG9tID0gNzIgKyA1NiAqIGkgKyAncHgnO1xuICAgICAgICAgIGNoaWxkcmVuW2ldLnN0eWxlLnJpZ2h0ID0gJzhweCc7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdkb3duJzpcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNoaWxkcmVuW2ldLnN0eWxlLnRvcCA9IDcyICsgNTYgKiBpICsgJ3B4JztcbiAgICAgICAgICBjaGlsZHJlbltpXS5zdHlsZS5sZWZ0ID0gJzhweCc7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdsZWZ0JzpcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNoaWxkcmVuW2ldLnN0eWxlLnRvcCA9ICc4cHgnO1xuICAgICAgICAgIGNoaWxkcmVuW2ldLnN0eWxlLnJpZ2h0ID0gNzIgKyA1NiAqIGkgKyAncHgnO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAncmlnaHQnOlxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgY2hpbGRyZW5baV0uc3R5bGUudG9wID0gJzhweCc7XG4gICAgICAgICAgY2hpbGRyZW5baV0uc3R5bGUubGVmdCA9IDcyICsgNTYgKiBpICsgJ3B4JztcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHV0aWwudGhyb3coJ0FyZ3VtZW50IG11c3QgYmUgb25lIG9mIHVwLCBkb3duLCBsZWZ0IG9yIHJpZ2h0LicpO1xuICAgIH1cbiAgfVxuXG4gIF91cGRhdGVQb3NpdGlvbigpIHtcbiAgICBjb25zdCBwb3NpdGlvbiA9IHRoaXMuZ2V0QXR0cmlidXRlKCdwb3NpdGlvbicpO1xuICAgIHRoaXMuY2xhc3NMaXN0LnJlbW92ZShcbiAgICAgICdmYWItLXRvcF9fbGVmdCcsXG4gICAgICAnZmFiLS1ib3R0b21fX3JpZ2h0JyxcbiAgICAgICdmYWItLWJvdHRvbV9fbGVmdCcsXG4gICAgICAnZmFiLS10b3BfX3JpZ2h0JyxcbiAgICAgICdmYWItLXRvcF9fY2VudGVyJyxcbiAgICAgICdmYWItLWJvdHRvbV9fY2VudGVyJyk7XG4gICAgc3dpdGNoIChwb3NpdGlvbikge1xuICAgICAgY2FzZSAndG9wIHJpZ2h0JzpcbiAgICAgIGNhc2UgJ3JpZ2h0IHRvcCc6XG4gICAgICAgIHRoaXMuY2xhc3NMaXN0LmFkZCgnZmFiLS10b3BfX3JpZ2h0Jyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndG9wIGxlZnQnOlxuICAgICAgY2FzZSAnbGVmdCB0b3AnOlxuICAgICAgICB0aGlzLmNsYXNzTGlzdC5hZGQoJ2ZhYi0tdG9wX19sZWZ0Jyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnYm90dG9tIHJpZ2h0JzpcbiAgICAgIGNhc2UgJ3JpZ2h0IGJvdHRvbSc6XG4gICAgICAgIHRoaXMuY2xhc3NMaXN0LmFkZCgnZmFiLS1ib3R0b21fX3JpZ2h0Jyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnYm90dG9tIGxlZnQnOlxuICAgICAgY2FzZSAnbGVmdCBib3R0b20nOlxuICAgICAgICB0aGlzLmNsYXNzTGlzdC5hZGQoJ2ZhYi0tYm90dG9tX19sZWZ0Jyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnY2VudGVyIHRvcCc6XG4gICAgICBjYXNlICd0b3AgY2VudGVyJzpcbiAgICAgICAgdGhpcy5jbGFzc0xpc3QuYWRkKCdmYWItLXRvcF9fY2VudGVyJyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnY2VudGVyIGJvdHRvbSc6XG4gICAgICBjYXNlICdib3R0b20gY2VudGVyJzpcbiAgICAgICAgdGhpcy5jbGFzc0xpc3QuYWRkKCdmYWItLWJvdHRvbV9fY2VudGVyJyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgX2dldFRyYW5zbGF0ZSgpIHtcbiAgICBjb25zdCBpc0JvdHRvbSA9ICh0aGlzLmdldEF0dHJpYnV0ZSgncG9zaXRpb24nKSB8fCAnJykuaW5kZXhPZignYm90dG9tJykgPj0gMDtcbiAgICBjb25zdCB0cmFuc2xhdGUgPSBpc0JvdHRvbSA/IGB0cmFuc2xhdGUzZCgwcHgsIC0ke3V0aWwuZ2xvYmFscy5mYWJPZmZzZXQgfHwgMH1weCwgMHB4KSBgIDogJyc7XG4gICAgcmV0dXJuIHRyYW5zbGF0ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIHNob3dcbiAgICogQHNpZ25hdHVyZSBzaG93KClcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVNob3cgdGhlIHNwZWVkIGRpYWwuWy9lbl1cbiAgICogICBbamFdU3BlZWQgZGlhbOOCkuihqOekuuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuICBzaG93KCkge1xuICAgIHRoaXMuX2ZhYi5zaG93KCk7XG4gICAgc3R5bGVyKHRoaXMsIHsgdHJhbnNmb3JtOiB0aGlzLl9nZXRUcmFuc2xhdGUgfSk7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgaGlkZVxuICAgKiBAc2lnbmF0dXJlIGhpZGUoKVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dSGlkZSB0aGUgc3BlZWQgZGlhbC5bL2VuXVxuICAgKiAgIFtqYV1TcGVlZCBkaWFs44KS6Z2e6KGo56S644Gr44GX44G+44GZ44CCWy9qYV1cbiAgICovXG4gIGhpZGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuaGlkZUl0ZW1zKCkudGhlbigoKT0+IHRoaXMuX2ZhYi5oaWRlKCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2Qgc2hvd0l0ZW1zXG4gICAqIEBzaWduYXR1cmUgc2hvd0l0ZW1zKClcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVNob3cgdGhlIHNwZWVkIGRpYWwgaXRlbXMuWy9lbl1cbiAgICogICBbamFdU3BlZWQgZGlhbOOBruWtkOimgee0oOOCkuihqOekuuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuICBzaG93SXRlbXMoKSB7XG4gICAgaWYgKHRoaXMuaGFzQXR0cmlidXRlKCdkaXJlY3Rpb24nKSkge1xuICAgICAgdGhpcy5fdXBkYXRlRGlyZWN0aW9uKHRoaXMuZ2V0QXR0cmlidXRlKCdkaXJlY3Rpb24nKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3VwZGF0ZURpcmVjdGlvbigndXAnKTtcbiAgICB9XG5cbiAgICBsZXQgdG90YWxEZWxheSA9IDA7XG4gICAgaWYgKCF0aGlzLl9pdGVtU2hvd24pIHtcbiAgICAgIGNvbnN0IGNoaWxkcmVuID0gdGhpcy5pdGVtcztcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgZGVsYXkgPSAyNSAqIGk7XG4gICAgICAgIHRvdGFsRGVsYXkgKz0gZGVsYXk7XG4gICAgICAgIHN0eWxlcihjaGlsZHJlbltpXSwge1xuICAgICAgICAgIHRyYW5zZm9ybTogJ3NjYWxlKDEpJyxcbiAgICAgICAgICB0cmFuc2l0aW9uRGVsYXk6IGRlbGF5ICsgJ21zJ1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHRvdGFsRGVsYXkgKz0gNTA7XG5cbiAgICAgIHRoaXMuX2l0ZW1TaG93biA9IHRydWU7XG4gICAgICB1dGlsLnRyaWdnZXJFbGVtZW50RXZlbnQodGhpcywgJ29wZW4nKTtcbiAgICB9XG5cbiAgICBjb25zdCBkZWZlcnJlZCA9IHV0aWwuZGVmZXIoKTtcbiAgICBzZXRUaW1lb3V0KGRlZmVycmVkLnJlc29sdmUsIHRvdGFsRGVsYXkpO1xuICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgaGlkZUl0ZW1zXG4gICAqIEBzaWduYXR1cmUgaGlkZUl0ZW1zKClcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUhpZGUgdGhlIHNwZWVkIGRpYWwgaXRlbXMuWy9lbl1cbiAgICogICBbamFdU3BlZWQgZGlhbOOBruWtkOimgee0oOOCkumdnuihqOekuuOBq+OBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuICBoaWRlSXRlbXMoKSB7XG4gICAgbGV0IHRvdGFsRGVsYXkgPSAwO1xuICAgIGlmICh0aGlzLl9pdGVtU2hvd24pIHtcbiAgICAgIGNvbnN0IGNoaWxkcmVuID0gdGhpcy5pdGVtcztcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgZGVsYXkgPSAyNSAqIChjaGlsZHJlbi5sZW5ndGggLSBpKTtcbiAgICAgICAgdG90YWxEZWxheSArPSBkZWxheTtcbiAgICAgICAgc3R5bGVyKGNoaWxkcmVuW2ldLCB7XG4gICAgICAgICAgdHJhbnNmb3JtOiAnc2NhbGUoMCknLFxuICAgICAgICAgIHRyYW5zaXRpb25EZWxheTogZGVsYXkgKyAnbXMnXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgdG90YWxEZWxheSArPSA1MDtcblxuICAgICAgdGhpcy5faXRlbVNob3duID0gZmFsc2U7XG4gICAgICB1dGlsLnRyaWdnZXJFbGVtZW50RXZlbnQodGhpcywgJ2Nsb3NlJyk7XG4gICAgfVxuXG4gICAgY29uc3QgZGVmZXJyZWQgPSB1dGlsLmRlZmVyKCk7XG4gICAgc2V0VGltZW91dChkZWZlcnJlZC5yZXNvbHZlLCB0b3RhbERlbGF5KTtcbiAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgZGlzYWJsZWRcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1XaGV0aGVyIHRoZSBlbGVtZW50IGlzIGRpc2FibGVkIG9yIG5vdC5bL2VuXVxuICAgKiAgIFtqYV3nhKHlirnljJbjgZXjgozjgabjgYTjgovloLTlkIjjgatgdHJ1ZWDjgIJbL2phXVxuICAgKi9cbiAgc2V0IGRpc2FibGVkKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICB0aGlzLmhpZGVJdGVtcygpO1xuICAgIH1cbiAgICB1dGlsLmFycmF5RnJvbSh0aGlzLmNoaWxkcmVuKS5mb3JFYWNoKGUgPT4ge1xuICAgICAgdXRpbC5tYXRjaChlLCAnLmZhYicpICYmIHV0aWwudG9nZ2xlQXR0cmlidXRlKGUsICdkaXNhYmxlZCcsIHZhbHVlKTtcbiAgICB9KTtcblxuICAgIHJldHVybiB1dGlsLnRvZ2dsZUF0dHJpYnV0ZSh0aGlzLCAnZGlzYWJsZWQnLCB2YWx1ZSk7XG4gIH1cblxuICBnZXQgZGlzYWJsZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaGFzQXR0cmlidXRlKCdkaXNhYmxlZCcpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBpbmxpbmVcbiAgICogQHJlYWRvbmx5XG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dV2hldGhlciB0aGUgZWxlbWVudCBpcyBpbmxpbmUgb3Igbm90LlsvZW5dXG4gICAqICAgW2phXeOCpOODs+ODqeOCpOODs+imgee0oOOBruWgtOWQiOOBq2B0cnVlYOOAglsvamFdXG4gICAqL1xuICBnZXQgaW5saW5lKCkge1xuICAgIHJldHVybiB0aGlzLmhhc0F0dHJpYnV0ZSgnaW5saW5lJyk7XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IHZpc2libGVcbiAgICogQHJlYWRvbmx5XG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dV2hldGhlciB0aGUgZWxlbWVudCBpcyB2aXNpYmxlIG9yIG5vdC5bL2VuXVxuICAgKiAgIFtqYV3opoHntKDjgYzopovjgYjjgovloLTlkIjjgatgdHJ1ZWDjgIJbL2phXVxuICAgKi9cbiAgZ2V0IHZpc2libGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ZhYi52aXNpYmxlICYmIHRoaXMuc3R5bGUuZGlzcGxheSAhPT0gJ25vbmUnO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgaXNPcGVuXG4gICAqIEBzaWduYXR1cmUgaXNPcGVuKClcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVJldHVybnMgd2hldGhlciB0aGUgbWVudSBpcyBvcGVuIG9yIG5vdC5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cbiAgaXNPcGVuKCkge1xuICAgIHJldHVybiB0aGlzLl9pdGVtU2hvd247XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCB0b2dnbGVcbiAgICogQHNpZ25hdHVyZSB0b2dnbGUoKVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dVG9nZ2xlIHZpc2liaWxpdHkuWy9lbl1cbiAgICogICBbamFdU3BlZWQgZGlhbOOBruihqOekuumdnuihqOekuuOCkuWIh+OCiuabv+OBiOOBvuOBmeOAglsvamFdXG4gICAqL1xuICB0b2dnbGUoKSB7XG4gICAgcmV0dXJuIHRoaXMudmlzaWJsZSA/IHRoaXMuaGlkZSgpIDogdGhpcy5zaG93KCk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCB0b2dnbGVJdGVtc1xuICAgKiBAc2lnbmF0dXJlIHRvZ2dsZUl0ZW1zKClcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVRvZ2dsZSBpdGVtIHZpc2liaWxpdHkuWy9lbl1cbiAgICogICBbamFdU3BlZWQgZGlhbOOBruWtkOimgee0oOOBruihqOekuumdnuihqOekuuOCkuWIh+OCiuabv+OBiOOBvuOBmeOAglsvamFdXG4gICAqL1xuICB0b2dnbGVJdGVtcygpIHtcbiAgICByZXR1cm4gdGhpcy5pc09wZW4oKSA/IHRoaXMuaGlkZUl0ZW1zKCkgOiB0aGlzLnNob3dJdGVtcygpO1xuICB9XG5cbiAgc3RhdGljIGdldCBldmVudHMoKSB7XG4gICAgcmV0dXJuIFsnb3BlbicsICdjbG9zZSddO1xuICB9XG59XG5cbm9uc0VsZW1lbnRzLlNwZWVkRGlhbCA9IFNwZWVkRGlhbEVsZW1lbnQ7XG5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ29ucy1zcGVlZC1kaWFsJywgU3BlZWREaWFsRWxlbWVudCk7XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgb25zRWxlbWVudHMgZnJvbSAnLi4vb25zL2VsZW1lbnRzJztcbmltcG9ydCB1dGlsIGZyb20gJy4uL29ucy91dGlsJztcbmltcG9ydCBpbnRlcm5hbCBmcm9tICcuLi9vbnMvaW50ZXJuYWwnO1xuaW1wb3J0IE1vZGlmaWVyVXRpbCBmcm9tICcuLi9vbnMvaW50ZXJuYWwvbW9kaWZpZXItdXRpbCc7XG5pbXBvcnQgQmFzZUVsZW1lbnQgZnJvbSAnLi9iYXNlL2Jhc2UtZWxlbWVudCc7XG5pbXBvcnQge1BhZ2VMb2FkZXIsIGRlZmF1bHRQYWdlTG9hZGVyfSBmcm9tICcuLi9vbnMvcGFnZS1sb2FkZXInO1xuaW1wb3J0IGNvbnRlbnRSZWFkeSBmcm9tICcuLi9vbnMvY29udGVudC1yZWFkeSc7XG5cbmNvbnN0IHJld3JpdGFibGVzID0ge1xuICAvKipcbiAgICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqL1xuICByZWFkeShlbGVtZW50LCBjYWxsYmFjaykge1xuICAgIHNldEltbWVkaWF0ZShjYWxsYmFjayk7XG4gIH1cbn07XG5cbi8qKlxuICogQGVsZW1lbnQgb25zLXNwbGl0dGVyLWNvbnRlbnRcbiAqIEBjYXRlZ29yeSBtZW51XG4gKiBAZGVzY3JpcHRpb25cbiAqICBbZW5dXG4gKiAgICBUaGUgYDxvbnMtc3BsaXR0ZXItY29udGVudD5gIGVsZW1lbnQgaXMgdXNlZCBhcyBhIGNoaWxkIGVsZW1lbnQgb2YgYDxvbnMtc3BsaXR0ZXI+YC5cbiAqXG4gKiAgICBJdCBjb250YWlucyB0aGUgbWFpbiBjb250ZW50IG9mIHRoZSBwYWdlIHdoaWxlIGA8b25zLXNwbGl0dGVyLXNpZGU+YCBjb250YWlucyB0aGUgbGlzdC5cbiAqICBbL2VuXVxuICogIFtqYV1vbnMtc3BsaXR0ZXItY29udGVudOimgee0oOOBr+OAgW9ucy1zcGxpdHRlcuimgee0oOOBruWtkOimgee0oOOBqOOBl+OBpuWIqeeUqOOBl+OBvuOBmeOAglsvamFdXG4gKiBAY29kZXBlbiByT1FPTUxcbiAqIEB0dXRvcmlhbCB2YW5pbGxhL1JlZmVyZW5jZS9zcGxpdHRlclxuICogQGd1aWRlIGZ1bmRhbWVudGFscy5odG1sI21hbmFnaW5nLXBhZ2VzXG4gKiAgW2VuXU1hbmFnaW5nIG11bHRpcGxlIHBhZ2VzLlsvZW5dXG4gKiAgW2phXeikh+aVsOOBruODmuODvOOCuOOCkueuoeeQhuOBmeOCi1svamFdXG4gKiBAc2VlYWxzbyBvbnMtc3BsaXR0ZXJcbiAqICBbZW5dVGhlIGA8b25zLXNwbGl0dGVyPmAgY29tcG9uZW50IGlzIHRoZSBwYXJlbnQgZWxlbWVudC5bL2VuXVxuICogIFtqYV1vbnMtc3BsaXR0ZXLjgrPjg7Pjg53jg7zjg43jg7Pjg4hbL2phXVxuICogQHNlZWFsc28gb25zLXNwbGl0dGVyLXNpZGVcbiAqICBbZW5dVGhlIGA8b25zLXNwbGl0dGVyLXNpZGU+YCBjb21wb25lbnQgY29udGFpbnMgdGhlIG1lbnUuWy9lbl1cbiAqICBbamFdb25zLXNwbGl0dGVyLXNpZGXjgrPjg7Pjg53jg7zjg43jg7Pjg4hbL2phXVxuICogQGV4YW1wbGVcbiAqIDxvbnMtc3BsaXR0ZXI+XG4gKiAgIDxvbnMtc3BsaXR0ZXItY29udGVudD5cbiAqICAgICAuLi5cbiAqICAgPC9vbnMtc3BsaXR0ZXItY29udGVudD5cbiAqXG4gKiAgIDxvbnMtc3BsaXR0ZXItc2lkZSBzaWRlPVwibGVmdFwiIHdpZHRoPVwiODAlXCIgY29sbGFwc2U+XG4gKiAgICAgLi4uXG4gKiAgIDwvb25zLXNwbGl0dGVyLXNpZGU+XG4gKiA8L29ucy1zcGxpdHRlcj5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU3BsaXR0ZXJDb250ZW50RWxlbWVudCBleHRlbmRzIEJhc2VFbGVtZW50IHtcblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBwYWdlXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1cbiAgICogICAgIFRoZSB1cmwgb2YgdGhlIGNvbnRlbnQgcGFnZS4gSWYgdGhpcyBhdHRyaWJ1dGUgaXMgdXNlZCB0aGUgY29udGVudCB3aWxsIGJlIGxvYWRlZCBmcm9tIGEgYDx0ZW1wbGF0ZT5gIHRhZyBvciBhIHJlbW90ZSBmaWxlLlxuICAgKlxuICAgKiAgICAgSXQgaXMgYWxzbyBwb3NzaWJsZSB0byBwdXQgYDxvbnMtcGFnZT5gIGVsZW1lbnQgYXMgYSBjaGlsZCBvZiB0aGUgZWxlbWVudC5cbiAgICogICBbL2VuXVxuICAgKiAgIFtqYV1vbnMtc3BsaXR0ZXItY29udGVudOimgee0oOOBq+ihqOekuuOBmeOCi+ODmuODvOOCuOOBrlVSTOOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG5cbiAgICB0aGlzLl9wYWdlID0gbnVsbDtcbiAgICB0aGlzLl9wYWdlTG9hZGVyID0gZGVmYXVsdFBhZ2VMb2FkZXI7XG5cbiAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4ge1xuICAgICAgcmV3cml0YWJsZXMucmVhZHkodGhpcywgKCkgPT4ge1xuICAgICAgICBjb25zdCBwYWdlID0gdGhpcy5fZ2V0UGFnZVRhcmdldCgpO1xuXG4gICAgICAgIGlmIChwYWdlKSB7XG4gICAgICAgICAgdGhpcy5sb2FkKHBhZ2UpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIGNvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIGlmICghdXRpbC5tYXRjaCh0aGlzLnBhcmVudE5vZGUsICdvbnMtc3BsaXR0ZXInKSkge1xuICAgICAgdXRpbC50aHJvdygnXCJvbnMtc3BsaXR0ZXItY29udGVudFwiIG11c3QgaGF2ZSBcIm9ucy1zcGxpdHRlclwiIGFzIHBhcmVudCcpO1xuICAgIH1cbiAgfVxuXG4gIF9nZXRQYWdlVGFyZ2V0KCkge1xuICAgIHJldHVybiB0aGlzLl9wYWdlIHx8IHRoaXMuZ2V0QXR0cmlidXRlKCdwYWdlJyk7XG4gIH1cblxuICBkaXNjb25uZWN0ZWRDYWxsYmFjaygpIHt9XG5cbiAgc3RhdGljIGdldCBvYnNlcnZlZEF0dHJpYnV0ZXMoKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIGxhc3QsIGN1cnJlbnQpIHtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgcGFnZVxuICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1UaGUgcGFnZSB0byBsb2FkIGluIHRoZSBzcGxpdHRlciBjb250ZW50LlsvZW5dXG4gICAqICAgW2phXeOBk+OBruimgee0oOWGheOBq+ihqOekuuOBmeOCi+ODmuODvOOCuOOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuICBnZXQgcGFnZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fcGFnZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0geyp9IHBhZ2VcbiAgICovXG4gIHNldCBwYWdlKHBhZ2UpIHtcbiAgICB0aGlzLl9wYWdlID0gcGFnZTtcbiAgfVxuXG4gIGdldCBfY29udGVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5jaGlsZHJlblswXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgcGFnZUxvYWRlclxuICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1QYWdlIGVsZW1lbnQgbG9hZGVkIGluIHRoZSBzcGxpdHRlciBjb250ZW50LlsvZW5dXG4gICAqICAgW2phXeOBk+OBruimgee0oOWGheOBq+ihqOekuuOBmeOCi+ODmuODvOOCuOOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuICBnZXQgcGFnZUxvYWRlcigpIHtcbiAgICByZXR1cm4gdGhpcy5fcGFnZUxvYWRlcjtcbiAgfVxuXG4gIHNldCBwYWdlTG9hZGVyKGxvYWRlcikge1xuICAgIGlmICghKGxvYWRlciBpbnN0YW5jZW9mIFBhZ2VMb2FkZXIpKSB7XG4gICAgICB1dGlsLnRocm93UGFnZUxvYWRlcigpO1xuICAgIH1cbiAgICB0aGlzLl9wYWdlTG9hZGVyID0gbG9hZGVyO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgbG9hZFxuICAgKiBAc2lnbmF0dXJlIGxvYWQocGFnZSwgW29wdGlvbnNdKVxuICAgKiBAcGFyYW0ge1N0cmluZ30gcGFnZSwgW29wdGlvbnNdXG4gICAqICAgW2VuXVBhZ2UgVVJMLiBDYW4gYmUgZWl0aGVyIGFuIEhUTUwgZG9jdW1lbnQgb3IgYW4gYDx0ZW1wbGF0ZT5gIGlkLlsvZW5dXG4gICAqICAgW2phXXBhZ2Xjga5VUkzjgYvjgIFgPHRlbXBsYXRlPmDjgaflrqPoqIDjgZfjgZ/jg4bjg7Pjg5fjg6zjg7zjg4jjga5pZOWxnuaAp+OBruWApOOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuY2FsbGJhY2tdXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1TaG93IHRoZSBwYWdlIHNwZWNpZmllZCBpbiBgcGFnZWAgaW4gdGhlIGNvbnRlbnQuWy9lbl1cbiAgICogICBbamFd5oyH5a6a44GX44GfVVJM44KS44Oh44Kk44Oz44Oa44O844K444KS6Kqt44G/6L6844G/44G+44GZ44CCWy9qYV1cbiAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICogICBbZW5dUmVzb2x2ZXMgdG8gdGhlIG5ldyBgPG9ucy1wYWdlPmAgZWxlbWVudFsvZW5dXG4gICAqICAgW2phXWA8b25zLXBhZ2U+YOimgee0oOOCkuino+axuuOBmeOCi1Byb21pc2Xjgqrjg5bjgrjjgqfjgq/jg4jjgpLov5TjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cbiAgbG9hZChwYWdlLCBvcHRpb25zID0ge30pIHtcbiAgICB0aGlzLl9wYWdlID0gcGFnZTtcbiAgICBjb25zdCBjYWxsYmFjayA9IG9wdGlvbnMuY2FsbGJhY2sgfHwgZnVuY3Rpb24oKSB7fTtcblxuICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgIGxldCBvbGRDb250ZW50ID0gdGhpcy5fY29udGVudCB8fCBudWxsO1xuXG4gICAgICB0aGlzLl9wYWdlTG9hZGVyLmxvYWQoe3BhZ2UsIHBhcmVudDogdGhpc30sIHBhZ2VFbGVtZW50ID0+IHtcbiAgICAgICAgaWYgKG9sZENvbnRlbnQpIHtcbiAgICAgICAgICB0aGlzLl9wYWdlTG9hZGVyLnVubG9hZChvbGRDb250ZW50KTtcbiAgICAgICAgICBvbGRDb250ZW50ID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHNldEltbWVkaWF0ZSgoKSA9PiB0aGlzLl9zaG93KCkpO1xuXG4gICAgICAgIGNhbGxiYWNrKHBhZ2VFbGVtZW50KTtcbiAgICAgICAgcmVzb2x2ZShwYWdlRWxlbWVudCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIF9zaG93KCkge1xuICAgIGlmICh0aGlzLl9jb250ZW50KSB7XG4gICAgICB0aGlzLl9jb250ZW50Ll9zaG93KCk7XG4gICAgfVxuICB9XG5cbiAgX2hpZGUoKSB7XG4gICAgaWYgKHRoaXMuX2NvbnRlbnQpIHtcbiAgICAgIHRoaXMuX2NvbnRlbnQuX2hpZGUoKTtcbiAgICB9XG4gIH1cblxuICBfZGVzdHJveSgpIHtcbiAgICBpZiAodGhpcy5fY29udGVudCkge1xuICAgICAgdGhpcy5fcGFnZUxvYWRlci51bmxvYWQodGhpcy5fY29udGVudCk7XG4gICAgfVxuICAgIHRoaXMucmVtb3ZlKCk7XG4gIH1cblxuICBzdGF0aWMgZ2V0IHJld3JpdGFibGVzKCkge1xuICAgIHJldHVybiByZXdyaXRhYmxlcztcbiAgfVxufVxuXG5vbnNFbGVtZW50cy5TcGxpdHRlckNvbnRlbnQgPSBTcGxpdHRlckNvbnRlbnRFbGVtZW50O1xuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdvbnMtc3BsaXR0ZXItY29udGVudCcsIFNwbGl0dGVyQ29udGVudEVsZW1lbnQpO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IG9uc0VsZW1lbnRzIGZyb20gJy4uL29ucy9lbGVtZW50cyc7XG5pbXBvcnQgQmFzZUVsZW1lbnQgZnJvbSAnLi9iYXNlL2Jhc2UtZWxlbWVudCc7XG5pbXBvcnQgdXRpbCBmcm9tICcuLi9vbnMvdXRpbCc7XG5pbXBvcnQgY29udGVudFJlYWR5IGZyb20gJy4uL29ucy9jb250ZW50LXJlYWR5JztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU3BsaXR0ZXJNYXNrRWxlbWVudCBleHRlbmRzIEJhc2VFbGVtZW50IHtcblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgdGhpcy5fYm91bmRPbkNsaWNrID0gdGhpcy5fb25DbGljay5iaW5kKHRoaXMpO1xuICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB7XG4gICAgICBpZiAodGhpcy5wYXJlbnROb2RlLl9zaWRlcy5ldmVyeShzaWRlID0+IHNpZGUubW9kZSA9PT0gJ3NwbGl0JykpIHtcbiAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ3N0eWxlJywgJ2Rpc3BsYXk6IG5vbmUgIWltcG9ydGFudCcpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgX29uQ2xpY2soZXZlbnQpIHtcbiAgICBpZiAodGhpcy5vbkNsaWNrIGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcbiAgICAgIHRoaXMub25DbGljaygpO1xuICAgIH0gZWxzZSBpZiAodXRpbC5tYXRjaCh0aGlzLnBhcmVudE5vZGUsICdvbnMtc3BsaXR0ZXInKSkge1xuICAgICAgdGhpcy5wYXJlbnROb2RlLl9zaWRlcy5mb3JFYWNoKHNpZGUgPT4gc2lkZS5jbG9zZSgnbGVmdCcpLmNhdGNoKCgpID0+IHt9KSk7XG4gICAgfVxuICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICB9XG5cbiAgc3RhdGljIGdldCBvYnNlcnZlZEF0dHJpYnV0ZXMoKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIGxhc3QsIGN1cnJlbnQpIHtcbiAgfVxuXG4gIGNvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLl9ib3VuZE9uQ2xpY2spO1xuICAgIHV0aWwuaW9zTWFza1Njcm9sbEZpeCh0aGlzLCB0cnVlKTtcbiAgfVxuXG4gIGRpc2Nvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLl9ib3VuZE9uQ2xpY2spO1xuICAgIHV0aWwuaW9zTWFza1Njcm9sbEZpeCh0aGlzLCBmYWxzZSk7XG4gIH1cbn1cblxub25zRWxlbWVudHMuU3BsaXR0ZXJNYXNrID0gU3BsaXR0ZXJNYXNrRWxlbWVudDtcbmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnb25zLXNwbGl0dGVyLW1hc2snLCBTcGxpdHRlck1hc2tFbGVtZW50KTtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCB1dGlsIGZyb20gJy4uLy4uL29ucy91dGlsJztcbmltcG9ydCBzdHlsZXIgZnJvbSAnLi4vLi4vb25zL3N0eWxlcic7XG5pbXBvcnQgY29udGVudFJlYWR5IGZyb20gJy4uLy4uL29ucy9jb250ZW50LXJlYWR5JztcbmltcG9ydCBCYXNlQW5pbWF0b3IgZnJvbSAnLi4vLi4vb25zL2Jhc2UtYW5pbWF0b3InO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTcGxpdHRlckFuaW1hdG9yIGV4dGVuZHMgQmFzZUFuaW1hdG9yIHtcblxuICBjb25zdHJ1Y3Rvcih7dGltaW5nID0gJ2N1YmljLWJlemllciguMSwgLjcsIC4xLCAxKScsIGR1cmF0aW9uID0gMC4zLCBkZWxheSA9IDB9ID0ge30pIHtcbiAgICBzdXBlcih7IHRpbWluZywgZHVyYXRpb24sIGRlbGF5IH0pO1xuICB9XG5cbiAgdXBkYXRlT3B0aW9ucyhvcHRpb25zID0ge30pIHtcbiAgICB1dGlsLmV4dGVuZCh0aGlzLCB7XG4gICAgICB0aW1pbmc6IHRoaXMudGltaW5nLCBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbiwgZGVsYXk6IHRoaXMuZGVsYXlcbiAgICB9LCBvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IHNpZGVFbGVtZW50XG4gICAqL1xuICBhY3RpdmF0ZShzaWRlRWxlbWVudCkge1xuICAgIGNvbnN0IHNwbGl0dGVyID0gc2lkZUVsZW1lbnQucGFyZW50Tm9kZTtcblxuICAgIGNvbnRlbnRSZWFkeShzcGxpdHRlciwgKCkgPT4ge1xuICAgICAgdGhpcy5fc2lkZSA9IHNpZGVFbGVtZW50O1xuICAgICAgdGhpcy5fb3Bwb3NpdGVTaWRlID0gc3BsaXR0ZXIucmlnaHQgIT09IHNpZGVFbGVtZW50ICYmIHNwbGl0dGVyLnJpZ2h0IHx8IHNwbGl0dGVyLmxlZnQgIT09IHNpZGVFbGVtZW50ICYmIHNwbGl0dGVyLmxlZnQ7XG4gICAgICB0aGlzLl9jb250ZW50ID0gc3BsaXR0ZXIuY29udGVudDtcbiAgICAgIHRoaXMuX21hc2sgPSBzcGxpdHRlci5tYXNrO1xuICAgIH0pO1xuICB9XG5cbiAgZGVhY3RpdmF0ZSgpIHtcbiAgICB0aGlzLmNsZWFyVHJhbnNpdGlvbigpO1xuICAgIHRoaXMuX21hc2sgJiYgdGhpcy5jbGVhck1hc2soKTtcbiAgICB0aGlzLl9jb250ZW50ID0gdGhpcy5fc2lkZSA9IHRoaXMuX29wcG9zaXRlU2lkZSA9IHRoaXMuX21hc2sgPSBudWxsO1xuICB9XG5cbiAgZ2V0IG1pbnVzKCkge1xuICAgIHJldHVybiB0aGlzLl9zaWRlLnNpZGUgPT09ICdyaWdodCcgPyAnLScgOiAnJztcbiAgfVxuXG4gIGNsZWFyVHJhbnNpdGlvbigpIHtcbiAgICAnc2lkZSBtYXNrIGNvbnRlbnQnLnNwbGl0KC9cXHMrLylcbiAgICAgIC5mb3JFYWNoKGUgPT4gdGhpc1snXycgKyBlXSAmJiBzdHlsZXIuY2xlYXIodGhpc1snXycgKyBlXSwgJ3RyYW5zZm9ybSB0cmFuc2l0aW9uJykpXG4gIH1cblxuICBjbGVhck1hc2soKSB7XG4gICAgLy8gQ2hlY2sgaWYgdGhlIG90aGVyIHNpZGUgbmVlZHMgdGhlIG1hc2sgYmVmb3JlIGNsZWFyaW5nXG4gICAgaWYgKCF0aGlzLl9vcHBvc2l0ZVNpZGUgfHwgdGhpcy5fb3Bwb3NpdGVTaWRlLm1vZGUgPT09ICdzcGxpdCcgfHwgIXRoaXMuX29wcG9zaXRlU2lkZS5pc09wZW4pIHtcbiAgICAgIHRoaXMuX21hc2suc3R5bGUub3BhY2l0eSA9ICcnO1xuICAgICAgdGhpcy5fbWFzay5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge051bWJlcn0gZGlzdGFuY2VcbiAgICovXG4gIHRyYW5zbGF0ZShkaXN0YW5jZSkge1xuXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZG9uZVxuICAgKi9cbiAgb3Blbihkb25lKSB7XG4gICAgZG9uZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGRvbmVcbiAgICovXG4gIGNsb3NlKGRvbmUpIHtcbiAgICBkb25lKCk7XG4gIH1cbn1cbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCBhbmltaXQgZnJvbSAnLi4vLi4vb25zL2FuaW1pdCc7XG5pbXBvcnQgU3BsaXR0ZXJBbmltYXRvciBmcm9tICcuL2FuaW1hdG9yLmpzJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgT3ZlcmxheVNwbGl0dGVyQW5pbWF0b3IgZXh0ZW5kcyBTcGxpdHRlckFuaW1hdG9yIHtcblxuICB0cmFuc2xhdGUoZGlzdGFuY2UpIHtcbiAgICB0aGlzLl9tYXNrLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snOyAvLyBBdm9pZCBjb250ZW50IGNsaWNrc1xuXG4gICAgYW5pbWl0KHRoaXMuX3NpZGUpXG4gICAgICAucXVldWUoe1xuICAgICAgICB0cmFuc2Zvcm06IGB0cmFuc2xhdGUzZCgke3RoaXMubWludXMgKyBkaXN0YW5jZX1weCwgMCwgMClgXG4gICAgICB9KVxuICAgICAgLnBsYXkoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBkb25lXG4gICAqL1xuICBvcGVuKGRvbmUpIHtcbiAgICBhbmltaXQucnVuQWxsKFxuICAgICAgYW5pbWl0KHRoaXMuX3NpZGUpXG4gICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgdHJhbnNmb3JtOiBgdHJhbnNsYXRlM2QoJHt0aGlzLm1pbnVzfTEwMCUsIDAsIDApYFxuICAgICAgICB9LCB0aGlzLmRlZilcbiAgICAgICAgLnF1ZXVlKGNhbGxiYWNrID0+IHtcbiAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgIGRvbmUgJiYgZG9uZSgpO1xuICAgICAgICB9KSxcblxuICAgICAgYW5pbWl0KHRoaXMuX21hc2spXG4gICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgZGlzcGxheTogJ2Jsb2NrJ1xuICAgICAgICB9KVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIG9wYWNpdHk6ICcxJ1xuICAgICAgICB9LCB7XG4gICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgdGltaW5nOiAnbGluZWFyJyxcbiAgICAgICAgfSlcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGRvbmVcbiAgICovXG4gIGNsb3NlKGRvbmUpIHtcblxuICAgIGFuaW1pdC5ydW5BbGwoXG4gICAgICBhbmltaXQodGhpcy5fc2lkZSlcbiAgICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzZCgwLCAwLCAwKSdcbiAgICAgICAgfSwgdGhpcy5kZWYpXG4gICAgICAgIC5xdWV1ZShjYWxsYmFjayA9PiB7XG4gICAgICAgICAgZG9uZSAmJiBkb25lKCk7XG4gICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgfSksXG5cbiAgICAgIGFuaW1pdCh0aGlzLl9tYXNrKVxuICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIG9wYWNpdHk6ICcwJ1xuICAgICAgICB9LCB7XG4gICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgdGltaW5nOiAnbGluZWFyJyxcbiAgICAgICAgfSlcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBkaXNwbGF5OiAnbm9uZSdcbiAgICAgICAgfSlcbiAgICApO1xuICB9XG59XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgYW5pbWl0IGZyb20gJy4uLy4uL29ucy9hbmltaXQnO1xuaW1wb3J0IFNwbGl0dGVyQW5pbWF0b3IgZnJvbSAnLi9hbmltYXRvci5qcyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFB1c2hTcGxpdHRlckFuaW1hdG9yIGV4dGVuZHMgU3BsaXR0ZXJBbmltYXRvciB7XG5cbiAgX2dldFNsaWRpbmdFbGVtZW50cygpIHtcbiAgICBjb25zdCBzbGlkaW5nRWxlbWVudHMgPSBbdGhpcy5fc2lkZSwgdGhpcy5fY29udGVudF07XG4gICAgaWYgKHRoaXMuX29wcG9zaXRlU2lkZSAmJiB0aGlzLl9vcHBvc2l0ZVNpZGUubW9kZSA9PT0gJ3NwbGl0Jykge1xuICAgICAgc2xpZGluZ0VsZW1lbnRzLnB1c2godGhpcy5fb3Bwb3NpdGVTaWRlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc2xpZGluZ0VsZW1lbnRzO1xuICB9XG5cbiAgdHJhbnNsYXRlKGRpc3RhbmNlKSB7XG4gICAgaWYgKCF0aGlzLl9zbGlkaW5nRWxlbWVudHMpIHtcbiAgICAgIHRoaXMuX3NsaWRpbmdFbGVtZW50cyA9IHRoaXMuX2dldFNsaWRpbmdFbGVtZW50cygpO1xuICAgIH1cblxuICAgIHRoaXMuX21hc2suc3R5bGUuZGlzcGxheSA9ICdibG9jayc7IC8vIEF2b2lkIGNvbnRlbnQgY2xpY2tzXG5cbiAgICBhbmltaXQodGhpcy5fc2xpZGluZ0VsZW1lbnRzKVxuICAgICAgLnF1ZXVlKHtcbiAgICAgICAgdHJhbnNmb3JtOiBgdHJhbnNsYXRlM2QoJHt0aGlzLm1pbnVzICsgZGlzdGFuY2V9cHgsIDAsIDApYFxuICAgICAgfSlcbiAgICAgIC5wbGF5KCk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZG9uZVxuICAgKi9cbiAgb3Blbihkb25lKSB7XG4gICAgY29uc3QgbWF4ID0gdGhpcy5fc2lkZS5vZmZzZXRXaWR0aDtcbiAgICB0aGlzLl9zbGlkaW5nRWxlbWVudHMgPSB0aGlzLl9nZXRTbGlkaW5nRWxlbWVudHMoKTtcblxuICAgIGFuaW1pdC5ydW5BbGwoXG4gICAgICBhbmltaXQodGhpcy5fc2xpZGluZ0VsZW1lbnRzKVxuICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIHRyYW5zZm9ybTogYHRyYW5zbGF0ZTNkKCR7dGhpcy5taW51cyArIG1heH1weCwgMCwgMClgXG4gICAgICAgIH0sIHRoaXMuZGVmKVxuICAgICAgICAucXVldWUoY2FsbGJhY2sgPT4ge1xuICAgICAgICAgIHRoaXMuX3NsaWRpbmdFbGVtZW50cyA9IG51bGw7XG4gICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICBkb25lICYmIGRvbmUoKTtcbiAgICAgICAgfSksXG5cbiAgICAgIGFuaW1pdCh0aGlzLl9tYXNrKVxuICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIGRpc3BsYXk6ICdibG9jaydcbiAgICAgICAgfSlcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGRvbmVcbiAgICovXG4gIGNsb3NlKGRvbmUpIHtcbiAgICB0aGlzLl9zbGlkaW5nRWxlbWVudHMgPSB0aGlzLl9nZXRTbGlkaW5nRWxlbWVudHMoKTtcblxuICAgIGFuaW1pdC5ydW5BbGwoXG4gICAgICBhbmltaXQodGhpcy5fc2xpZGluZ0VsZW1lbnRzKVxuICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNkKDAsIDAsIDApJ1xuICAgICAgICB9LCB0aGlzLmRlZilcbiAgICAgICAgLnF1ZXVlKGNhbGxiYWNrID0+IHtcbiAgICAgICAgICB0aGlzLl9zbGlkaW5nRWxlbWVudHMgPSBudWxsO1xuICAgICAgICAgIHN1cGVyLmNsZWFyVHJhbnNpdGlvbigpO1xuICAgICAgICAgIGRvbmUgJiYgZG9uZSgpO1xuICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgIH0pLFxuXG4gICAgICBhbmltaXQodGhpcy5fbWFzaylcbiAgICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBkaXNwbGF5OiAnbm9uZSdcbiAgICAgICAgfSlcbiAgICApO1xuICB9XG59XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgY29udGVudFJlYWR5IGZyb20gJy4uLy4uL29ucy9jb250ZW50LXJlYWR5JztcbmltcG9ydCBzdHlsZXIgZnJvbSAnLi4vLi4vb25zL3N0eWxlcic7XG5pbXBvcnQgYW5pbWl0IGZyb20gJy4uLy4uL29ucy9hbmltaXQnO1xuaW1wb3J0IFNwbGl0dGVyQW5pbWF0b3IgZnJvbSAnLi9hbmltYXRvci5qcyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJldmVhbFNwbGl0dGVyQW5pbWF0b3IgZXh0ZW5kcyBTcGxpdHRlckFuaW1hdG9yIHtcblxuICBfZ2V0U2xpZGluZ0VsZW1lbnRzKCkge1xuICAgIGNvbnN0IHNsaWRpbmdFbGVtZW50cyA9IFt0aGlzLl9jb250ZW50LCB0aGlzLl9tYXNrXTtcbiAgICBpZiAodGhpcy5fb3Bwb3NpdGVTaWRlICYmIHRoaXMuX29wcG9zaXRlU2lkZS5tb2RlID09PSAnc3BsaXQnKSB7XG4gICAgICBzbGlkaW5nRWxlbWVudHMucHVzaCh0aGlzLl9vcHBvc2l0ZVNpZGUpO1xuICAgIH1cblxuICAgIHJldHVybiBzbGlkaW5nRWxlbWVudHM7XG4gIH1cblxuICBhY3RpdmF0ZShzaWRlRWxlbWVudCkge1xuICAgIHN1cGVyLmFjdGl2YXRlKHNpZGVFbGVtZW50KTtcbiAgICBpZiAoc2lkZUVsZW1lbnQubW9kZSA9PT0gJ2NvbGxhcHNlJykge1xuICAgICAgdGhpcy5fc2V0U3R5bGVzKHNpZGVFbGVtZW50KTtcbiAgICB9XG4gIH1cblxuICBkZWFjdGl2YXRlKCkge1xuICAgIHRoaXMuX3NpZGUgJiYgdGhpcy5fdW5zZXRTdHlsZXModGhpcy5fc2lkZSk7XG4gICAgc3VwZXIuZGVhY3RpdmF0ZSgpO1xuICB9XG5cbiAgX3NldFN0eWxlcyhzaWRlRWxlbWVudCkge1xuICAgIHN0eWxlcihzaWRlRWxlbWVudCwge1xuICAgICAgbGVmdDogc2lkZUVsZW1lbnQuc2lkZSA9PT0gJ3JpZ2h0JyA/ICdhdXRvJyA6IDAsXG4gICAgICByaWdodDogc2lkZUVsZW1lbnQuc2lkZSA9PT0gJ3JpZ2h0JyAgPyAwIDogJ2F1dG8nLFxuICAgICAgekluZGV4OiAwLFxuICAgICAgYmFja2dyb3VuZENvbG9yOiAnYmxhY2snLFxuICAgICAgdHJhbnNmb3JtOiB0aGlzLl9nZW5lcmF0ZUJlaGluZFBhZ2VTdHlsZSgwKS5jb250YWluZXIudHJhbnNmb3JtLFxuICAgICAgZGlzcGxheTogJ25vbmUnXG4gICAgfSk7XG5cbiAgICBjb25zdCBzcGxpdHRlciA9IHNpZGVFbGVtZW50LnBhcmVudEVsZW1lbnQ7XG4gICAgY29udGVudFJlYWR5KHNwbGl0dGVyLCAoKSA9PiBzcGxpdHRlci5jb250ZW50ICYmIHN0eWxlcihzcGxpdHRlci5jb250ZW50LCB7IGJveFNoYWRvdzogJzAgMCAxMnB4IDAgcmdiYSgwLCAwLCAwLCAwLjIpJyB9KSk7XG4gIH1cblxuICBfdW5zZXRTdHlsZXMoc2lkZUVsZW1lbnQpIHtcbiAgICBzdHlsZXIuY2xlYXIoc2lkZUVsZW1lbnQsICdsZWZ0IHJpZ2h0IHpJbmRleCBiYWNrZ3JvdW5kQ29sb3IgZGlzcGxheScpO1xuICAgIGlmIChzaWRlRWxlbWVudC5fY29udGVudCkge1xuICAgICAgc2lkZUVsZW1lbnQuX2NvbnRlbnQuc3R5bGUub3BhY2l0eSA9ICcnO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGlmIHRoZSBvdGhlciBzaWRlIG5lZWRzIHRoZSBjb21tb24gc3R5bGVzXG4gICAgaWYgKCF0aGlzLl9vcHBvc2l0ZVNpZGUgfHwgdGhpcy5fb3Bwb3NpdGVTaWRlLm1vZGUgPT09ICdzcGxpdCcpIHtcbiAgICAgIHNpZGVFbGVtZW50LnBhcmVudEVsZW1lbnQuY29udGVudCAmJiBzdHlsZXIuY2xlYXIoc2lkZUVsZW1lbnQucGFyZW50RWxlbWVudC5jb250ZW50LCAnYm94U2hhZG93Jyk7XG4gICAgfVxuICB9XG5cbiAgX2dlbmVyYXRlQmVoaW5kUGFnZVN0eWxlKGRpc3RhbmNlKSB7XG4gICAgY29uc3QgbWF4ID0gdGhpcy5tYXhXaWR0aDtcblxuICAgIGxldCBiZWhpbmREaXN0YW5jZSA9IChkaXN0YW5jZSAtIG1heCkgLyBtYXggKiAxMDtcbiAgICBiZWhpbmREaXN0YW5jZSA9IGlzTmFOKGJlaGluZERpc3RhbmNlKSA/IDAgOiBNYXRoLm1heChNYXRoLm1pbihiZWhpbmREaXN0YW5jZSwgMCksIC0xMCk7XG5cbiAgICBjb25zdCBiZWhpbmRUcmFuc2Zvcm0gPSBgdHJhbnNsYXRlM2QoJHsodGhpcy5taW51cyA/IC0xIDogMSkgKiBiZWhpbmREaXN0YW5jZX0lLCAwLCAwKWA7XG4gICAgY29uc3Qgb3BhY2l0eSA9IDEgKyBiZWhpbmREaXN0YW5jZSAvIDEwMDtcblxuICAgIHJldHVybiB7XG4gICAgICBjb250ZW50OiB7XG4gICAgICAgIG9wYWNpdHlcbiAgICAgIH0sXG4gICAgICBjb250YWluZXI6IHtcbiAgICAgICAgdHJhbnNmb3JtOiBiZWhpbmRUcmFuc2Zvcm1cbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgdHJhbnNsYXRlKGRpc3RhbmNlKSB7XG4gICAgdGhpcy5fc2lkZS5zdHlsZS5kaXNwbGF5ID0gJyc7XG4gICAgdGhpcy5fc2lkZS5zdHlsZS56SW5kZXggPSAxO1xuICAgIHRoaXMubWF4V2lkdGggPSB0aGlzLm1heFdpZHRoIHx8IHRoaXMuX2dldE1heFdpZHRoKCk7XG4gICAgY29uc3QgbWVudVN0eWxlID0gdGhpcy5fZ2VuZXJhdGVCZWhpbmRQYWdlU3R5bGUoTWF0aC5taW4oZGlzdGFuY2UsIHRoaXMubWF4V2lkdGgpKTtcblxuICAgIGlmICghdGhpcy5fc2xpZGluZ0VsZW1lbnRzKSB7XG4gICAgICB0aGlzLl9zbGlkaW5nRWxlbWVudHMgPSB0aGlzLl9nZXRTbGlkaW5nRWxlbWVudHMoKTtcbiAgICB9XG5cbiAgICB0aGlzLl9tYXNrLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snOyAvLyBBdm9pZCBjb250ZW50IGNsaWNrc1xuXG4gICAgYW5pbWl0LnJ1bkFsbChcbiAgICAgIGFuaW1pdCh0aGlzLl9zbGlkaW5nRWxlbWVudHMpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgdHJhbnNmb3JtOiBgdHJhbnNsYXRlM2QoJHt0aGlzLm1pbnVzICsgZGlzdGFuY2V9cHgsIDAsIDApYFxuICAgICAgICB9KSxcbiAgICAgIGFuaW1pdCh0aGlzLl9zaWRlLl9jb250ZW50KVxuICAgICAgICAucXVldWUobWVudVN0eWxlLmNvbnRlbnQpLFxuICAgICAgYW5pbWl0KHRoaXMuX3NpZGUpXG4gICAgICAgIC5xdWV1ZShtZW51U3R5bGUuY29udGFpbmVyKVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZG9uZVxuICAgKi9cbiAgb3Blbihkb25lKSB7XG4gICAgdGhpcy5fc2lkZS5zdHlsZS5kaXNwbGF5ID0gJyc7XG4gICAgdGhpcy5fc2lkZS5zdHlsZS56SW5kZXggPSAxO1xuICAgIHRoaXMubWF4V2lkdGggPSB0aGlzLm1heFdpZHRoIHx8IHRoaXMuX2dldE1heFdpZHRoKCk7XG4gICAgY29uc3QgbWVudVN0eWxlID0gdGhpcy5fZ2VuZXJhdGVCZWhpbmRQYWdlU3R5bGUodGhpcy5tYXhXaWR0aCk7XG4gICAgdGhpcy5fc2xpZGluZ0VsZW1lbnRzID0gdGhpcy5fZ2V0U2xpZGluZ0VsZW1lbnRzKCk7XG5cbiAgICBzZXRUaW1lb3V0KCgpID0+IHsgLy8gRml4OiBUaW1lIHRvIHVwZGF0ZSBwcmV2aW91cyB0cmFuc2xhdGUzZCBhZnRlciBjaGFuZ2luZyBzdHlsZS5kaXNwbGF5XG4gICAgICBhbmltaXQucnVuQWxsKFxuICAgICAgICBhbmltaXQodGhpcy5fc2xpZGluZ0VsZW1lbnRzKVxuICAgICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogYHRyYW5zbGF0ZTNkKCR7dGhpcy5taW51cyArIHRoaXMubWF4V2lkdGh9cHgsIDAsIDApYFxuICAgICAgICAgIH0sIHRoaXMuZGVmKSxcblxuICAgICAgICBhbmltaXQodGhpcy5fbWFzaylcbiAgICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgICBkaXNwbGF5OiAnYmxvY2snXG4gICAgICAgICAgfSksXG5cbiAgICAgICAgYW5pbWl0KHRoaXMuX3NpZGUuX2NvbnRlbnQpXG4gICAgICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgICAgICAucXVldWUobWVudVN0eWxlLmNvbnRlbnQsIHRoaXMuZGVmKSxcblxuICAgICAgICBhbmltaXQodGhpcy5fc2lkZSlcbiAgICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAgIC5xdWV1ZShtZW51U3R5bGUuY29udGFpbmVyLCB0aGlzLmRlZilcbiAgICAgICAgICAucXVldWUoY2FsbGJhY2sgPT4ge1xuICAgICAgICAgICAgdGhpcy5fc2xpZGluZ0VsZW1lbnRzID0gbnVsbDtcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICBkb25lICYmIGRvbmUoKTtcbiAgICAgICAgICB9KSxcbiAgICAgICk7XG4gICAgfSwgMTAwMC82MCk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZG9uZVxuICAgKi9cbiAgY2xvc2UoZG9uZSkge1xuICAgIGNvbnN0IG1lbnVTdHlsZSA9IHRoaXMuX2dlbmVyYXRlQmVoaW5kUGFnZVN0eWxlKDApO1xuICAgIHRoaXMuX3NsaWRpbmdFbGVtZW50cyA9IHRoaXMuX2dldFNsaWRpbmdFbGVtZW50cygpO1xuXG4gICAgYW5pbWl0LnJ1bkFsbChcbiAgICAgIGFuaW1pdCh0aGlzLl9zbGlkaW5nRWxlbWVudHMpXG4gICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoMCwgMCwgMCknXG4gICAgICAgIH0sIHRoaXMuZGVmKSxcblxuICAgICAgYW5pbWl0KHRoaXMuX21hc2spXG4gICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgZGlzcGxheTogJ25vbmUnXG4gICAgICAgIH0pLFxuXG4gICAgICBhbmltaXQodGhpcy5fc2lkZS5fY29udGVudClcbiAgICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgICAgLnF1ZXVlKG1lbnVTdHlsZS5jb250ZW50LCB0aGlzLmRlZiksXG5cbiAgICAgIGFuaW1pdCh0aGlzLl9zaWRlKVxuICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAucXVldWUobWVudVN0eWxlLmNvbnRhaW5lciwgdGhpcy5kZWYpXG4gICAgICAgIC5xdWV1ZShjYWxsYmFjayA9PiB7XG4gICAgICAgICAgdGhpcy5fc2xpZGluZ0VsZW1lbnRzID0gbnVsbDtcbiAgICAgICAgICB0aGlzLl9zaWRlLnN0eWxlLnpJbmRleCA9IDA7XG4gICAgICAgICAgdGhpcy5fc2lkZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICAgIHRoaXMuX3NpZGUuX2NvbnRlbnQuc3R5bGUub3BhY2l0eSA9ICcnO1xuICAgICAgICAgIGRvbmUgJiYgZG9uZSgpO1xuICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgIH0pLFxuICAgICk7XG4gIH1cblxuICBfZ2V0TWF4V2lkdGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NpZGUub2Zmc2V0V2lkdGg7XG4gIH1cbn1cbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCBvbnNFbGVtZW50cyBmcm9tICcuLi8uLi9vbnMvZWxlbWVudHMnO1xuaW1wb3J0IHV0aWwgZnJvbSAnLi4vLi4vb25zL3V0aWwnO1xuaW1wb3J0IE1vZGlmaWVyVXRpbCBmcm9tICcuLi8uLi9vbnMvaW50ZXJuYWwvbW9kaWZpZXItdXRpbCc7XG5pbXBvcnQgQW5pbWF0b3JGYWN0b3J5IGZyb20gJy4uLy4uL29ucy9pbnRlcm5hbC9hbmltYXRvci1mYWN0b3J5JztcbmltcG9ydCBPdmVybGF5U3BsaXR0ZXJBbmltYXRvciBmcm9tICcuL292ZXJsYXktYW5pbWF0b3InO1xuaW1wb3J0IFB1c2hTcGxpdHRlckFuaW1hdG9yIGZyb20gJy4vcHVzaC1hbmltYXRvcic7XG5pbXBvcnQgUmV2ZWFsU3BsaXR0ZXJBbmltYXRvciBmcm9tICcuL3JldmVhbC1hbmltYXRvcic7XG5pbXBvcnQgQmFzZUVsZW1lbnQgZnJvbSAnLi4vYmFzZS9iYXNlLWVsZW1lbnQnO1xuaW1wb3J0IGRldmljZUJhY2tCdXR0b25EaXNwYXRjaGVyIGZyb20gJy4uLy4uL29ucy9pbnRlcm5hbC9kZXZpY2UtYmFjay1idXR0b24tZGlzcGF0Y2hlcic7XG5pbXBvcnQgY29udGVudFJlYWR5IGZyb20gJy4uLy4uL29ucy9jb250ZW50LXJlYWR5JztcblxuY29uc3QgX2FuaW1hdG9yRGljdCA9IHtcbiAgZGVmYXVsdDogT3ZlcmxheVNwbGl0dGVyQW5pbWF0b3IsXG4gIG92ZXJsYXk6IE92ZXJsYXlTcGxpdHRlckFuaW1hdG9yLFxuICBwdXNoOiBQdXNoU3BsaXR0ZXJBbmltYXRvcixcbiAgcmV2ZWFsOiBSZXZlYWxTcGxpdHRlckFuaW1hdG9yXG59O1xuXG4vKipcbiAqIEBlbGVtZW50IG9ucy1zcGxpdHRlclxuICogQGNhdGVnb3J5IG1lbnVcbiAqIEBkZXNjcmlwdGlvblxuICogIFtlbl1cbiAqICAgIEEgY29tcG9uZW50IHRoYXQgZW5hYmxlcyByZXNwb25zaXZlIGxheW91dCBieSBpbXBsZW1lbnRpbmcgYm90aCBhIHR3by1jb2x1bW4gbGF5b3V0IGFuZCBhIHNsaWRpbmcgbWVudSBsYXlvdXQuXG4gKlxuICogICAgSXQgY2FuIGJlIGNvbmZpZ3VyZWQgdG8gYXV0b21hdGljYWxseSBleHBhbmQgaW50byBhIGNvbHVtbiBsYXlvdXQgb24gbGFyZ2Ugc2NyZWVucyBhbmQgY29sbGFwc2UgdGhlIG1lbnUgb24gc21hbGxlciBzY3JlZW5zLiBXaGVuIHRoZSBtZW51IGlzIGNvbGxhcHNlZCB0aGUgdXNlciBjYW4gb3BlbiBpdCBieSBzd2lwaW5nLlxuICogIFsvZW5dXG4gKiAgW2phXVsvamFdXG4gKiBAY29kZXBlbiByT1FPTUxcbiAqIEB0dXRvcmlhbCB2YW5pbGxhL1JlZmVyZW5jZS9zcGxpdHRlclxuICogQGd1aWRlIGZ1bmRhbWVudGFscy5odG1sI21hbmFnaW5nLXBhZ2VzXG4gKiAgW2VuXU1hbmFnaW5nIG11bHRpcGxlIHBhZ2VzLlsvZW5dXG4gKiAgW2phXeikh+aVsOOBruODmuODvOOCuOOCkueuoeeQhuOBmeOCi1svamFdXG4gKiBAc2VlYWxzbyBvbnMtc3BsaXR0ZXItY29udGVudFxuICogIFtlbl1UaGUgYDxvbnMtc3BsaXR0ZXItY29udGVudD5gIGNvbXBvbmVudCBjb250YWlucyB0aGUgbWFpbiBjb250ZW50IG9mIHRoZSBwYWdlLlsvZW5dXG4gKiAgW2phXW9ucy1zcGxpdHRlci1jb250ZW5044Kz44Oz44Od44O844ON44Oz44OIWy9qYV1cbiAqIEBzZWVhbHNvIG9ucy1zcGxpdHRlci1zaWRlXG4gKiAgW2VuXVRoZSBgPG9ucy1zcGxpdHRlci1zaWRlPmAgY29tcG9uZW50IGNvbnRhaW5zIHRoZSBtZW51LlsvZW5dXG4gKiAgW2phXW9ucy1zcGxpdHRlci1zaWRl44Kz44Oz44Od44O844ON44Oz44OIWy9qYV1cbiAqIEBleGFtcGxlXG4gKiA8b25zLXNwbGl0dGVyIGlkPVwic3BsaXR0ZXJcIj5cbiAqICAgPG9ucy1zcGxpdHRlci1jb250ZW50PlxuICogICAgIC4uLlxuICogICA8L29ucy1zcGxpdHRlci1jb250ZW50PlxuICpcbiAqICAgPG9ucy1zcGxpdHRlci1zaWRlIHNpZGU9XCJsZWZ0XCIgd2lkdGg9XCI4MCVcIiBjb2xsYXBzZSBzd2lwZWFibGU+XG4gKiAgICAgLi4uXG4gKiAgIDwvb25zLXNwbGl0dGVyLXNpZGU+XG4gKiA8L29ucy1zcGxpdHRlcj5cbiAqXG4gKiA8c2NyaXB0PlxuICogICB2YXIgc3BsaXR0ZXIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc3BsaXR0ZXInKTtcbiAqICAgc3BsaXR0ZXIubGVmdC5vcGVuKCk7XG4gKiA8L3NjcmlwdD5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU3BsaXR0ZXJFbGVtZW50IGV4dGVuZHMgQmFzZUVsZW1lbnQge1xuXG4gIF9nZXRTaWRlKHNpZGUpIHtcbiAgICBjb25zdCBlbGVtZW50ID0gdXRpbC5maW5kQ2hpbGQodGhpcywgZSA9PiB7XG4gICAgICByZXR1cm4gdXRpbC5tYXRjaChlLCAnb25zLXNwbGl0dGVyLXNpZGUnKSAmJiBlLmdldEF0dHJpYnV0ZSgnc2lkZScpID09PSBzaWRlO1xuICAgIH0pO1xuICAgIHJldHVybiBlbGVtZW50O1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBsZWZ0XG4gICAqIEByZWFkb25seVxuICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1MZWZ0IGA8b25zLXNwbGl0dGVyLXNpZGU+YCBlbGVtZW50LlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuICBnZXQgbGVmdCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0U2lkZSgnbGVmdCcpO1xuICB9XG4gIC8qKlxuICAgKiBAcHJvcGVydHkgcmlnaHRcbiAgICogQHJlYWRvbmx5XG4gICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVJpZ2h0IGA8b25zLXNwbGl0dGVyLXNpZGU+YCBlbGVtZW50LlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuICBnZXQgcmlnaHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldFNpZGUoJ3JpZ2h0Jyk7XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IHNpZGVcbiAgICogQHJlYWRvbmx5XG4gICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUZpcnN0IGA8b25zLXNwbGl0dGVyLXNpZGU+YCBlbGVtZW50IHJlZ2FyZGxlc3MgdGhlIGFjdHVhbCBzaWRlLlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuICBnZXQgc2lkZSgpIHtcbiAgICByZXR1cm4gdXRpbC5maW5kQ2hpbGQodGhpcywgJ29ucy1zcGxpdHRlci1zaWRlJyk7XG4gIH1cblxuICBnZXQgX3NpZGVzKCkge1xuICAgIHJldHVybiBbdGhpcy5sZWZ0LCB0aGlzLnJpZ2h0XS5maWx0ZXIoZSA9PiBlKTtcbiAgfVxuICAvKipcbiAgICogQHByb3BlcnR5IGNvbnRlbnRcbiAgICogQHJlYWRvbmx5XG4gICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVRoZSBgPG9ucy1zcGxpdHRlci1jb250ZW50PmAgZWxlbWVudC5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cbiAgZ2V0IGNvbnRlbnQoKSB7XG4gICAgcmV0dXJuIHV0aWwuZmluZENoaWxkKHRoaXMsICdvbnMtc3BsaXR0ZXItY29udGVudCcpO1xuICB9XG5cbiAgZ2V0IHRvcFBhZ2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29udGVudC5fY29udGVudDtcbiAgfVxuXG4gIGdldCBtYXNrKCkge1xuICAgIHJldHVybiB1dGlsLmZpbmRDaGlsZCh0aGlzLCAnb25zLXNwbGl0dGVyLW1hc2snKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgb25EZXZpY2VCYWNrQnV0dG9uXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1CYWNrLWJ1dHRvbiBoYW5kbGVyLlsvZW5dXG4gICAqICAgW2phXeODkOODg+OCr+ODnOOCv+ODs+ODj+ODs+ODieODqeOAglsvamFdXG4gICAqL1xuICBnZXQgb25EZXZpY2VCYWNrQnV0dG9uKCkge1xuICAgIHJldHVybiB0aGlzLl9iYWNrQnV0dG9uSGFuZGxlcjtcbiAgfVxuXG4gIHNldCBvbkRldmljZUJhY2tCdXR0b24oY2FsbGJhY2spIHtcbiAgICBpZiAodGhpcy5fYmFja0J1dHRvbkhhbmRsZXIpIHtcbiAgICAgIHRoaXMuX2JhY2tCdXR0b25IYW5kbGVyLmRlc3Ryb3koKTtcbiAgICB9XG5cbiAgICB0aGlzLl9iYWNrQnV0dG9uSGFuZGxlciA9IGRldmljZUJhY2tCdXR0b25EaXNwYXRjaGVyLmNyZWF0ZUhhbmRsZXIodGhpcywgY2FsbGJhY2spO1xuICB9XG5cbiAgX29uRGV2aWNlQmFja0J1dHRvbihldmVudCkge1xuICAgIHRoaXMuX3NpZGVzLnNvbWUocyA9PiBzLmlzT3BlbiA/IHMuY2xvc2UoKSA6IGZhbHNlKSB8fCBldmVudC5jYWxsUGFyZW50SGFuZGxlcigpO1xuICB9XG5cbiAgX29uTW9kZUNoYW5nZShlKSB7XG4gICAgaWYgKGUudGFyZ2V0LnBhcmVudE5vZGUpIHtcbiAgICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB7XG4gICAgICAgIHRoaXMuX2xheW91dCgpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgX2xheW91dCgpIHtcbiAgICB0aGlzLl9zaWRlcy5mb3JFYWNoKHNpZGUgPT4ge1xuICAgICAgaWYgKHRoaXMuY29udGVudCkge1xuICAgICAgICB0aGlzLmNvbnRlbnQuc3R5bGVbc2lkZS5zaWRlXSA9IHNpZGUubW9kZSA9PT0gJ3NwbGl0JyA/IHNpZGUuc3R5bGUud2lkdGggOiAwO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIHRoaXMuX29uTW9kZUNoYW5nZSA9IHRoaXMuX29uTW9kZUNoYW5nZS5iaW5kKHRoaXMpO1xuXG4gICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHtcbiAgICAgICF0aGlzLm1hc2sgJiYgdGhpcy5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdvbnMtc3BsaXR0ZXItbWFzaycpKTtcbiAgICAgIHRoaXMuX2xheW91dCgpO1xuICAgIH0pO1xuICB9XG5cbiAgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgdGhpcy5vbkRldmljZUJhY2tCdXR0b24gPSB0aGlzLl9vbkRldmljZUJhY2tCdXR0b24uYmluZCh0aGlzKTtcbiAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ21vZGVjaGFuZ2UnLCB0aGlzLl9vbk1vZGVDaGFuZ2UsIGZhbHNlKTtcbiAgfVxuXG4gIGRpc2Nvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIHRoaXMuX2JhY2tCdXR0b25IYW5kbGVyLmRlc3Ryb3koKTtcbiAgICB0aGlzLl9iYWNrQnV0dG9uSGFuZGxlciA9IG51bGw7XG4gICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCdtb2RlY2hhbmdlJywgdGhpcy5fb25Nb2RlQ2hhbmdlLCBmYWxzZSk7XG4gIH1cblxuICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgbGFzdCwgY3VycmVudCkge31cblxuICBfc2hvdygpIHtcbiAgICB1dGlsLnByb3BhZ2F0ZUFjdGlvbih0aGlzLCAnX3Nob3cnKTtcbiAgfVxuXG4gIF9oaWRlKCkge1xuICAgIHV0aWwucHJvcGFnYXRlQWN0aW9uKHRoaXMsICdfaGlkZScpO1xuICB9XG5cbiAgX2Rlc3Ryb3koKSB7XG4gICAgdXRpbC5wcm9wYWdhdGVBY3Rpb24odGhpcywgJ19kZXN0cm95Jyk7XG4gICAgdGhpcy5yZW1vdmUoKTtcbiAgfVxuXG4gIHN0YXRpYyByZWdpc3RlckFuaW1hdG9yKG5hbWUsIEFuaW1hdG9yKSB7XG4gICAgaWYgKCEoQW5pbWF0b3IgaW5zdGFuY2VvZiBTcGxpdHRlckFuaW1hdG9yKSkge1xuICAgICAgdXRpbC50aHJvd0FuaW1hdG9yKCdTcGxpdHRlcicpO1xuICAgIH1cbiAgICBfYW5pbWF0b3JEaWN0W25hbWVdID0gQW5pbWF0b3I7XG4gIH1cblxuICBzdGF0aWMgZ2V0IFNwbGl0dGVyQW5pbWF0b3IoKSB7XG4gICAgcmV0dXJuIFNwbGl0dGVyQW5pbWF0b3I7XG4gIH1cblxuICBzdGF0aWMgZ2V0IGFuaW1hdG9ycygpIHtcbiAgICByZXR1cm4gX2FuaW1hdG9yRGljdDtcbiAgfVxufVxuXG5vbnNFbGVtZW50cy5TcGxpdHRlciA9IFNwbGl0dGVyRWxlbWVudDtcbmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnb25zLXNwbGl0dGVyJywgU3BsaXR0ZXJFbGVtZW50KTtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCBvbnNFbGVtZW50cyBmcm9tICcuLi9vbnMvZWxlbWVudHMnO1xuaW1wb3J0IHV0aWwgZnJvbSAnLi4vb25zL3V0aWwnO1xuaW1wb3J0IEFuaW1hdG9yRmFjdG9yeSBmcm9tICcuLi9vbnMvaW50ZXJuYWwvYW5pbWF0b3ItZmFjdG9yeSc7XG5pbXBvcnQgb3JpZW50YXRpb24gZnJvbSAnLi4vb25zL29yaWVudGF0aW9uJztcbmltcG9ydCBpbnRlcm5hbCBmcm9tICcuLi9vbnMvaW50ZXJuYWwnO1xuaW1wb3J0IE1vZGlmaWVyVXRpbCBmcm9tICcuLi9vbnMvaW50ZXJuYWwvbW9kaWZpZXItdXRpbCc7XG5pbXBvcnQgQmFzZUVsZW1lbnQgZnJvbSAnLi9iYXNlL2Jhc2UtZWxlbWVudCc7XG5pbXBvcnQgU3BsaXR0ZXJBbmltYXRvciBmcm9tICcuL29ucy1zcGxpdHRlci9hbmltYXRvcic7XG5pbXBvcnQgU3dpcGVSZXZlYWwgZnJvbSAnLi4vb25zL2ludGVybmFsL3N3aXBlLXJldmVhbCc7XG5pbXBvcnQgRG9vckxvY2sgZnJvbSAnLi4vb25zL2Rvb3Jsb2NrJztcbmltcG9ydCBjb250ZW50UmVhZHkgZnJvbSAnLi4vb25zL2NvbnRlbnQtcmVhZHknO1xuaW1wb3J0IHsgUGFnZUxvYWRlciwgZGVmYXVsdFBhZ2VMb2FkZXJ9IGZyb20gJy4uL29ucy9wYWdlLWxvYWRlcic7XG5pbXBvcnQgU3BsaXR0ZXJFbGVtZW50IGZyb20gJy4vb25zLXNwbGl0dGVyJztcblxuY29uc3QgU1BMSVRfTU9ERSA9ICdzcGxpdCc7XG5jb25zdCBDT0xMQVBTRV9NT0RFID0gJ2NvbGxhcHNlJztcbmNvbnN0IENMT1NFRF9TVEFURSA9ICdjbG9zZWQnO1xuY29uc3QgT1BFTl9TVEFURSA9ICdvcGVuJztcbmNvbnN0IENIQU5HSU5HX1NUQVRFID0gJ2NoYW5naW5nJztcblxuY29uc3QgcmV3cml0YWJsZXMgPSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IHNwbGl0dGVyU2lkZUVsZW1lbnRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICovXG4gIHJlYWR5KHNwbGl0dGVyU2lkZUVsZW1lbnQsIGNhbGxiYWNrKSB7XG4gICAgc2V0SW1tZWRpYXRlKGNhbGxiYWNrKTtcbiAgfVxufTtcblxuY2xhc3MgQ29sbGFwc2VEZXRlY3Rpb24ge1xuICBjb25zdHJ1Y3RvcihlbGVtZW50LCB0YXJnZXQpIHtcbiAgICB0aGlzLl9lbGVtZW50ID0gZWxlbWVudDtcbiAgICB0aGlzLl9vbkNoYW5nZSA9IHRoaXMuX29uQ2hhbmdlLmJpbmQodGhpcyk7XG4gICAgdGFyZ2V0ICYmIHRoaXMuY2hhbmdlVGFyZ2V0KHRhcmdldCk7XG4gIH1cblxuICBjaGFuZ2VUYXJnZXQodGFyZ2V0KSB7XG4gICAgdGhpcy5kaXNhYmxlKCk7XG4gICAgdGhpcy5fdGFyZ2V0ID0gdGFyZ2V0O1xuICAgIGlmICh0YXJnZXQpIHtcbiAgICAgIHRoaXMuX29yaWVudGF0aW9uID0gWydwb3J0cmFpdCcsICdsYW5kc2NhcGUnXS5pbmRleE9mKHRhcmdldCkgIT09IC0xO1xuICAgICAgdGhpcy5hY3RpdmF0ZSgpO1xuICAgIH1cbiAgfVxuXG4gIF9tYXRjaCh2YWx1ZSkge1xuICAgIGlmICh0aGlzLl9vcmllbnRhdGlvbikge1xuICAgICAgcmV0dXJuIHRoaXMuX3RhcmdldCA9PT0gKHZhbHVlLmlzUG9ydHJhaXQgPyAncG9ydHJhaXQnIDogJ2xhbmRzY2FwZScpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWUubWF0Y2hlcztcbiAgfVxuXG4gIF9vbkNoYW5nZSh2YWx1ZSkge1xuICAgIHRoaXMuX2VsZW1lbnQuX3VwZGF0ZU1vZGUodGhpcy5fbWF0Y2godmFsdWUpID8gQ09MTEFQU0VfTU9ERSA6IFNQTElUX01PREUpO1xuICB9XG5cbiAgYWN0aXZhdGUoKSB7XG4gICAgaWYgKHRoaXMuX29yaWVudGF0aW9uKSB7XG4gICAgICBvcmllbnRhdGlvbi5vbignY2hhbmdlJywgdGhpcy5fb25DaGFuZ2UpO1xuICAgICAgdGhpcy5fb25DaGFuZ2Uoe2lzUG9ydHJhaXQ6IG9yaWVudGF0aW9uLmlzUG9ydHJhaXQoKX0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9xdWVyeVJlc3VsdCA9IHdpbmRvdy5tYXRjaE1lZGlhKHRoaXMuX3RhcmdldCk7XG4gICAgICB0aGlzLl9xdWVyeVJlc3VsdC5hZGRMaXN0ZW5lcih0aGlzLl9vbkNoYW5nZSk7XG4gICAgICB0aGlzLl9vbkNoYW5nZSh0aGlzLl9xdWVyeVJlc3VsdCk7XG4gICAgfVxuICB9XG5cbiAgZGlzYWJsZSgpIHtcbiAgICBpZiAodGhpcy5fb3JpZW50YXRpb24pIHtcbiAgICAgIG9yaWVudGF0aW9uLm9mZignY2hhbmdlJywgdGhpcy5fb25DaGFuZ2UpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5fcXVlcnlSZXN1bHQpIHtcbiAgICAgIHRoaXMuX3F1ZXJ5UmVzdWx0LnJlbW92ZUxpc3RlbmVyKHRoaXMuX29uQ2hhbmdlKTtcbiAgICAgIHRoaXMuX3F1ZXJ5UmVzdWx0ID0gbnVsbDtcbiAgICB9XG4gIH1cbn1cblxuY29uc3Qgd2lkdGhUb1B4ID0gKHdpZHRoLCBwYXJlbnQpID0+IHtcbiAgY29uc3QgW3ZhbHVlLCBweF0gPSBbcGFyc2VJbnQod2lkdGgsIDEwKSwgL3B4Ly50ZXN0KHdpZHRoKV07XG4gIHJldHVybiBweCA/IHZhbHVlIDogTWF0aC5yb3VuZChwYXJlbnQub2Zmc2V0V2lkdGggKiB2YWx1ZSAvIDEwMCk7XG59O1xuXG4vKipcbiAqIEBlbGVtZW50IG9ucy1zcGxpdHRlci1zaWRlXG4gKiBAY2F0ZWdvcnkgbWVudVxuICogQGRlc2NyaXB0aW9uXG4gKiAgW2VuXVxuICogICAgVGhlIGA8b25zLXNwbGl0dGVyLXNpZGU+YCBlbGVtZW50IGlzIHVzZWQgYXMgYSBjaGlsZCBlbGVtZW50IG9mIGA8b25zLXNwbGl0dGVyPmAuXG4gKlxuICogICAgSXQgd2lsbCBiZSBkaXNwbGF5ZWQgb24gZWl0aGVyIHRoZSBsZWZ0IG9yIHJpZ2h0IHNpZGUgb2YgdGhlIGA8b25zLXNwbGl0dGVyLWNvbnRlbnQ+YCBlbGVtZW50LlxuICpcbiAqICAgIEl0IHN1cHBvcnRzIHR3byBtb2RlczogY29sbGFwc2VkIGFuZCBzcGxpdC4gV2hlbiBpdCdzIGluIGNvbGxhcHNlZCBtb2RlIGl0IHdpbGwgYmUgaGlkZGVuIGZyb20gdmlldyBhbmQgY2FuIGJlIGRpc3BsYXllZCB3aGVuIHRoZSB1c2VyIHN3aXBlcyB0aGUgc2NyZWVuIG9yIHRhcHMgYSBidXR0b24uIEluIHNwbGl0IG1vZGUgdGhlIGVsZW1lbnQgaXMgYWx3YXlzIHNob3duLiBJdCBjYW4gYmUgY29uZmlndXJlZCB0byBhdXRvbWF0aWNhbGx5IHN3aXRjaCBiZXR3ZWVuIHRoZSB0d28gbW9kZXMgZGVwZW5kaW5nIG9uIHRoZSBzY3JlZW4gc2l6ZS5cbiAqICBbL2VuXVxuICogIFtqYV1vbnMtc3BsaXR0ZXItc2lkZeimgee0oOOBr+OAgW9ucy1zcGxpdHRlcuimgee0oOOBruWtkOimgee0oOOBqOOBl+OBpuWIqeeUqOOBl+OBvuOBmeOAglsvamFdXG4gKiBAY29kZXBlbiByT1FPTUxcbiAqIEB0dXRvcmlhbCB2YW5pbGxhL1JlZmVyZW5jZS9zcGxpdHRlclxuICogQGd1aWRlIGZ1bmRhbWVudGFscy5odG1sI21hbmFnaW5nLXBhZ2VzXG4gKiAgW2VuXU1hbmFnaW5nIG11bHRpcGxlIHBhZ2VzLlsvZW5dXG4gKiAgW2phXeikh+aVsOOBruODmuODvOOCuOOCkueuoeeQhuOBmeOCi1svamFdXG4gKiBAc2VlYWxzbyBvbnMtc3BsaXR0ZXJcbiAqICBbZW5dVGhlIGA8b25zLXNwbGl0dGVyPmAgaXMgdGhlIHBhcmVudCBjb21wb25lbnQuWy9lbl1cbiAqICBbamFdb25zLXNwbGl0dGVy44Kz44Oz44Od44O844ON44Oz44OIWy9qYV1cbiAqIEBzZWVhbHNvIG9ucy1zcGxpdHRlci1jb250ZW50XG4gKiAgW2VuXVRoZSBgPG9ucy1zcGxpdHRlci1jb250ZW50PmAgY29tcG9uZW50IGNvbnRhaW5zIHRoZSBtYWluIGNvbnRlbnQgb2YgdGhlIHBhZ2UuWy9lbl1cbiAqICBbamFdb25zLXNwbGl0dGVyLWNvbnRlbnTjgrPjg7Pjg53jg7zjg43jg7Pjg4hbL2phXVxuICogQGV4YW1wbGVcbiAqIDxvbnMtc3BsaXR0ZXI+XG4gKiAgIDxvbnMtc3BsaXR0ZXItY29udGVudD5cbiAqICAgICAuLi5cbiAqICAgPC9vbnMtc3BsaXR0ZXItY29udGVudD5cbiAqXG4gKiAgIDxvbnMtc3BsaXR0ZXItc2lkZSBzaWRlPVwibGVmdFwiIHdpZHRoPVwiODAlXCIgY29sbGFwc2U+XG4gKiAgICAgLi4uXG4gKiAgIDwvb25zLXNwbGl0dGVyLXNpZGU+XG4gKiA8L29ucy1zcGxpdHRlcj5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU3BsaXR0ZXJTaWRlRWxlbWVudCBleHRlbmRzIEJhc2VFbGVtZW50IHtcblxuICAvKipcbiAgICogQGV2ZW50IG1vZGVjaGFuZ2VcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUZpcmVkIGp1c3QgYWZ0ZXIgdGhlIGNvbXBvbmVudCdzIG1vZGUgY2hhbmdlcy5bL2VuXVxuICAgKiAgIFtqYV3jgZPjga7opoHntKDjga7jg6Ljg7zjg4njgYzlpInljJbjgZfjgZ/pmpvjgavnmbrngavjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnRcbiAgICogICBbZW5dRXZlbnQgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCpOODmeODs+ODiOOCquODluOCuOOCp+OCr+ODiOOBp+OBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5zaWRlXG4gICAqICAgW2VuXUNvbXBvbmVudCBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Kz44Oz44Od44O844ON44Oz44OI44Gu44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50Lm1vZGVcbiAgICogICBbZW5dUmV0dXJucyB0aGUgY3VycmVudCBtb2RlLiBDYW4gYmUgZWl0aGVyIGBcImNvbGxhcHNlXCJgIG9yIGBcInNwbGl0XCJgLlsvZW5dXG4gICAqICAgW2phXeePvuWcqOOBruODouODvOODieOCkui/lOOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAZXZlbnQgcHJlb3BlblxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dRmlyZWQganVzdCBiZWZvcmUgdGhlIHNsaWRpbmcgbWVudSBpcyBvcGVuZWQuWy9lbl1cbiAgICogICBbamFd44K544Op44Kk44OH44Kj44Oz44Kw44Oh44OL44Ol44O844GM6ZaL44GP5YmN44Gr55m654Gr44GX44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50XG4gICAqICAgW2VuXUV2ZW50IG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgqTjg5njg7Pjg4jjgqrjg5bjgrjjgqfjgq/jg4jjgafjgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBldmVudC5jYW5jZWxcbiAgICogICBbZW5dQ2FsbCB0byBjYW5jZWwgb3BlbmluZyBzbGlkaW5nIG1lbnUuWy9lbl1cbiAgICogICBbamFd44K544Op44Kk44OH44Kj44Oz44Kw44Oh44OL44Ol44O844GM6ZaL44GP44Gu44KS44Kt44Oj44Oz44K744Or44GX44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50LnNpZGVcbiAgICogICBbZW5dQ29tcG9uZW50IG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgrPjg7Pjg53jg7zjg43jg7Pjg4jjga7jgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGV2ZW50IHBvc3RvcGVuXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1GaXJlZCBqdXN0IGFmdGVyIHRoZSBzbGlkaW5nIG1lbnUgaXMgb3BlbmVkLlsvZW5dXG4gICAqICAgW2phXeOCueODqeOCpOODh+OCo+ODs+OCsOODoeODi+ODpeODvOOBjOmWi+OBhOOBn+W+jOOBq+eZuueBq+OBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudFxuICAgKiAgIFtlbl1FdmVudCBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Kk44OZ44Oz44OI44Kq44OW44K444Kn44Kv44OI44Gn44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50LnNpZGVcbiAgICogICBbZW5dQ29tcG9uZW50IG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgrPjg7Pjg53jg7zjg43jg7Pjg4jjga7jgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGV2ZW50IHByZWNsb3NlXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1GaXJlZCBqdXN0IGJlZm9yZSB0aGUgc2xpZGluZyBtZW51IGlzIGNsb3NlZC5bL2VuXVxuICAgKiAgIFtqYV3jgrnjg6njgqTjg4fjgqPjg7PjgrDjg6Hjg4vjg6Xjg7zjgYzplonjgZjjgovliY3jgavnmbrngavjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnRcbiAgICogICBbZW5dRXZlbnQgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCpOODmeODs+ODiOOCquODluOCuOOCp+OCr+ODiOOBp+OBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5zaWRlXG4gICAqICAgW2VuXUNvbXBvbmVudCBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Kz44Oz44Od44O844ON44Oz44OI44Gu44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZXZlbnQuY2FuY2VsXG4gICAqICAgW2VuXUNhbGwgdG8gY2FuY2VsIG9wZW5pbmcgc2xpZGluZy1tZW51LlsvZW5dXG4gICAqICAgW2phXeOCueODqeOCpOODh+OCo+ODs+OCsOODoeODi+ODpeODvOOBjOmWieOBmOOCi+OBruOCkuOCreODo+ODs+OCu+ODq+OBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAZXZlbnQgcG9zdGNsb3NlXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1GaXJlZCBqdXN0IGFmdGVyIHRoZSBzbGlkaW5nIG1lbnUgaXMgY2xvc2VkLlsvZW5dXG4gICAqICAgW2phXeOCueODqeOCpOODh+OCo+ODs+OCsOODoeODi+ODpeODvOOBjOmWieOBmOOBn+W+jOOBq+eZuueBq+OBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudFxuICAgKiAgIFtlbl1FdmVudCBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Kk44OZ44Oz44OI44Kq44OW44K444Kn44Kv44OI44Gn44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50LnNpZGVcbiAgICogICBbZW5dQ29tcG9uZW50IG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgrPjg7Pjg53jg7zjg43jg7Pjg4jjga7jgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBhbmltYXRpb25cbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlZmF1bHQgIGRlZmF1bHRcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dU3BlY2lmeSB0aGUgYW5pbWF0aW9uLiBVc2Ugb25lIG9mIGBvdmVybGF5YCwgYHB1c2hgLCBgcmV2ZWFsYCBvciAgYGRlZmF1bHRgLlsvZW5dXG4gICAqICBbamFd44Ki44OL44Oh44O844K344On44Oz44KS5oyH5a6a44GX44G+44GZ44CCXCJvdmVybGF5XCIsIFwicHVzaFwiLCBcInJldmVhbFwiLCBcImRlZmF1bHRcIuOBruOBhOOBmuOCjOOBi+OCkuaMh+WumuOBp+OBjeOBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGFuaW1hdGlvbi1vcHRpb25zXG4gICAqIEB0eXBlIHtFeHByZXNzaW9ufVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFtlbl1TcGVjaWZ5IHRoZSBhbmltYXRpb24ncyBkdXJhdGlvbiwgdGltaW5nIGFuZCBkZWxheSB3aXRoIGFuIG9iamVjdCBsaXRlcmFsLiBFLmcuIGB7ZHVyYXRpb246IDAuMiwgZGVsYXk6IDEsIHRpbWluZzogJ2Vhc2UtaW4nfWAuWy9lbl1cbiAgICogIFtqYV3jgqLjg4vjg6Hjg7zjgrfjg6fjg7PmmYLjga5kdXJhdGlvbiwgdGltaW5nLCBkZWxheeOCkuOCquODluOCuOOCp+OCr+ODiOODquODhuODqeODq+OBp+aMh+WumuOBl+OBvuOBmeOAgmUuZy4ge2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAxLCB0aW1pbmc6ICdlYXNlLWluJ31bL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBvcGVuLXRocmVzaG9sZFxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAZGVmYXVsdCAgMC4zXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXVNwZWNpZnkgaG93IG11Y2ggdGhlIG1lbnUgbmVlZHMgdG8gYmUgc3dpcGVkIGJlZm9yZSBvcGVuaW5nLiBBIHZhbHVlIGJldHdlZW4gYDBgIGFuZCBgMWAuWy9lbl1cbiAgICogIFtqYV3jganjga7jgY/jgonjgYTjgrnjg6/jgqTjg5fjgZnjgozjgbDjgrnjg6njgqTjg4fjgqPjg7PjgrDjg6Hjg4vjg6Xjg7zjgpLplovjgY/jgYvjganjgYbjgYvjga7libLlkIjjgpLmjIflrprjgZfjgb7jgZnjgIIw44GL44KJMeOBrumWk+OBruaVsOWApOOCkuaMh+WumuOBl+OBvuOBmeOAguOCueODr+OCpOODl+OBrui3nembouOBjOOBk+OBk+OBp+aMh+WumuOBl+OBn+aVsOWApOaOm+OBkeOCi+OBk+OBruimgee0oOOBruW5heOCiOOCiuOCguWkp+OBjeOBkeOCjOOBsOOAgeOCueODr+OCpOODl+OBjOe1guOCj+OBo+OBn+aZguOBq+OBk+OBruimgee0oOOCkumWi+OBjeOBvuOBmeOAguODh+ODleOCqeODq+ODiOOBrzAuM+OBp+OBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGNvbGxhcHNlXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1cbiAgICogICAgIFNwZWNpZnkgdGhlIGNvbGxhcHNlIGJlaGF2aW9yLiBWYWxpZCB2YWx1ZXMgYXJlIGBcInBvcnRyYWl0XCJgLCBgXCJsYW5kc2NhcGVcImAgb3IgYSBtZWRpYSBxdWVyeS5cbiAgICogICAgIFRoZSBzdHJpbmdzIGBcInBvcnRyYWl0XCJgIGFuZCBgXCJsYW5kc2NhcGVcImAgbWVhbnMgdGhlIHZpZXcgd2lsbCBjb2xsYXBzZSB3aGVuIGRldmljZSBpcyBpbiBsYW5kc2NhcGUgb3IgcG9ydHJhaXQgb3JpZW50YXRpb24uXG4gICAqICAgICBJZiB0aGUgdmFsdWUgaXMgYSBtZWRpYSBxdWVyeSwgdGhlIHZpZXcgd2lsbCBjb2xsYXBzZSB3aGVuIHRoZSBtZWRpYSBxdWVyeSByZXNvbHZlcyB0byBgdHJ1ZWAuXG4gICAqICAgICBJZiB0aGUgdmFsdWUgaXMgbm90IGRlZmluZWQsIHRoZSB2aWV3IGFsd2F5cyBiZSBpbiBgXCJjb2xsYXBzZVwiYCBtb2RlLlxuICAgKiAgIFsvZW5dXG4gICAqICAgW2phXVxuICAgKiAgICAg5bem5YG044Gu44Oa44O844K444KS6Z2e6KGo56S644Gr44GZ44KL5p2h5Lu244KS5oyH5a6a44GX44G+44GZ44CCcG9ydHJhaXQsIGxhbmRzY2FwZeOAgXdpZHRoICNweOOCguOBl+OBj+OBr+ODoeODh+OCo+OCouOCr+OCqOODquOBruaMh+WumuOBjOWPr+iDveOBp+OBmeOAglxuICAgKiAgICAgcG9ydHJhaXTjgoLjgZfjgY/jga9sYW5kc2NhcGXjgpLmjIflrprjgZnjgovjgajjgIHjg4fjg5DjgqTjgrnjga7nlLvpnaLjgYznuKblkJHjgY3jgoLjgZfjgY/jga/mqKrlkJHjgY3jgavjgarjgaPjgZ/mmYLjgavpgannlKjjgZXjgozjgb7jgZnjgIJcbiAgICogICAgIOODoeODh+OCo+OCouOCr+OCqOODquOCkuaMh+WumuOBmeOCi+OBqOOAgeaMh+WumuOBl+OBn+OCr+OCqOODquOBq+mBqeWQiOOBl+OBpuOBhOOCi+WgtOWQiOOBq+mBqeeUqOOBleOCjOOBvuOBmeOAglxuICAgKiAgICAg5YCk44Gr5L2V44KC5oyH5a6a44GX44Gq44GE5aC05ZCI44Gr44Gv44CB5bi444GrY29sbGFwc2Xjg6Ljg7zjg4njgavjgarjgorjgb7jgZnjgIJcbiAgICogICBbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBzd2lwZS10YXJnZXQtd2lkdGhcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVRoZSB3aWR0aCBvZiBzd2lwZWFibGUgYXJlYSBjYWxjdWxhdGVkIGZyb20gdGhlIGVkZ2UgKGluIHBpeGVscykuIFVzZSB0aGlzIHRvIGVuYWJsZSBzd2lwZSBvbmx5IHdoZW4gdGhlIGZpbmdlciB0b3VjaCBvbiB0aGUgc2NyZWVuIGVkZ2UuWy9lbl1cbiAgICogICBbamFd44K544Ov44Kk44OX44Gu5Yik5a6a6aCY5Z+f44KS44OU44Kv44K744Or5Y2Y5L2N44Gn5oyH5a6a44GX44G+44GZ44CC55S76Z2i44Gu56uv44GL44KJ5oyH5a6a44GX44Gf6Led6Zui44Gr6YGU44GZ44KL44Go44Oa44O844K444GM6KGo56S644GV44KM44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgd2lkdGhcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUNhbiBiZSBzcGVjaWZpZWQgaW4gZWl0aGVyIHBpeGVscyBvciBhcyBhIHBlcmNlbnRhZ2UsIGUuZy4gYDkwJWAgb3IgYDIwMHB4YC5bL2VuXVxuICAgKiAgIFtqYV3jgZPjga7opoHntKDjga7mqKrluYXjgpLmjIflrprjgZfjgb7jgZnjgIJweOOBqCXjgafjga7mjIflrprjgYzlj6/og73jgafjgZnjgIJlZy4gOTAlLCAyMDBweFsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIHNpZGVcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlZmF1bHQgbGVmdFxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dU3BlY2lmeSB3aGljaCBzaWRlIG9mIHRoZSBzY3JlZW4gdGhlIGA8b25zLXNwbGl0dGVyLXNpZGU+YCBlbGVtZW50IGlzIGxvY2F0ZWQuIFBvc3NpYmxlIHZhbHVlcyBhcmUgYFwibGVmdFwiYCBhbmQgYFwicmlnaHRcImAuWy9lbl1cbiAgICogICBbamFd44GT44Gu6KaB57Sg44GM5bem44GL5Y+z44GL44KS5oyH5a6a44GX44G+44GZ44CC5oyH5a6a44Gn44GN44KL5YCk44GvXCJsZWZ0XCLjgYtcInJpZ2h0XCLjga7jgb/jgafjgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBtb2RlXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1DdXJyZW50IG1vZGUuIFBvc3NpYmxlIHZhbHVlcyBhcmUgYFwiY29sbGFwc2VcImAgb3IgYFwic3BsaXRcImAuIFRoaXMgYXR0cmlidXRlIGlzIHJlYWQgb25seS5bL2VuXVxuICAgKiAgIFtqYV3nj77lnKjjga7jg6Ljg7zjg4njgYzoqK3lrprjgZXjgozjgb7jgZnjgIJcImNvbGxhcHNlXCLjgoLjgZfjgY/jga9cInNwbGl0XCLjgYzmjIflrprjgZXjgozjgb7jgZnjgILjgZPjga7lsZ7mgKfjga/oqq3jgb/ovrzjgb/lsILnlKjjgafjgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBwYWdlXG4gICAqIEBpbml0b25seVxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dVGhlIFVSTCBvZiB0aGUgbWVudSBwYWdlLlsvZW5dXG4gICAqICAgW2phXW9ucy1zcGxpdHRlci1zaWRl6KaB57Sg44Gr6KGo56S644GZ44KL44Oa44O844K444GuVVJM44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgc3dpcGVhYmxlXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dV2hldGhlciB0byBlbmFibGUgc3dpcGUgaW50ZXJhY3Rpb24gb24gY29sbGFwc2UgbW9kZS5bL2VuXVxuICAgKiAgIFtqYV1jb2xsYXBzZeODouODvOODieaZguOBq+OCueODr+OCpOODl+aTjeS9nOOCkuacieWKueOBq+OBmeOCi+WgtOWQiOOBq+aMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG5cbiAgICB0aGlzLl9wYWdlID0gbnVsbDtcbiAgICB0aGlzLl9zdGF0ZSA9IENMT1NFRF9TVEFURTtcbiAgICB0aGlzLl9sb2NrID0gbmV3IERvb3JMb2NrKCk7XG4gICAgdGhpcy5fcGFnZUxvYWRlciA9IGRlZmF1bHRQYWdlTG9hZGVyO1xuICAgIHRoaXMuX2NvbGxhcHNlRGV0ZWN0aW9uID0gbmV3IENvbGxhcHNlRGV0ZWN0aW9uKHRoaXMpO1xuXG4gICAgdGhpcy5fYW5pbWF0b3JGYWN0b3J5ID0gbmV3IEFuaW1hdG9yRmFjdG9yeSh7XG4gICAgICBhbmltYXRvcnM6IFNwbGl0dGVyRWxlbWVudC5hbmltYXRvcnMsXG4gICAgICBiYXNlQ2xhc3M6IFNwbGl0dGVyQW5pbWF0b3IsXG4gICAgICBiYXNlQ2xhc3NOYW1lOiAnU3BsaXR0ZXJBbmltYXRvcicsXG4gICAgICBkZWZhdWx0QW5pbWF0aW9uOiB0aGlzLmdldEF0dHJpYnV0ZSgnYW5pbWF0aW9uJylcbiAgICB9KTtcblxuICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB7XG4gICAgICAvLyBUaGVzZSBhdHRyaWJ1dGVzIGFyZSB1c2VkIGVhcmx5IGJ5IHRoZSBwYXJlbnQgZWxlbWVudFxuICAgICAgdGhpcy5hdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2soJ3dpZHRoJyk7XG4gICAgICBpZiAoIXRoaXMuaGFzQXR0cmlidXRlKCdzaWRlJykpIHtcbiAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ3NpZGUnLCAnbGVmdCcpO1xuICAgICAgfVxuXG4gICAgICByZXdyaXRhYmxlcy5yZWFkeSh0aGlzLCAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHBhZ2UgPSB0aGlzLl9wYWdlIHx8IHRoaXMuZ2V0QXR0cmlidXRlKCdwYWdlJyk7XG4gICAgICAgIHBhZ2UgJiYgdGhpcy5sb2FkKHBhZ2UpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICBpZiAoIXV0aWwubWF0Y2godGhpcy5wYXJlbnROb2RlLCAnb25zLXNwbGl0dGVyJykpIHtcbiAgICAgIHV0aWwudGhyb3coJ1BhcmVudCBtdXN0IGJlIGFuIG9ucy1zcGxpdHRlciBlbGVtZW50Jyk7XG4gICAgfVxuXG4gICAgdGhpcy5fc3dpcGUgPSBuZXcgU3dpcGVSZXZlYWwoe1xuICAgICAgZWxlbWVudDogdGhpcyxcbiAgICAgIGVsZW1lbnRIYW5kbGVyOiB0aGlzLnBhcmVudEVsZW1lbnQsXG4gICAgICBzd2lwZU1heDogKCkgPT4ge1xuICAgICAgICB0aGlzLl9vblN3aXBlICYmIHRoaXMuX29uU3dpcGUoMSwgdGhpcy5fYW5pbWF0aW9uT3B0KTtcbiAgICAgICAgdGhpcy5vcGVuKCk7XG4gICAgICB9LFxuICAgICAgc3dpcGVNaWQ6IChkaXN0YW5jZSwgd2lkdGgpID0+IHtcbiAgICAgICAgdGhpcy5fb25Td2lwZSAmJiB0aGlzLl9vblN3aXBlKGRpc3RhbmNlL3dpZHRoKTtcbiAgICAgICAgdGhpcy5fYW5pbWF0b3IudHJhbnNsYXRlKGRpc3RhbmNlKTtcbiAgICAgIH0sXG4gICAgICBzd2lwZU1pbjogKCkgPT4ge1xuICAgICAgICB0aGlzLl9vblN3aXBlICYmIHRoaXMuX29uU3dpcGUoMCwgdGhpcy5fYW5pbWF0aW9uT3B0KTtcbiAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgfSxcbiAgICAgIGdldFRocmVzaG9sZDogKCkgPT4gTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgcGFyc2VGbG9hdCh0aGlzLmdldEF0dHJpYnV0ZSgnb3Blbi10aHJlc2hvbGQnKSkgfHwgMC4zKSksXG4gICAgICBnZXRTaWRlOiAoKSA9PiB0aGlzLnNpZGUsXG4gICAgICBpc0luaXRpYWxTdGF0ZTogKCkgPT4ge1xuICAgICAgICBjb25zdCBjbG9zZWQgPSB0aGlzLl9zdGF0ZSA9PT0gQ0xPU0VEX1NUQVRFO1xuICAgICAgICB0aGlzLl9zdGF0ZSA9IENIQU5HSU5HX1NUQVRFO1xuICAgICAgICByZXR1cm4gY2xvc2VkO1xuICAgICAgfSxcbiAgICAgIGlnbm9yZVN3aXBlOiAoZXZlbnQsIGRpc3RhbmNlKSA9PiB7XG4gICAgICAgIGNvbnN0IGlzT3BlbiA9IHRoaXMuaXNPcGVuO1xuICAgICAgICBjb25zdCB2YWxpZERyYWcgPSBkID0+IHRoaXMuc2lkZSA9PT0gJ2xlZnQnXG4gICAgICAgICAgPyAoKGQgPT09ICdsZWZ0JyAmJiBpc09wZW4pIHx8IChkID09PSAncmlnaHQnICYmICFpc09wZW4pKVxuICAgICAgICAgIDogKChkID09PSAnbGVmdCcgJiYgIWlzT3BlbikgfHwgKGQgPT09ICdyaWdodCcgJiYgaXNPcGVuKSk7XG5cbiAgICAgICAgY29uc3QgYXJlYSA9IE1hdGgubWF4KDAsIHBhcnNlSW50KHRoaXMuZ2V0QXR0cmlidXRlKCdzd2lwZS10YXJnZXQtd2lkdGgnKSwgMTApIHx8IDApO1xuXG4gICAgICAgIHJldHVybiB0aGlzLl9tb2RlID09PSBTUExJVF9NT0RFIHx8IHRoaXMuX2xvY2suaXNMb2NrZWQoKSB8fCB0aGlzLl9pc090aGVyU2lkZU9wZW4oKVxuICAgICAgICAgIHx8ICF2YWxpZERyYWcoZXZlbnQuZ2VzdHVyZS5kaXJlY3Rpb24pXG4gICAgICAgICAgfHwgKCFpc09wZW4gJiYgYXJlYSAhPT0gMCAmJiBkaXN0YW5jZSA+IGFyZWEpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdGhpcy5hdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2soJ3N3aXBlYWJsZScpO1xuXG4gICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHtcbiAgICAgIHRoaXMuY29uc3RydWN0b3Iub2JzZXJ2ZWRBdHRyaWJ1dGVzLmZvckVhY2goYXR0ciA9PiB0aGlzLmF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhhdHRyLCBudWxsLCB0aGlzLmdldEF0dHJpYnV0ZShhdHRyKSkpO1xuICAgIH0pO1xuICB9XG5cbiAgZ2V0IHNpZGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0QXR0cmlidXRlKCdzaWRlJykgPT09ICdyaWdodCcgPyAncmlnaHQnIDogJ2xlZnQnO1xuICB9XG5cbiAgZGlzY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgdGhpcy5fc3dpcGUgJiYgdGhpcy5fc3dpcGUuZGlzcG9zZSgpO1xuICAgIHRoaXMuX2FuaW1hdG9yID0gdGhpcy5fYW5pbWF0aW9uT3B0ID0gdGhpcy5fc3dpcGUgPSBudWxsO1xuICB9XG5cbiAgc3RhdGljIGdldCBvYnNlcnZlZEF0dHJpYnV0ZXMoKSB7XG4gICAgcmV0dXJuIFsnYW5pbWF0aW9uJywgJ3dpZHRoJywgJ2NvbGxhcHNlJywgJ3N3aXBlYWJsZScsICdhbmltYXRpb24tb3B0aW9ucyddO1xuICB9XG5cbiAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIGxhc3QsIGN1cnJlbnQpIHtcbiAgICBzd2l0Y2ggKG5hbWUpIHtcbiAgICAgIGNhc2UgJ3N3aXBlYWJsZSc6XG4gICAgICAgIHRoaXMuX3N3aXBlICYmIHRoaXMuX3N3aXBlLnVwZGF0ZSgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3dpZHRoJzpcbiAgICAgICAgY3VycmVudCA9IHRoaXMuZ2V0QXR0cmlidXRlKCd3aWR0aCcpOyAvLyBTb21ldGltZXMgdW5kZWZpbmVkLiBDRSBidWc/XG4gICAgICAgIHRoaXMuc3R5bGUud2lkdGggPSAvXlxcZCsocHh8JSkkLy50ZXN0KGN1cnJlbnQpID8gY3VycmVudCA6ICc4MCUnO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRoaXNbdXRpbC5jYW1lbGl6ZShgX3VwZGF0ZS0ke25hbWV9YCldKGN1cnJlbnQpO1xuICAgIH1cbiAgfVxuXG4gIF9lbWl0RXZlbnQobmFtZSkge1xuICAgIGlmIChuYW1lLnNsaWNlKDAsIDMpICE9PSAncHJlJykge1xuICAgICAgcmV0dXJuIHV0aWwudHJpZ2dlckVsZW1lbnRFdmVudCh0aGlzLCBuYW1lLCB7c2lkZTogdGhpc30pO1xuICAgIH1cbiAgICBsZXQgaXNDYW5jZWxlZCA9IGZhbHNlO1xuXG4gICAgdXRpbC50cmlnZ2VyRWxlbWVudEV2ZW50KHRoaXMsIG5hbWUsIHtcbiAgICAgIHNpZGU6IHRoaXMsXG4gICAgICBjYW5jZWw6ICgpID0+IGlzQ2FuY2VsZWQgPSB0cnVlXG4gICAgfSk7XG5cbiAgICByZXR1cm4gaXNDYW5jZWxlZDtcbiAgfVxuXG4gIF9pc090aGVyU2lkZU9wZW4oKSB7XG4gICAgcmV0dXJuICEhdXRpbC5maW5kQ2hpbGQodGhpcy5wYXJlbnRFbGVtZW50LFxuICAgICAgZWwgPT4gZWwgaW5zdGFuY2VvZiB0aGlzLmNvbnN0cnVjdG9yICYmIGVsICE9PSB0aGlzICYmIGVsLl9tb2RlID09PSBDT0xMQVBTRV9NT0RFICYmIGVsLmlzT3BlblxuICAgICk7XG4gIH1cblxuICBfdXBkYXRlQ29sbGFwc2UodmFsdWUgPSB0aGlzLmdldEF0dHJpYnV0ZSgnY29sbGFwc2UnKSkge1xuICAgIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gJ3NwbGl0Jykge1xuICAgICAgdGhpcy5fY29sbGFwc2VEZXRlY3Rpb24uZGlzYWJsZSgpO1xuICAgICAgcmV0dXJuIHRoaXMuX3VwZGF0ZU1vZGUoU1BMSVRfTU9ERSk7XG4gICAgfVxuICAgIGlmICh2YWx1ZSA9PT0gJycgfHwgdmFsdWUgPT09ICdjb2xsYXBzZScpIHtcbiAgICAgIHRoaXMuX2NvbGxhcHNlRGV0ZWN0aW9uLmRpc2FibGUoKTtcbiAgICAgIHJldHVybiB0aGlzLl91cGRhdGVNb2RlKENPTExBUFNFX01PREUpO1xuICAgIH1cblxuICAgIHRoaXMuX2NvbGxhcHNlRGV0ZWN0aW9uLmNoYW5nZVRhcmdldCh2YWx1ZSk7XG4gIH1cblxuICBfdXBkYXRlTW9kZShtb2RlKSB7XG4gICAgaWYgKG1vZGUgIT09IHRoaXMuX21vZGUpIHtcbiAgICAgIHRoaXMuX21vZGUgPSBtb2RlO1xuICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ21vZGUnLCBtb2RlKTsgLy8gcmVhZG9ubHkgYXR0cmlidXRlIGZvciB0aGUgdXNlcnNcblxuICAgICAgaWYgKG1vZGUgPT09IFNQTElUX01PREUpIHtcbiAgICAgICAgdGhpcy5fYW5pbWF0b3IgJiYgdGhpcy5fYW5pbWF0b3IuZGVhY3RpdmF0ZSgpO1xuICAgICAgICB0aGlzLl9zdGF0ZSA9IENMT1NFRF9TVEFURTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2FuaW1hdG9yICYmIHRoaXMuX2FuaW1hdG9yLmFjdGl2YXRlKHRoaXMpO1xuICAgICAgICB0aGlzLl9zdGF0ZSA9PT0gT1BFTl9TVEFURSAmJiB0aGlzLl9hbmltYXRvci5vcGVuKCk7XG4gICAgICB9XG5cbiAgICAgIHV0aWwudHJpZ2dlckVsZW1lbnRFdmVudCh0aGlzLCAnbW9kZWNoYW5nZScsIHsgc2lkZTogdGhpcywgbW9kZSB9KTtcbiAgICB9XG4gIH1cblxuICBfdXBkYXRlQW5pbWF0aW9uKGFuaW1hdGlvbiA9IHRoaXMuZ2V0QXR0cmlidXRlKCdhbmltYXRpb24nKSkge1xuICAgIGlmICh0aGlzLnBhcmVudE5vZGUpIHtcbiAgICAgIHRoaXMuX2FuaW1hdG9yICYmIHRoaXMuX2FuaW1hdG9yLmRlYWN0aXZhdGUoKTtcbiAgICAgIHRoaXMuX2FuaW1hdG9yID0gdGhpcy5fYW5pbWF0b3JGYWN0b3J5Lm5ld0FuaW1hdG9yKHthbmltYXRpb259KTtcbiAgICAgIHRoaXMuX2FuaW1hdG9yLmFjdGl2YXRlKHRoaXMpO1xuICAgICAgdGhpcy5fYW5pbWF0aW9uT3B0ID0ge1xuICAgICAgICB0aW1pbmc6IHRoaXMuX2FuaW1hdG9yLmR1cmF0aW9uLFxuICAgICAgICBkdXJhdGlvbjogdGhpcy5fYW5pbWF0b3IuZHVyYXRpb25cbiAgICAgIH07XG4gICAgfVxuICB9XG5cbiAgX3VwZGF0ZUFuaW1hdGlvbk9wdGlvbnModmFsdWUgPSB0aGlzLmdldEF0dHJpYnV0ZSgnYW5pbWF0aW9uLW9wdGlvbnMnKSkge1xuICAgIHRoaXMuX2FuaW1hdG9yLnVwZGF0ZU9wdGlvbnMoQW5pbWF0b3JGYWN0b3J5LnBhcnNlQW5pbWF0aW9uT3B0aW9uc1N0cmluZyh2YWx1ZSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBwYWdlXG4gICAqIEB0eXBlIHsqfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dUGFnZSBsb2NhdGlvbiB0byBsb2FkIGluIHRoZSBzcGxpdHRlciBzaWRlLlsvZW5dXG4gICAqICAgW2phXeOBk+OBruimgee0oOWGheOBq+ihqOekuuOBmeOCi+ODmuODvOOCuOOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuICBnZXQgcGFnZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fcGFnZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0geyp9IHBhZ2VcbiAgICovXG4gIHNldCBwYWdlKHBhZ2UpIHtcbiAgICB0aGlzLl9wYWdlID0gcGFnZTtcbiAgfVxuXG4gIGdldCBfY29udGVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5jaGlsZHJlblswXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgcGFnZUxvYWRlclxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG4gIGdldCBwYWdlTG9hZGVyKCkge1xuICAgIHJldHVybiB0aGlzLl9wYWdlTG9hZGVyO1xuICB9XG5cbiAgc2V0IHBhZ2VMb2FkZXIobG9hZGVyKSB7XG4gICAgaWYgKCEobG9hZGVyIGluc3RhbmNlb2YgUGFnZUxvYWRlcikpIHtcbiAgICAgIHV0aWwudGhyb3dQYWdlTG9hZGVyKCk7XG4gICAgfVxuICAgIHRoaXMuX3BhZ2VMb2FkZXIgPSBsb2FkZXI7XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IG1vZGVcbiAgICogQHJlYWRvbmx5XG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1DdXJyZW50IG1vZGUuIFBvc3NpYmxlIHZhbHVlcyBhcmUgXCJzcGxpdFwiLCBcImNvbGxhcHNlXCIsIFwiY2xvc2VkXCIsIFwib3BlblwiIG9yIFwiY2hhbmdpbmdcIi5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cbiAgZ2V0IG1vZGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX21vZGU7XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IG9uU3dpcGVcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dSG9vayBjYWxsZWQgd2hlbmV2ZXIgdGhlIHVzZXIgc2xpZGVzIHRoZSBzcGxpdHRlci4gSXQgZ2V0cyBhIGRlY2ltYWwgcmF0aW8gKDAtMSkgYW5kIGFuIGFuaW1hdGlvbk9wdGlvbnMgb2JqZWN0IGFzIGFyZ3VtZW50cy5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cbiAgZ2V0IG9uU3dpcGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX29uU3dpcGU7XG4gIH1cblxuICBzZXQgb25Td2lwZSh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSAmJiAhKHZhbHVlIGluc3RhbmNlb2YgRnVuY3Rpb24pKSB7XG4gICAgICB1dGlsLnRocm93KCdcIm9uU3dpcGVcIiBtdXN0IGJlIGEgZnVuY3Rpb24nKVxuICAgIH1cbiAgICB0aGlzLl9vblN3aXBlID0gdmFsdWU7XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IGlzT3BlblxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQHJlYWRvbmx5XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1UaGlzIHZhbHVlIGlzIGB0cnVlYCB3aGVuIHRoZSBtZW51IGlzIG9wZW4uWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG4gIGdldCBpc09wZW4oKSB7XG4gICAgcmV0dXJuIHRoaXMuX21vZGUgPT09IENPTExBUFNFX01PREUgJiYgdGhpcy5fc3RhdGUgIT09IENMT1NFRF9TVEFURTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIG9wZW5cbiAgICogQHNpZ25hdHVyZSBvcGVuKFtvcHRpb25zXSlcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiAgIFtlbl1QYXJhbWV0ZXIgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCquODl+OCt+ODp+ODs+OCkuaMh+WumuOBmeOCi+OCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmNhbGxiYWNrXVxuICAgKiAgIFtlbl1UaGlzIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIGFmdGVyIHRoZSBtZW51IGhhcyBiZWVuIG9wZW5lZC5bL2VuXVxuICAgKiAgIFtqYV3jg6Hjg4vjg6Xjg7zjgYzplovjgYTjgZ/lvozjgavlkbzjgbPlh7rjgZXjgozjgovplqLmlbDjgqrjg5bjgrjjgqfjgq/jg4jjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dT3BlbiBtZW51IGluIGNvbGxhcHNlIG1vZGUuWy9lbl1cbiAgICogICBbamFdY29sbGFwc2Xjg6Ljg7zjg4njgavjgarjgaPjgabjgYTjgotvbnMtc3BsaXR0ZXItc2lkZeimgee0oOOCkumWi+OBjeOBvuOBmeOAglsvamFdXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqICAgW2VuXVJlc29sdmVzIHRvIHRoZSBzcGxpdHRlciBzaWRlIGVsZW1lbnQgb3IgZmFsc2UgaWYgbm90IGluIGNvbGxhcHNlIG1vZGVbL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cbiAgb3BlbihvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMudG9nZ2xlKG9wdGlvbnMsIHRydWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgY2xvc2VcbiAgICogQHNpZ25hdHVyZSBjbG9zZShbb3B0aW9uc10pXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogICBbZW5dUGFyYW1ldGVyIG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgqrjg5fjgrfjg6fjg7PjgpLmjIflrprjgZnjgovjgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5jYWxsYmFja11cbiAgICogICBbZW5dVGhpcyBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCBhZnRlciB0aGUgbWVudSBoYXMgYmVlbiBjbG9zZWQuWy9lbl1cbiAgICogICBbamFd44Oh44OL44Ol44O844GM6ZaJ44GY44Gf5b6M44Gr5ZG844Gz5Ye644GV44KM44KL6Zai5pWw44Kq44OW44K444Kn44Kv44OI44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUNsb3NlIG1lbnUgaW4gY29sbGFwc2UgbW9kZS5bL2VuXVxuICAgKiAgIFtqYV1jb2xsYXBzZeODouODvOODieOBq+OBquOBo+OBpuOBhOOCi29ucy1zcGxpdHRlci1zaWRl6KaB57Sg44KS6ZaJ44GY44G+44GZ44CCWy9qYV1cbiAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICogICBbZW5dUmVzb2x2ZXMgdG8gdGhlIHNwbGl0dGVyIHNpZGUgZWxlbWVudCBvciBmYWxzZSBpZiBub3QgaW4gY29sbGFwc2UgbW9kZVsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuICBjbG9zZShvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMudG9nZ2xlKG9wdGlvbnMsIGZhbHNlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIHRvZ2dsZVxuICAgKiBAc2lnbmF0dXJlIHRvZ2dsZShbb3B0aW9uc10pXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXU9wZW5zIGlmIGl0J3MgY2xvc2VkLiBDbG9zZXMgaWYgaXQncyBvcGVuLlsvZW5dXG4gICAqICAgW2phXemWi+OBkeOBpuOBhOOCi+WgtOWQiOOBr+imgee0oOOCkumWieOBmOOBvuOBmeOBneOBl+OBpumWi+OBkeOBpuOBhOOCi+WgtOWQiOOBr+imgee0oOOCkumWi+OBjeOBvuOBmeOAglsvamFdXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqICAgW2VuXVJlc29sdmVzIHRvIHRoZSBzcGxpdHRlciBzaWRlIGVsZW1lbnQgb3IgZmFsc2UgaWYgbm90IGluIGNvbGxhcHNlIG1vZGVbL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cbiAgdG9nZ2xlKG9wdGlvbnMgPSB7fSwgZm9yY2UpIHtcbiAgICBjb25zdCBzaG91bGRPcGVuID0gdHlwZW9mIGZvcmNlID09PSAnYm9vbGVhbicgPyBmb3JjZSA6ICF0aGlzLmlzT3BlbjtcbiAgICBjb25zdCBhY3Rpb24gPSBzaG91bGRPcGVuID8gJ29wZW4nIDogJ2Nsb3NlJztcbiAgICBjb25zdCBGSU5BTF9TVEFURSA9IHNob3VsZE9wZW4gPyBPUEVOX1NUQVRFIDogQ0xPU0VEX1NUQVRFO1xuXG4gICAgaWYgKHRoaXMuX21vZGUgPT09IFNQTElUX01PREUpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoZmFsc2UpO1xuICAgIH1cbiAgICBpZiAodGhpcy5fc3RhdGUgPT09IEZJTkFMX1NUQVRFKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMpO1xuICAgIH1cbiAgICBpZiAodGhpcy5fbG9jay5pc0xvY2tlZCgpKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoJ0Fub3RoZXIgc3BsaXR0ZXItc2lkZSBhY3Rpb24gaXMgYWxyZWFkeSBydW5uaW5nLicpO1xuICAgIH1cbiAgICBpZiAoc2hvdWxkT3BlbiAmJiB0aGlzLl9pc090aGVyU2lkZU9wZW4oKSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KCdBbm90aGVyIG1lbnUgaXMgYWxyZWFkeSBvcGVuLicpO1xuICAgIH1cbiAgICBpZiAodGhpcy5fZW1pdEV2ZW50KGBwcmUke2FjdGlvbn1gKSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGBDYW5jZWxlZCBpbiBwcmUke2FjdGlvbn0gZXZlbnQuYCk7XG4gICAgfVxuXG4gICAgY29uc3QgdW5sb2NrID0gdGhpcy5fbG9jay5sb2NrKCk7XG4gICAgdGhpcy5fc3RhdGUgPSBDSEFOR0lOR19TVEFURTtcblxuICAgIGlmIChvcHRpb25zLmFuaW1hdGlvbikge1xuICAgICAgdGhpcy5fdXBkYXRlQW5pbWF0aW9uKG9wdGlvbnMuYW5pbWF0aW9uKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICB0aGlzLl9hbmltYXRvclthY3Rpb25dKCgpID0+IHtcbiAgICAgICAgdXRpbC5pb3NQYWdlU2Nyb2xsRml4KHNob3VsZE9wZW4pO1xuICAgICAgICB0aGlzLl9zdGF0ZSA9IEZJTkFMX1NUQVRFO1xuICAgICAgICB1bmxvY2soKTtcbiAgICAgICAgdGhpcy5fZW1pdEV2ZW50KGBwb3N0JHthY3Rpb259YCk7XG4gICAgICAgIG9wdGlvbnMuY2FsbGJhY2sgaW5zdGFuY2VvZiBGdW5jdGlvbiAmJiBvcHRpb25zLmNhbGxiYWNrKHRoaXMpO1xuICAgICAgICByZXNvbHZlKHRoaXMpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBsb2FkXG4gICAqIEBzaWduYXR1cmUgbG9hZChwYWdlLCBbb3B0aW9uc10pXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwYWdlXG4gICAqICAgW2VuXVBhZ2UgVVJMLiBDYW4gYmUgZWl0aGVyIGFuIEhUTUwgZG9jdW1lbnQgb3IgYSBgPHRlbXBsYXRlPmAuWy9lbl1cbiAgICogICBbamFdcGFnZeOBrlVSTOOBi+OAgWA8dGVtcGxhdGU+YOOBp+Wuo+iogOOBl+OBn+ODhuODs+ODl+ODrOODvOODiOOBrmlk5bGe5oCn44Gu5YCk44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5jYWxsYmFja11cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVNob3cgdGhlIHBhZ2Ugc3BlY2lmaWVkIGluIHBhZ2VVcmwgaW4gdGhlIHJpZ2h0IHNlY3Rpb25bL2VuXVxuICAgKiAgIFtqYV3mjIflrprjgZfjgZ9VUkzjgpLjg6HjgqTjg7Pjg5rjg7zjgrjjgpLoqq3jgb/ovrzjgb/jgb7jgZnjgIJbL2phXVxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKiAgIFtlbl1SZXNvbHZlcyB0byB0aGUgbmV3IHBhZ2UgZWxlbWVudFsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuICBsb2FkKHBhZ2UsIG9wdGlvbnMgPSB7fSkge1xuICAgIHRoaXMuX3BhZ2UgPSBwYWdlO1xuICAgIGNvbnN0IGNhbGxiYWNrID0gb3B0aW9ucy5jYWxsYmFjayB8fCAoKCkgPT4ge30pO1xuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgbGV0IG9sZENvbnRlbnQgPSB0aGlzLl9jb250ZW50IHx8IG51bGw7XG5cbiAgICAgIHRoaXMuX3BhZ2VMb2FkZXIubG9hZCh7cGFnZSwgcGFyZW50OiB0aGlzfSwgcGFnZUVsZW1lbnQgPT4ge1xuICAgICAgICBpZiAob2xkQ29udGVudCkge1xuICAgICAgICAgIHRoaXMuX3BhZ2VMb2FkZXIudW5sb2FkKG9sZENvbnRlbnQpO1xuICAgICAgICAgIG9sZENvbnRlbnQgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgc2V0SW1tZWRpYXRlKCgpID0+IHRoaXMuX3Nob3coKSk7XG5cbiAgICAgICAgY2FsbGJhY2socGFnZUVsZW1lbnQpO1xuICAgICAgICByZXNvbHZlKHBhZ2VFbGVtZW50KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgX3Nob3coKSB7XG4gICAgaWYgKHRoaXMuX2NvbnRlbnQpIHtcbiAgICAgIHRoaXMuX2NvbnRlbnQuX3Nob3coKTtcbiAgICB9XG4gIH1cblxuICBfaGlkZSgpIHtcbiAgICBpZiAodGhpcy5fY29udGVudCkge1xuICAgICAgdGhpcy5fY29udGVudC5faGlkZSgpO1xuICAgIH1cbiAgfVxuXG4gIF9kZXN0cm95KCkge1xuICAgIGlmICh0aGlzLl9jb250ZW50KSB7XG4gICAgICB0aGlzLl9wYWdlTG9hZGVyLnVubG9hZCh0aGlzLl9jb250ZW50KTtcbiAgICB9XG4gICAgdGhpcy5yZW1vdmUoKTtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgZXZlbnRzKCkge1xuICAgIHJldHVybiBbJ3ByZW9wZW4nLCAncG9zdG9wZW4nLCAncHJlY2xvc2UnLCAncG9zdGNsb3NlJywgJ21vZGVjaGFuZ2UnXTtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgcmV3cml0YWJsZXMoKSB7XG4gICAgcmV0dXJuIHJld3JpdGFibGVzO1xuICB9XG59XG5cbm9uc0VsZW1lbnRzLlNwbGl0dGVyU2lkZSA9IFNwbGl0dGVyU2lkZUVsZW1lbnQ7XG5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ29ucy1zcGxpdHRlci1zaWRlJywgU3BsaXR0ZXJTaWRlRWxlbWVudCk7XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgb25zRWxlbWVudHMgZnJvbSAnLi4vb25zL2VsZW1lbnRzJztcbmltcG9ydCB1dGlsIGZyb20gJy4uL29ucy91dGlsJztcbmltcG9ydCBhdXRvU3R5bGUgZnJvbSAnLi4vb25zL2F1dG9zdHlsZSc7XG5pbXBvcnQgTW9kaWZpZXJVdGlsIGZyb20gJy4uL29ucy9pbnRlcm5hbC9tb2RpZmllci11dGlsJztcbmltcG9ydCBCYXNlQ2hlY2tib3hFbGVtZW50IGZyb20gJy4vYmFzZS9iYXNlLWNoZWNrYm94JztcbmltcG9ydCBjb250ZW50UmVhZHkgZnJvbSAnLi4vb25zL2NvbnRlbnQtcmVhZHknO1xuaW1wb3J0IEdlc3R1cmVEZXRlY3RvciBmcm9tICcuLi9vbnMvZ2VzdHVyZS1kZXRlY3Rvcic7XG5cbmNvbnN0IHNjaGVtZSA9IHtcbiAgJyc6ICdzd2l0Y2gtLSonLFxuICAnLnN3aXRjaF9faW5wdXQnOiAnc3dpdGNoLS0qX19pbnB1dCcsXG4gICcuc3dpdGNoX19oYW5kbGUnOiAnc3dpdGNoLS0qX19oYW5kbGUnLFxuICAnLnN3aXRjaF9fdG9nZ2xlJzogJ3N3aXRjaC0tKl9fdG9nZ2xlJ1xufTtcblxuY29uc3QgbG9jYXRpb25zID0ge1xuICBpb3M6IFsxLCAyMV0sXG4gIG1hdGVyaWFsOiBbMCwgMTZdXG59O1xuXG4vKipcbiAqIEBlbGVtZW50IG9ucy1zd2l0Y2hcbiAqIEBjYXRlZ29yeSBmb3JtXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXVxuICogICAgIFN3aXRjaCBjb21wb25lbnQuIFRoZSBzd2l0Y2ggY2FuIGJlIHRvZ2dsZWQgYm90aCBieSBkcmFnZ2luZyBhbmQgdGFwcGluZy5cbiAqXG4gKiAgICAgV2lsbCBhdXRvbWF0aWNhbGx5IGRpc3BsYXlzIGEgTWF0ZXJpYWwgRGVzaWduIHN3aXRjaCBvbiBBbmRyb2lkIGRldmljZXMuXG4gKiAgIFsvZW5dXG4gKiAgIFtqYV3jgrnjgqTjg4Pjg4HjgpLooajnpLrjgZnjgovjgrPjg7Pjg53jg7zjg43jg7Pjg4jjgafjgZnjgIJbL2phXVxuICogQG1vZGlmaWVyIG1hdGVyaWFsXG4gKiAgIFtlbl1NYXRlcmlhbCBEZXNpZ24gc3dpdGNoWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAY29kZXBlbiBMcFhaUVFcbiAqIEB0dXRvcmlhbCB2YW5pbGxhL1JlZmVyZW5jZS9zd2l0Y2hcbiAqIEBndWlkZSB0aGVtaW5nLmh0bWwjbW9kaWZpZXJzIFtlbl1Nb3JlIGRldGFpbHMgYWJvdXQgdGhlIGBtb2RpZmllcmAgYXR0cmlidXRlWy9lbl1bamFdbW9kaWZpZXLlsZ7mgKfjga7kvb/jgYTmlrlbL2phXVxuICogQGV4YW1wbGVcbiAqIDxvbnMtc3dpdGNoIGNoZWNrZWQ+PC9vbnMtc3dpdGNoPlxuICogPG9ucy1zd2l0Y2ggZGlzYWJsZWQ+PC9vbnMtc3dpdGNoPlxuICogPG9ucy1zd2l0Y2ggbW9kaWZpZXI9XCJtYXRlcmlhbFwiPjwvb25zLXN3aXRjaD5cbiAqL1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTd2l0Y2hFbGVtZW50IGV4dGVuZHMgQmFzZUNoZWNrYm94RWxlbWVudCB7XG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB7XG4gICAgICB0aGlzLmF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjaygnbW9kaWZpZXInLCBudWxsLCB0aGlzLmdldEF0dHJpYnV0ZSgnbW9kaWZpZXInKSk7XG4gICAgfSk7XG5cbiAgICB0aGlzLl9vbkNoYW5nZSA9IHRoaXMuX29uQ2hhbmdlLmJpbmQodGhpcyk7XG4gICAgdGhpcy5fb25SZWxlYXNlID0gdGhpcy5fb25SZWxlYXNlLmJpbmQodGhpcyk7XG4gICAgdGhpcy5fbGFzdFRpbWVTdGFtcCA9IDA7XG4gIH1cblxuICBnZXQgX3NjaGVtZSgpIHtcbiAgICByZXR1cm4gc2NoZW1lO1xuICB9XG5cbiAgZ2V0IF9kZWZhdWx0Q2xhc3NOYW1lKCkge1xuICAgIHJldHVybiAnc3dpdGNoJztcbiAgfVxuXG4gIGdldCBfdGVtcGxhdGUoKSB7XG4gICAgcmV0dXJuIGBcbiAgICAgIDxpbnB1dCB0eXBlPVwiJHt0aGlzLnR5cGV9XCIgY2xhc3M9XCIke3RoaXMuX2RlZmF1bHRDbGFzc05hbWV9X19pbnB1dFwiPlxuICAgICAgPGRpdiBjbGFzcz1cIiR7dGhpcy5fZGVmYXVsdENsYXNzTmFtZX1fX3RvZ2dsZVwiPlxuICAgICAgICA8ZGl2IGNsYXNzPVwiJHt0aGlzLl9kZWZhdWx0Q2xhc3NOYW1lfV9faGFuZGxlXCI+XG4gICAgICAgICAgPGRpdiBjbGFzcz1cIiR7dGhpcy5fZGVmYXVsdENsYXNzTmFtZX1fX3RvdWNoXCI+PC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9kaXY+XG4gICAgYDtcbiAgfVxuXG4gIGdldCB0eXBlKCkge1xuICAgIHJldHVybiAnY2hlY2tib3gnO1xuICB9XG5cbiAgLyogT3duIHByb3BzICovXG5cbiAgX2dldFBvc2l0aW9uKGUpIHtcbiAgICBjb25zdCBsID0gdGhpcy5fbG9jYXRpb25zO1xuICAgIHJldHVybiBNYXRoLm1pbihsWzFdLCBNYXRoLm1heChsWzBdLCB0aGlzLl9zdGFydFggKyBlLmdlc3R1cmUuZGVsdGFYKSk7XG4gIH1cblxuICBfZW1pdENoYW5nZUV2ZW50KCkge1xuICAgIHV0aWwudHJpZ2dlckVsZW1lbnRFdmVudCh0aGlzLCAnY2hhbmdlJywge1xuICAgICAgdmFsdWU6IHRoaXMuY2hlY2tlZCxcbiAgICAgIHN3aXRjaDogdGhpcyxcbiAgICAgIGlzSW50ZXJhY3RpdmU6IHRydWVcbiAgICB9KTtcbiAgfVxuXG4gIF9vbkNoYW5nZShldmVudCkge1xuICAgIGlmIChldmVudCAmJiBldmVudC5zdG9wUHJvcGFnYXRpb24pIHtcbiAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIH1cblxuICAgIHRoaXMuX2VtaXRDaGFuZ2VFdmVudCgpO1xuICB9XG5cbiAgX29uQ2xpY2soZXYpIHtcbiAgICBpZiAoZXYudGFyZ2V0LmNsYXNzTGlzdC5jb250YWlucyhgJHt0aGlzLmRlZmF1bHRFbGVtZW50Q2xhc3N9X190b3VjaGApXG4gICAgICB8fCAoZXYudGltZVN0YW1wIC0gdGhpcy5fbGFzdFRpbWVTdGFtcCA8IDUwKSAvLyBQcmV2ZW50IHNlY29uZCBjbGljayB0cmlnZ2VyZWQgYnkgPGxhYmVsPlxuICAgICkge1xuICAgICAgZXYucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gICAgdGhpcy5fbGFzdFRpbWVTdGFtcCA9IGV2LnRpbWVTdGFtcDtcbiAgfVxuXG4gIF9vbkhvbGQoZSkge1xuICAgIGlmICghdGhpcy5kaXNhYmxlZCkge1xuICAgICAgTW9kaWZpZXJVdGlsLmFkZE1vZGlmaWVyKHRoaXMsICdhY3RpdmUnKTtcbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3JlbGVhc2UnLCB0aGlzLl9vblJlbGVhc2UpO1xuICAgIH1cbiAgfVxuXG4gIF9vbkRyYWdTdGFydChlKSB7XG4gICAgaWYgKHRoaXMuZGlzYWJsZWQgfHwgWydsZWZ0JywgJ3JpZ2h0J10uaW5kZXhPZihlLmdlc3R1cmUuZGlyZWN0aW9uKSA9PT0gLTEpIHtcbiAgICAgIE1vZGlmaWVyVXRpbC5yZW1vdmVNb2RpZmllcih0aGlzLCAnYWN0aXZlJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZS5jb25zdW1lZCA9IHRydWU7XG5cbiAgICBNb2RpZmllclV0aWwuYWRkTW9kaWZpZXIodGhpcywgJ2FjdGl2ZScpO1xuICAgIHRoaXMuX3N0YXJ0WCA9IHRoaXMuX2xvY2F0aW9uc1t0aGlzLmNoZWNrZWQgPyAxIDogMF07Ly8gLSBlLmdlc3R1cmUuZGVsdGFYO1xuXG4gICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdkcmFnJywgdGhpcy5fb25EcmFnKTtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdyZWxlYXNlJywgdGhpcy5fb25SZWxlYXNlKTtcbiAgfVxuXG4gIF9vbkRyYWcoZSkge1xuICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgdGhpcy5faGFuZGxlLnN0eWxlLmxlZnQgPSB0aGlzLl9nZXRQb3NpdGlvbihlKSArICdweCc7XG4gIH1cblxuICBfb25SZWxlYXNlKGUpIHtcbiAgICBjb25zdCBsID0gdGhpcy5fbG9jYXRpb25zO1xuICAgIGNvbnN0IHBvc2l0aW9uID0gdGhpcy5fZ2V0UG9zaXRpb24oZSk7XG4gICAgY29uc3QgcHJldmlvdXNWYWx1ZSA9IHRoaXMuY2hlY2tlZDtcblxuICAgIHRoaXMuY2hlY2tlZCA9IHBvc2l0aW9uID49IChsWzBdICsgbFsxXSkgLyAyO1xuXG4gICAgaWYgKHRoaXMuY2hlY2tlZCAhPT0gcHJldmlvdXNWYWx1ZSkge1xuICAgICAgdGhpcy5fZW1pdENoYW5nZUV2ZW50KCk7XG4gICAgfVxuXG4gICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCdkcmFnJywgdGhpcy5fb25EcmFnKTtcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdyZWxlYXNlJywgdGhpcy5fb25SZWxlYXNlKTtcblxuICAgIHRoaXMuX2hhbmRsZS5zdHlsZS5sZWZ0ID0gJyc7XG4gICAgTW9kaWZpZXJVdGlsLnJlbW92ZU1vZGlmaWVyKHRoaXMsICdhY3RpdmUnKTtcbiAgfVxuXG4gIGNsaWNrKGV2ID0ge30pIHtcbiAgICBpZiAoIXRoaXMuZGlzYWJsZWQpIHtcbiAgICAgIHRoaXMuY2hlY2tlZCA9ICF0aGlzLmNoZWNrZWQ7XG4gICAgICB0aGlzLl9lbWl0Q2hhbmdlRXZlbnQoKTtcbiAgICAgIHRoaXMuX2xhc3RUaW1lU3RhbXAgPSBldi50aW1lU3RhbXAgfHwgMDtcbiAgICB9XG4gIH1cblxuICBnZXQgX2hhbmRsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5xdWVyeVNlbGVjdG9yKGAuJHt0aGlzLl9kZWZhdWx0Q2xhc3NOYW1lfV9faGFuZGxlYCk7XG4gIH1cblxuICBnZXQgY2hlY2tib3goKSB7XG4gICAgcmV0dXJuIHRoaXMuX2lucHV0O1xuICB9XG5cbiAgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHtcbiAgICAgIHRoaXMuX2lucHV0LmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIHRoaXMuX29uQ2hhbmdlKTtcbiAgICB9KTtcblxuICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignZHJhZ3N0YXJ0JywgdGhpcy5fb25EcmFnU3RhcnQpO1xuICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignaG9sZCcsIHRoaXMuX29uSG9sZCk7XG4gICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCd0YXAnLCB0aGlzLmNsaWNrKTtcbiAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5fb25DbGljayk7XG4gICAgdGhpcy5fZ2VzdHVyZURldGVjdG9yID0gbmV3IEdlc3R1cmVEZXRlY3Rvcih0aGlzLCB7IGRyYWdNaW5EaXN0YW5jZTogMSwgaG9sZFRpbWVvdXQ6IDI1MSwgcGFzc2l2ZTogdHJ1ZSB9KTtcbiAgfVxuXG4gIGRpc2Nvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB7XG4gICAgICB0aGlzLl9pbnB1dC5yZW1vdmVFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCB0aGlzLl9vbkNoYW5nZSk7XG4gICAgfSk7XG5cbiAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2RyYWdzdGFydCcsIHRoaXMuX29uRHJhZ1N0YXJ0KTtcbiAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2hvbGQnLCB0aGlzLl9vbkhvbGQpO1xuICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcigndGFwJywgdGhpcy5jbGljayk7XG4gICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuX29uQ2xpY2spO1xuICAgIGlmICh0aGlzLl9nZXN0dXJlRGV0ZWN0b3IpIHtcbiAgICAgIHRoaXMuX2dlc3R1cmVEZXRlY3Rvci5kaXNwb3NlKCk7XG4gICAgfVxuICB9XG5cbiAgc3RhdGljIGdldCBvYnNlcnZlZEF0dHJpYnV0ZXMoKSB7XG4gICAgcmV0dXJuIFsuLi5zdXBlci5vYnNlcnZlZEF0dHJpYnV0ZXMsICdtb2RpZmllciddO1xuICB9XG5cbiAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIGxhc3QsIGN1cnJlbnQpIHtcbiAgICBpZiAobmFtZSA9PT0gJ21vZGlmaWVyJykge1xuICAgICAgY29uc3QgbWQgPSAoY3VycmVudCB8fCAnJykuaW5kZXhPZignbWF0ZXJpYWwnKSAhPT0gLTE7XG4gICAgICB0aGlzLl9sb2NhdGlvbnMgPSBsb2NhdGlvbnNbbWQgPyAnbWF0ZXJpYWwnIDogJ2lvcyddO1xuICAgIH1cblxuICAgIHN1cGVyLmF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBsYXN0LCBjdXJyZW50KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAZXZlbnQgY2hhbmdlXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1GaXJlZCB3aGVuIHRoZSBzd2l0Y2ggaXMgdG9nZ2xlZC5bL2VuXVxuICAgKiAgIFtqYV1PTi9PRkbjgYzlpInjgo/jgaPjgZ/mmYLjgavnmbrngavjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnRcbiAgICogICBbZW5dRXZlbnQgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCpOODmeODs+ODiOOCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5zd2l0Y2hcbiAgICogICBbZW5dU3dpdGNoIG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgqTjg5njg7Pjg4jjgYznmbrngavjgZfjgZ9Td2l0Y2jjgqrjg5bjgrjjgqfjgq/jg4jjgpLov5TjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGV2ZW50LnZhbHVlXG4gICAqICAgW2VuXUN1cnJlbnQgdmFsdWUuWy9lbl1cbiAgICogICBbamFd54++5Zyo44Gu5YCk44KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtCb29sZWFufSBldmVudC5pc0ludGVyYWN0aXZlXG4gICAqICAgW2VuXVRydWUgaWYgdGhlIGNoYW5nZSB3YXMgdHJpZ2dlcmVkIGJ5IHRoZSB1c2VyIGNsaWNraW5nIG9uIHRoZSBzd2l0Y2guWy9lbl1cbiAgICogICBbamFd44K/44OD44OX44KE44Kv44Oq44OD44Kv44Gq44Gp44Gu44Om44O844K244Gu5pON5L2c44Gr44KI44Gj44Gm5aSJ44KP44Gj44Gf5aC05ZCI44Gr44GvdHJ1ZeOCkui/lOOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIG1vZGlmaWVyXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXVRoZSBhcHBlYXJhbmNlIG9mIHRoZSBzd2l0Y2guWy9lbl1cbiAgICogIFtqYV3jgrnjgqTjg4Pjg4Hjga7ooajnj77jgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBkaXNhYmxlZFxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dV2hldGhlciB0aGUgc3dpdGNoIGlzIGJlIGRpc2FibGVkLlsvZW5dXG4gICAqICAgW2phXeOCueOCpOODg+ODgeOCkueEoeWKueOBrueKtuaFi+OBq+OBmeOCi+WgtOWQiOOBq+aMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGNoZWNrZWRcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVdoZXRoZXIgdGhlIHN3aXRjaCBpcyBjaGVja2VkLlsvZW5dXG4gICAqICAgW2phXeOCueOCpOODg+ODgeOBjE9O44Gu54q25oWL44Gr44GZ44KL44Go44GN44Gr5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgaW5wdXQtaWRcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVNwZWNpZnkgdGhlIGBpZGAgYXR0cmlidXRlIG9mIHRoZSBpbm5lciBgPGlucHV0PmAgZWxlbWVudC4gVGhpcyBpcyB1c2VmdWwgd2hlbiB1c2luZyBgPGxhYmVsIGZvcj1cIi4uLlwiPmAgZWxlbWVudHMuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBjaGVja2VkXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dVGhpcyB2YWx1ZSBpcyBgdHJ1ZWAgaWYgdGhlIHN3aXRjaCBpcyBjaGVja2VkLlsvZW5dXG4gICAqICAgW2phXeOCueOCpOODg+ODgeOBjE9O44Gu5aC05ZCI44GrYHRydWVg44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSB2YWx1ZVxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dVGhlIGN1cnJlbnQgdmFsdWUgb2YgdGhlIGlucHV0LlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgZGlzYWJsZWRcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1XaGV0aGVyIHRoZSBlbGVtZW50IGlzIGRpc2FibGVkIG9yIG5vdC5bL2VuXVxuICAgKiAgIFtqYV3nhKHlirnljJbjgZXjgozjgabjgYTjgovloLTlkIjjgatgdHJ1ZWDjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQHByb3BlcnR5IGNoZWNrYm94XG4gICAqIEByZWFkb25seVxuICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1UaGUgdW5kZXJseWluZyBjaGVja2JveCBlbGVtZW50LlsvZW5dXG4gICAqICAgW2phXeOCs+ODs+ODneODvOODjeODs+ODiOWGhemDqOOBrmNoZWNrYm946KaB57Sg44Gr44Gq44KK44G+44GZ44CCWy9qYV1cbiAgICovXG5cbn1cblxub25zRWxlbWVudHMuU3dpdGNoID0gU3dpdGNoRWxlbWVudDtcbmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnb25zLXN3aXRjaCcsIFN3aXRjaEVsZW1lbnQpO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IG9uc0VsZW1lbnRzIGZyb20gJy4uLy4uL29ucy9lbGVtZW50cyc7XG5pbXBvcnQgdXRpbCBmcm9tICcuLi8uLi9vbnMvdXRpbCc7XG5pbXBvcnQgaW50ZXJuYWwgZnJvbSAnLi4vLi4vb25zL2ludGVybmFsJztcbmltcG9ydCBhdXRvU3R5bGUgZnJvbSAnLi4vLi4vb25zL2F1dG9zdHlsZSc7XG5pbXBvcnQgU3dpcGVyIGZyb20gJy4uLy4uL29ucy9pbnRlcm5hbC9zd2lwZXInO1xuaW1wb3J0IE1vZGlmaWVyVXRpbCBmcm9tICcuLi8uLi9vbnMvaW50ZXJuYWwvbW9kaWZpZXItdXRpbCc7XG5pbXBvcnQgQmFzZUVsZW1lbnQgZnJvbSAnLi4vYmFzZS9iYXNlLWVsZW1lbnQnO1xuaW1wb3J0IGNvbnRlbnRSZWFkeSBmcm9tICcuLi8uLi9vbnMvY29udGVudC1yZWFkeSc7XG5cbmNvbnN0IHNjaGVtZSA9IHtcbiAgJy50YWJiYXJfX2NvbnRlbnQnOiAndGFiYmFyLS0qX19jb250ZW50JyxcbiAgJy50YWJiYXJfX2JvcmRlcic6ICd0YWJiYXItLSpfX2JvcmRlcicsXG4gICcudGFiYmFyJzogJ3RhYmJhci0tKidcbn07XG5cbmNvbnN0IHJld3JpdGFibGVzID0ge1xuICAvKipcbiAgICogQHBhcmFtIHtFbGVtZW50fSB0YWJiYXJFbGVtZW50XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqL1xuICByZWFkeSh0YWJiYXJFbGVtZW50LCBjYWxsYmFjaykge1xuICAgIGNhbGxiYWNrKCk7XG4gIH1cbn07XG5cbmNvbnN0IG51bGxQYWdlID0gaW50ZXJuYWwubnVsbEVsZW1lbnQ7XG5jb25zdCBsZXJwID0gKHgwLCB4MSwgdCkgPT4gKDEgLSB0KSAqIHgwICsgdCAqIHgxO1xuXG4vKipcbiAqIEBlbGVtZW50IG9ucy10YWJiYXJcbiAqIEBjYXRlZ29yeSB0YWJiYXJcbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dQSBjb21wb25lbnQgdG8gZGlzcGxheSBhIHRhYiBiYXIgb24gdGhlIGJvdHRvbSBvZiBhIHBhZ2UuIFVzZWQgd2l0aCBgPG9ucy10YWI+YCB0byBtYW5hZ2UgcGFnZXMgdXNpbmcgdGFicy5bL2VuXVxuICogICBbamFd44K/44OW44OQ44O844KS44Oa44O844K45LiL6YOo44Gr6KGo56S644GZ44KL44Gf44KB44Gu44Kz44Oz44Od44O844ON44Oz44OI44Gn44GZ44CCb25zLXRhYuOBqOe1hOOBv+WQiOOCj+OBm+OBpuS9v+OBhuOBk+OBqOOBp+OAgeODmuODvOOCuOOCkueuoeeQhuOBp+OBjeOBvuOBmeOAglsvamFdXG4gKiBAY29kZXBlbiBwR3VETFxuICogQHR1dG9yaWFsIHZhbmlsbGEvUmVmZXJlbmNlL3RhYmJhclxuICogQG1vZGlmaWVyIG1hdGVyaWFsXG4gKiAgIFtlbl1BIHRhYmJhciBpbiBNYXRlcmlhbCBEZXNpZ24uWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAbW9kaWZpZXIgYXV0b2dyb3dcbiAqICAgW2VuXVRhYnMgYXV0b21hdGljYWxseSBncm93IGRlcGVuZGluZyBvbiB0aGVpciBjb250ZW50IGluc3RlYWQgb2YgaGF2aW5nIGEgZml4ZWQgd2lkdGguWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAbW9kaWZpZXIgdG9wLWJvcmRlclxuICogICBbZW5dU2hvd3MgYSBzdGF0aWMgYm9yZGVyLWJvdHRvbSBpbiB0YWJzIGZvciBpT1MgdG9wIHRhYmJhcnMuWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAZ3VpZGUgZnVuZGFtZW50YWxzLmh0bWwjbWFuYWdpbmctcGFnZXNcbiAqICBbZW5dTWFuYWdpbmcgbXVsdGlwbGUgcGFnZXMuWy9lbl1cbiAqICBbamFd6KSH5pWw44Gu44Oa44O844K444KS566h55CG44GZ44KLWy9qYV1cbiAqIEBzZWVhbHNvIG9ucy10YWJcbiAqICAgW2VuXVRoZSBgPG9ucy10YWI+YCBjb21wb25lbnQuWy9lbl1cbiAqICAgW2phXW9ucy10YWLjgrPjg7Pjg53jg7zjg43jg7Pjg4hbL2phXVxuICogQHNlZWFsc28gb25zLXBhZ2VcbiAqICAgW2VuXVRoZSBgPG9ucy1wYWdlPmAgY29tcG9uZW50LlsvZW5dXG4gKiAgIFtqYV1vbnMtcGFnZeOCs+ODs+ODneODvOODjeODs+ODiFsvamFdXG4gKiBAZXhhbXBsZVxuICogPG9ucy10YWJiYXI+XG4gKiAgIDxvbnMtdGFiXG4gKiAgICAgcGFnZT1cImhvbWUuaHRtbFwiXG4gKiAgICAgbGFiZWw9XCJIb21lXCJcbiAqICAgICBhY3RpdmU+XG4gKiAgIDwvb25zLXRhYj5cbiAqICAgPG9ucy10YWJcbiAqICAgICBwYWdlPVwic2V0dGluZ3MuaHRtbFwiXG4gKiAgICAgbGFiZWw9XCJTZXR0aW5nc1wiXG4gKiAgICAgYWN0aXZlPlxuICogICA8L29ucy10YWI+XG4gKiA8L29ucy10YWJiYXI+XG4gKlxuICogPHRlbXBsYXRlIGlkPVwiaG9tZS5odG1sXCI+XG4gKiAgIC4uLlxuICogPC90ZW1wbGF0ZT5cbiAqXG4gKiA8dGVtcGxhdGUgaWQ9XCJzZXR0aW5ncy5odG1sXCI+XG4gKiAgIC4uLlxuICogPC90ZW1wbGF0ZT5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVGFiYmFyRWxlbWVudCBleHRlbmRzIEJhc2VFbGVtZW50IHtcblxuICAvKipcbiAgICogQGV2ZW50IHByZWNoYW5nZVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dRmlyZXMganVzdCBiZWZvcmUgdGhlIHRhYiBpcyBjaGFuZ2VkLlsvZW5dXG4gICAqICAgW2phXeOCouOCr+ODhuOCo+ODluOBquOCv+ODluOBjOWkieOCj+OCi+WJjeOBq+eZuueBq+OBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudFxuICAgKiAgIFtlbl1FdmVudCBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Kk44OZ44Oz44OI44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGV2ZW50LmluZGV4XG4gICAqICAgW2VuXUN1cnJlbnQgaW5kZXguWy9lbl1cbiAgICogICBbamFd54++5Zyo44Ki44Kv44OG44Kj44OW44Gr44Gq44Gj44Gm44GE44KLb25zLXRhYuOBruOCpOODs+ODh+ODg+OCr+OCueOCkui/lOOBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC50YWJJdGVtXG4gICAqICAgW2VuXVRhYiBpdGVtIG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV10YWJJdGVt44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZXZlbnQuY2FuY2VsXG4gICAqICAgW2VuXUNhbGwgdGhpcyBmdW5jdGlvbiB0byBjYW5jZWwgdGhlIGNoYW5nZSBldmVudC5bL2VuXVxuICAgKiAgIFtqYV3jgZPjga7plqLmlbDjgpLlkbzjgbPlh7rjgZnjgajjgIHjgqLjgq/jg4bjgqPjg5bjgarjgr/jg5bjga7lpInmm7TjgYzjgq3jg6Pjg7Pjgrvjg6vjgZXjgozjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGV2ZW50IHBvc3RjaGFuZ2VcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUZpcmVzIGp1c3QgYWZ0ZXIgdGhlIHRhYiBpcyBjaGFuZ2VkLlsvZW5dXG4gICAqICAgW2phXeOCouOCr+ODhuOCo+ODluOBquOCv+ODluOBjOWkieOCj+OBo+OBn+W+jOOBq+eZuueBq+OBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudFxuICAgKiAgIFtlbl1FdmVudCBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Kk44OZ44Oz44OI44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGV2ZW50LmluZGV4XG4gICAqICAgW2VuXUN1cnJlbnQgaW5kZXguWy9lbl1cbiAgICogICBbamFd54++5Zyo44Ki44Kv44OG44Kj44OW44Gr44Gq44Gj44Gm44GE44KLb25zLXRhYuOBruOCpOODs+ODh+ODg+OCr+OCueOCkui/lOOBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC50YWJJdGVtXG4gICAqICAgW2VuXVRhYiBpdGVtIG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV10YWJJdGVt44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBldmVudCByZWFjdGl2ZVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dRmlyZXMgaWYgdGhlIGFscmVhZHkgb3BlbiB0YWIgaXMgdGFwcGVkIGFnYWluLlsvZW5dXG4gICAqICAgW2phXeOBmeOBp+OBq+OCouOCr+ODhuOCo+ODluOBq+OBquOBo+OBpuOBhOOCi+OCv+ODluOBjOOCguOBhuS4gOW6puOCv+ODg+ODl+OChOOCr+ODquODg+OCr+OBleOCjOOBn+WgtOWQiOOBq+eZuueBq+OBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudFxuICAgKiAgIFtlbl1FdmVudCBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Kk44OZ44Oz44OI44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGV2ZW50LmluZGV4XG4gICAqICAgW2VuXUN1cnJlbnQgaW5kZXguWy9lbl1cbiAgICogICBbamFd54++5Zyo44Ki44Kv44OG44Kj44OW44Gr44Gq44Gj44Gm44GE44KLb25zLXRhYuOBruOCpOODs+ODh+ODg+OCr+OCueOCkui/lOOBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC50YWJJdGVtXG4gICAqICAgW2VuXVRhYiBpdGVtIG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV10YWJJdGVt44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgYW5pbWF0aW9uXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZWZhdWx0IG5vbmVcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUlmIHRoaXMgYXR0cmlidXRlIGlzIHNldCB0byBgXCJub25lXCJgIHRoZSB0cmFuc2l0aW9ucyB3aWxsIG5vdCBiZSBhbmltYXRlZC5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBhbmltYXRpb24tb3B0aW9uc1xuICAgKiBAdHlwZSB7RXhwcmVzc2lvbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dU3BlY2lmeSB0aGUgYW5pbWF0aW9uJ3MgZHVyYXRpb24sIHRpbWluZyBhbmQgZGVsYXkgd2l0aCBhbiBvYmplY3QgbGl0ZXJhbC4gRS5nLiBge2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAxLCB0aW1pbmc6ICdlYXNlLWluJ31gLlsvZW5dXG4gICAqICBbamFd44Ki44OL44Oh44O844K344On44Oz5pmC44GuZHVyYXRpb24sIHRpbWluZywgZGVsYXnjgpLjgqrjg5bjgrjjgqfjgq/jg4jjg6rjg4bjg6njg6vjgafmjIflrprjgZfjgb7jgZnjgIJlLmcuIHtkdXJhdGlvbjogMC4yLCBkZWxheTogMSwgdGltaW5nOiAnZWFzZS1pbid9Wy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgcG9zaXRpb25cbiAgICogQGluaXRvbmx5XG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZWZhdWx0IGJvdHRvbVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dVGFiYmFyJ3MgcG9zaXRpb24uIEF2YWlsYWJsZSB2YWx1ZXMgYXJlIGBcImJvdHRvbVwiYCBhbmQgYFwidG9wXCJgLiBVc2UgYFwiYXV0b1wiYCB0byBjaG9vc2UgcG9zaXRpb24gZGVwZW5kaW5nIG9uIHBsYXRmb3JtIChib3R0b20gZm9yIGlPUyBmbGF0IGRlc2lnbiwgdG9wIGZvciBNYXRlcmlhbCBEZXNpZ24pLlsvZW5dXG4gICAqICAgW2phXeOCv+ODluODkOODvOOBruS9jee9ruOCkuaMh+WumuOBl+OBvuOBmeOAglwiYm90dG9tXCLjgoLjgZfjgY/jga9cInRvcFwi44KS6YG45oqe44Gn44GN44G+44GZ44CC44OH44OV44Kp44Or44OI44GvXCJib3R0b21cIuOBp+OBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIHN3aXBlYWJsZVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dSWYgdGhpcyBhdHRyaWJ1dGUgaXMgc2V0IHRoZSB0YWIgYmFyIGNhbiBiZSBzY3JvbGxlZCBieSBkcmFnIG9yIHN3aXBlLlsvZW5dXG4gICAqICAgW2phXeOBk+OBruWxnuaAp+OBjOOBguOCi+aZguOAgeOCv+ODluODkOODvOOCkuOCueODr+OCpOODl+OChOODieODqeODg+OCsOOBp+enu+WLleOBp+OBjeOCi+OCiOOBhuOBq+OBquOCiuOBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGlnbm9yZS1lZGdlLXdpZHRoXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqIEBkZWZhdWx0IDIwXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1EaXN0YW5jZSBpbiBwaXhlbHMgZnJvbSBib3RoIGVkZ2VzLiBTd2lwaW5nIG9uIHRoZXNlIGFyZWFzIHdpbGwgcHJpb3JpdGl6ZSBwYXJlbnQgY29tcG9uZW50cyBzdWNoIGFzIGBvbnMtc3BsaXR0ZXJgIG9yIGBvbnMtbmF2aWdhdG9yYC5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBoaWRlLXRhYnNcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVdoZXRoZXIgdG8gaGlkZSB0aGUgdGFicy5bL2VuXVxuICAgKiAgIFtqYV3jgr/jg5bjgpLpnZ7ooajnpLrjgavjgZnjgovloLTlkIjjgavmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSB0YWItYm9yZGVyXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1JZiB0aGlzIGF0dHJpYnV0ZSBpcyBzZXQgdGhlIHRhYnMgc2hvdyBhIGR5bmFtaWMgYm90dG9tIGJvcmRlci4gT25seSB3b3JrcyBmb3IgaU9TIGZsYXQgZGVzaWduIHNpbmNlIHRoZSBib3JkZXIgaXMgYWx3YXlzIHZpc2libGUgaW4gTWF0ZXJpYWwgRGVzaWduLlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIG1vZGlmaWVyXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1UaGUgYXBwZWFyYW5jZSBvZiB0aGUgdGFiYmFyLlsvZW5dXG4gICAqICAgW2phXeOCv+ODluODkOODvOOBruihqOePvuOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5fbG9hZEluYWN0aXZlID0gdXRpbC5kZWZlcigpOyAvLyBJbXByb3ZlcyAjMjMyNFxuICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB0aGlzLl9jb21waWxlKCkpO1xuICB9XG5cbiAgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgaWYgKCF0aGlzLl9zd2lwZXIpIHtcbiAgICAgIHRoaXMuX3N3aXBlciA9IG5ldyBTd2lwZXIoe1xuICAgICAgICBnZXRFbGVtZW50OiAoKSA9PiB0aGlzLl9jb250ZW50RWxlbWVudCxcbiAgICAgICAgZ2V0SW5pdGlhbEluZGV4OiAoKSA9PiB0aGlzLmdldEF0dHJpYnV0ZSgnYWN0aXZlSW5kZXgnKSB8fCB0aGlzLmdldEF0dHJpYnV0ZSgnYWN0aXZlLWluZGV4JyksXG4gICAgICAgIGdldEF1dG9TY3JvbGxSYXRpbzogdGhpcy5fZ2V0QXV0b1Njcm9sbFJhdGlvLmJpbmQodGhpcyksXG4gICAgICAgIGdldEJ1YmJsZVdpZHRoOiAoKSA9PiBwYXJzZUludCh0aGlzLmdldEF0dHJpYnV0ZSgnaWdub3JlLWVkZ2Utd2lkdGgnKSB8fCAyNSwgMTApLFxuICAgICAgICBpc0F1dG9TY3JvbGxhYmxlOiAoKSA9PiB0cnVlLFxuICAgICAgICBwcmVDaGFuZ2VIb29rOiB0aGlzLl9vblByZUNoYW5nZS5iaW5kKHRoaXMpLFxuICAgICAgICBwb3N0Q2hhbmdlSG9vazogdGhpcy5fb25Qb3N0Q2hhbmdlLmJpbmQodGhpcyksXG4gICAgICAgIHJlZnJlc2hIb29rOiB0aGlzLl9vblJlZnJlc2guYmluZCh0aGlzKSxcbiAgICAgICAgc2Nyb2xsSG9vazogdGhpcy5fb25TY3JvbGwuYmluZCh0aGlzKVxuICAgICAgfSk7XG5cbiAgICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB7XG4gICAgICAgIHRoaXMuX3RhYmJhckJvcmRlciA9IHV0aWwuZmluZENoaWxkKHRoaXMuX3RhYmJhckVsZW1lbnQsICcudGFiYmFyX19ib3JkZXInKTtcbiAgICAgICAgdGhpcy5fc3dpcGVyLmluaXQoeyBzd2lwZWFibGU6IHRoaXMuaGFzQXR0cmlidXRlKCdzd2lwZWFibGUnKSB9KTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB7XG4gICAgICB0aGlzLl91cGRhdGVQb3NpdGlvbigpO1xuXG4gICAgICBpZiAoIXV0aWwuZmluZFBhcmVudCh0aGlzLCAnb25zLXBhZ2UnLCBwID0+IHAgPT09IGRvY3VtZW50LmJvZHkpKSB7XG4gICAgICAgIHRoaXMuX3Nob3coKTsgLy8gVGhpcyB0YWJiYXIgaXMgdGhlIHRvcCBjb21wb25lbnRcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGRpc2Nvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIGlmICh0aGlzLl9zd2lwZXIgJiYgdGhpcy5fc3dpcGVyLmluaXRpYWxpemVkKSB7XG4gICAgICB0aGlzLl9zd2lwZXIuZGlzcG9zZSgpO1xuICAgICAgdGhpcy5fc3dpcGVyID0gbnVsbDtcbiAgICAgIHRoaXMuX3RhYmJhckJvcmRlciA9IG51bGw7XG4gICAgICB0aGlzLl90YWJzUmVjdCA9IG51bGw7XG4gICAgfVxuICB9XG5cbiAgX25vcm1hbGl6ZUV2ZW50KGV2ZW50KSB7XG4gICAgcmV0dXJuIHsgLi4uZXZlbnQsIGluZGV4OiBldmVudC5hY3RpdmVJbmRleCwgdGFiSXRlbTogdGhpcy50YWJzW2V2ZW50LmFjdGl2ZUluZGV4XSB9O1xuICB9XG5cbiAgX29uUG9zdENoYW5nZShldmVudCkge1xuICAgIGV2ZW50ID0gdGhpcy5fbm9ybWFsaXplRXZlbnQoZXZlbnQpO1xuICAgIHV0aWwudHJpZ2dlckVsZW1lbnRFdmVudCh0aGlzLCAncG9zdGNoYW5nZScsIGV2ZW50KTtcbiAgICBjb25zdCBwYWdlID0gZXZlbnQudGFiSXRlbS5wYWdlRWxlbWVudDtcbiAgICBwYWdlICYmIHBhZ2UuX3Nob3coKTtcbiAgfVxuXG4gIF9vblByZUNoYW5nZShldmVudCkge1xuICAgIGV2ZW50ID0gdGhpcy5fbm9ybWFsaXplRXZlbnQoZXZlbnQpO1xuICAgIGV2ZW50LmNhbmNlbCA9ICgpID0+IGV2ZW50LmNhbmNlbGVkID0gdHJ1ZTtcblxuICAgIHV0aWwudHJpZ2dlckVsZW1lbnRFdmVudCh0aGlzLCAncHJlY2hhbmdlJywgZXZlbnQpO1xuXG4gICAgaWYgKCFldmVudC5jYW5jZWxlZCkge1xuICAgICAgY29uc3QgeyBhY3RpdmVJbmRleCwgbGFzdEFjdGl2ZUluZGV4IH0gPSBldmVudDtcbiAgICAgIGNvbnN0IHRhYnMgPSB0aGlzLnRhYnM7XG5cbiAgICAgIHRhYnNbYWN0aXZlSW5kZXhdLnNldEFjdGl2ZSh0cnVlKTtcbiAgICAgIGlmIChsYXN0QWN0aXZlSW5kZXggPj0gMCkge1xuICAgICAgICBjb25zdCBwcmV2VGFiID0gdGFic1tsYXN0QWN0aXZlSW5kZXhdO1xuICAgICAgICBwcmV2VGFiLnNldEFjdGl2ZShmYWxzZSk7XG4gICAgICAgIHByZXZUYWIucGFnZUVsZW1lbnQgJiYgcHJldlRhYi5wYWdlRWxlbWVudC5faGlkZSgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBldmVudC5jYW5jZWxlZFxuICB9XG5cbiAgX29uU2Nyb2xsKGluZGV4LCBvcHRpb25zID0ge30pIHtcbiAgICBpZiAodGhpcy5fdGFiYmFyQm9yZGVyKSB7XG4gICAgICB0aGlzLl90YWJiYXJCb3JkZXIuc3R5bGUudHJhbnNpdGlvbiA9IGBhbGwgJHtvcHRpb25zLmR1cmF0aW9uIHx8IDB9cyAke29wdGlvbnMudGltaW5nIHx8ICcnfWA7XG5cbiAgICAgIGlmICh0aGlzLl9hdXRvZ3JvdyAmJiB0aGlzLl90YWJzUmVjdC5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbnN0IGEgPSBNYXRoLmZsb29yKGluZGV4KSwgYiA9IE1hdGguY2VpbChpbmRleCksIHIgPSBpbmRleCAlIDE7XG4gICAgICAgIHRoaXMuX3RhYmJhckJvcmRlci5zdHlsZS53aWR0aCA9IGxlcnAodGhpcy5fdGFic1JlY3RbYV0ud2lkdGgsIHRoaXMuX3RhYnNSZWN0W2JdLndpZHRoLCByKSArICdweCc7XG4gICAgICAgIHRoaXMuX3RhYmJhckJvcmRlci5zdHlsZS50cmFuc2Zvcm0gPSBgdHJhbnNsYXRlM2QoJHtsZXJwKHRoaXMuX3RhYnNSZWN0W2FdLmxlZnQsIHRoaXMuX3RhYnNSZWN0W2JdLmxlZnQsIHIpfXB4LCAwLCAwKWA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl90YWJiYXJCb3JkZXIuc3R5bGUudHJhbnNmb3JtID0gYHRyYW5zbGF0ZTNkKCR7aW5kZXggKiAxMDB9JSwgMCwgMClgO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuX29uU3dpcGUgJiYgdGhpcy5fb25Td2lwZShpbmRleCwgb3B0aW9ucyk7XG4gIH1cblxuICBfb25SZWZyZXNoKCkge1xuICAgIHRoaXMuX2F1dG9ncm93ID0gdXRpbC5oYXNNb2RpZmllcih0aGlzLCAnYXV0b2dyb3cnKTtcbiAgICB0aGlzLl90YWJzUmVjdCA9IHRoaXMudGFicy5tYXAodGFiID0+IHRhYi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSk7XG4gICAgaWYgKHRoaXMuX3RhYmJhckJvcmRlcikge1xuICAgICAgdGhpcy5fdGFiYmFyQm9yZGVyLnN0eWxlLmRpc3BsYXkgPSB0aGlzLmhhc0F0dHJpYnV0ZSgndGFiLWJvcmRlcicpIHx8IHV0aWwuaGFzTW9kaWZpZXIodGhpcywgJ21hdGVyaWFsJykgPyAnYmxvY2snIDogJ25vbmUnO1xuICAgICAgY29uc3QgaW5kZXggPSB0aGlzLmdldEFjdGl2ZVRhYkluZGV4KCk7XG4gICAgICBpZiAodGhpcy5fdGFic1JlY3QubGVuZ3RoID4gMCAmJiBpbmRleCA+PSAwKSB7XG4gICAgICAgIHRoaXMuX3RhYmJhckJvcmRlci5zdHlsZS53aWR0aCA9IHRoaXMuX3RhYnNSZWN0W2luZGV4XS53aWR0aCArICdweCc7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgX2dldEF1dG9TY3JvbGxSYXRpbyhtYXRjaGVzLCB2ZWxvY2l0eSwgc2l6ZSkge1xuICAgIGNvbnN0IHJhdGlvID0gLjY7IC8vIEJhc2UgcmF0aW9cbiAgICBjb25zdCBtb2RpZmllciA9IHNpemUgLyAzMDAgKiAobWF0Y2hlcyA/IC0xIDogMSk7IC8vIEJhc2VkIG9uIHNjcmVlbiBzaXplXG4gICAgcmV0dXJuIE1hdGgubWluKDEsIE1hdGgubWF4KDAsIHJhdGlvICsgdmVsb2NpdHkgKiBtb2RpZmllcikpO1xuICB9XG5cbiAgZ2V0IF90YWJiYXJFbGVtZW50KCkge1xuICAgIHJldHVybiB1dGlsLmZpbmRDaGlsZCh0aGlzLCAnLnRhYmJhcicpO1xuICB9XG5cbiAgZ2V0IF9jb250ZW50RWxlbWVudCgpIHtcbiAgICByZXR1cm4gdXRpbC5maW5kQ2hpbGQodGhpcywgJy50YWJiYXJfX2NvbnRlbnQnKTtcbiAgfVxuXG4gIGdldCBfdGFyZ2V0RWxlbWVudCgpIHtcbiAgICBjb25zdCBjb250ZW50ID0gdGhpcy5fY29udGVudEVsZW1lbnQ7XG4gICAgcmV0dXJuIGNvbnRlbnQgJiYgY29udGVudC5jaGlsZHJlblswXSB8fCBudWxsO1xuICB9XG5cbiAgX2NvbXBpbGUoKSB7XG4gICAgYXV0b1N0eWxlLnByZXBhcmUodGhpcyk7XG5cbiAgICBjb25zdCBjb250ZW50ID0gdGhpcy5fY29udGVudEVsZW1lbnQgfHwgdXRpbC5jcmVhdGUoJy50YWJiYXJfX2NvbnRlbnQnKTtcbiAgICBjb250ZW50LmNsYXNzTGlzdC5hZGQoJ29ucy10YWJiYXJfX2NvbnRlbnQnKTtcbiAgICBjb25zdCB0YWJiYXIgPSB0aGlzLl90YWJiYXJFbGVtZW50IHx8IHV0aWwuY3JlYXRlKCcudGFiYmFyJyk7XG4gICAgdGFiYmFyLmNsYXNzTGlzdC5hZGQoJ29ucy10YWJiYXJfX2Zvb3RlcicpO1xuXG4gICAgaWYgKCF0YWJiYXIucGFyZW50Tm9kZSkge1xuICAgICAgd2hpbGUgKHRoaXMuZmlyc3RDaGlsZCkge1xuICAgICAgICB0YWJiYXIuYXBwZW5kQ2hpbGQodGhpcy5maXJzdENoaWxkKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBhY3RpdmVJbmRleCA9IE51bWJlcih0aGlzLmdldEF0dHJpYnV0ZSgnYWN0aXZlSW5kZXgnKSk7IC8vIDAgYnkgZGVmYXVsdFxuICAgIGlmICh0YWJiYXIuY2hpbGRyZW4ubGVuZ3RoID4gYWN0aXZlSW5kZXggJiYgIXV0aWwuZmluZENoaWxkKHRhYmJhciwgJ1thY3RpdmVdJykpIHtcbiAgICAgIHRhYmJhci5jaGlsZHJlblthY3RpdmVJbmRleF0uc2V0QXR0cmlidXRlKCdhY3RpdmUnLCAnJyk7XG4gICAgfVxuXG4gICAgdGhpcy5fdGFiYmFyQm9yZGVyID0gdXRpbC5maW5kQ2hpbGQodGFiYmFyLCAnLnRhYmJhcl9fYm9yZGVyJykgfHwgdXRpbC5jcmVhdGUoJy50YWJiYXJfX2JvcmRlcicpO1xuICAgIHRhYmJhci5hcHBlbmRDaGlsZCh0aGlzLl90YWJiYXJCb3JkZXIpO1xuICAgIHRhYmJhci5jbGFzc0xpc3QuYWRkKCdvbnMtc3dpcGVyLXRhYmJhcicpOyAvLyBIaWRlcyBtYXRlcmlhbCBib3JkZXJcblxuICAgICFjb250ZW50LmNoaWxkcmVuWzBdICYmIGNvbnRlbnQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JykpO1xuICAgICFjb250ZW50LmNoaWxkcmVuWzFdICYmIGNvbnRlbnQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JykpO1xuICAgIGNvbnRlbnQuYXBwZW5kQ2hpbGQgPSBjb250ZW50LmFwcGVuZENoaWxkLmJpbmQoY29udGVudC5jaGlsZHJlblswXSk7XG4gICAgY29udGVudC5pbnNlcnRCZWZvcmUgPSBjb250ZW50Lmluc2VydEJlZm9yZS5iaW5kKGNvbnRlbnQuY2hpbGRyZW5bMF0pO1xuXG4gICAgdGhpcy5hcHBlbmRDaGlsZChjb250ZW50KTtcbiAgICB0aGlzLmFwcGVuZENoaWxkKHRhYmJhcik7IC8vIFRyaWdnZXJzIG9ucy10YWIgY29ubmVjdGVkQ2FsbGJhY2tcblxuICAgIE1vZGlmaWVyVXRpbC5pbml0TW9kaWZpZXIodGhpcywgc2NoZW1lKTtcbiAgfVxuXG4gIF91cGRhdGVQb3NpdGlvbihwb3NpdGlvbiA9IHRoaXMuZ2V0QXR0cmlidXRlKCdwb3NpdGlvbicpKSB7XG4gICAgY29uc3QgdG9wID0gdGhpcy5fdG9wID0gcG9zaXRpb24gPT09ICd0b3AnIHx8IChwb3NpdGlvbiA9PT0gJ2F1dG8nICYmIHV0aWwuaGFzTW9kaWZpZXIodGhpcywgJ21hdGVyaWFsJykpO1xuICAgIGNvbnN0IGFjdGlvbiA9IHRvcCA/IHV0aWwuYWRkTW9kaWZpZXIgOiB1dGlsLnJlbW92ZU1vZGlmaWVyO1xuXG4gICAgYWN0aW9uKHRoaXMsICd0b3AnKTtcblxuICAgIGNvbnN0IHBhZ2UgPSB1dGlsLmZpbmRQYXJlbnQodGhpcywgJ29ucy1wYWdlJyk7XG4gICAgaWYgKHBhZ2UpIHtcbiAgICAgIGNvbnRlbnRSZWFkeShwYWdlLCAoKSA9PiB7XG4gICAgICAgIGxldCBwID0gMDtcbiAgICAgICAgaWYgKHBhZ2UuY2hpbGRyZW5bMF0gJiYgdXRpbC5tYXRjaChwYWdlLmNoaWxkcmVuWzBdLCAnb25zLXRvb2xiYXInKSkge1xuICAgICAgICAgIGFjdGlvbihwYWdlLmNoaWxkcmVuWzBdLCAnbm9zaGFkb3cnKTtcbiAgICAgICAgICBwID0gMTsgLy8gVmlzdWFsIGZpeCBmb3Igc29tZSBkZXZpY2VzXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBjb250ZW50ID0gcGFnZS5fZ2V0Q29udGVudEVsZW1lbnQoKTtcbiAgICAgICAgY29uc3QgY3MgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShwYWdlLl9nZXRDb250ZW50RWxlbWVudCgpLCBudWxsKVxuXG4gICAgICAgIHRoaXMuc3R5bGUudG9wID0gdG9wID8gcGFyc2VJbnQoY3MuZ2V0UHJvcGVydHlWYWx1ZSgncGFkZGluZy10b3AnKSwgMTApIC0gcCArICdweCcgOiAnJztcblxuICAgICAgICAvLyBSZWZyZXNoIGNvbnRlbnQgdG9wIC0gRml4IGZvciBpT1MgOFxuICAgICAgICBjb250ZW50LnN0eWxlLnRvcCA9IGNzLnRvcDtcbiAgICAgICAgY29udGVudC5zdHlsZS50b3AgPSAnJztcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGludGVybmFsLmF1dG9TdGF0dXNCYXJGaWxsKCgpID0+IHtcbiAgICAgIGNvbnN0IGZpbGxlZCA9IHV0aWwuZmluZFBhcmVudCh0aGlzLCBlID0+IGUuaGFzQXR0cmlidXRlKCdzdGF0dXMtYmFyLWZpbGwnKSk7XG4gICAgICB1dGlsLnRvZ2dsZUF0dHJpYnV0ZSh0aGlzLCAnc3RhdHVzLWJhci1maWxsJywgdG9wICYmICFmaWxsZWQpO1xuICAgIH0pO1xuICB9XG5cbiAgZ2V0IHRvcFBhZ2UoKSB7XG4gICAgY29uc3QgdGFicyA9IHRoaXMudGFicyxcbiAgICAgIGluZGV4ID0gdGhpcy5nZXRBY3RpdmVUYWJJbmRleCgpO1xuICAgIHJldHVybiB0YWJzW2luZGV4XVxuICAgICAgPyB0YWJzW2luZGV4XS5wYWdlRWxlbWVudCB8fCB0aGlzLnBhZ2VzWzBdIHx8IG51bGxcbiAgICAgIDogbnVsbDtcbiAgfVxuXG4gIGdldCBwYWdlcygpIHtcbiAgICByZXR1cm4gdXRpbC5hcnJheUZyb20odGhpcy5fdGFyZ2V0RWxlbWVudC5jaGlsZHJlbik7XG4gIH1cblxuICBnZXQgdGFicygpIHtcbiAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLmZpbHRlci5jYWxsKHRoaXMuX3RhYmJhckVsZW1lbnQuY2hpbGRyZW4sIGUgPT4gZS50YWdOYW1lID09PSAnT05TLVRBQicpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2Qgc2V0QWN0aXZlVGFiXG4gICAqIEBzaWduYXR1cmUgc2V0QWN0aXZlVGFiKGluZGV4LCBbb3B0aW9uc10pXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxuICAgKiAgIFtlbl1UYWIgaW5kZXguWy9lbl1cbiAgICogICBbamFd44K/44OW44Gu44Kk44Oz44OH44OD44Kv44K544KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiAgIFtlbl1QYXJhbWV0ZXIgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCquODl+OCt+ODp+ODs+OCkuaMh+WumuOBmeOCi+OCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmNhbGxiYWNrXVxuICAgKiAgIFtlbl1GdW5jdGlvbiB0aGF0IHJ1bnMgd2hlbiB0aGUgbmV3IHBhZ2UgaGFzIGxvYWRlZC5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuYW5pbWF0aW9uXVxuICAgKiAgIFtlbl1JZiB0aGlzIG9wdGlvbiBpcyBcIm5vbmVcIiwgdGhlIHRyYW5zaXRpb24gd29uJ3Qgc2xpZGUuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmFuaW1hdGlvbk9wdGlvbnNdXG4gICAqICAgW2VuXVNwZWNpZnkgdGhlIGFuaW1hdGlvbidzIGR1cmF0aW9uLCBkZWxheSBhbmQgdGltaW5nLiBFLmcuIGB7ZHVyYXRpb246IDAuMiwgZGVsYXk6IDAuNCwgdGltaW5nOiAnZWFzZS1pbid9YC5bL2VuXVxuICAgKiAgIFtqYV3jgqLjg4vjg6Hjg7zjgrfjg6fjg7PmmYLjga5kdXJhdGlvbiwgZGVsYXksIHRpbWluZ+OCkuaMh+WumuOBl+OBvuOBmeOAgmUuZy4ge2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAwLjQsIHRpbWluZzogJ2Vhc2UtaW4nfVsvamFdXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1TaG93IHNwZWNpZmllZCB0YWIgcGFnZS4gQW5pbWF0aW9ucyBhbmQgdGhlaXIgb3B0aW9ucyBjYW4gYmUgc3BlY2lmaWVkIGJ5IHRoZSBzZWNvbmQgcGFyYW1ldGVyLlsvZW5dXG4gICAqICAgW2phXeaMh+WumuOBl+OBn+OCpOODs+ODh+ODg+OCr+OCueOBruOCv+ODluOCkuihqOekuuOBl+OBvuOBmeOAguOCouODi+ODoeODvOOCt+ODp+ODs+OBquOBqeOBruOCquODl+OCt+ODp+ODs+OCkuaMh+WumuOBp+OBjeOBvuOBmeOAglsvamFdXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqICAgW2VuXUEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSBuZXcgcGFnZSBlbGVtZW50LlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuICBzZXRBY3RpdmVUYWIobmV4dEluZGV4LCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCBwcmV2SW5kZXggPSB0aGlzLmdldEFjdGl2ZVRhYkluZGV4KCk7XG4gICAgY29uc3QgcHJldlRhYiA9IHRoaXMudGFic1twcmV2SW5kZXhdLFxuICAgICAgbmV4dFRhYiA9IHRoaXMudGFic1tuZXh0SW5kZXhdO1xuXG4gICAgaWYgKCFuZXh0VGFiKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoJ1NwZWNpZmllZCBpbmRleCBkb2VzIG5vdCBtYXRjaCBhbnkgdGFiLicpO1xuICAgIH1cblxuICAgIGlmIChuZXh0SW5kZXggPT09IHByZXZJbmRleCkge1xuICAgICAgdXRpbC50cmlnZ2VyRWxlbWVudEV2ZW50KHRoaXMsICdyZWFjdGl2ZScsIHsgaW5kZXg6IG5leHRJbmRleCwgYWN0aXZlSW5kZXg6IG5leHRJbmRleCwgdGFiSXRlbTogbmV4dFRhYiB9KTtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobmV4dFRhYi5wYWdlRWxlbWVudCk7XG4gICAgfVxuXG4gICAgLy8gRklYTUU6IG5leHRUYWIubG9hZGVkIGlzIGJyb2tlbiBpbiBab25lLmpzIHByb21pc2VzIChBbmd1bGFyMilcbiAgICBjb25zdCBuZXh0UGFnZSA9IG5leHRUYWIucGFnZUVsZW1lbnQ7XG4gICAgcmV0dXJuIChuZXh0UGFnZSA/IFByb21pc2UucmVzb2x2ZShuZXh0UGFnZSkgOiBuZXh0VGFiLmxvYWRlZClcbiAgICAgIC50aGVuKG5leHRQYWdlID0+IHRoaXMuX3N3aXBlci5zZXRBY3RpdmVJbmRleChuZXh0SW5kZXgsIHtcbiAgICAgICAgcmVqZWN0OiB0cnVlLFxuICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICBhbmltYXRpb246IHByZXZUYWIgJiYgbmV4dFBhZ2UgPyBvcHRpb25zLmFuaW1hdGlvbiB8fCB0aGlzLmdldEF0dHJpYnV0ZSgnYW5pbWF0aW9uJykgOiAnbm9uZScsXG4gICAgICAgIGFuaW1hdGlvbk9wdGlvbnM6IHV0aWwuZXh0ZW5kKFxuICAgICAgICAgIHsgZHVyYXRpb246IC4zLCB0aW1pbmc6ICdjdWJpYy1iZXppZXIoLjQsIC43LCAuNSwgMSknIH0sXG4gICAgICAgICAgdGhpcy5oYXNBdHRyaWJ1dGUoJ2FuaW1hdGlvbi1vcHRpb25zJykgPyB1dGlsLmFuaW1hdGlvbk9wdGlvbnNQYXJzZSh0aGlzLmdldEF0dHJpYnV0ZSgnYW5pbWF0aW9uLW9wdGlvbnMnKSkgOiB7fSxcbiAgICAgICAgICBvcHRpb25zLmFuaW1hdGlvbk9wdGlvbnMgfHwge31cbiAgICAgICAgKVxuICAgICAgfSkudGhlbigoKSA9PiB7XG4gICAgICAgIG9wdGlvbnMuY2FsbGJhY2sgaW5zdGFuY2VvZiBGdW5jdGlvbiAmJiBvcHRpb25zLmNhbGxiYWNrKG5leHRQYWdlKTtcbiAgICAgICAgcmV0dXJuIG5leHRQYWdlO1xuICAgICAgfSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2Qgc2V0VGFiYmFyVmlzaWJpbGl0eVxuICAgKiBAc2lnbmF0dXJlIHNldFRhYmJhclZpc2liaWxpdHkodmlzaWJsZSlcbiAgICogQHBhcmFtIHtCb29sZWFufSB2aXNpYmxlXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1Vc2VkIHRvIGhpZGUgb3Igc2hvdyB0aGUgdGFiIGJhci5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cbiAgc2V0VGFiYmFyVmlzaWJpbGl0eSh2aXNpYmxlKSB7XG4gICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHtcbiAgICAgIHRoaXMuX2NvbnRlbnRFbGVtZW50LnN0eWxlW3RoaXMuX3RvcCA/ICd0b3AnIDogJ2JvdHRvbSddID0gdmlzaWJsZSA/ICcnIDogJzBweCc7XG4gICAgICB0aGlzLl90YWJiYXJFbGVtZW50LnN0eWxlLmRpc3BsYXkgPSB2aXNpYmxlID8gJycgOiAnbm9uZSc7XG4gICAgICB2aXNpYmxlICYmIHRoaXMuX29uUmVmcmVzaCgpO1xuICAgIH0pO1xuICB9XG5cbiAgc2hvdygpIHtcbiAgICB0aGlzLnNldFRhYmJhclZpc2liaWxpdHkodHJ1ZSk7XG4gIH1cblxuICBoaWRlKCkge1xuICAgIHRoaXMuc2V0VGFiYmFyVmlzaWJpbGl0eShmYWxzZSk7XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IHZpc2libGVcbiAgICogQHJlYWRvbmx5XG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dV2hldGhlciB0aGUgdGFiYmFyIGlzIHZpc2libGUgb3Igbm90LlsvZW5dXG4gICAqICAgW2phXeOCv+ODluODkOODvOOBjOimi+OBiOOCi+WgtOWQiOOBq2B0cnVlYOOAglsvamFdXG4gICAqL1xuICBnZXQgdmlzaWJsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fdGFiYmFyRWxlbWVudC5zdHlsZS5kaXNwbGF5ICE9PSAnbm9uZSc7XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IHN3aXBlYWJsZVxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUVuYWJsZSBzd2lwZSBpbnRlcmFjdGlvbi5bL2VuXVxuICAgKiAgIFtqYV1zd2lwZWFibGXjgafjgYLjgozjgbB0cnVl44KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAgICovXG4gIGdldCBzd2lwZWFibGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuaGFzQXR0cmlidXRlKCdzd2lwZWFibGUnKTtcbiAgfVxuXG4gIHNldCBzd2lwZWFibGUodmFsdWUpIHtcbiAgICByZXR1cm4gdXRpbC50b2dnbGVBdHRyaWJ1dGUodGhpcywgJ3N3aXBlYWJsZScsIHZhbHVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgb25Td2lwZVxuICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1Ib29rIGNhbGxlZCB3aGVuZXZlciB0aGUgdXNlciBzbGlkZXMgdGhlIHRhYmJhci4gSXQgZ2V0cyBhIGRlY2ltYWwgaW5kZXggYW5kIGFuIGFuaW1hdGlvbk9wdGlvbnMgb2JqZWN0IGFzIGFyZ3VtZW50cy5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cbiAgZ2V0IG9uU3dpcGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX29uU3dpcGU7XG4gIH1cblxuICBzZXQgb25Td2lwZSh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSAmJiAhKHZhbHVlIGluc3RhbmNlb2YgRnVuY3Rpb24pKSB7XG4gICAgICB1dGlsLnRocm93KGBcIm9uU3dpcGVcIiBtdXN0IGJlIGEgZnVuY3Rpb25gKVxuICAgIH1cbiAgICB0aGlzLl9vblN3aXBlID0gdmFsdWU7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBnZXRBY3RpdmVUYWJJbmRleFxuICAgKiBAc2lnbmF0dXJlIGdldEFjdGl2ZVRhYkluZGV4KClcbiAgICogQHJldHVybiB7TnVtYmVyfVxuICAgKiAgIFtlbl1UaGUgaW5kZXggb2YgdGhlIGN1cnJlbnRseSBhY3RpdmUgdGFiLlsvZW5dXG4gICAqICAgW2phXeePvuWcqOOCouOCr+ODhuOCo+ODluOBq+OBquOBo+OBpuOBhOOCi+OCv+ODluOBruOCpOODs+ODh+ODg+OCr+OCueOCkui/lOOBl+OBvuOBmeOAglsvamFdXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1SZXR1cm5zIHRhYiBpbmRleCBvbiBjdXJyZW50IGFjdGl2ZSB0YWIuIElmIGFjdGl2ZSB0YWIgaXMgbm90IGZvdW5kLCByZXR1cm5zIC0xLlsvZW5dXG4gICAqICAgW2phXeePvuWcqOOCouOCr+ODhuOCo+ODluOBq+OBquOBo+OBpuOBhOOCi+OCv+ODluOBruOCpOODs+ODh+ODg+OCr+OCueOCkui/lOOBl+OBvuOBmeOAguePvuWcqOOCouOCr+ODhuOCo+ODluOBquOCv+ODluOBjOOBquOBhOWgtOWQiOOBq+OBry0x44KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAgICovXG4gIGdldEFjdGl2ZVRhYkluZGV4KHRhYnMgPSB0aGlzLnRhYnMpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRhYnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICh0YWJzW2ldICYmIHRhYnNbaV0udGFnTmFtZSA9PT0gJ09OUy1UQUInICYmIHRhYnNbaV0uaXNBY3RpdmUoKSkge1xuICAgICAgICByZXR1cm4gaTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIC0xO1xuICB9XG5cbiAgX3Nob3coKSB7XG4gICAgdGhpcy5fc3dpcGVyLnNob3coKTtcblxuICAgIHNldEltbWVkaWF0ZSgoKSA9PiB7XG4gICAgICBjb25zdCB0YWJzID0gdGhpcy50YWJzO1xuICAgICAgY29uc3QgYWN0aXZlSW5kZXggPSB0aGlzLmdldEFjdGl2ZVRhYkluZGV4KHRhYnMpO1xuICAgICAgdGhpcy5fbG9hZEluYWN0aXZlLnJlc29sdmUoKTtcbiAgICAgIGlmICh0YWJzLmxlbmd0aCA+IDAgJiYgYWN0aXZlSW5kZXggPj0gMCkge1xuICAgICAgICB0YWJzW2FjdGl2ZUluZGV4XS5sb2FkZWQudGhlbihlbCA9PiBlbCAmJiBzZXRJbW1lZGlhdGUoKCkgPT4gZWwuX3Nob3coKSkpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgX2hpZGUoKSB7XG4gICAgdGhpcy5fc3dpcGVyLmhpZGUoKTtcbiAgICBjb25zdCB0b3BQYWdlID0gdGhpcy50b3BQYWdlO1xuICAgIHRvcFBhZ2UgJiYgdG9wUGFnZS5faGlkZSgpO1xuICB9XG5cbiAgX2Rlc3Ryb3koKSB7XG4gICAgdGhpcy50YWJzLmZvckVhY2godGFiID0+IHRhYi5yZW1vdmUoKSk7XG4gICAgdGhpcy5yZW1vdmUoKTtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgb2JzZXJ2ZWRBdHRyaWJ1dGVzKCkge1xuICAgIHJldHVybiBbJ21vZGlmaWVyJywgJ3Bvc2l0aW9uJywgJ3N3aXBlYWJsZScsICd0YWItYm9yZGVyJywgJ2hpZGUtdGFicyddO1xuICB9XG5cbiAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIGxhc3QsIGN1cnJlbnQpIHtcbiAgICBpZiAobmFtZSA9PT0gJ21vZGlmaWVyJykge1xuICAgICAgTW9kaWZpZXJVdGlsLm9uTW9kaWZpZXJDaGFuZ2VkKGxhc3QsIGN1cnJlbnQsIHRoaXMsIHNjaGVtZSk7XG4gICAgICBjb25zdCBpc1RvcCA9IG0gPT4gLyhefFxccyspdG9wKCR8XFxzKykvaS50ZXN0KG0pO1xuICAgICAgaXNUb3AobGFzdCkgIT09IGlzVG9wKGN1cnJlbnQpICYmIHRoaXMuX3VwZGF0ZVBvc2l0aW9uKCk7XG4gICAgfSBlbHNlIGlmIChuYW1lID09PSAncG9zaXRpb24nKSB7XG4gICAgICB1dGlsLmlzQXR0YWNoZWQodGhpcykgJiYgdGhpcy5fdXBkYXRlUG9zaXRpb24oKTtcbiAgICB9IGVsc2UgaWYgKG5hbWUgPT09ICdzd2lwZWFibGUnKSB7XG4gICAgICB0aGlzLl9zd2lwZXIgJiYgdGhpcy5fc3dpcGVyLnVwZGF0ZVN3aXBlYWJsZSh0aGlzLmhhc0F0dHJpYnV0ZSgnc3dpcGVhYmxlJykpO1xuICAgIH0gZWxzZSBpZiAobmFtZSA9PT0gJ2hpZGUtdGFicycpIHtcbiAgICAgIHRoaXMuc2V0VGFiYmFyVmlzaWJpbGl0eSghdGhpcy5oYXNBdHRyaWJ1dGUoJ2hpZGUtdGFicycpIHx8IGN1cnJlbnQgPT09ICdmYWxzZScpO1xuICAgIH1cbiAgfVxuXG4gIHN0YXRpYyBnZXQgcmV3cml0YWJsZXMoKSB7XG4gICAgcmV0dXJuIHJld3JpdGFibGVzO1xuICB9XG5cbiAgc3RhdGljIGdldCBldmVudHMoKSB7XG4gICAgcmV0dXJuIFsncHJlY2hhbmdlJywgJ3Bvc3RjaGFuZ2UnLCAncmVhY3RpdmUnXTtcbiAgfVxufVxuXG5vbnNFbGVtZW50cy5UYWJiYXIgPSBUYWJiYXJFbGVtZW50O1xuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdvbnMtdGFiYmFyJywgVGFiYmFyRWxlbWVudCk7XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgb25zRWxlbWVudHMgZnJvbSAnLi4vb25zL2VsZW1lbnRzJztcbmltcG9ydCB1dGlsIGZyb20gJy4uL29ucy91dGlsJztcbmltcG9ydCBhdXRvU3R5bGUgZnJvbSAnLi4vb25zL2F1dG9zdHlsZSc7XG5pbXBvcnQgTW9kaWZpZXJVdGlsIGZyb20gJy4uL29ucy9pbnRlcm5hbC9tb2RpZmllci11dGlsJztcbmltcG9ydCBCYXNlRWxlbWVudCBmcm9tICcuL2Jhc2UvYmFzZS1lbGVtZW50JztcbmltcG9ydCBUYWJiYXJFbGVtZW50IGZyb20gJy4vb25zLXRhYmJhcic7XG5pbXBvcnQgY29udGVudFJlYWR5IGZyb20gJy4uL29ucy9jb250ZW50LXJlYWR5JztcbmltcG9ydCB7IFBhZ2VMb2FkZXIsIGRlZmF1bHRQYWdlTG9hZGVyIH0gZnJvbSAnLi4vb25zL3BhZ2UtbG9hZGVyJztcblxuY29uc3QgZGVmYXVsdENsYXNzTmFtZSA9ICd0YWJiYXJfX2l0ZW0nO1xuXG5jb25zdCBzY2hlbWUgPSB7XG4gICcnOiAndGFiYmFyLS0qX19pdGVtJyxcbiAgJy50YWJiYXJfX2J1dHRvbic6ICd0YWJiYXItLSpfX2J1dHRvbidcbn07XG5cbi8qKlxuICogQGVsZW1lbnQgb25zLXRhYlxuICogQGNhdGVnb3J5IHRhYmJhclxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1SZXByZXNlbnRzIGEgdGFiIGluc2lkZSB0YWIgYmFyLiBFYWNoIGA8b25zLXRhYj5gIHJlcHJlc2VudHMgYSBwYWdlLlsvZW5dXG4gKiAgIFtqYV1cbiAqICAgICDjgr/jg5bjg5Djg7zjgavphY3nva7jgZXjgozjgovlkITjgqLjgqTjg4bjg6Djga7jgrPjg7Pjg53jg7zjg43jg7Pjg4jjgafjgZnjgILjgZ3jgozjgZ7jgozjga5vbnMtdGFi44Gv44Oa44O844K444KS6KGo44GX44G+44GZ44CCXG4gKiAgICAgb25zLXRhYuimgee0oOOBruS4reOBq+OBr+OAgeOCv+ODluOBq+ihqOekuuOBleOCjOOCi+OCs+ODs+ODhuODs+ODhOOCkuebtOaOpeiomOi/sOOBmeOCi+OBk+OBqOOBjOWHuuadpeOBvuOBmeOAglxuICogICBbL2phXVxuICogQGNvZGVwZW4gcEd1RExcbiAqIEB0dXRvcmlhbCB2YW5pbGxhL1JlZmVyZW5jZS90YWJiYXJcbiAqIEBndWlkZSBmdW5kYW1lbnRhbHMuaHRtbCNtYW5hZ2luZy1wYWdlc1xuICogICBbZW5dTWFuYWdpbmcgbXVsdGlwbGUgcGFnZXMuWy9lbl1cbiAqICAgW2phXeikh+aVsOOBruODmuODvOOCuOOCkueuoeeQhuOBmeOCi1svamFdXVxuICogQGd1aWRlIGFwcHNpemUuaHRtbCNyZW1vdmluZy1pY29uLXBhY2tzIFtlbl1SZW1vdmluZyBpY29uIHBhY2tzLlsvZW5dW2phXVsvamFdXG4gKiBAZ3VpZGUgZmFxLmh0bWwjaG93LWNhbi1pLXVzZS1jdXN0b20taWNvbi1wYWNrcyBbZW5dQWRkaW5nIGN1c3RvbSBpY29uIHBhY2tzLlsvZW5dW2phXVsvamFdXG4gKiBAc2VlYWxzbyBvbnMtdGFiYmFyXG4gKiAgIFtlbl1vbnMtdGFiYmFyIGNvbXBvbmVudFsvZW5dXG4gKiAgIFtqYV1vbnMtdGFiYmFy44Kz44Oz44Od44O844ON44Oz44OIWy9qYV1cbiAqIEBzZWVhbHNvIG9ucy1wYWdlXG4gKiAgIFtlbl1vbnMtcGFnZSBjb21wb25lbnRbL2VuXVxuICogICBbamFdb25zLXBhZ2XjgrPjg7Pjg53jg7zjg43jg7Pjg4hbL2phXVxuICogQHNlZWFsc28gb25zLWljb25cbiAqICAgW2VuXW9ucy1pY29uIGNvbXBvbmVudFsvZW5dXG4gKiAgIFtqYV1vbnMtaWNvbuOCs+ODs+ODneODvOODjeODs+ODiFsvamFdXG4gKiBAZXhhbXBsZVxuICogPG9ucy10YWJiYXI+XG4gKiAgIDxvbnMtdGFiXG4gKiAgICAgcGFnZT1cImhvbWUuaHRtbFwiXG4gKiAgICAgbGFiZWw9XCJIb21lXCJcbiAqICAgICBhY3RpdmU+XG4gKiAgIDwvb25zLXRhYj5cbiAqICAgPG9ucy10YWJcbiAqICAgICBwYWdlPVwic2V0dGluZ3MuaHRtbFwiXG4gKiAgICAgbGFiZWw9XCJTZXR0aW5nc1wiXG4gKiAgICAgYWN0aXZlPlxuICogICA8L29ucy10YWI+XG4gKiA8L29ucy10YWJiYXI+XG4gKlxuICogPHRlbXBsYXRlIGlkPVwiaG9tZS5odG1sXCI+XG4gKiAgIC4uLlxuICogPC90ZW1wbGF0ZT5cbiAqXG4gKiA8dGVtcGxhdGUgaWQ9XCJzZXR0aW5ncy5odG1sXCI+XG4gKiAgIC4uLlxuICogPC90ZW1wbGF0ZT5cblxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUYWJFbGVtZW50IGV4dGVuZHMgQmFzZUVsZW1lbnQge1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIHBhZ2VcbiAgICogQGluaXRvbmx5XG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1UaGUgcGFnZSB0aGF0IGlzIGRpc3BsYXllZCB3aGVuIHRoZSB0YWIgaXMgdGFwcGVkLlsvZW5dXG4gICAqICAgW2phXW9ucy10YWLjgYzlj4LnhafjgZnjgovjg5rjg7zjgrjjgbjjga5VUkzjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBpY29uXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1cbiAgICogICAgIFRoZSBpY29uIG5hbWUgZm9yIHRoZSB0YWIuIENhbiBzcGVjaWZ5IHRoZSBzYW1lIGljb24gbmFtZSBhcyBgPG9ucy1pY29uPmAuIENoZWNrIFtTZWUgYWxzb10oI3NlZWFsc28pIHNlY3Rpb24gZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gICAqICAgWy9lbl1cbiAgICogICBbamFdXG4gICAqICAgICDjgqLjgqTjgrPjg7PlkI3jgpLmjIflrprjgZfjgb7jgZnjgIJvbnMtaWNvbuOBqOWQjOOBmOOCouOCpOOCs+ODs+WQjeOCkuaMh+WumuOBp+OBjeOBvuOBmeOAglxuICAgKiAgICAg5YCL5Yil44Gr44Ki44Kk44Kz44Oz44KS44Kr44K544K/44Oe44Kk44K644GZ44KL5aC05ZCI44Gv44CBYmFja2dyb3VuZC1pbWFnZeOBquOBqeOBrkNTU+OCueOCv+OCpOODq+OCkueUqOOBhOOBpuaMh+WumuOBp+OBjeOBvuOBmeOAglxuICAgKiAgIFsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGFjdGl2ZS1pY29uXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1UaGUgbmFtZSBvZiB0aGUgaWNvbiB3aGVuIHRoZSB0YWIgaXMgYWN0aXZlLlsvZW5dXG4gICAqICAgW2phXeOCouOCr+ODhuOCo+ODluOBrumam+OBruOCouOCpOOCs+ODs+WQjeOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGxhYmVsXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1UaGUgbGFiZWwgb2YgdGhlIHRhYiBpdGVtLlsvZW5dXG4gICAqICAgW2phXeOCouOCpOOCs+ODs+S4i+OBq+ihqOekuuOBleOCjOOCi+ODqeODmeODq+OCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGJhZGdlXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1EaXNwbGF5IGEgbm90aWZpY2F0aW9uIGJhZGdlIG9uIHRvcCBvZiB0aGUgdGFiLlsvZW5dXG4gICAqICAgW2phXeODkOODg+OCuOOBq+ihqOekuuOBmeOCi+WGheWuueOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGFjdGl2ZVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dVGhpcyBhdHRyaWJ1dGUgc2hvdWxkIGJlIHNldCB0byB0aGUgdGFiIHRoYXQgaXMgYWN0aXZlIGJ5IGRlZmF1bHQuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIGlmIChbJ2xhYmVsJywgJ2ljb24nLCAnYmFkZ2UnXS5zb21lKHRoaXMuaGFzQXR0cmlidXRlLmJpbmQodGhpcykpKSB7XG4gICAgICB0aGlzLl9jb21waWxlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB0aGlzLl9jb21waWxlKCkpO1xuICAgIH1cblxuICAgIHRoaXMuX3BhZ2VMb2FkZXIgPSBkZWZhdWx0UGFnZUxvYWRlcjtcbiAgICB0aGlzLl9vbkNsaWNrID0gdGhpcy5fb25DbGljay5iaW5kKHRoaXMpO1xuICB9XG5cbiAgc2V0IHBhZ2VMb2FkZXIobG9hZGVyKSB7XG4gICAgaWYgKCEobG9hZGVyIGluc3RhbmNlb2YgUGFnZUxvYWRlcikpIHtcbiAgICAgIHV0aWwudGhyb3dQYWdlTG9hZGVyKCk7XG4gICAgfVxuICAgIHRoaXMuX3BhZ2VMb2FkZXIgPSBsb2FkZXI7XG4gIH1cblxuICBnZXQgcGFnZUxvYWRlcigpIHtcbiAgICByZXR1cm4gdGhpcy5fcGFnZUxvYWRlcjtcbiAgfVxuXG4gIF9jb21waWxlKCkge1xuICAgIGF1dG9TdHlsZS5wcmVwYXJlKHRoaXMpO1xuICAgIHRoaXMuY2xhc3NMaXN0LmFkZChkZWZhdWx0Q2xhc3NOYW1lKTtcblxuICAgIGlmICh0aGlzLl9idXR0b24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBidXR0b24gPSB1dGlsLmNyZWF0ZSgnYnV0dG9uLnRhYmJhcl9fYnV0dG9uJyk7XG4gICAgd2hpbGUgKHRoaXMuY2hpbGROb2Rlc1swXSkge1xuICAgICAgYnV0dG9uLmFwcGVuZENoaWxkKHRoaXMuY2hpbGROb2Rlc1swXSk7XG4gICAgfVxuXG4gICAgY29uc3QgaW5wdXQgPSB1dGlsLmNyZWF0ZSgnaW5wdXQnLCB7IGRpc3BsYXk6ICdub25lJyB9KTtcbiAgICBpbnB1dC50eXBlID0gJ3JhZGlvJztcblxuICAgIHRoaXMuYXBwZW5kQ2hpbGQoaW5wdXQpO1xuICAgIHRoaXMuYXBwZW5kQ2hpbGQoYnV0dG9uKTtcblxuICAgIHRoaXMuX3VwZGF0ZUJ1dHRvbkNvbnRlbnQoKTtcbiAgICBNb2RpZmllclV0aWwuaW5pdE1vZGlmaWVyKHRoaXMsIHNjaGVtZSk7XG4gICAgdGhpcy5fdXBkYXRlUmlwcGxlKCk7XG4gIH1cblxuICBfdXBkYXRlUmlwcGxlKCkge1xuICAgIHRoaXMuX2J1dHRvbiAmJiB1dGlsLnVwZGF0ZVJpcHBsZSh0aGlzLl9idXR0b24sIHRoaXMuaGFzQXR0cmlidXRlKCdyaXBwbGUnKSk7XG4gIH1cblxuICBfdXBkYXRlQnV0dG9uQ29udGVudCgpIHtcbiAgICBjb25zdCBidXR0b24gPSB0aGlzLl9idXR0b247XG5cbiAgICBsZXQgaWNvbldyYXBwZXIgPSB0aGlzLl9pY29uO1xuICAgIGlmICh0aGlzLmhhc0F0dHJpYnV0ZSgnaWNvbicpKSB7XG4gICAgICBpY29uV3JhcHBlciA9IGljb25XcmFwcGVyIHx8IHV0aWwuY3JlYXRlRWxlbWVudCgnPGRpdiBjbGFzcz1cInRhYmJhcl9faWNvblwiPjxvbnMtaWNvbj48L29ucy1pY29uPjwvZGl2PicpO1xuICAgICAgY29uc3QgaWNvbiA9IGljb25XcmFwcGVyLmNoaWxkcmVuWzBdO1xuICAgICAgY29uc3QgZml4ID0gKGxhc3QgPT4gKCkgPT4gaWNvbi5hdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2soJ2ljb24nLCBsYXN0LCB0aGlzLmdldEF0dHJpYnV0ZSgnaWNvbicpKSkoaWNvbi5nZXRBdHRyaWJ1dGUoJ2ljb24nKSk7XG4gICAgICBpY29uLnNldEF0dHJpYnV0ZSgnaWNvbicsIHRoaXMuZ2V0QXR0cmlidXRlKCdpY29uJykpO1xuICAgICAgaWNvbldyYXBwZXIucGFyZW50RWxlbWVudCAhPT0gYnV0dG9uICYmIGJ1dHRvbi5pbnNlcnRCZWZvcmUoaWNvbldyYXBwZXIsIGJ1dHRvbi5maXJzdENoaWxkKTtcblxuICAgICAgLy8gZGlydHkgZml4IGZvciBodHRwczovL2dpdGh1Yi5jb20vT25zZW5VSS9PbnNlblVJL2lzc3Vlcy8xNjU0XG4gICAgICBpY29uLmF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayBpbnN0YW5jZW9mIEZ1bmN0aW9uXG4gICAgICAgID8gZml4KClcbiAgICAgICAgOiBzZXRJbW1lZGlhdGUoKCkgPT4gaWNvbi5hdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sgaW5zdGFuY2VvZiBGdW5jdGlvbiAmJiBmaXgoKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGljb25XcmFwcGVyICYmIGljb25XcmFwcGVyLnJlbW92ZSgpO1xuICAgIH1cblxuICAgIFsnbGFiZWwnLCAnYmFkZ2UnXS5mb3JFYWNoKChhdHRyLCBpbmRleCkgPT4ge1xuICAgICAgbGV0IHByb3AgPSB0aGlzLnF1ZXJ5U2VsZWN0b3IoYC50YWJiYXJfXyR7YXR0cn1gKTtcbiAgICAgIGlmICh0aGlzLmhhc0F0dHJpYnV0ZShhdHRyKSkge1xuICAgICAgICBwcm9wID0gcHJvcCB8fCB1dGlsLmNyZWF0ZShgLnRhYmJhcl9fJHthdHRyfWAgKyAoYXR0ciA9PT0gJ2JhZGdlJyA/ICcgbm90aWZpY2F0aW9uJyA6ICcnKSk7XG4gICAgICAgIHByb3AudGV4dENvbnRlbnQgPSB0aGlzLmdldEF0dHJpYnV0ZShhdHRyKTtcbiAgICAgICAgcHJvcC5wYXJlbnRFbGVtZW50ICE9PSBidXR0b24gJiYgYnV0dG9uLmFwcGVuZENoaWxkKHByb3ApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJvcCAmJiBwcm9wLnJlbW92ZSgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgZ2V0IF9pbnB1dCgpIHtcbiAgICByZXR1cm4gdXRpbC5maW5kQ2hpbGQodGhpcywgJ2lucHV0Jyk7XG4gIH1cblxuICBnZXQgX2J1dHRvbigpIHtcbiAgICByZXR1cm4gdXRpbC5maW5kQ2hpbGQodGhpcywgJy50YWJiYXJfX2J1dHRvbicpO1xuICB9XG5cbiAgZ2V0IF9pY29uKCkge1xuICAgIHJldHVybiB0aGlzLnF1ZXJ5U2VsZWN0b3IoJy50YWJiYXJfX2ljb24nKTtcbiAgfVxuXG4gIGdldCBfdGFiYmFyKCkge1xuICAgIHJldHVybiB1dGlsLmZpbmRQYXJlbnQodGhpcywgJ29ucy10YWJiYXInKTtcbiAgfVxuXG4gIGdldCBpbmRleCgpIHtcbiAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbCh0aGlzLnBhcmVudEVsZW1lbnQuY2hpbGRyZW4sIHRoaXMpO1xuICB9XG5cbiAgX29uQ2xpY2soKSB7XG4gICAgaWYgKHRoaXMub25DbGljayBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XG4gICAgICB0aGlzLm9uQ2xpY2soKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fdGFiYmFyLnNldEFjdGl2ZVRhYih0aGlzLmluZGV4LCB7IHJlamVjdDogZmFsc2UgfSk7XG4gICAgfVxuICB9XG5cbiAgc2V0QWN0aXZlKGFjdGl2ZSA9IHRydWUpIHtcbiAgICB0aGlzLl9pbnB1dC5jaGVja2VkID0gYWN0aXZlO1xuICAgIHRoaXMuY2xhc3NMaXN0LnRvZ2dsZSgnYWN0aXZlJywgYWN0aXZlKTtcbiAgICB1dGlsLnRvZ2dsZUF0dHJpYnV0ZSh0aGlzLCAnYWN0aXZlJywgYWN0aXZlKVxuXG4gICAgaWYgKHRoaXMuaGFzQXR0cmlidXRlKCdpY29uJykgJiYgdGhpcy5oYXNBdHRyaWJ1dGUoJ2FjdGl2ZS1pY29uJykpIHtcbiAgICAgIHRoaXMuX2ljb24uY2hpbGRyZW5bMF0uc2V0QXR0cmlidXRlKCdpY29uJywgdGhpcy5nZXRBdHRyaWJ1dGUoYWN0aXZlID8gJ2FjdGl2ZS1pY29uJyA6ICdpY29uJykpO1xuICAgIH1cbiAgfVxuXG4gIF9sb2FkUGFnZUVsZW1lbnQocGFyZW50LCBwYWdlKSB7XG4gICAgdGhpcy5faGFzTG9hZGVkID0gdHJ1ZTtcblxuICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgIHRoaXMuX3BhZ2VMb2FkZXIubG9hZCh7IHBhcmVudCwgcGFnZSB9LCBwYWdlRWxlbWVudCA9PiB7XG4gICAgICAgIHBhcmVudC5yZXBsYWNlQ2hpbGQocGFnZUVsZW1lbnQsIHBhcmVudC5jaGlsZHJlblt0aGlzLmluZGV4XSk7IC8vIEVuc3VyZSBwb3NpdGlvblxuICAgICAgICB0aGlzLl9sb2FkZWRQYWdlID0gcGFnZUVsZW1lbnQ7XG4gICAgICAgIHJlc29sdmUocGFnZUVsZW1lbnQpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICBnZXQgcGFnZUVsZW1lbnQoKSB7XG4gICAgLy8gSXQgaGFzIGJlZW4gbG9hZGVkIGJ5IG9ucy10YWJcbiAgICBpZiAodGhpcy5fbG9hZGVkUGFnZSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2xvYWRlZFBhZ2U7XG4gICAgfVxuICAgIC8vIE1hbnVhbGx5IGF0dGFjaGVkIHRvIERPTSwgMSBwZXIgdGFiXG4gICAgY29uc3QgdGFiYmFyID0gdGhpcy5fdGFiYmFyO1xuICAgIGlmICh0YWJiYXIucGFnZXMubGVuZ3RoID09PSB0YWJiYXIudGFicy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB0YWJiYXIucGFnZXNbdGhpcy5pbmRleF07XG4gICAgfVxuICAgIC8vIExvYWRlZCBpbiBhbm90aGVyIHdheVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuICBpc0FjdGl2ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5jbGFzc0xpc3QuY29udGFpbnMoJ2FjdGl2ZScpO1xuICB9XG5cbiAgZGlzY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuX29uQ2xpY2ssIGZhbHNlKTtcbiAgICBpZiAodGhpcy5fbG9hZGVkUGFnZSkge1xuICAgICAgdGhpcy5faGFzTG9hZGVkID0gZmFsc2U7XG4gICAgICB0aGlzLmxvYWRlZCA9IG51bGw7XG4gICAgfVxuICB9XG5cbiAgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuX29uQ2xpY2ssIGZhbHNlKTtcblxuICAgIGlmICghdXRpbC5pc0F0dGFjaGVkKHRoaXMpIHx8IHRoaXMubG9hZGVkKSB7XG4gICAgICByZXR1cm47IC8vIG9ucy10YWJiYXIgY29tcGlsYXRpb24gbWF5IHRyaWdnZXIgdGhpc1xuICAgIH1cblxuICAgIGNvbnN0IGRlZmVycmVkID0gdXRpbC5kZWZlcigpO1xuICAgIHRoaXMubG9hZGVkID0gZGVmZXJyZWQucHJvbWlzZTtcblxuICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB7XG4gICAgICBjb25zdCBpbmRleCA9IHRoaXMuaW5kZXg7XG4gICAgICBjb25zdCB0YWJiYXIgPSB0aGlzLl90YWJiYXI7XG4gICAgICBpZiAoIXRhYmJhcikge1xuICAgICAgICB1dGlsLnRocm93KCdUYWIgZWxlbWVudHMgbXVzdCBiZSBjaGlsZHJlbiBvZiBUYWJiYXInKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRhYmJhci5oYXNBdHRyaWJ1dGUoJ21vZGlmaWVyJykpIHtcbiAgICAgICAgdXRpbC5hZGRNb2RpZmllcih0aGlzLCB0YWJiYXIuZ2V0QXR0cmlidXRlKCdtb2RpZmllcicpKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLl9oYXNMb2FkZWQpIHtcbiAgICAgICAgaWYgKHRoaXMuaGFzQXR0cmlidXRlKCdhY3RpdmUnKSkge1xuICAgICAgICAgIHRoaXMuc2V0QWN0aXZlKHRydWUpO1xuICAgICAgICAgIHRhYmJhci5zZXRBdHRyaWJ1dGUoJ2FjdGl2ZUluZGV4JywgaW5kZXgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGluZGV4ID09PSB0YWJiYXIudGFicy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgdGFiYmFyLl9vblJlZnJlc2goKTtcbiAgICAgICAgICBzZXRJbW1lZGlhdGUoKCkgPT4gdGFiYmFyLl9vblJlZnJlc2goKSk7XG4gICAgICAgIH1cblxuICAgICAgICBUYWJiYXJFbGVtZW50LnJld3JpdGFibGVzLnJlYWR5KHRhYmJhciwgKCkgPT4ge1xuICAgICAgICAgIGNvbnN0IHBhZ2VUYXJnZXQgPSB0aGlzLnBhZ2UgfHwgdGhpcy5nZXRBdHRyaWJ1dGUoJ3BhZ2UnKTtcbiAgICAgICAgICBpZiAoIXRoaXMucGFnZUVsZW1lbnQgJiYgcGFnZVRhcmdldCkge1xuICAgICAgICAgICAgY29uc3QgcGFyZW50VGFyZ2V0ID0gdGFiYmFyLl90YXJnZXRFbGVtZW50O1xuICAgICAgICAgICAgY29uc3QgZHVtbXlQYWdlID0gdXRpbC5jcmVhdGUoJ2RpdicsIHsgaGVpZ2h0OiAnMTAwJScsIHdpZHRoOiAnMTAwJScsIHZpc2liaWxpdHk6ICdoaWRkZW4nIH0pO1xuICAgICAgICAgICAgcGFyZW50VGFyZ2V0Lmluc2VydEJlZm9yZShkdW1teVBhZ2UsIHBhcmVudFRhcmdldC5jaGlsZHJlbltpbmRleF0pOyAvLyBFbnN1cmUgcG9zaXRpb25cblxuICAgICAgICAgICAgY29uc3QgbG9hZCA9ICgpID0+IHRoaXMuX2xvYWRQYWdlRWxlbWVudChwYXJlbnRUYXJnZXQsIHBhZ2VUYXJnZXQpLnRoZW4oZGVmZXJyZWQucmVzb2x2ZSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pc0FjdGl2ZSgpID8gbG9hZCgpIDogdGFiYmFyLl9sb2FkSW5hY3RpdmUucHJvbWlzZS50aGVuKGxvYWQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBkZWZlcnJlZC5yZXNvbHZlKHRoaXMucGFnZUVsZW1lbnQpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgb2JzZXJ2ZWRBdHRyaWJ1dGVzKCkge1xuICAgIHJldHVybiBbJ21vZGlmaWVyJywgJ3JpcHBsZScsICdpY29uJywgJ2xhYmVsJywgJ3BhZ2UnLCAnYmFkZ2UnLCAnY2xhc3MnXTtcbiAgfVxuXG4gIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBsYXN0LCBjdXJyZW50KSB7XG4gICAgc3dpdGNoIChuYW1lKSB7XG4gICAgICBjYXNlICdjbGFzcyc6XG4gICAgICAgIHV0aWwucmVzdG9yZUNsYXNzKHRoaXMsIGRlZmF1bHRDbGFzc05hbWUsIHNjaGVtZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnbW9kaWZpZXInOlxuICAgICAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4gTW9kaWZpZXJVdGlsLm9uTW9kaWZpZXJDaGFuZ2VkKGxhc3QsIGN1cnJlbnQsIHRoaXMsIHNjaGVtZSkpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3JpcHBsZSc6XG4gICAgICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB0aGlzLl91cGRhdGVSaXBwbGUoKSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnaWNvbic6XG4gICAgICBjYXNlICdsYWJlbCc6XG4gICAgICBjYXNlICdiYWRnZSc6XG4gICAgICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB0aGlzLl91cGRhdGVCdXR0b25Db250ZW50KCkpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3BhZ2UnOlxuICAgICAgICB0aGlzLnBhZ2UgPSBjdXJyZW50IHx8ICcnO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cbn1cblxub25zRWxlbWVudHMuVGFiID0gVGFiRWxlbWVudDtcbmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnb25zLXRhYicsIFRhYkVsZW1lbnQpO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IEJhc2VBbmltYXRvciBmcm9tICcuLi8uLi9vbnMvYmFzZS1hbmltYXRvcic7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRvYXN0QW5pbWF0b3IgZXh0ZW5kcyBCYXNlQW5pbWF0b3Ige1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge1N0cmluZ30gb3B0aW9ucy50aW1pbmdcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbnMuZHVyYXRpb25cbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbnMuZGVsYXlcbiAgICovXG4gIGNvbnN0cnVjdG9yKHt0aW1pbmcgPSAnbGluZWFyJywgZGVsYXkgPSAwLCBkdXJhdGlvbiA9IDAuMn0gPSB7fSkge1xuICAgIHN1cGVyKHsgdGltaW5nLCBkZWxheSwgZHVyYXRpb24gfSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gbW9kYWxcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICovXG4gIHNob3cobW9kYWwsIGNhbGxiYWNrKSB7XG4gICAgY2FsbGJhY2soKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBtb2RhbFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKi9cbiAgaGlkZShtb2RhbCwgY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjaygpO1xuICB9XG59XG4iLCJcbi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCBhbmltaXQgZnJvbSAnLi4vLi4vb25zL2FuaW1pdCc7XG5pbXBvcnQgVG9hc3RBbmltYXRvciBmcm9tICcuL2FuaW1hdG9yJztcblxuLyoqXG4gKiBpT1Mgc3R5bGUgYW5pbWF0b3IgZm9yIGRpYWxvZy5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRmFkZVRvYXN0QW5pbWF0b3IgZXh0ZW5kcyBUb2FzdEFuaW1hdG9yIHtcblxuICBjb25zdHJ1Y3Rvcih7dGltaW5nID0gJ2xpbmVhcicsIGRlbGF5ID0gMCwgZHVyYXRpb24gPSAwLjN9ID0ge30pIHtcbiAgICBzdXBlcih7IHRpbWluZywgZGVsYXksIGR1cmF0aW9uIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHRvYXN0XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqL1xuICBzaG93KHRvYXN0LCBjYWxsYmFjaykge1xuICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgPyBjYWxsYmFjayA6IGZ1bmN0aW9uKCkge307XG5cbiAgICBhbmltaXQodG9hc3QsIHRoaXMuZGVmKVxuICAgICAgLmRlZmF1bHQoeyBvcGFjaXR5OiAwIH0sIHsgb3BhY2l0eTogMSB9KVxuICAgICAgLnF1ZXVlKGRvbmUgPT4ge1xuICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICBkb25lKCk7XG4gICAgICB9KVxuICAgICAgLnBsYXkoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSB0b2FzdFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKi9cbiAgaGlkZSh0b2FzdCwgY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjayA9IGNhbGxiYWNrID8gY2FsbGJhY2sgOiBmdW5jdGlvbigpIHt9O1xuXG4gICAgYW5pbWl0KHRvYXN0LCB0aGlzLmRlZilcbiAgICAgIC5kZWZhdWx0KHsgb3BhY2l0eTogMSB9LCB7IG9wYWNpdHk6IDAgfSlcbiAgICAgIC5xdWV1ZShkb25lID0+IHtcbiAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgZG9uZSgpO1xuICAgICAgfSlcbiAgICAgIC5wbGF5KCk7XG4gIH1cbn1cbiIsIlxuLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IHV0aWwgZnJvbSAnLi4vLi4vb25zL3V0aWwnO1xuaW1wb3J0IGFuaW1pdCBmcm9tICcuLi8uLi9vbnMvYW5pbWl0JztcbmltcG9ydCBwbGF0Zm9ybSBmcm9tICcuLi8uLi9vbnMvcGxhdGZvcm0nO1xuaW1wb3J0IGlQaG9uZVhQYXRjaCBmcm9tICcuLi8uLi9vbnMvaXBob25leC1wYXRjaCc7XG5pbXBvcnQgVG9hc3RBbmltYXRvciBmcm9tICcuL2FuaW1hdG9yJztcblxuLyoqXG4gKiBBc2NlbmQgVG9hc3QgQW5pbWF0b3IuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEFzY2VuZFRvYXN0QW5pbWF0b3IgZXh0ZW5kcyBUb2FzdEFuaW1hdG9yIHtcblxuICBjb25zdHJ1Y3Rvcih7IHRpbWluZyA9ICdlYXNlJywgZGVsYXkgPSAwLCBkdXJhdGlvbiA9IDAuMjUgfSA9IHt9KSB7XG4gICAgc3VwZXIoeyB0aW1pbmcsIGRlbGF5LCBkdXJhdGlvbiB9KTtcblxuICAgIHRoaXMubWVzc2FnZURlbGF5ID0gdGhpcy5kdXJhdGlvbiAqIDAuNCArIHRoaXMuZGVsYXk7IC8vIERlbGF5IG1lc3NhZ2Ugb3BhY2l0eSBjaGFuZ2VcbiAgICBpZiAocGxhdGZvcm0uaXNBbmRyb2lkKCkpIHtcbiAgICAgIHRoaXMuYXNjZW5zaW9uID0gNDg7IC8vIFRvYXN0cyBhcmUgYWx3YXlzIDEgbGluZVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoaVBob25lWFBhdGNoLmlzSVBob25lWFBvcnRyYWl0UGF0Y2hBY3RpdmUoKSkge1xuICAgICAgICB0aGlzLmFzY2Vuc2lvbiA9IDk4OyAvLyA2NCArIDM0XG4gICAgICB9IGVsc2UgaWYgKGlQaG9uZVhQYXRjaC5pc0lQaG9uZVhMYW5kc2NhcGVQYXRjaEFjdGl2ZSgpKSB7XG4gICAgICAgIHRoaXMuYXNjZW5zaW9uID0gODU7IC8vIDY0ICsgMjFcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuYXNjZW5zaW9uID0gNjQ7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHRvYXN0XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqL1xuICBzaG93KHRvYXN0LCBjYWxsYmFjaykge1xuICAgIHRvYXN0ID0gdG9hc3QuX3RvYXN0O1xuICAgIHV0aWwuZ2xvYmFscy5mYWJPZmZzZXQgPSB0aGlzLmFzY2Vuc2lvbjtcblxuICAgIGFuaW1pdC5ydW5BbGwoXG4gICAgICBhbmltaXQodG9hc3QsIHRoaXMuZGVmKVxuICAgICAgICAuZGVmYXVsdChcbiAgICAgICAgICB7IHRyYW5zZm9ybTogYHRyYW5zbGF0ZTNkKDAsICR7dGhpcy5hc2NlbnNpb259cHgsIDApYCB9LFxuICAgICAgICAgIHsgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoMCwgMCwgMCknIH1cbiAgICAgICAgKVxuICAgICAgICAucXVldWUoZG9uZSA9PiB7XG4gICAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soKTtcbiAgICAgICAgICBkb25lKCk7XG4gICAgICAgIH0pLFxuXG4gICAgICBhbmltaXQodGhpcy5fZ2V0RmFicygpKVxuICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAucXVldWUoeyB0cmFuc2Zvcm06IGB0cmFuc2xhdGUzZCgwLCAtJHt0aGlzLmFzY2Vuc2lvbn1weCwgMCkgc2NhbGUoMSlgIH0sIHRoaXMuZGVmKSxcblxuICAgICAgYW5pbWl0KHV0aWwuYXJyYXlGcm9tKHRvYXN0LmNoaWxkcmVuKSwgdGhpcy5kZWYpXG4gICAgICAgIC5kZWZhdWx0KHsgb3BhY2l0eTogMCB9LCB7IG9wYWNpdHk6IDEgfSlcbiAgICAgICk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gdG9hc3RcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICovXG4gIGhpZGUodG9hc3QsIGNhbGxiYWNrKSB7XG4gICAgdG9hc3QgPSB0b2FzdC5fdG9hc3Q7XG4gICAgdXRpbC5nbG9iYWxzLmZhYk9mZnNldCA9IDA7XG5cbiAgICBhbmltaXQucnVuQWxsKFxuICAgICAgYW5pbWl0KHRvYXN0LCB0aGlzLmRlZilcbiAgICAgICAgLmRlZmF1bHQoXG4gICAgICAgICAgeyB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzZCgwLCAwLCAwKScgfSxcbiAgICAgICAgICB7IHRyYW5zZm9ybTogYHRyYW5zbGF0ZTNkKDAsICR7dGhpcy5hc2NlbnNpb259cHgsIDApYCB9XG4gICAgICAgIClcbiAgICAgICAgLnF1ZXVlKGRvbmUgPT4ge1xuICAgICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKCk7XG4gICAgICAgICAgZG9uZSgpO1xuICAgICAgICB9KSxcblxuICAgICAgYW5pbWl0KHRoaXMuX2dldEZhYnMoKSwgdGhpcy5kZWYpXG4gICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAgIC5xdWV1ZSh7IHRyYW5zZm9ybTogYHRyYW5zbGF0ZTNkKDAsIDAsIDApIHNjYWxlKDEpYCB9LCB0aGlzLmRlZiksXG5cbiAgICAgIGFuaW1pdCh1dGlsLmFycmF5RnJvbSh0b2FzdC5jaGlsZHJlbiksIHRoaXMuZGVmKVxuICAgICAgICAuZGVmYXVsdCh7IG9wYWNpdHk6IDEgfSwgeyBvcGFjaXR5OiAwIH0pXG4gICAgKTtcbiAgfVxuXG4gIF9nZXRGYWJzKCkge1xuICAgIHJldHVybiB1dGlsLmFycmF5RnJvbShkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdvbnMtZmFiW3Bvc2l0aW9ufj1ib3R0b21dLCBvbnMtc3BlZWQtZGlhbFtwb3NpdGlvbn49Ym90dG9tXScpKS5maWx0ZXIoZmFiID0+IGZhYi52aXNpYmxlKTtcbiAgfVxufVxuIiwiXG4vKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgdXRpbCBmcm9tICcuLi8uLi9vbnMvdXRpbCc7XG5pbXBvcnQgYW5pbWl0IGZyb20gJy4uLy4uL29ucy9hbmltaXQnO1xuaW1wb3J0IGlQaG9uZVhQYXRjaCBmcm9tICcuLi8uLi9vbnMvaXBob25leC1wYXRjaCc7XG5pbXBvcnQgVG9hc3RBbmltYXRvciBmcm9tICcuL2FuaW1hdG9yJztcblxuLyoqXG4gKiBMaWZ0LWZhZGUgVG9hc3QgQW5pbWF0b3JcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTGlmdFRvYXN0QW5pbWF0b3IgZXh0ZW5kcyBUb2FzdEFuaW1hdG9yIHtcblxuICBjb25zdHJ1Y3Rvcih7IHRpbWluZyA9ICdlYXNlJywgZGVsYXkgPSAwLCBkdXJhdGlvbiA9IDAuMzUgfSA9IHt9KSB7XG4gICAgc3VwZXIoeyB0aW1pbmcsIGRlbGF5LCBkdXJhdGlvbiB9KTtcbiAgICB0aGlzLmJvZHlIZWlnaHQgPSBkb2N1bWVudC5ib2R5LmNsaWVudEhlaWdodDsgLy8gYXZvaWQgRm9yY2VkIFN5bmNocm9ub3VzIExheW91dFxuICAgIGlmIChpUGhvbmVYUGF0Y2guaXNJUGhvbmVYUG9ydHJhaXRQYXRjaEFjdGl2ZSgpKSB7XG4gICAgICB0aGlzLmxpZnRBbW91bnQgPSAnY2FsYygxMDAlICsgMzRweCknO1xuICAgIH0gZWxzZSBpZiAoaVBob25lWFBhdGNoLmlzSVBob25lWExhbmRzY2FwZVBhdGNoQWN0aXZlKCkpIHtcbiAgICAgIHRoaXMubGlmdEFtb3VudCA9ICdjYWxjKDEwMCUgKyAyMXB4KSc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubGlmdEFtb3VudCA9ICcxMDAlJztcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gdG9hc3RcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICovXG4gIHNob3codG9hc3QsIGNhbGxiYWNrKSB7XG4gICAgdG9hc3QgPSB0b2FzdC5fdG9hc3Q7XG5cbiAgICBhbmltaXQucnVuQWxsKFxuICAgICAgYW5pbWl0KHRvYXN0LCB0aGlzLmRlZilcbiAgICAgICAgLmRlZmF1bHQoXG4gICAgICAgICAgeyB0cmFuc2Zvcm06IGB0cmFuc2xhdGUzZCgwLCAke3RoaXMubGlmdEFtb3VudH0sIDApYCwgb3BhY2l0eTogMCB9LFxuICAgICAgICAgIHsgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoMCwgMCwgMCknLCBvcGFjaXR5OiAxIH1cbiAgICAgICAgKVxuICAgICAgICAucXVldWUoZG9uZSA9PiB7XG4gICAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soKTtcbiAgICAgICAgICBkb25lKCk7XG4gICAgICAgIH0pXG4gICAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHRvYXN0XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqL1xuICBoaWRlKHRvYXN0LCBjYWxsYmFjaykge1xuICAgIHRvYXN0ID0gdG9hc3QuX3RvYXN0O1xuXG4gICAgYW5pbWl0LnJ1bkFsbChcbiAgICAgIGFuaW1pdCh0b2FzdCwgdGhpcy5kZWYpXG4gICAgICAgIC5kZWZhdWx0KFxuICAgICAgICAgIHsgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoMCwgMCwgMCknLCBvcGFjaXR5OiAxIH0sXG4gICAgICAgICAgeyB0cmFuc2Zvcm06IGB0cmFuc2xhdGUzZCgwLCAke3RoaXMubGlmdEFtb3VudH0sIDApYCwgb3BhY2l0eTogMCB9XG4gICAgICAgIClcbiAgICAgICAgLnF1ZXVlKGRvbmUgPT4ge1xuICAgICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKCk7XG4gICAgICAgICAgZG9uZSgpO1xuICAgICAgICB9KVxuICAgICk7XG4gIH1cblxuICBfdXBkYXRlUG9zaXRpb24odG9hc3QpIHtcbiAgICBpZiAocGFyc2VJbnQodG9hc3Quc3R5bGUudG9wLCAxMCkgPT09IDApIHtcbiAgICAgIHRvYXN0LnN0eWxlLnRvcCA9IHRvYXN0LnN0eWxlLmJvdHRvbSA9ICcnO1xuICAgIH1cbiAgfVxufVxuIiwiXG4vKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgdXRpbCBmcm9tICcuLi8uLi9vbnMvdXRpbCc7XG5pbXBvcnQgYW5pbWl0IGZyb20gJy4uLy4uL29ucy9hbmltaXQnO1xuaW1wb3J0IGlQaG9uZVhQYXRjaCBmcm9tICcuLi8uLi9vbnMvaXBob25leC1wYXRjaCc7XG5pbXBvcnQgVG9hc3RBbmltYXRvciBmcm9tICcuL2FuaW1hdG9yJztcblxuLyoqXG4gKiBGYWxsLWZhZGUgVG9hc3QgQW5pbWF0b3JcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRmFsbFRvYXN0QW5pbWF0b3IgZXh0ZW5kcyBUb2FzdEFuaW1hdG9yIHtcblxuICBjb25zdHJ1Y3Rvcih7IHRpbWluZyA9ICdlYXNlJywgZGVsYXkgPSAwLCBkdXJhdGlvbiA9IDAuMzUgfSA9IHt9KSB7XG4gICAgc3VwZXIoeyB0aW1pbmcsIGRlbGF5LCBkdXJhdGlvbiB9KTtcbiAgICBpZiAoaVBob25lWFBhdGNoLmlzSVBob25lWFBvcnRyYWl0UGF0Y2hBY3RpdmUoKSkge1xuICAgICAgdGhpcy5mYWxsQW1vdW50ID0gJ2NhbGMoLTEwMCUgLSA0NHB4KSc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZmFsbEFtb3VudCA9ICctMTAwJSc7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHRvYXN0XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqL1xuICBzaG93KHRvYXN0LCBjYWxsYmFjaykge1xuICAgIHRvYXN0ID0gdG9hc3QuX3RvYXN0O1xuICAgIHRoaXMuX3VwZGF0ZVBvc2l0aW9uKHRvYXN0KTtcblxuICAgIGFuaW1pdC5ydW5BbGwoXG4gICAgICBhbmltaXQodG9hc3QsIHRoaXMuZGVmKVxuICAgICAgICAuZGVmYXVsdChcbiAgICAgICAgICB7IHRyYW5zZm9ybTogYHRyYW5zbGF0ZTNkKDAsICR7dGhpcy5mYWxsQW1vdW50fSwgMClgLCBvcGFjaXR5OiAwIH0sXG4gICAgICAgICAgeyB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzZCgwLCAwLCAwKScsIG9wYWNpdHk6IDEgfVxuICAgICAgICApXG4gICAgICAgIC5xdWV1ZShkb25lID0+IHtcbiAgICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjaygpO1xuICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgfSlcbiAgICAgICk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gdG9hc3RcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICovXG4gIGhpZGUodG9hc3QsIGNhbGxiYWNrKSB7XG4gICAgdG9hc3QgPSB0b2FzdC5fdG9hc3Q7XG4gICAgdGhpcy5fdXBkYXRlUG9zaXRpb24odG9hc3QpO1xuXG4gICAgYW5pbWl0LnJ1bkFsbChcbiAgICAgIGFuaW1pdCh0b2FzdCwgdGhpcy5kZWYpXG4gICAgICAgIC5kZWZhdWx0KFxuICAgICAgICAgIHsgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoMCwgMCwgMCknLCBvcGFjaXR5OiAxIH0sXG4gICAgICAgICAgeyB0cmFuc2Zvcm06IGB0cmFuc2xhdGUzZCgwLCAke3RoaXMuZmFsbEFtb3VudH0sIDApYCwgb3BhY2l0eTogMCB9XG4gICAgICAgIClcbiAgICAgICAgLnF1ZXVlKGRvbmUgPT4ge1xuICAgICAgICAgIHRoaXMuX3VwZGF0ZVBvc2l0aW9uKHRvYXN0LCB0cnVlKTtcbiAgICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjaygpO1xuICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgfSlcbiAgICApO1xuICB9XG5cbiAgX3VwZGF0ZVBvc2l0aW9uKHRvYXN0LCBjbGVhblVwKSB7XG4gICAgbGV0IGNvcnJlY3RUb3A7XG4gICAgaWYgKGlQaG9uZVhQYXRjaC5pc0lQaG9uZVhQb3J0cmFpdFBhdGNoQWN0aXZlKCkpIHtcbiAgICAgIGNvcnJlY3RUb3AgPSAnNDRweCc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvcnJlY3RUb3AgPSAnMCc7XG4gICAgfVxuXG4gICAgaWYgKHRvYXN0LnN0eWxlLnRvcCAhPT0gY29ycmVjdFRvcCkge1xuICAgICAgdG9hc3Quc3R5bGUudG9wID0gY29ycmVjdFRvcDtcbiAgICAgIHRvYXN0LnN0eWxlLmJvdHRvbSA9ICdpbml0aWFsJztcbiAgICB9XG4gIH1cbn1cbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCBvbnNFbGVtZW50cyBmcm9tICcuLi8uLi9vbnMvZWxlbWVudHMnO1xuaW1wb3J0IHV0aWwgZnJvbSAnLi4vLi4vb25zL3V0aWwnO1xuaW1wb3J0IGF1dG9TdHlsZSBmcm9tICcuLi8uLi9vbnMvYXV0b3N0eWxlJztcbmltcG9ydCBNb2RpZmllclV0aWwgZnJvbSAnLi4vLi4vb25zL2ludGVybmFsL21vZGlmaWVyLXV0aWwnO1xuaW1wb3J0IEFuaW1hdG9yRmFjdG9yeSBmcm9tICcuLi8uLi9vbnMvaW50ZXJuYWwvYW5pbWF0b3ItZmFjdG9yeSc7XG5pbXBvcnQgVG9hc3RBbmltYXRvciBmcm9tICcuL2FuaW1hdG9yJztcbmltcG9ydCBGYWRlVG9hc3RBbmltYXRvciBmcm9tICcuL2ZhZGUtYW5pbWF0b3InO1xuaW1wb3J0IEFzY2VuZFRvYXN0QW5pbWF0b3IgZnJvbSAnLi9hc2NlbmQtYW5pbWF0b3InO1xuaW1wb3J0IExpZnRUb2FzdEFuaW1hdG9yIGZyb20gJy4vbGlmdC1hbmltYXRvcic7XG5pbXBvcnQgRmFsbFRvYXN0QW5pbWF0b3IgZnJvbSAnLi9mYWxsLWFuaW1hdG9yJztcbmltcG9ydCBwbGF0Zm9ybSBmcm9tICcuLi8uLi9vbnMvcGxhdGZvcm0nO1xuaW1wb3J0IEJhc2VEaWFsb2dFbGVtZW50IGZyb20gJy4uL2Jhc2UvYmFzZS1kaWFsb2cnO1xuaW1wb3J0IGNvbnRlbnRSZWFkeSBmcm9tICcuLi8uLi9vbnMvY29udGVudC1yZWFkeSc7XG5cbmNvbnN0IHNjaGVtZSA9IHtcbiAgJy50b2FzdCc6ICd0b2FzdC0tKicsXG4gICcudG9hc3RfX21lc3NhZ2UnOiAndG9hc3QtLSpfX21lc3NhZ2UnLFxuICAnLnRvYXN0X19idXR0b24nOiAndG9hc3QtLSpfX2J1dHRvbidcbn07XG5cbmNvbnN0IGRlZmF1bHRDbGFzc05hbWUgPSAndG9hc3QnO1xuXG5jb25zdCBfYW5pbWF0b3JEaWN0ID0ge1xuICAnZGVmYXVsdCc6IHBsYXRmb3JtLmlzQW5kcm9pZCgpID8gQXNjZW5kVG9hc3RBbmltYXRvciA6IExpZnRUb2FzdEFuaW1hdG9yLFxuICAnZmFkZSc6IEZhZGVUb2FzdEFuaW1hdG9yLFxuICAnYXNjZW5kJzogQXNjZW5kVG9hc3RBbmltYXRvcixcbiAgJ2xpZnQnOiBMaWZ0VG9hc3RBbmltYXRvcixcbiAgJ2ZhbGwnOiBGYWxsVG9hc3RBbmltYXRvcixcbiAgJ25vbmUnOiBUb2FzdEFuaW1hdG9yXG59O1xuXG4vKipcbiAqIEBlbGVtZW50IG9ucy10b2FzdFxuICogQGNhdGVnb3J5IGRpYWxvZ1xuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1cbiAqICAgICBUaGUgVG9hc3Qgb3IgU25hY2tiYXIgY29tcG9uZW50IGlzIHVzZWZ1bCBmb3IgZGlzcGxheWluZyBkaXNtaXNzYWJsZSBpbmZvcm1hdGlvbiBvciBzaW1wbGUgYWN0aW9ucyBhdCAobm9ybWFsbHkpIHRoZSBib3R0b20gb2YgdGhlIHBhZ2UuXG4gKlxuICogICAgIFRoaXMgY29tcG9uZW50IGRvZXMgbm90IGJsb2NrIHVzZXIgaW5wdXQsIGFsbG93aW5nIHRoZSBhcHAgdG8gY29udGludWUgaXRzIGZsb3cuIEZvciBzaW1wbGUgdG9hc3RzLCBjb25zaWRlciBgb25zLm5vdGlmaWNhdGlvbi50b2FzdGAgaW5zdGVhZC5cbiAqICAgWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAdHV0b3JpYWwgdmFuaWxsYS9SZWZlcmVuY2UvdG9hc3RcbiAqIEBzZWVhbHNvIG9ucy1hbGVydC1kaWFsb2dcbiAqICAgW2VuXVRoZSBgPG9ucy1hbGVydC1kaWFsb2c+YCBjb21wb25lbnQgaXMgcHJlZmVycmVkIGZvciBkaXNwbGF5aW5nIHVuZGlzbWlzc2FibGUgaW5mb3JtYXRpb24uWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRvYXN0RWxlbWVudCBleHRlbmRzIEJhc2VEaWFsb2dFbGVtZW50IHtcblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBhbmltYXRpb25cbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlZmF1bHQgZGVmYXVsdFxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFtlbl1UaGUgYW5pbWF0aW9uIHVzZWQgd2hlbiBzaG93aW5nIGFuZCBoaWRpbmcgdGhlIHRvYXN0LiBDYW4gYmUgZWl0aGVyIGBcImRlZmF1bHRcImAsIGBcImFzY2VuZFwiYCAoQW5kcm9pZCksIGBcImxpZnRcImAgKGlPUyksIGBcImZhbGxcImAsIGBcImZhZGVcImAgb3IgYFwibm9uZVwiYC5bL2VuXVxuICAgKiAgW2phXVsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGFuaW1hdGlvbi1vcHRpb25zXG4gICAqIEB0eXBlIHtFeHByZXNzaW9ufVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFtlbl1TcGVjaWZ5IHRoZSBhbmltYXRpb24ncyBkdXJhdGlvbiwgdGltaW5nIGFuZCBkZWxheSB3aXRoIGFuIG9iamVjdCBsaXRlcmFsLiBFLmcuIGB7ZHVyYXRpb246IDAuMiwgZGVsYXk6IDEsIHRpbWluZzogJ2Vhc2UtaW4nfWAuWy9lbl1cbiAgICogIFtqYV3jgqLjg4vjg6Hjg7zjgrfjg6fjg7PmmYLjga5kdXJhdGlvbiwgdGltaW5nLCBkZWxheeOCkuOCquODluOCuOOCp+OCr+ODiOODquODhuODqeODq+OBp+aMh+WumuOBl+OBvuOBmeOAgmUuZy4gPGNvZGU+e2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAxLCB0aW1pbmc6ICdlYXNlLWluJ308L2NvZGU+Wy9qYV1cbiAgICovXG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIHRoaXMuX2RlZmF1bHREQkIgPSBudWxsO1xuICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB0aGlzLl9jb21waWxlKCkpO1xuICB9XG5cbiAgZ2V0IF9zY2hlbWUoKSB7XG4gICAgcmV0dXJuIHNjaGVtZTtcbiAgfVxuXG4gIGdldCBfdG9hc3QoKSB7XG4gICAgcmV0dXJuIHV0aWwuZmluZENoaWxkKHRoaXMsIGAuJHtkZWZhdWx0Q2xhc3NOYW1lfWApO1xuICB9XG5cbiAgX3VwZGF0ZUFuaW1hdG9yRmFjdG9yeSgpIHtcbiAgICAvLyBSZXNldCBwb3NpdGlvbiBzdHlsZVxuICAgIHRoaXMuX3RvYXN0ICYmICh0aGlzLl90b2FzdC5zdHlsZS50b3AgPSB0aGlzLl90b2FzdC5zdHlsZS5ib3R0b20gPSAnJyk7XG5cbiAgICByZXR1cm4gbmV3IEFuaW1hdG9yRmFjdG9yeSh7XG4gICAgICBhbmltYXRvcnM6IF9hbmltYXRvckRpY3QsXG4gICAgICBiYXNlQ2xhc3M6IFRvYXN0QW5pbWF0b3IsXG4gICAgICBiYXNlQ2xhc3NOYW1lOiAnVG9hc3RBbmltYXRvcicsXG4gICAgICBkZWZhdWx0QW5pbWF0aW9uOiB0aGlzLmdldEF0dHJpYnV0ZSgnYW5pbWF0aW9uJylcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgb25EZXZpY2VCYWNrQnV0dG9uXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1CYWNrLWJ1dHRvbiBoYW5kbGVyLlsvZW5dXG4gICAqICAgW2phXeODkOODg+OCr+ODnOOCv+ODs+ODj+ODs+ODieODqeOAglsvamFdXG4gICAqL1xuXG4gIF9jb21waWxlKCkge1xuICAgIGF1dG9TdHlsZS5wcmVwYXJlKHRoaXMpO1xuXG4gICAgdGhpcy5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgIHRoaXMuc3R5bGUuekluZGV4ID0gMTAwMDA7IC8vIExvd2VyIHRoYW4gZGlhbG9nc1xuXG4gICAgY29uc3QgbWVzc2FnZUNsYXNzTmFtZSA9ICd0b2FzdF9fbWVzc2FnZSc7XG4gICAgY29uc3QgYnV0dG9uQ2xhc3NOYW1lID0gJ3RvYXN0X19idXR0b24nO1xuXG4gICAgbGV0IHRvYXN0ID0gdXRpbC5maW5kQ2hpbGQodGhpcywgYC4ke2RlZmF1bHRDbGFzc05hbWV9YCk7XG4gICAgaWYgKCF0b2FzdCkge1xuICAgICAgdG9hc3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIHRvYXN0LmNsYXNzTGlzdC5hZGQoZGVmYXVsdENsYXNzTmFtZSk7XG4gICAgICB3aGlsZSAodGhpcy5jaGlsZE5vZGVzWzBdKSB7XG4gICAgICAgIHRvYXN0LmFwcGVuZENoaWxkKHRoaXMuY2hpbGROb2Rlc1swXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbGV0IGJ1dHRvbiA9IHV0aWwuZmluZENoaWxkKHRvYXN0LCBgLiR7YnV0dG9uQ2xhc3NOYW1lfWApO1xuICAgIGlmICghYnV0dG9uKSB7XG4gICAgICBidXR0b24gPSB1dGlsLmZpbmRDaGlsZCh0b2FzdCwgZSA9PiB1dGlsLm1hdGNoKGUsICcuYnV0dG9uJykgfHwgdXRpbC5tYXRjaChlLCAnYnV0dG9uJykpO1xuICAgICAgaWYgKGJ1dHRvbikge1xuICAgICAgICBidXR0b24uY2xhc3NMaXN0LnJlbW92ZSgnYnV0dG9uJyk7XG4gICAgICAgIGJ1dHRvbi5jbGFzc0xpc3QuYWRkKGJ1dHRvbkNsYXNzTmFtZSk7XG4gICAgICAgIHRvYXN0LmFwcGVuZENoaWxkKGJ1dHRvbik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCF1dGlsLmZpbmRDaGlsZCh0b2FzdCwgYC4ke21lc3NhZ2VDbGFzc05hbWV9YCkpIHtcbiAgICAgIGxldCBtZXNzYWdlID0gdXRpbC5maW5kQ2hpbGQodG9hc3QsICcubWVzc2FnZScpO1xuICAgICAgaWYgKCFtZXNzYWdlKSB7XG4gICAgICAgIG1lc3NhZ2UgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IHRvYXN0LmNoaWxkTm9kZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICBpZiAodG9hc3QuY2hpbGROb2Rlc1tpXSAhPT0gYnV0dG9uKSB7XG4gICAgICAgICAgICBtZXNzYWdlLmluc2VydEJlZm9yZSh0b2FzdC5jaGlsZE5vZGVzW2ldLCBtZXNzYWdlLmZpcnN0Q2hpbGQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbWVzc2FnZS5jbGFzc0xpc3QuYWRkKG1lc3NhZ2VDbGFzc05hbWUpO1xuXG4gICAgICB0b2FzdC5pbnNlcnRCZWZvcmUobWVzc2FnZSwgdG9hc3QuZmlyc3RDaGlsZCk7XG4gICAgfVxuXG4gICAgaWYgKHRvYXN0LnBhcmVudE5vZGUgIT09IHRoaXMpIHtcbiAgICAgIHRoaXMuYXBwZW5kQ2hpbGQodG9hc3QpO1xuICAgIH1cblxuICAgIE1vZGlmaWVyVXRpbC5pbml0TW9kaWZpZXIodGhpcywgdGhpcy5fc2NoZW1lKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgdmlzaWJsZVxuICAgKiBAcmVhZG9ubHlcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1XaGV0aGVyIHRoZSBlbGVtZW50IGlzIHZpc2libGUgb3Igbm90LlsvZW5dXG4gICAqICAgW2phXeimgee0oOOBjOimi+OBiOOCi+WgtOWQiOOBq2B0cnVlYOOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAbWV0aG9kIHNob3dcbiAgICogQHNpZ25hdHVyZSBzaG93KFtvcHRpb25zXSlcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiAgIFtlbl1QYXJhbWV0ZXIgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCquODl+OCt+ODp+ODs+OCkuaMh+WumuOBmeOCi+OCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5hbmltYXRpb25dXG4gICAqICAgW2VuXUFuaW1hdGlvbiBuYW1lLiBBdmFpbGFibGUgYW5pbWF0aW9ucyBhcmUgYFwiZGVmYXVsdFwiYCwgYFwiYXNjZW5kXCJgIChBbmRyb2lkKSwgYFwibGlmdFwiYCAoaU9TKSwgYFwiZmFsbFwiYCwgYFwiZmFkZVwiYCBvciBgXCJub25lXCJgLlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5hbmltYXRpb25PcHRpb25zXVxuICAgKiAgIFtlbl1TcGVjaWZ5IHRoZSBhbmltYXRpb24ncyBkdXJhdGlvbiwgZGVsYXkgYW5kIHRpbWluZy4gRS5nLiBge2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAwLjQsIHRpbWluZzogJ2Vhc2UtaW4nfWAuWy9lbl1cbiAgICogICBbamFd44Ki44OL44Oh44O844K344On44Oz5pmC44GuZHVyYXRpb24sIGRlbGF5LCB0aW1pbmfjgpLmjIflrprjgZfjgb7jgZnjgIJlLmcuIHtkdXJhdGlvbjogMC4yLCBkZWxheTogMC40LCB0aW1pbmc6ICdlYXNlLWluJ31bL2phXVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dU2hvdyB0aGUgZWxlbWVudC5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKiAgIFtlbl1SZXNvbHZlcyB0byB0aGUgZGlzcGxheWVkIGVsZW1lbnRbL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQG1ldGhvZCB0b2dnbGVcbiAgICogQHNpZ25hdHVyZSB0b2dnbGUoW29wdGlvbnNdKVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqICAgW2VuXVBhcmFtZXRlciBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Kq44OX44K344On44Oz44KS5oyH5a6a44GZ44KL44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmFuaW1hdGlvbl1cbiAgICogICBbZW5dQW5pbWF0aW9uIG5hbWUuIEF2YWlsYWJsZSBhbmltYXRpb25zIGFyZSBgXCJkZWZhdWx0XCJgLCBgXCJhc2NlbmRcImAgKEFuZHJvaWQpLCBgXCJsaWZ0XCJgIChpT1MpLCBgXCJmYWxsXCJgLCBgXCJmYWRlXCJgIG9yIGBcIm5vbmVcImAuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmFuaW1hdGlvbk9wdGlvbnNdXG4gICAqICAgW2VuXVNwZWNpZnkgdGhlIGFuaW1hdGlvbidzIGR1cmF0aW9uLCBkZWxheSBhbmQgdGltaW5nLiBFLmcuIGB7ZHVyYXRpb246IDAuMiwgZGVsYXk6IDAuNCwgdGltaW5nOiAnZWFzZS1pbid9YC5bL2VuXVxuICAgKiAgIFtqYV3jgqLjg4vjg6Hjg7zjgrfjg6fjg7PmmYLjga5kdXJhdGlvbiwgZGVsYXksIHRpbWluZ+OCkuaMh+WumuOBl+OBvuOBmeOAgmUuZy4ge2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAwLjQsIHRpbWluZzogJ2Vhc2UtaW4nfVsvamFdXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1Ub2dnbGUgdG9hc3QgdmlzaWJpbGl0eS5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQG1ldGhvZCBoaWRlXG4gICAqIEBzaWduYXR1cmUgaGlkZShbb3B0aW9uc10pXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogICBbZW5dUGFyYW1ldGVyIG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgqrjg5fjgrfjg6fjg7PjgpLmjIflrprjgZnjgovjgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuYW5pbWF0aW9uXVxuICAgKiAgIFtlbl1BbmltYXRpb24gbmFtZS4gQXZhaWxhYmxlIGFuaW1hdGlvbnMgYXJlIGBcImRlZmF1bHRcImAsIGBcImFzY2VuZFwiYCAoQW5kcm9pZCksIGBcImxpZnRcImAgKGlPUyksIGBcImZhbGxcImAsIGBcImZhZGVcImAgb3IgYFwibm9uZVwiYC5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuYW5pbWF0aW9uT3B0aW9uc11cbiAgICogICBbZW5dU3BlY2lmeSB0aGUgYW5pbWF0aW9uJ3MgZHVyYXRpb24sIGRlbGF5IGFuZCB0aW1pbmcuIEUuZy4gYHtkdXJhdGlvbjogMC4yLCBkZWxheTogMC40LCB0aW1pbmc6ICdlYXNlLWluJ31gLlsvZW5dXG4gICAqICAgW2phXeOCouODi+ODoeODvOOCt+ODp+ODs+aZguOBrmR1cmF0aW9uLCBkZWxheSwgdGltaW5n44KS5oyH5a6a44GX44G+44GZ44CCZS5nLiB7ZHVyYXRpb246IDAuMiwgZGVsYXk6IDAuNCwgdGltaW5nOiAnZWFzZS1pbid9Wy9qYV1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUhpZGUgdG9hc3QuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICogICBbZW5dUmVzb2x2ZXMgdG8gdGhlIGhpZGRlbiBlbGVtZW50Wy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IEFuaW1hdG9yXG4gICAqL1xuICBzdGF0aWMgcmVnaXN0ZXJBbmltYXRvcihuYW1lLCBBbmltYXRvcikge1xuICAgIGlmICghKEFuaW1hdG9yLnByb3RvdHlwZSBpbnN0YW5jZW9mIFRvYXN0QW5pbWF0b3IpKSB7XG4gICAgICB1dGlsLnRocm93KCdcIkFuaW1hdG9yXCIgcGFyYW0gbXVzdCBpbmhlcml0IE9uc1RvYXN0RWxlbWVudC5Ub2FzdEFuaW1hdG9yJyk7XG4gICAgfVxuICAgIF9hbmltYXRvckRpY3RbbmFtZV0gPSBBbmltYXRvcjtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgYW5pbWF0b3JzKCkge1xuICAgIHJldHVybiBfYW5pbWF0b3JEaWN0O1xuICB9XG5cbiAgc3RhdGljIGdldCBUb2FzdEFuaW1hdG9yKCkge1xuICAgIHJldHVybiBUb2FzdEFuaW1hdG9yO1xuICB9XG59XG5cbm9uc0VsZW1lbnRzLlRvYXN0ID0gVG9hc3RFbGVtZW50O1xuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdvbnMtdG9hc3QnLCBUb2FzdEVsZW1lbnQpO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IG9uc0VsZW1lbnRzIGZyb20gJy4uL29ucy9lbGVtZW50cyc7XG5pbXBvcnQgQmFzZUJ1dHRvbkVsZW1lbnQgZnJvbSAnLi9iYXNlL2Jhc2UtYnV0dG9uJztcblxuLyoqXG4gKiBAZWxlbWVudCBvbnMtdG9vbGJhci1idXR0b25cbiAqIEBjYXRlZ29yeSBwYWdlXG4gKiBAbW9kaWZpZXIgbWF0ZXJpYWxcbiAqICAgW2VuXU1hdGVyaWFsIERlc2lnbiB0b29sYmFyIGJ1dHRvbi5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBtb2RpZmllciBvdXRsaW5lXG4gKiAgIFtlbl1BIGJ1dHRvbiB3aXRoIGFuIG91dGxpbmUuWy9lbl1cbiAqICAgW2phXeOCouOCpuODiOODqeOCpOODs+OCkuOCguOBo+OBn+ODnOOCv+ODs+OCkuihqOekuuOBl+OBvuOBmeOAglsvamFdXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXUJ1dHRvbiBjb21wb25lbnQgZm9yIG9ucy10b29sYmFyIGFuZCBvbnMtYm90dG9tLXRvb2xiYXIuWy9lbl1cbiAqICAgW2phXW9ucy10b29sYmFy44GC44KL44GE44Gvb25zLWJvdHRvbS10b29sYmFy44Gr6Kit572u44Gn44GN44KL44Oc44K/44Oz55So44Kz44Oz44Od44O844ON44Oz44OI44Gn44GZ44CCWy9qYV1cbiAqIEBjb2RlcGVuIGFIbUdMXG4gKiBAdHV0b3JpYWwgdmFuaWxsYS9SZWZlcmVuY2UvcGFnZVxuICogQGd1aWRlIGNvbXBpbGF0aW9uLmh0bWwjdG9vbGJhci1jb21waWxhdGlvblxuICogICBbZW5dQWRkaW5nIGEgdG9vbGJhclsvZW5dXG4gKiAgIFtqYV3jg4Tjg7zjg6vjg5Djg7zjga7ov73liqBbL2phXVxuICogQHNlZWFsc28gb25zLXRvb2xiYXJcbiAqICAgW2VuXVRoZSBgPG9ucy10b29sYmFyPmAgY29tcG9uZW50IGRpc3BsYXlzIGEgbmF2aWdhdGlvbiBiYXIgYXQgdGhlIHRvcCBvZiBhIHBhZ2UuWy9lbl1cbiAqICAgW2phXW9ucy10b29sYmFy44Kz44Oz44Od44O844ON44Oz44OIWy9qYV1cbiAqIEBzZWVhbHNvIG9ucy1iYWNrLWJ1dHRvblxuICogICBbZW5dVGhlIGA8b25zLWJhY2stYnV0dG9uPmAgZGlzcGxheXMgYSBiYWNrIGJ1dHRvbiBpbiB0aGUgbmF2aWdhdGlvbiBiYXIuWy9lbl1cbiAqICAgW2phXW9ucy1iYWNrLWJ1dHRvbuOCs+ODs+ODneODvOODjeODs+ODiFsvamFdXG4gKiBAZXhhbXBsZVxuICogPG9ucy10b29sYmFyPlxuICogICA8ZGl2IGNsYXNzPVwibGVmdFwiPlxuICogICAgIDxvbnMtdG9vbGJhci1idXR0b24+XG4gKiAgICAgICBCdXR0b25cbiAqICAgICA8L29ucy10b29sYmFyLWJ1dHRvbj5cbiAqICAgPC9kaXY+XG4gKiAgIDxkaXYgY2xhc3M9XCJjZW50ZXJcIj5cbiAqICAgICBUaXRsZVxuICogICA8L2Rpdj5cbiAqICAgPGRpdiBjbGFzcz1cInJpZ2h0XCI+XG4gKiAgICAgPG9ucy10b29sYmFyLWJ1dHRvbj5cbiAqICAgICAgIDxvbnMtaWNvbiBpY29uPVwiaW9uLW5hdmljb25cIiBzaXplPVwiMjhweFwiPjwvb25zLWljb24+XG4gKiAgICAgPC9vbnMtdG9vbGJhci1idXR0b24+XG4gKiAgIDwvZGl2PlxuICogPC9vbnMtdG9vbGJhcj5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVG9vbGJhckJ1dHRvbkVsZW1lbnQgZXh0ZW5kcyBCYXNlQnV0dG9uRWxlbWVudCB7XG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgbW9kaWZpZXJcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVRoZSBhcHBlYXJhbmNlIG9mIHRoZSBidXR0b24uWy9lbl1cbiAgICogICBbamFd44Oc44K/44Oz44Gu6KGo54++44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgaWNvblxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFtlbl1DcmVhdGVzIGFuIGBvbnMtaWNvbmAgY29tcG9uZW50IHdpdGggdGhpcyBzdHJpbmcuWy9lbl1cbiAgICogIFtqYV1gb25zLWljb25g44Kz44Oz44Od44O844ON44Oz44OI44KS5oKq5oCn44GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgZGlzYWJsZWRcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVNwZWNpZnkgaWYgYnV0dG9uIHNob3VsZCBiZSBkaXNhYmxlZC5bL2VuXVxuICAgKiAgIFtqYV3jg5zjgr/jg7PjgpLnhKHlirnljJbjgZnjgovloLTlkIjjga/mjIflrprjgZfjgabjgY/jgaDjgZXjgYTjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQHByb3BlcnR5IGRpc2FibGVkXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dV2hldGhlciB0aGUgZWxlbWVudCBpcyBkaXNhYmxlZCBvciBub3QuWy9lbl1cbiAgICogICBbamFd54Sh5Yq55YyW44GV44KM44Gm44GE44KL5aC05ZCI44GrYHRydWVg44CCWy9qYV1cbiAgICovXG5cbiAgZ2V0IF9zY2hlbWUoKSB7XG4gICAgcmV0dXJuIHsgJyc6ICd0b29sYmFyLWJ1dHRvbi0tKicgfTtcbiAgfVxuXG4gIGdldCBfZGVmYXVsdENsYXNzTmFtZSgpIHtcbiAgICByZXR1cm4gJ3Rvb2xiYXItYnV0dG9uJztcbiAgfVxuXG4gIGdldCBfcmlwcGxlT3B0KCkge1xuICAgIHJldHVybiBbdGhpcywgdW5kZWZpbmVkLCB7IGNlbnRlcjogJycsICdzaXplJzogJ2NvbnRhaW4nLCAnYmFja2dyb3VuZCc6ICd0cmFuc3BhcmVudCcgfV07XG4gIH1cbn1cblxub25zRWxlbWVudHMuVG9vbGJhckJ1dHRvbiA9IFRvb2xiYXJCdXR0b25FbGVtZW50O1xuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdvbnMtdG9vbGJhci1idXR0b24nLCBUb29sYmFyQnV0dG9uRWxlbWVudCk7XG4iLCJpbXBvcnQgb25zIGZyb20gJy4vb25zJzsgLy8gQWRkIG9ucyBpbnRlcm5hbHNcbmltcG9ydCBzZXR1cCBmcm9tICcuL3NldHVwJzsgLy8gQWRkIHBvbHlmaWxsc1xuXG4vLyBBZGQgYW5kIHJlZ2lzdGVyIEN1c3RvbSBFbGVtZW50c1xuaW1wb3J0ICcuL2VsZW1lbnRzL29ucy10ZW1wbGF0ZSc7XG5pbXBvcnQgJy4vZWxlbWVudHMvb25zLWlmJztcbmltcG9ydCAnLi9lbGVtZW50cy9vbnMtYWN0aW9uLXNoZWV0JztcbmltcG9ydCAnLi9lbGVtZW50cy9vbnMtYWN0aW9uLXNoZWV0LWJ1dHRvbic7XG5pbXBvcnQgJy4vZWxlbWVudHMvb25zLWFsZXJ0LWRpYWxvZyc7XG5pbXBvcnQgJy4vZWxlbWVudHMvb25zLWFsZXJ0LWRpYWxvZy1idXR0b24nO1xuaW1wb3J0ICcuL2VsZW1lbnRzL29ucy1iYWNrLWJ1dHRvbic7XG5pbXBvcnQgJy4vZWxlbWVudHMvb25zLWJvdHRvbS10b29sYmFyJztcbmltcG9ydCAnLi9lbGVtZW50cy9vbnMtYnV0dG9uJztcbmltcG9ydCAnLi9lbGVtZW50cy9vbnMtY2FyZCc7XG5pbXBvcnQgJy4vZWxlbWVudHMvb25zLWNhcm91c2VsLWl0ZW0nO1xuaW1wb3J0ICcuL2VsZW1lbnRzL29ucy1jYXJvdXNlbCc7XG5pbXBvcnQgJy4vZWxlbWVudHMvb25zLWNvbCc7XG5pbXBvcnQgJy4vZWxlbWVudHMvb25zLWRpYWxvZyc7XG5pbXBvcnQgJy4vZWxlbWVudHMvb25zLWZhYic7XG5pbXBvcnQgJy4vZWxlbWVudHMvb25zLWdlc3R1cmUtZGV0ZWN0b3InO1xuaW1wb3J0ICcuL2VsZW1lbnRzL29ucy1pY29uJztcbmltcG9ydCAnLi9lbGVtZW50cy9vbnMtbGF6eS1yZXBlYXQnO1xuaW1wb3J0ICcuL2VsZW1lbnRzL29ucy1saXN0LWhlYWRlcic7XG5pbXBvcnQgJy4vZWxlbWVudHMvb25zLWxpc3QtdGl0bGUnO1xuaW1wb3J0ICcuL2VsZW1lbnRzL29ucy1saXN0LWl0ZW0nO1xuaW1wb3J0ICcuL2VsZW1lbnRzL29ucy1saXN0JztcbmltcG9ydCAnLi9lbGVtZW50cy9vbnMtaW5wdXQnO1xuaW1wb3J0ICcuL2VsZW1lbnRzL29ucy1jaGVja2JveCc7XG5pbXBvcnQgJy4vZWxlbWVudHMvb25zLXJhZGlvJztcbmltcG9ydCAnLi9lbGVtZW50cy9vbnMtc2VhcmNoLWlucHV0JztcbmltcG9ydCAnLi9lbGVtZW50cy9vbnMtbW9kYWwnO1xuaW1wb3J0ICcuL2VsZW1lbnRzL29ucy1uYXZpZ2F0b3InO1xuaW1wb3J0ICcuL2VsZW1lbnRzL29ucy1wYWdlJztcbmltcG9ydCAnLi9lbGVtZW50cy9vbnMtcG9wb3Zlcic7XG5pbXBvcnQgJy4vZWxlbWVudHMvb25zLXByb2dyZXNzLWJhcic7XG5pbXBvcnQgJy4vZWxlbWVudHMvb25zLXByb2dyZXNzLWNpcmN1bGFyJztcbmltcG9ydCAnLi9lbGVtZW50cy9vbnMtcHVsbC1ob29rJztcbmltcG9ydCAnLi9lbGVtZW50cy9vbnMtcmFuZ2UnO1xuaW1wb3J0ICcuL2VsZW1lbnRzL29ucy1yaXBwbGUnO1xuaW1wb3J0ICcuL2VsZW1lbnRzL29ucy1yb3cnO1xuaW1wb3J0ICcuL2VsZW1lbnRzL29ucy1zZWdtZW50JztcbmltcG9ydCAnLi9lbGVtZW50cy9vbnMtc2VsZWN0JztcbmltcG9ydCAnLi9lbGVtZW50cy9vbnMtc3BlZWQtZGlhbC1pdGVtJztcbmltcG9ydCAnLi9lbGVtZW50cy9vbnMtc3BlZWQtZGlhbCc7XG5pbXBvcnQgJy4vZWxlbWVudHMvb25zLXNwbGl0dGVyLWNvbnRlbnQnO1xuaW1wb3J0ICcuL2VsZW1lbnRzL29ucy1zcGxpdHRlci1tYXNrJztcbmltcG9ydCAnLi9lbGVtZW50cy9vbnMtc3BsaXR0ZXItc2lkZSc7XG5pbXBvcnQgJy4vZWxlbWVudHMvb25zLXNwbGl0dGVyJztcbmltcG9ydCAnLi9lbGVtZW50cy9vbnMtc3dpdGNoJztcbmltcG9ydCAnLi9lbGVtZW50cy9vbnMtdGFiJztcbmltcG9ydCAnLi9lbGVtZW50cy9vbnMtdGFiYmFyJztcbmltcG9ydCAnLi9lbGVtZW50cy9vbnMtdG9hc3QnO1xuaW1wb3J0ICcuL2VsZW1lbnRzL29ucy10b29sYmFyLWJ1dHRvbic7XG5pbXBvcnQgJy4vZWxlbWVudHMvb25zLXRvb2xiYXInO1xuXG5zZXR1cChvbnMpOyAvLyBTZXR1cCBpbml0aWFsIGxpc3RlbmVyc1xud2luZG93Ll9zdXBlclNlY3JldE9ucyA9IG9ucztcblxuZXhwb3J0IGRlZmF1bHQgb25zO1xuIl0sIm5hbWVzIjpbInByZWZpeCIsInN0eWxlcyIsIndpbmRvdyIsImdldENvbXB1dGVkU3R5bGUiLCJkb2N1bWVudCIsImRvY3VtZW50RWxlbWVudCIsIkFycmF5IiwicHJvdG90eXBlIiwic2xpY2UiLCJjYWxsIiwiam9pbiIsIm1hdGNoIiwiT0xpbmsiLCJuYW1lIiwidXRpbCIsImh5cGhlbmF0ZSIsInN0eWxlciIsImVsZW1lbnQiLCJzdHlsZSIsImtleXMiLCJmb3JFYWNoIiwia2V5Iiwid2FybiIsImNsZWFyIiwiY2xlYXJsaXN0Iiwic3BsaXQiLCJyZWR1Y2UiLCJyIiwicyIsImNvbmNhdCIsImkiLCJsZW5ndGgiLCJzb21lIiwiaW5kZXhPZiIsInB1c2giLCJnZXRBdHRyaWJ1dGUiLCJyZW1vdmVBdHRyaWJ1dGUiLCJOYXRpdmVIVE1MRWxlbWVudCIsIkhUTUxFbGVtZW50IiwiUGxhdGZvcm0iLCJfc2VsZWN0ZWRQbGF0Zm9ybSIsIl9pZ25vcmVQbGF0Zm9ybVNlbGVjdCIsInBsYXRmb3JtIiwidHJpbSIsInRvTG93ZXJDYXNlIiwiZm4iLCJyZXN1bHQiLCJyZWFkeVN0YXRlIiwiRXJyb3IiLCJjb3Jkb3ZhIiwicGhvbmVnYXAiLCJQaG9uZUdhcCIsInRlc3QiLCJuYXZpZ2F0b3IiLCJ1c2VyQWdlbnQiLCJpc0lQaG9uZSIsInNjcmVlbiIsIndpZHRoIiwiaGVpZ2h0IiwiZm9yY2VBY3R1YWxQbGF0Zm9ybSIsIl9nZXRTZWxlY3RlZFBsYXRmb3JtIiwiZGV2aWNlIiwicGFyc2VJbnQiLCJ2ZXJzaW9uIiwidmVyIiwicmVwbGFjZSIsInVhIiwiaXNJT1MiLCJzdGFuZGFsb25lIiwibHRlOSIsIndlYmtpdCIsIm1lc3NhZ2VIYW5kbGVycyIsImluZGV4ZWREQiIsImlzSU9TU2FmYXJpIiwiaXNXS1dlYlZpZXciLCJvcGVyYSIsIkluc3RhbGxUcmlnZ2VyIiwiT2JqZWN0IiwidG9TdHJpbmciLCJwIiwic2FmYXJpIiwicHVzaE5vdGlmaWNhdGlvbiIsImNocm9tZSIsImRvY3VtZW50TW9kZSIsImlzQW5kcm9pZCIsImlzV1AiLCJpc0lQYWQiLCJpc0lQb2QiLCJlcnJvciIsInRocm93IiwibWVzc2FnZSIsInBhZ2VBdHRyaWJ1dGVFeHByZXNzaW9uIiwidmFsdWUiLCJvdmVyd3JpdGUiLCJfdmFyaWFibGVzIiwiaGFzT3duUHJvcGVydHkiLCJwYXJ0IiwiYyIsImluSW50ZXJwb2xhdGlvbiIsImN1cnJlbnRJbmRleCIsInRva2VucyIsImNoYXJBdCIsInRva2VuIiwic3Vic3RyaW5nIiwicmUiLCJ2YXJpYWJsZSIsImdldFZhcmlhYmxlIiwicnYiLCJtYXAiLCJfcmVwbGFjZVRva2VuIiwiYmluZCIsImV4cHJlc3Npb24iLCJfcGFyc2VQYXJ0IiwiX3JlcGxhY2VUb2tlbnMiLCJfcGFyc2VFeHByZXNzaW9uIiwiZGVmaW5lVmFyaWFibGUiLCJnZXRNb2JpbGVPUyIsImdldElPU0RldmljZSIsImlzV2ViVmlldyIsImludGVybmFsIiwiY29uZmlnIiwibnVsbEVsZW1lbnQiLCJjcmVhdGVFbGVtZW50IiwiaXNFbmFibGVkQXV0b1N0YXR1c0JhckZpbGwiLCJhdXRvU3RhdHVzQmFyRmlsbCIsIm5vcm1hbGl6ZVBhZ2VIVE1MIiwiaHRtbCIsIndhaXRET01Db250ZW50TG9hZGVkIiwid3JhcHBlZENhbGxiYWNrIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImFkZEV2ZW50TGlzdGVuZXIiLCJjYWxsYmFjayIsIm9uUmVhZHkiLCJzaG91bGRGaWxsU3RhdHVzQmFyIiwiaXNJT1M3YWJvdmUiLCJpc0lQaG9uZVgiLCJib2R5IiwicXVlcnlTZWxlY3RvciIsInRlbXBsYXRlU3RvcmUiLCJfc3RvcmFnZSIsInRlbXBsYXRlIiwiZSIsInRhcmdldCIsIm5vZGVOYW1lIiwic2V0IiwidGVtcGxhdGVJZCIsInJlZ2lzdGVyIiwicXVlcnkiLCJ0ZW1wbGF0ZXMiLCJxdWVyeVNlbGVjdG9yQWxsIiwidGV4dENvbnRlbnQiLCJjb250ZW50IiwiZ2V0VGVtcGxhdGVIVE1MQXN5bmMiLCJwYWdlIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJjYWNoZSIsImdldCIsIkRvY3VtZW50RnJhZ21lbnQiLCJsb2NhbCIsImdldEVsZW1lbnRCeUlkIiwieGhyIiwiWE1MSHR0cFJlcXVlc3QiLCJvcGVuIiwib25sb2FkIiwicmVzcG9uc2VUZXh0Iiwic3RhdHVzIiwiZnJhZ21lbnQiLCJjcmVhdGVGcmFnbWVudCIsImFycmF5RnJvbSIsInNjcmlwdCIsInR5cGUiLCJlbCIsImFwcGVuZENoaWxkIiwiY3JlYXRlVGV4dE5vZGUiLCJ0ZXh0IiwiaW5uZXJIVE1MIiwicGFyZW50Tm9kZSIsInJlcGxhY2VDaGlsZCIsIm9uZXJyb3IiLCJzZW5kIiwiZ2V0UGFnZUhUTUxBc3luYyIsInBhZ2VzIiwiZXZhbHVhdGUiLCJnZXRQYWdlIiwiY2F0Y2giLCJzaGlmdCIsIkFuaW1hdG9yRmFjdG9yeSIsIm9wdHMiLCJfYW5pbWF0b3JzIiwiYW5pbWF0b3JzIiwiX2Jhc2VDbGFzcyIsImJhc2VDbGFzcyIsIl9iYXNlQ2xhc3NOYW1lIiwiYmFzZUNsYXNzTmFtZSIsIl9hbmltYXRpb24iLCJkZWZhdWx0QW5pbWF0aW9uIiwiX2FuaW1hdGlvbk9wdGlvbnMiLCJkZWZhdWx0QW5pbWF0aW9uT3B0aW9ucyIsIm9wdGlvbnMiLCJkZWZhdWx0QW5pbWF0b3IiLCJhbmltYXRvciIsImFuaW1hdGlvbiIsIkFuaW1hdG9yIiwiYW5pbWF0aW9uT3B0cyIsImV4dGVuZCIsImFuaW1hdGlvbk9wdGlvbnMiLCJhbmltYXRpb25zRGlzYWJsZWQiLCJkdXJhdGlvbiIsImRlbGF5IiwianNvblN0cmluZyIsImFuaW1hdGlvbk9wdGlvbnNQYXJzZSIsImF1dG9TdHlsZUVuYWJsZWQiLCJtb2RpZmllcnNNYXAiLCJwbGF0Zm9ybXMiLCJhbmRyb2lkIiwiZWxlbWVudE5hbWUiLCJ0YWdOYW1lIiwiaGFzTW9kaWZpZXIiLCJvbGRNb2RpZmllciIsIm5ld01vZGlmaWVyIiwidW5zaGlmdCIsInNldEF0dHJpYnV0ZSIsImVsZW1lbnRzIiwiaGFzQXR0cmlidXRlIiwiaW9zIiwicmVtb3ZlTW9kaWZpZXIiLCJhZGRNb2RpZmllciIsInVubG9ja2VkIiwiZ2V0UGxhdGZvcm0iLCJmb3JjZSIsIm1vYmlsZU9TIiwib25zUGxhdGZvcm0iLCJwcmVwYXJlIiwibWFwTW9kaWZpZXIiLCJtb2RpZmllciIsIm0iLCJyZXN0b3JlTW9kaWZpZXIiLCJNb2RpZmllclV0aWwiLCJsYXN0IiwiY3VycmVudCIsIm1ha2VEaWN0IiwicmVtb3ZlZCIsImFkZGVkIiwiZGljdCIsImRpZmYiLCJjbGFzc0xpc3QiLCJrbGFzcyIsImFkZCIsImsiLCJyZW1vdmUiLCJzY2hlbWUiLCJ0YXJnZXRFbGVtZW50cyIsInNlbGVjdG9yIiwiZmlsdGVyIiwiZmluZFBhcmVudCIsInRhcmdldEVsZW1lbnQiLCJwYXJlbnQiLCJhcHBseURpZmZUb0NsYXNzTGlzdCIsImFwcGx5RGlmZlRvRWxlbWVudCIsIm1vZGlmaWVyVG9rZW4iLCJpbmRleCIsInNwbGljZSIsIl9kb21Db250ZW50TG9hZGVkIiwiX3JlYWR5IiwiX29uRE9NQ29udGVudExvYWRlZCIsIkhhbmRsZXJSZXBvc2l0b3J5IiwiaGFuZGxlciIsImRhdGFzZXQiLCJkZXZpY2VCYWNrQnV0dG9uSGFuZGxlcklkIiwiaWQiLCJfZ2VuSWQiLCJfc3RvcmUiLCJ1bmRlZmluZWQiLCJEZXZpY2VCYWNrQnV0dG9uRGlzcGF0Y2hlciIsIl9pc0VuYWJsZWQiLCJfYm91bmRDYWxsYmFjayIsIl9jYWxsYmFjayIsImFkZEJhY2tCdXR0b25MaXN0ZW5lciIsInJlbW92ZUJhY2tCdXR0b25MaXN0ZW5lciIsImV2ZW50IiwiY3JlYXRlRXZlbnQiLCJpbml0RXZlbnQiLCJkaXNwYXRjaEV2ZW50IiwiX2Rpc3BhdGNoRGV2aWNlQmFja0J1dHRvbkV2ZW50IiwiRnVuY3Rpb24iLCJfZWxlbWVudCIsImVuYWJsZSIsInRyZWUiLCJfY2FwdHVyZVRyZWUiLCJfZmluZEhhbmRsZXJMZWFmRWxlbWVudCIsImNyZWF0ZVRyZWUiLCJhcHBseSIsImFycmF5T2YiLCJjaGlsZHJlbiIsImNoaWxkRWxlbWVudCIsImRpc3BsYXkiLCJfaXNTaG93biIsImhhcyIsInN1YlRyZWUiLCJmaW5kIiwibm9kZSIsImNoaWxkTm9kZSIsImxlZnQiLCJyaWdodCIsImxlZnRaIiwiekluZGV4IiwicmlnaHRaIiwiaXNOYU4iLCJkYmJEaXNwYXRjaGVyIiwiZGV2aWNlQmFja0J1dHRvbkRpc3BhdGNoZXIiLCJzdGFydHNXaXRoIiwic3Vic3RyIiwiZW5kc1dpdGgiLCJ1bndyYXAiLCJpc09iamVjdFN0cmluZyIsImlzQXJyYXlTdHJpbmciLCJpc1F1b3RlZFN0cmluZyIsInN0cmluZyIsIm9yaWdpbmFsU3RyaW5nIiwicHJvY2Vzc1Rva2VuIiwicGFyc2VPYmplY3QiLCJwYXJzZUFycmF5IiwibmV4dFRva2VuIiwibGltaXQiLCJjaGFyQ29kZUF0IiwibmVzdGVkT2JqZWN0IiwiaXNWYWxpZEtleSIsIm9iamVjdCIsInJlYWRpbmdLZXkiLCJwcmV2aW91c1Rva2VuIiwiYXJyYXkiLCJwYXJzZSIsImVycm9yUHJlZml4IiwiZ2xvYmFscyIsIl9ydW5PbkFjdHVhbFBsYXRmb3JtIiwiYWN0dWFsTW9iaWxlT1MiLCJpc1VJV2ViVmlldyIsImRlZmluZVByb3BlcnR5Iiwic3VwcG9ydHNQYXNzaXZlIiwib3B0IiwiaXNHRCIsImNhcHR1cmUiLCJwcmVwYXJlUXVlcnkiLCJtYXRjaGVzIiwid2Via2l0TWF0Y2hlc1NlbGVjdG9yIiwibW96TWF0Y2hlc1NlbGVjdG9yIiwibXNNYXRjaGVzU2VsZWN0b3IiLCJmaW5kQ2hpbGQiLCJjaGlsZE5vZGVzIiwibm9kZVR5cGUiLCJOb2RlIiwiRUxFTUVOVF9OT0RFIiwidW50aWwiLCJpc0F0dGFjaGVkIiwiY29udGFpbnMiLCJoYXNBbnlDb21wb25lbnRBc1BhcmVudCIsImdldEFsbENoaWxkTm9kZXMiLCJmcm9tIiwiY2hpbGRFbCIsImlzUGFnZUNvbnRyb2wiLCJwcm9wYWdhdGVBY3Rpb24iLCJhY3Rpb24iLCJjaGlsZCIsImNhbWVsaXplIiwibCIsInRvVXBwZXJDYXNlIiwiY3JlYXRlIiwiY2xhc3NOYW1lIiwid3JhcHBlciIsImltcG9ydE5vZGUiLCJkc3QiLCJhcmdzIiwiaiIsImFycmF5TGlrZSIsInBhcnNlSlNPTk9iamVjdFNhZmVseSIsImZhaWxTYWZlIiwiSlNPTiIsImZpbmRGcm9tUGF0aCIsInBhdGgiLCJnZXRUb3BQYWdlIiwiY29udGFpbmVyIiwidG9wUGFnZSIsImZpbmRUb29sYmFyUGFnZSIsIl9jYW5BbmltYXRlVG9vbGJhciIsIl9jb250ZW50RWxlbWVudCIsIm5leHRQYWdlIiwidHJpZ2dlckVsZW1lbnRFdmVudCIsImV2ZW50TmFtZSIsImRldGFpbCIsIkN1c3RvbUV2ZW50IiwibW9kaWZpZXJOYW1lIiwiUmVnRXhwIiwiYXV0b1N0eWxlIiwiZm9yY2VBdXRvU3R5bGUiLCJuZXdNb2RpZmllcnMiLCJ0b2dnbGVNb2RpZmllciIsInRvZ2dsZSIsInJlc3RvcmVDbGFzcyIsImRlZmF1bHRDbGFzcyIsInJlZnJlc2giLCJ1cGRhdGVQYXJlbnRQb3NpdGlvbiIsIl9wYXJlbnRVcGRhdGVkIiwicGFyZW50RWxlbWVudCIsImdldFByb3BlcnR5VmFsdWUiLCJwb3NpdGlvbiIsInRvZ2dsZUF0dHJpYnV0ZSIsImJpbmRMaXN0ZW5lcnMiLCJsaXN0ZW5lck5hbWVzIiwiYm91bmROYW1lIiwiZWFjaCIsIm9iaiIsImYiLCJ1cGRhdGVSaXBwbGUiLCJoYXNSaXBwbGUiLCJhdHRycyIsInJpcHBsZUVsZW1lbnQiLCJpbnNlcnRCZWZvcmUiLCJmaXJzdENoaWxkIiwiaXNJbnRlZ2VyIiwiaXNGaW5pdGUiLCJNYXRoIiwiZmxvb3IiLCJkZWZlciIsImRlZmVycmVkIiwicHJvbWlzZSIsIndhcm5pbmdzRGlzYWJsZWQiLCJ0aHJvd0Fic3RyYWN0IiwidGhyb3dNZW1iZXIiLCJ0aHJvd1BhZ2VMb2FkZXIiLCJ0aHJvd0FuaW1hdG9yIiwicHJldmVudCIsImNhbmNlbGFibGUiLCJwcmV2ZW50RGVmYXVsdCIsImlvc1ByZXZlbnRTY3JvbGwiLCJjbGVhbiIsIm9mZiIsIm9uIiwiaW9zUGFnZVNjcm9sbEZpeCIsImZvcmNlVUlXZWJWaWV3U2Nyb2xsRml4IiwiaW9zTWFza1Njcm9sbEZpeCIsImlzVmFsaWRHZXN0dXJlIiwiZ2VzdHVyZSIsImRpc3RhbmNlIiwiZGVsdGFUaW1lIiwiY2hlY2tNaXNzaW5nSW1wb3J0IiwiZWxlbWVudE5hbWVzIiwib25zRWxlbWVudHMiLCJUSU1FT1VUX1JBVElPIiwiY2FwaXRhbGl6ZSIsInN0ciIsImJ1aWxkVHJhbnNpdGlvblZhbHVlIiwicGFyYW1zIiwicHJvcGVydHkiLCJ0aW1pbmciLCJwcm9wcyIsInByb3AiLCJvbmNlT25UcmFuc2l0aW9uRW5kIiwic3RvcFByb3BhZ2F0aW9uIiwicmVtb3ZlTGlzdGVuZXJzIiwiX3RyYW5zaXRpb25FbmRFdmVudHMiLCJ2ZW5kb3JQcmVmaXgiLCJfY3NzUHJvcGVydHlEaWN0IiwiYSIsInoiLCJ1cHBlciIsImhhc0Nzc1Byb3BlcnR5IiwicHJlIiwiZm9yY2VMYXlvdXRBdE9uY2UiLCJiYXRjaEltbWVkaWF0ZSIsIm9mZnNldEhlaWdodCIsImNhbGxiYWNrcyIsImNvbmNyZWF0ZUNhbGxiYWNrcyIsImJhdGNoQW5pbWF0aW9uRnJhbWUiLCJyYWYiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJ3ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJtb3pSZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJvUmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwibXNSZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJ0cmFuc2l0aW9uUHJvcGVydHlOYW1lIiwiQW5pbWl0IiwiZGVmYXVsdHMiLCJ0cmFuc2l0aW9uUXVldWUiLCJsYXN0U3R5bGVBdHRyaWJ1dGVEaWN0IiwiZG9uZSIsInN0YXJ0QW5pbWF0aW9uIiwidG8iLCJzdGVwIiwiY3NzIiwic2F2ZVN0eWxlIiwicXVldWUiLCJ3YWl0IiwicmVzdG9yZVN0eWxlIiwidHJhbnNpdGlvbiIsIlRyYW5zaXRpb24iLCJidWlsZCIsInNlY29uZHMiLCJzZWxmIiwidHJhbnNpdGlvbk5hbWUiLCJ0cmFuc2l0aW9uVmFsdWUiLCJ0aW1lb3V0SWQiLCJjbGVhclRyYW5zaXRpb24iLCJzZXRUaW1lb3V0IiwibGVuIiwicmVzZXQiLCJfZGVxdWV1ZVRyYW5zaXRpb24iLCJfY3VycmVudFRyYW5zaXRpb24iLCJjYWxsZWQiLCJydW5BbGwiLCJhcmd1bWVudHMiLCJwbGF5IiwiY3JlYXRlQWN0dWFsQ3NzUHJvcHMiLCJ0aW1lb3V0IiwicHJlZml4ZWQiLCJFdmVudCIsIlV0aWxzIiwiRGV0ZWN0aW9uIiwiUG9pbnRlckV2ZW50IiwiR2VzdHVyZURldGVjdG9yIiwiSW5zdGFuY2UiLCJET0NVTUVOVCIsIkhBU19QT0lOVEVSRVZFTlRTIiwicG9pbnRlckVuYWJsZWQiLCJtc1BvaW50ZXJFbmFibGVkIiwiSEFTX1RPVUNIRVZFTlRTIiwiSVNfTU9CSUxFIiwiTk9fTU9VU0VFVkVOVFMiLCJDQUxDVUxBVEVfSU5URVJWQUwiLCJFVkVOVF9UWVBFUyIsIkRJUkVDVElPTl9ET1dOIiwiRElSRUNUSU9OX0xFRlQiLCJESVJFQ1RJT05fVVAiLCJESVJFQ1RJT05fUklHSFQiLCJQT0lOVEVSX01PVVNFIiwiUE9JTlRFUl9UT1VDSCIsIlBPSU5URVJfUEVOIiwiRVZFTlRfU1RBUlQiLCJFVkVOVF9NT1ZFIiwiRVZFTlRfRU5EIiwiRVZFTlRfUkVMRUFTRSIsIkVWRU5UX1RPVUNIIiwiUkVBRFkiLCJwbHVnaW5zIiwiZ2VzdHVyZXMiLCJzZXR1cCIsImRldGVybWluZUV2ZW50VHlwZXMiLCJvblRvdWNoIiwiZGV0ZWN0IiwidXRpbHMiLCJkZXN0Iiwic3JjIiwibWVyZ2UiLCJpdGVyYXRvciIsImNvbnRleHQiLCJpblN0ciIsImluQXJyYXkiLCJkZWVwIiwiZXZlcnkiLCJ0b0FycmF5IiwiaGFzUGFyZW50IiwiZ2V0Q2VudGVyIiwidG91Y2hlcyIsInBhZ2VYIiwicGFnZVkiLCJjbGllbnRYIiwiY2xpZW50WSIsIm1pbiIsIm1heCIsInRvdWNoIiwiZ2V0VmVsb2NpdHkiLCJkZWx0YVgiLCJkZWx0YVkiLCJhYnMiLCJnZXRBbmdsZSIsInRvdWNoMSIsInRvdWNoMiIsIngiLCJ5IiwiYXRhbjIiLCJQSSIsImdldERpcmVjdGlvbiIsImdldERpc3RhbmNlIiwic3FydCIsImdldFNjYWxlIiwic3RhcnQiLCJlbmQiLCJnZXRSb3RhdGlvbiIsImlzVmVydGljYWwiLCJkaXJlY3Rpb24iLCJzZXRQcmVmaXhlZENzcyIsInByZWZpeGVzIiwidG9DYW1lbENhc2UiLCJ0b2dnbGVCZWhhdmlvciIsImZhbHNlRm4iLCJ1c2VyU2VsZWN0Iiwib25zZWxlY3RzdGFydCIsInVzZXJEcmFnIiwib25kcmFnc3RhcnQiLCJob29rIiwidHlwZXMiLCJldmVudFR5cGUiLCJvblRvdWNoSGFuZGxlciIsImV2Iiwic3JjVHlwZSIsImlzUG9pbnRlciIsImlzTW91c2UiLCJ0cmlnZ2VyVHlwZSIsInByZXZlbnRNb3VzZUV2ZW50cyIsImJ1dHRvbiIsInNob3VsZERldGVjdCIsImJ1dHRvbnMiLCJtYXRjaFR5cGUiLCJ1cGRhdGVQb2ludGVyIiwiZG9EZXRlY3QiLCJ0b3VjaExpc3QiLCJnZXRUb3VjaExpc3QiLCJ0b3VjaExpc3RMZW5ndGgiLCJ0cmlnZ2VyQ2hhbmdlIiwidHJpZ2dlciIsImNoYW5nZWRMZW5ndGgiLCJjaGFuZ2VkVG91Y2hlcyIsInN0YXJ0ZWQiLCJldkRhdGEiLCJjb2xsZWN0RXZlbnREYXRhIiwiaWRlbnRpZmllcnMiLCJpZGVudGlmaWVyIiwicG9pbnRlclR5cGUiLCJEYXRlIiwibm93Iiwic3JjRXZlbnQiLCJwcmV2ZW50TWFuaXB1bGF0aW9uIiwic3RvcERldGVjdCIsInRvdWNobGlzdCIsInBvaW50ZXJzIiwicG9pbnRlciIsInBvaW50ZXJFdmVudCIsInBvaW50ZXJJZCIsInB0IiwiTVNQT0lOVEVSX1RZUEVfTU9VU0UiLCJNU1BPSU5URVJfVFlQRV9UT1VDSCIsIk1TUE9JTlRFUl9UWVBFX1BFTiIsInJlc2V0TGlzdCIsImRldGVjdGlvbiIsInN0YXJ0RGV0ZWN0IiwiaW5zdCIsImV2ZW50RGF0YSIsInN0b3BwZWQiLCJleHRlbmRFdmVudERhdGEiLCJpbnN0T3B0aW9ucyIsInRyaWdnZXJHZXN0dXJlIiwiZW5hYmxlZCIsImxhc3RFdmVudCIsInByZXZpb3VzIiwiZ2V0Q2FsY3VsYXRlZERhdGEiLCJjZW50ZXIiLCJjdXIiLCJyZWNhbGMiLCJjYWxjRXYiLCJsYXN0Q2FsY0V2ZW50IiwiY2FsY0RhdGEiLCJsYXN0Q2FsY0RhdGEiLCJ0aW1lU3RhbXAiLCJmdXR1cmVDYWxjRXZlbnQiLCJ2ZWxvY2l0eSIsImFuZ2xlIiwidmVsb2NpdHlYIiwidmVsb2NpdHlZIiwiaW50ZXJpbUFuZ2xlIiwiaW50ZXJpbURpcmVjdGlvbiIsInN0YXJ0RXYiLCJzdGFydEV2ZW50IiwibGFzdEV2Iiwic29ydCIsImIiLCJsaXN0ZW5lck9wdGlvbnMiLCJwYXNzaXZlIiwiYmVoYXZpb3IiLCJldmVudFN0YXJ0SGFuZGxlciIsImV2ZW50SGFuZGxlcnMiLCJvbkV2ZW50Iiwib2ZmRXZlbnQiLCJ0cmlnZ2VyRXZlbnQiLCJzdGF0ZSIsImRpc3Bvc2UiLCJlaCIsInRyaWdnZXJlZCIsImRyYWdHZXN0dXJlIiwiZHJhZ01heFRvdWNoZXMiLCJkcmFnTWluRGlzdGFuY2UiLCJzdGFydENlbnRlciIsImRyYWdEaXN0YW5jZUNvcnJlY3Rpb24iLCJmYWN0b3IiLCJkcmFnTG9ja1RvQXhpcyIsImRyYWdMb2NrTWluRGlzdGFuY2UiLCJsYXN0RGlyZWN0aW9uIiwiZHJhZ0Jsb2NrVmVydGljYWwiLCJkcmFnQmxvY2tIb3Jpem9udGFsIiwiRHJhZyIsIkdlc3R1cmUiLCJyZWxlYXNlR2VzdHVyZSIsInRpbWVyIiwiaG9sZEdlc3R1cmUiLCJob2xkVGltZW91dCIsImhvbGRUaHJlc2hvbGQiLCJIb2xkIiwiUmVsZWFzZSIsIkluZmluaXR5IiwiU3dpcGUiLCJzd2lwZUdlc3R1cmUiLCJzd2lwZU1pblRvdWNoZXMiLCJzd2lwZU1heFRvdWNoZXMiLCJzd2lwZVZlbG9jaXR5WCIsInN3aXBlVmVsb2NpdHlZIiwiaGFzTW92ZWQiLCJ0YXBHZXN0dXJlIiwicHJldiIsInNpbmNlUHJldiIsImRpZERvdWJsZVRhcCIsInRhcE1heERpc3RhbmNlIiwidGFwTWF4VGltZSIsImRvdWJsZVRhcEludGVydmFsIiwiZG91YmxlVGFwRGlzdGFuY2UiLCJ0YXBBbHdheXMiLCJUYXAiLCJUb3VjaCIsInRvdWNoR2VzdHVyZSIsInByZXZlbnRNb3VzZSIsInRyYW5zZm9ybUdlc3R1cmUiLCJzY2FsZVRocmVzaG9sZCIsInNjYWxlIiwicm90YXRpb25UaHJlc2hvbGQiLCJyb3RhdGlvbiIsInRyYW5zZm9ybU1pblNjYWxlIiwidHJhbnNmb3JtTWluUm90YXRpb24iLCJUcmFuc2Zvcm0iLCJyZWFkeU1hcCIsInF1ZXVlTWFwIiwiaXNDb250ZW50UmVhZHkiLCJzZXRDb250ZW50UmVhZHkiLCJhZGRDYWxsYmFjayIsImNvbnN1bWVRdWV1ZSIsImRlbGV0ZSIsImNvbnRlbnRSZWFkeSIsIldlYWtNYXAiLCJvYnNlcnZlciIsIk11dGF0aW9uT2JzZXJ2ZXIiLCJvYnNlcnZlIiwiY2hpbGRMaXN0IiwiY2hhcmFjdGVyRGF0YSIsIlRvYXN0UXVldWUiLCJ0aGVuIiwiX3NldEF0dHJpYnV0ZXMiLCJfbm9ybWFsaXplQXJndW1lbnRzIiwibWVzc2FnZUhUTUwiLCJidXR0b25MYWJlbHMiLCJidXR0b25MYWJlbCIsImlzQXJyYXkiLCJwYXJhbSIsIm5vdGlmaWNhdGlvbiIsIl9jcmVhdGVBbGVydERpYWxvZyIsImlucHV0U3RyaW5nIiwiaXNQcm9tcHQiLCJpbnB1dFR5cGUiLCJwbGFjZWhvbGRlciIsImRlZmF1bHRWYWx1ZSIsImxhYmVsIiwicHJpbWFyeUJ1dHRvbkluZGV4IiwiX2Rlc3Ryb3lEaWFsb2ciLCJkaWFsb2ciLCJvbkRpYWxvZ0NhbmNlbCIsImRlc3Ryb3kiLCJtYXNrQ29sb3IiLCJ0aXRsZSIsInN1Ym1pdE9uRW50ZXIiLCJpbnB1dCIsIm9ua2V5cHJlc3MiLCJrZXlDb2RlIiwiaGlkZSIsInJlc29sdmVWYWx1ZSIsImZvb3RlciIsImJ1dHRvbkVsZW1lbnQiLCJvbmNsaWNrIiwiY29tcGlsZSIsInNob3ciLCJhdXRvZm9jdXMiLCJzdHJMZW5ndGgiLCJmb2N1cyIsInNldFNlbGVjdGlvblJhbmdlIiwiYWxlcnQiLCJjb25maXJtIiwicHJvbXB0IiwidG9hc3QiLCJmaW5pc2giLCJfdG9hc3QiLCJjaGVja09wdGlvbnMiLCJlcnIiLCJpbnN0YW5jZU9mIiwiY2IiLCJkIiwiYWN0aW9uU2hlZXQiLCJjbGFzcyIsImNyZWF0ZURvY3VtZW50RnJhZ21lbnQiLCJpdGVtIiwiYnV0dG9uT3B0aW9ucyIsImRlc3RydWN0aXZlIiwiaWNvbiIsIk1pY3JvRXZlbnQiLCJmY3QiLCJfZXZlbnRzIiwiX2ZjdCIsIm1peGluIiwiZGVzdE9iamVjdCIsIl9pc1BvcnRyYWl0IiwiaXNQb3J0cmFpdCIsIl9vbk9yaWVudGF0aW9uQ2hhbmdlIiwiX29uUmVzaXplIiwiaW5uZXJIZWlnaHQiLCJpbm5lcldpZHRoIiwiX2luc3RhbGxJc1BvcnRyYWl0SW1wbGVtZW50YXRpb24iLCJlbWl0Iiwib3JpZW50YXRpb24iLCJuSXRlciIsImludGVydmFsIiwic2V0SW50ZXJ2YWwiLCJ3IiwiaCIsIl9pbml0IiwibW9kaWZpZXJzIiwic29mdHdhcmVLZXlib2FyZCIsIl92aXNpYmxlIiwib25TaG93Iiwib25IaWRlIiwiYmluZEV2ZW50cyIsIktleWJvYXJkIiwib25zaG93Iiwib25oaWRlIiwidmlzaWJsZSIsImlzVmlzaWJsZSIsIm5vUGx1Z2luRXJyb3IiLCJnZW5lcmF0ZUlkIiwiRG9vckxvY2siLCJfbG9ja0xpc3QiLCJfd2FpdExpc3QiLCJfbG9nIiwibG9nIiwidW5sb2NrIiwiX3VubG9jayIsIl90cnlUb0ZyZWVXYWl0TGlzdCIsImlzTG9ja2VkIiwibG9hZFBhZ2UiLCJwYWdlRWxlbWVudCIsInVubG9hZFBhZ2UiLCJfZGVzdHJveSIsIlBhZ2VMb2FkZXIiLCJsb2FkZXIiLCJ1bmxvYWRlciIsIl9sb2FkZXIiLCJfdW5sb2FkZXIiLCJFbGVtZW50IiwiZGVmYXVsdFBhZ2VMb2FkZXIiLCJpbnN0YW50UGFnZUxvYWRlciIsIm9ucyIsInNlbGVjdCIsImxvY2F0aW9uIiwic2VhcmNoIiwid2FpdERldmljZVJlYWR5IiwicmVhZHlFcnJvciIsImFmdGVyIiwiaXNSZWFkeSIsIl9yZWFkeUxvY2siLCJyZWFkeSIsIndhaXRVbmxvY2siLCJzZXREZWZhdWx0RGV2aWNlQmFja0J1dHRvbkxpc3RlbmVyIiwibGlzdGVuZXIiLCJfZGVmYXVsdERldmljZUJhY2tCdXR0b25IYW5kbGVyIiwic2V0TGlzdGVuZXIiLCJkaXNhYmxlRGV2aWNlQmFja0J1dHRvbkhhbmRsZXIiLCJkaXNhYmxlIiwiZW5hYmxlRGV2aWNlQmFja0J1dHRvbkhhbmRsZXIiLCJmaXJlRGV2aWNlQmFja0J1dHRvbkV2ZW50IiwiZW5hYmxlQXV0b1N0YXR1c0JhckZpbGwiLCJkaXNhYmxlQXV0b1N0YXR1c0JhckZpbGwiLCJtb2NrU3RhdHVzQmFyIiwibW9jayIsImRpc2FibGVBbmltYXRpb25zIiwiZW5hYmxlQW5pbWF0aW9ucyIsIl9kaXNhYmxlV2FybmluZ3MiLCJfZW5hYmxlV2FybmluZ3MiLCJkaXNhYmxlQXV0b1N0eWxpbmciLCJlbmFibGVBdXRvU3R5bGluZyIsImRpc2FibGVJY29uQXV0b1ByZWZpeCIsIkljb24iLCJzZXRBdXRvUHJlZml4IiwiZm9yY2VQbGF0Zm9ybVN0eWxpbmciLCJuZXdQbGF0Zm9ybSIsIl91dGlsIiwiX3BsYXRmb3JtVXBkYXRlIiwiX3VwZGF0ZVBvc2l0aW9uIiwicHJlbG9hZCIsImFsbCIsImFwcGVuZCIsImxpbmsiLCJjcmVhdGVQb3BvdmVyIiwiY3JlYXRlRGlhbG9nIiwiY3JlYXRlQWxlcnREaWFsb2ciLCJvcGVuQWN0aW9uU2hlZXQiLCJyZXNvbHZlTG9hZGluZ1BsYWNlaG9sZGVyIiwiX3Jlc29sdmVMb2FkaW5nUGxhY2Vob2xkZXIiLCJfc2V0dXBMb2FkaW5nUGxhY2VIb2xkZXJzIiwicmVtb3ZlQ2hpbGQiLCJ1bmxvY2tEZXZpY2VSZWFkeSIsImxvY2siLCJnZXRDUyIsImN1cnJlbnRTY3JpcHQiLCJzY3JpcHRzIiwiZ2V0U2NyaXB0UGFnZSIsIkZhc3RDbGljayIsImxheWVyIiwib2xkT25DbGljayIsInRyYWNraW5nQ2xpY2siLCJ0cmFja2luZ0NsaWNrU3RhcnQiLCJ0b3VjaFN0YXJ0WCIsInRvdWNoU3RhcnRZIiwibGFzdFRvdWNoSWRlbnRpZmllciIsInRvdWNoQm91bmRhcnkiLCJ0YXBEZWxheSIsInRhcFRpbWVvdXQiLCJub3ROZWVkZWQiLCJtZXRob2QiLCJtZXRob2RzIiwiZGV2aWNlSXNBbmRyb2lkIiwib25Nb3VzZSIsIm9uQ2xpY2siLCJvblRvdWNoU3RhcnQiLCJvblRvdWNoTW92ZSIsIm9uVG91Y2hFbmQiLCJvblRvdWNoQ2FuY2VsIiwic3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uIiwicm12IiwiaGlqYWNrZWQiLCJhZHYiLCJwcm9wYWdhdGlvblN0b3BwZWQiLCJkZXZpY2VJc1dpbmRvd3NQaG9uZSIsImRldmljZUlzSU9TIiwiZGV2aWNlSXNJT1M0IiwiZGV2aWNlSXNJT1NXaXRoQmFkVGFyZ2V0IiwiZGV2aWNlSXNCbGFja0JlcnJ5MTAiLCJ0ZXh0RmllbGRzIiwibmVlZHNDbGljayIsImRpc2FibGVkIiwibmVlZHNGb2N1cyIsInJlYWRPbmx5Iiwic2VuZENsaWNrIiwiY2xpY2tFdmVudCIsImFjdGl2ZUVsZW1lbnQiLCJibHVyIiwiaW5pdE1vdXNlRXZlbnQiLCJkZXRlcm1pbmVFdmVudFR5cGUiLCJzY3JlZW5YIiwic2NyZWVuWSIsImZvcndhcmRlZFRvdWNoRXZlbnQiLCJ1cGRhdGVTY3JvbGxQYXJlbnQiLCJzY3JvbGxQYXJlbnQiLCJmYXN0Q2xpY2tTY3JvbGxQYXJlbnQiLCJzY3JvbGxIZWlnaHQiLCJmYXN0Q2xpY2tMYXN0U2Nyb2xsVG9wIiwic2Nyb2xsVG9wIiwiZ2V0VGFyZ2V0RWxlbWVudEZyb21FdmVudFRhcmdldCIsImV2ZW50VGFyZ2V0IiwiVEVYVF9OT0RFIiwiaXNUZXh0RmllbGQiLCJ0YXJnZXRUb3VjaGVzIiwiaXNDb250ZW50RWRpdGFibGUiLCJsYXN0Q2xpY2tUaW1lIiwidG91Y2hIYXNNb3ZlZCIsImJvdW5kYXJ5IiwiZmluZENvbnRyb2wiLCJsYWJlbEVsZW1lbnQiLCJjb250cm9sIiwiaHRtbEZvciIsImZvckVsZW1lbnQiLCJ0YXJnZXRUYWdOYW1lIiwiY2FuY2VsTmV4dENsaWNrIiwiZWxlbWVudEZyb21Qb2ludCIsInBhZ2VYT2Zmc2V0IiwicGFnZVlPZmZzZXQiLCJ0b3AiLCJwZXJtaXR0ZWQiLCJtZXRhVmlld3BvcnQiLCJjaHJvbWVWZXJzaW9uIiwiYmxhY2tiZXJyeVZlcnNpb24iLCJmaXJlZm94VmVyc2lvbiIsIm9udG91Y2hzdGFydCIsImV4ZWMiLCJzY3JvbGxXaWR0aCIsIm91dGVyV2lkdGgiLCJtc1RvdWNoQWN0aW9uIiwidG91Y2hBY3Rpb24iLCJhdHRhY2giLCJkZWZpbmUiLCJiYWJlbEhlbHBlcnMudHlwZW9mIiwiYW1kIiwibW9kdWxlIiwiZXhwb3J0cyIsImN1c3RvbUVsZW1lbnRzIiwiZm9yY2VQb2x5ZmlsbCIsImdsb2JhbCIsIl9fZyIsImNvcmUiLCJfX2UiLCJpdCIsImlzT2JqZWN0IiwiVHlwZUVycm9yIiwicmVxdWlyZSQkMCIsImlzIiwicmVxdWlyZSQkMSIsInJlcXVpcmUkJDIiLCJTIiwidmFsIiwidmFsdWVPZiIsImRQIiwiTyIsIlAiLCJBdHRyaWJ1dGVzIiwidG9QcmltaXRpdmUiLCJJRThfRE9NX0RFRklORSIsImJpdG1hcCIsImNyZWF0ZURlc2MiLCJweCIsInJhbmRvbSIsIlNIQVJFRCIsInN0b3JlIiwiU1JDIiwiVE9fU1RSSU5HIiwiVFBMIiwiJHRvU3RyaW5nIiwiaW5zcGVjdFNvdXJjZSIsInNhZmUiLCJpc0Z1bmN0aW9uIiwiU3RyaW5nIiwidGhhdCIsIlBST1RPVFlQRSIsIiRleHBvcnQiLCJzb3VyY2UiLCJJU19GT1JDRUQiLCJGIiwiSVNfR0xPQkFMIiwiRyIsIklTX1NUQVRJQyIsIklTX1BST1RPIiwiSVNfQklORCIsIkIiLCJleHBQcm90byIsIm93biIsIm91dCIsImV4cCIsImN0eCIsInJlZGVmaW5lIiwiVSIsIlciLCJSIiwicHJvcGVydHlJc0VudW1lcmFibGUiLCJjb2YiLCJJT2JqZWN0IiwiZGVmaW5lZCIsImdPUEQiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJ0b0lPYmplY3QiLCJwSUUiLCJjaGVjayIsInByb3RvIiwic2V0UHJvdG90eXBlT2YiLCJidWdneSIsIl9fcHJvdG9fXyIsIlN5bWJvbCIsIlVTRV9TWU1CT0wiLCIkZXhwb3J0cyIsInVpZCIsIlRBRyIsIkFSRyIsInRyeUdldCIsIlQiLCJjYWxsZWUiLCJjbGFzc29mIiwiY2VpbCIsInBvcyIsInRvSW50ZWdlciIsIklTX0lOQ0xVREVTIiwiJHRoaXMiLCJmcm9tSW5kZXgiLCJ0b0xlbmd0aCIsInRvQWJzb2x1dGVJbmRleCIsInNoYXJlZCIsImFycmF5SW5kZXhPZiIsIklFX1BST1RPIiwibmFtZXMiLCIka2V5cyIsImVudW1CdWdLZXlzIiwiZGVmaW5lUHJvcGVydGllcyIsIlByb3BlcnRpZXMiLCJnZXRLZXlzIiwiRW1wdHkiLCJjcmVhdGVEaWN0IiwiaWZyYW1lIiwibHQiLCJndCIsImlmcmFtZURvY3VtZW50IiwiY29udGVudFdpbmRvdyIsIndyaXRlIiwiY2xvc2UiLCJhbk9iamVjdCIsImRQcyIsImRlZiIsInRhZyIsInN0YXQiLCJjb25maWd1cmFibGUiLCJJdGVyYXRvclByb3RvdHlwZSIsIkNvbnN0cnVjdG9yIiwiTkFNRSIsIm5leHQiLCJkZXNjcmlwdG9yIiwiT2JqZWN0UHJvdG8iLCJnZXRQcm90b3R5cGVPZiIsInRvT2JqZWN0IiwiY29uc3RydWN0b3IiLCJJVEVSQVRPUiIsIkJVR0dZIiwiRkZfSVRFUkFUT1IiLCJLRVlTIiwiVkFMVUVTIiwicmV0dXJuVGhpcyIsIkJhc2UiLCJERUZBVUxUIiwiSVNfU0VUIiwiRk9SQ0VEIiwiZ2V0TWV0aG9kIiwia2luZCIsInZhbHVlcyIsImVudHJpZXMiLCJERUZfVkFMVUVTIiwiVkFMVUVTX0JVRyIsIiRuYXRpdmUiLCIkZGVmYXVsdCIsIiRlbnRyaWVzIiwiJGFueU5hdGl2ZSIsIkxJQlJBUlkiLCIkYXQiLCJpdGVyYXRlZCIsIl90IiwiX2kiLCJwb2ludCIsIlVOU0NPUEFCTEVTIiwiQXJyYXlQcm90byIsIl9rIiwiSXRlcmF0b3JzIiwiQXJndW1lbnRzIiwiYWRkVG9VbnNjb3BhYmxlcyIsIndrcyIsIlRPX1NUUklOR19UQUciLCJBcnJheVZhbHVlcyIsIkRPTUl0ZXJhYmxlcyIsImNvbGxlY3Rpb25zIiwiZXhwbGljaXQiLCJDb2xsZWN0aW9uIiwiJGl0ZXJhdG9ycyIsImZvcmJpZGRlbkZpZWxkIiwicmV0IiwiZ2V0SXRlcmF0b3JNZXRob2QiLCJCUkVBSyIsIlJFVFVSTiIsIml0ZXJhYmxlIiwiaXRlckZuIiwiZ2V0SXRlckZuIiwiaXNBcnJheUl0ZXIiLCJTUEVDSUVTIiwiS0VZIiwiQyIsIkRFU0NSSVBUT1JTIiwiTUVUQSIsInNldERlc2MiLCJpc0V4dGVuc2libGUiLCJGUkVFWkUiLCJwcmV2ZW50RXh0ZW5zaW9ucyIsInNldE1ldGEiLCJmYXN0S2V5IiwiZ2V0V2VhayIsIm9uRnJlZXplIiwibWV0YSIsIk5FRUQiLCJUWVBFIiwiU0laRSIsImdldEVudHJ5IiwiZW50cnkiLCJfZiIsIm4iLCJJU19NQVAiLCJBRERFUiIsIl9sIiwiZm9yT2YiLCJ2YWxpZGF0ZSIsImRhdGEiLCJjYWxsYmFja2ZuIiwidiIsIlNBRkVfQ0xPU0lORyIsInJpdGVyIiwic2tpcENsb3NpbmciLCJhcnIiLCJpdGVyIiwiY29tbW9uIiwiSVNfV0VBSyIsImZpeE1ldGhvZCIsImZhaWxzIiwiZ2V0Q29uc3RydWN0b3IiLCJpbnN0YW5jZSIsIkhBU05UX0NIQUlOSU5HIiwiVEhST1dTX09OX1BSSU1JVElWRVMiLCJBQ0NFUFRfSVRFUkFCTEVTIiwiJGl0ZXJEZXRlY3QiLCJCVUdHWV9aRVJPIiwiJGluc3RhbmNlIiwiaW5oZXJpdElmUmVxdWlyZWQiLCJzZXRTdHJvbmciLCJTRVQiLCJTZXQiLCJzdHJvbmciLCJ0b0pTT04iLCJDT0xMRUNUSU9OIiwib2YiLCJBIiwibWFwRm4iLCJtYXBwaW5nIiwiYUZ1bmN0aW9uIiwibmV4dEl0ZW0iLCJyZXF1aXJlJCQ3IiwiTUFQIiwiTWFwIiwiYXJnIiwib3JpZ2luYWwiLCJzcGVjaWVzQ29uc3RydWN0b3IiLCIkY3JlYXRlIiwiSVNfRklMVEVSIiwiSVNfU09NRSIsIklTX0VWRVJZIiwiSVNfRklORF9JTkRFWCIsIk5PX0hPTEVTIiwiYXNjIiwicmVzIiwiZ2V0T3duUHJvcGVydHlTeW1ib2xzIiwiJGFzc2lnbiIsImFzc2lnbiIsIksiLCJhTGVuIiwiZ2V0U3ltYm9scyIsImdPUFMiLCJpc0VudW0iLCJhcnJheUZpbmQiLCJjcmVhdGVBcnJheU1ldGhvZCIsImFycmF5RmluZEluZGV4IiwidW5jYXVnaHRGcm96ZW5TdG9yZSIsIlVuY2F1Z2h0RnJvemVuU3RvcmUiLCJmaW5kVW5jYXVnaHRGcm96ZW4iLCIkaGFzIiwiTkFUSVZFX1dFQUtfTUFQIiwiSVNfSUUxMSIsIkFjdGl2ZVhPYmplY3QiLCJXRUFLX01BUCIsIndlYWsiLCJ1ZnN0b3JlIiwiSW50ZXJuYWxNYXAiLCIkV2Vha01hcCIsInJlcXVpcmUkJDUiLCIkZGVmaW5lUHJvcGVydHkiLCJtYXBmbiIsInJlc2VydmVkVGFnTGlzdCIsImlzVmFsaWRDdXN0b21FbGVtZW50TmFtZSIsImxvY2FsTmFtZSIsInJlc2VydmVkIiwidmFsaWRGb3JtIiwiaXNDb25uZWN0ZWQiLCJuYXRpdmVWYWx1ZSIsIl9fQ0VfaXNJbXBvcnREb2N1bWVudCIsIkRvY3VtZW50IiwiU2hhZG93Um9vdCIsImhvc3QiLCJuZXh0U2libGluZ09yQW5jZXN0b3JTaWJsaW5nIiwicm9vdCIsIm5leHRTaWJsaW5nIiwibmV4dE5vZGUiLCJ3YWxrRGVlcERlc2NlbmRhbnRFbGVtZW50cyIsInZpc2l0ZWRJbXBvcnRzIiwiaW1wb3J0Iiwic2hhZG93Um9vdCIsIl9fQ0Vfc2hhZG93Um9vdCIsInNldFByb3BlcnR5VW5jaGVja2VkIiwiZGVzdGluYXRpb24iLCJDdXN0b21FbGVtZW50U3RhdGUiLCJDdXN0b21FbGVtZW50SW50ZXJuYWxzIiwiX2xvY2FsTmFtZVRvRGVmaW5pdGlvbiIsIl9jb25zdHJ1Y3RvclRvRGVmaW5pdGlvbiIsIl9wYXRjaGVzIiwiX2hhc1BhdGNoZXMiLCJkZWZpbml0aW9uIiwicGF0Y2giLCJfX0NFX3BhdGNoZWQiLCJfX0NFX3N0YXRlIiwiQ0VTdGF0ZSIsImN1c3RvbSIsIlV0aWxpdGllcyIsImNvbm5lY3RlZENhbGxiYWNrIiwidXBncmFkZUVsZW1lbnQiLCJkaXNjb25uZWN0ZWRDYWxsYmFjayIsImdhdGhlckVsZW1lbnRzIiwiX19DRV9oYXNSZWdpc3RyeSIsIl9fQ0VfZG9jdW1lbnRMb2FkSGFuZGxlZCIsInBhdGNoQW5kVXBncmFkZVRyZWUiLCJjdXJyZW50U3RhdGUiLCJsb2NhbE5hbWVUb0RlZmluaXRpb24iLCJjb25zdHJ1Y3Rpb25TdGFjayIsInBvcCIsImZhaWxlZCIsIl9fQ0VfZGVmaW5pdGlvbiIsImF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayIsIm9ic2VydmVkQXR0cmlidXRlcyIsIl9fQ0VfaXNDb25uZWN0ZWRDYWxsYmFja0NhbGxlZCIsIm9sZFZhbHVlIiwibmV3VmFsdWUiLCJuYW1lc3BhY2UiLCJEb2N1bWVudENvbnN0cnVjdGlvbk9ic2VydmVyIiwiaW50ZXJuYWxzIiwiZG9jIiwiX2ludGVybmFscyIsIl9kb2N1bWVudCIsIl9vYnNlcnZlciIsIl9oYW5kbGVNdXRhdGlvbnMiLCJkaXNjb25uZWN0IiwibXV0YXRpb25zIiwiYWRkZWROb2RlcyIsIkRlZmVycmVkIiwiX3ZhbHVlIiwiX3Jlc29sdmUiLCJfcHJvbWlzZSIsIkN1c3RvbUVsZW1lbnRSZWdpc3RyeSIsIl9lbGVtZW50RGVmaW5pdGlvbklzUnVubmluZyIsIl93aGVuRGVmaW5lZERlZmVycmVkIiwiX2ZsdXNoQ2FsbGJhY2siLCJfZmx1c2hQZW5kaW5nIiwiX3VuZmx1c2hlZExvY2FsTmFtZXMiLCJfZG9jdW1lbnRDb25zdHJ1Y3Rpb25PYnNlcnZlciIsIlN5bnRheEVycm9yIiwiYWRvcHRlZENhbGxiYWNrIiwiZ2V0Q2FsbGJhY2siLCJjYWxsYmFja1ZhbHVlIiwic2V0RGVmaW5pdGlvbiIsIl9mbHVzaCIsInByaW9yIiwidG9Qcm9taXNlIiwib3V0ZXIiLCJpbm5lciIsImZsdXNoIiwid2hlbkRlZmluZWQiLCJwb2x5ZmlsbFdyYXBGbHVzaENhbGxiYWNrIiwiY3JlYXRlRWxlbWVudE5TIiwiY2xvbmVOb2RlIiwiZ2V0QXR0cmlidXRlTlMiLCJzZXRBdHRyaWJ1dGVOUyIsInJlbW92ZUF0dHJpYnV0ZU5TIiwiQWxyZWFkeUNvbnN0cnVjdGVkTWFya2VyIiwiY29uc3RydWN0b3JUb0RlZmluaXRpb24iLCJOYXRpdmUiLCJEb2N1bWVudF9jcmVhdGVFbGVtZW50IiwibGFzdEluZGV4IiwiYnVpbHRJbiIsIm5vZGVzIiwiY29ubmVjdGVkQmVmb3JlIiwicHJlcGVuZCIsImRpc2Nvbm5lY3RUcmVlIiwiY29ubmVjdFRyZWUiLCJjbG9uZSIsIkRvY3VtZW50X2ltcG9ydE5vZGUiLCJwYXRjaFRyZWUiLCJOU19IVE1MIiwiRG9jdW1lbnRfY3JlYXRlRWxlbWVudE5TIiwiRG9jdW1lbnRfcHJlcGVuZCIsIkRvY3VtZW50X2FwcGVuZCIsInJlZk5vZGUiLCJpbnNlcnRlZE5vZGVzIiwibmF0aXZlUmVzdWx0IiwiTm9kZV9pbnNlcnRCZWZvcmUiLCJub2RlV2FzQ29ubmVjdGVkIiwiTm9kZV9hcHBlbmRDaGlsZCIsIk5vZGVfY2xvbmVOb2RlIiwib3duZXJEb2N1bWVudCIsIk5vZGVfcmVtb3ZlQ2hpbGQiLCJub2RlVG9JbnNlcnQiLCJub2RlVG9SZW1vdmUiLCJOb2RlX3JlcGxhY2VDaGlsZCIsIm5vZGVUb0luc2VydFdhc0Nvbm5lY3RlZCIsInRoaXNJc0Nvbm5lY3RlZCIsInBhdGNoX3RleHRDb250ZW50IiwiYmFzZURlc2NyaXB0b3IiLCJlbnVtZXJhYmxlIiwiYXNzaWduZWRWYWx1ZSIsInJlbW92ZWROb2RlcyIsImNoaWxkTm9kZXNMZW5ndGgiLCJOb2RlX3RleHRDb250ZW50IiwiYWRkUGF0Y2giLCJwYXJ0cyIsImJlZm9yZSIsIndhc0Nvbm5lY3RlZCIsInJlcGxhY2VXaXRoIiwiRWxlbWVudF9hdHRhY2hTaGFkb3ciLCJpbml0IiwicGF0Y2hfaW5uZXJIVE1MIiwiaHRtbFN0cmluZyIsInJlbW92ZWRFbGVtZW50cyIsIkVsZW1lbnRfaW5uZXJIVE1MIiwiSFRNTEVsZW1lbnRfaW5uZXJIVE1MIiwicmF3RGl2IiwiRWxlbWVudF9zZXRBdHRyaWJ1dGUiLCJFbGVtZW50X2dldEF0dHJpYnV0ZSIsIkVsZW1lbnRfc2V0QXR0cmlidXRlTlMiLCJFbGVtZW50X2dldEF0dHJpYnV0ZU5TIiwiRWxlbWVudF9yZW1vdmVBdHRyaWJ1dGUiLCJFbGVtZW50X3JlbW92ZUF0dHJpYnV0ZU5TIiwicGF0Y2hfaW5zZXJ0QWRqYWNlbnRFbGVtZW50IiwiYmFzZU1ldGhvZCIsIndoZXJlIiwiaW5zZXJ0ZWRFbGVtZW50IiwiSFRNTEVsZW1lbnRfaW5zZXJ0QWRqYWNlbnRFbGVtZW50IiwiRWxlbWVudF9pbnNlcnRBZGphY2VudEVsZW1lbnQiLCJFbGVtZW50X3ByZXBlbmQiLCJFbGVtZW50X2FwcGVuZCIsIkVsZW1lbnRfYmVmb3JlIiwiRWxlbWVudF9hZnRlciIsIkVsZW1lbnRfcmVwbGFjZVdpdGgiLCJFbGVtZW50X3JlbW92ZSIsInByaW9yQ3VzdG9tRWxlbWVudHMiLCJKc011dGF0aW9uT2JzZXJ2ZXIiLCJyZWdpc3RyYXRpb25zVGFibGUiLCJzZXRJbW1lZGlhdGUiLCJzZXRJbW1lZGlhdGVRdWV1ZSIsInNlbnRpbmVsIiwiZnVuYyIsInBvc3RNZXNzYWdlIiwiaXNTY2hlZHVsZWQiLCJzY2hlZHVsZWRPYnNlcnZlcnMiLCJzY2hlZHVsZUNhbGxiYWNrIiwiZGlzcGF0Y2hDYWxsYmFja3MiLCJ3cmFwSWZOZWVkZWQiLCJTaGFkb3dET01Qb2x5ZmlsbCIsIm9ic2VydmVycyIsIm8xIiwibzIiLCJ1aWRfIiwiYW55Tm9uRW1wdHkiLCJ0YWtlUmVjb3JkcyIsImNhbGxiYWNrXyIsInJlbW92ZVRyYW5zaWVudE9ic2VydmVyc0ZvciIsIm5vZGVzXyIsInJlZ2lzdHJhdGlvbnMiLCJyZWdpc3RyYXRpb24iLCJyZW1vdmVUcmFuc2llbnRPYnNlcnZlcnMiLCJmb3JFYWNoQW5jZXN0b3JBbmRPYnNlcnZlckVucXVldWVSZWNvcmQiLCJzdWJ0cmVlIiwicmVjb3JkIiwiZW5xdWV1ZSIsInVpZENvdW50ZXIiLCJyZWNvcmRzXyIsImF0dHJpYnV0ZXMiLCJhdHRyaWJ1dGVPbGRWYWx1ZSIsImF0dHJpYnV0ZUZpbHRlciIsImNoYXJhY3RlckRhdGFPbGRWYWx1ZSIsIlJlZ2lzdHJhdGlvbiIsImFkZExpc3RlbmVycyIsImNvcHlPZlJlY29yZHMiLCJNdXRhdGlvblJlY29yZCIsInByZXZpb3VzU2libGluZyIsImF0dHJpYnV0ZU5hbWUiLCJhdHRyaWJ1dGVOYW1lc3BhY2UiLCJjb3B5TXV0YXRpb25SZWNvcmQiLCJjdXJyZW50UmVjb3JkIiwicmVjb3JkV2l0aE9sZFZhbHVlIiwiZ2V0UmVjb3JkIiwiZ2V0UmVjb3JkV2l0aE9sZFZhbHVlIiwiY2xlYXJSZWNvcmRzIiwicmVjb3JkUmVwcmVzZW50c0N1cnJlbnRNdXRhdGlvbiIsInNlbGVjdFJlY29yZCIsImxhc3RSZWNvcmQiLCJuZXdSZWNvcmQiLCJ0cmFuc2llbnRPYnNlcnZlZE5vZGVzIiwicmVjb3JkcyIsInJlY29yZFRvUmVwbGFjZUxhc3QiLCJhZGRMaXN0ZW5lcnNfIiwicmVtb3ZlTGlzdGVuZXJzXyIsImF0dHJOYW1lIiwicmVsYXRlZE5vZGUiLCJuYW1lc3BhY2VVUkkiLCJhdHRyQ2hhbmdlIiwiTXV0YXRpb25FdmVudCIsIkFERElUSU9OIiwicHJldlZhbHVlIiwiYWRkVHJhbnNpZW50T2JzZXJ2ZXIiLCJjaGFuZ2VkTm9kZSIsIl9pc1BvbHlmaWxsZWQiLCJuZXh0SGFuZGxlIiwidGFza3NCeUhhbmRsZSIsImN1cnJlbnRseVJ1bm5pbmdBVGFzayIsImFkZEZyb21TZXRJbW1lZGlhdGVBcmd1bWVudHMiLCJwYXJ0aWFsbHlBcHBsaWVkIiwicnVuSWZQcmVzZW50IiwiaGFuZGxlIiwidGFzayIsImNsZWFySW1tZWRpYXRlIiwiaW5zdGFsbE5leHRUaWNrSW1wbGVtZW50YXRpb24iLCJuZXh0VGljayIsImNhblVzZVBvc3RNZXNzYWdlIiwiaW1wb3J0U2NyaXB0cyIsInBvc3RNZXNzYWdlSXNBc3luY2hyb25vdXMiLCJvbGRPbk1lc3NhZ2UiLCJvbm1lc3NhZ2UiLCJpbnN0YWxsUG9zdE1lc3NhZ2VJbXBsZW1lbnRhdGlvbiIsIm1lc3NhZ2VQcmVmaXgiLCJvbkdsb2JhbE1lc3NhZ2UiLCJhdHRhY2hFdmVudCIsImluc3RhbGxNZXNzYWdlQ2hhbm5lbEltcGxlbWVudGF0aW9uIiwiY2hhbm5lbCIsIk1lc3NhZ2VDaGFubmVsIiwicG9ydDEiLCJwb3J0MiIsImluc3RhbGxSZWFkeVN0YXRlQ2hhbmdlSW1wbGVtZW50YXRpb24iLCJvbnJlYWR5c3RhdGVjaGFuZ2UiLCJpbnN0YWxsU2V0VGltZW91dEltcGxlbWVudGF0aW9uIiwiYXR0YWNoVG8iLCJwcm9jZXNzIiwiREVGQVVMVF9WSUVXUE9SVCIsIlZpZXdwb3J0Iiwidmlld3BvcnRFbGVtZW50IiwiaGVhZCIsImVuc3VyZVZpZXdwb3J0RWxlbWVudCIsIl9vbnNMb2FkZWQiLCJmYXN0Q2xpY2siLCJzdXBwb3J0VG91Y2hBY3Rpb24iLCJfaW50ZXJuYWwiLCJjcmVhdGVIYW5kbGVyIiwiYXBwIiwiZXhpdEFwcCIsIl9nZXN0dXJlRGV0ZWN0b3IiLCJnZXRFbGVtZW50Q2xhc3MiLCJCYXNlRWxlbWVudCIsIlRlbXBsYXRlRWxlbWVudCIsIm91dGVySFRNTCIsImJ1YmJsZXMiLCJUZW1wbGF0ZSIsIklmRWxlbWVudCIsIl9pc0FsbG93ZWRQbGF0Zm9ybSIsImNvbmRpdGlvbmFsT3JpZW50YXRpb24iLCJjdXJyZW50T3JpZW50YXRpb24iLCJJZiIsIkJhc2VBbmltYXRvciIsInByb3BlcnRpZXMiLCJleHRlbmRlZEFuaW1hdG9yIiwibmV3QW5pbWF0b3IiLCJpUGhvbmVYUGF0Y2giLCJpc0lQaG9uZVhQb3J0cmFpdFBhdGNoQWN0aXZlIiwiaXNJUGhvbmVYTGFuZHNjYXBlUGF0Y2hBY3RpdmUiLCJnZXRTYWZlQXJlYUxlbmd0aHMiLCJzYWZlQXJlYUxlbmd0aHMiLCJnZXRTYWZlQXJlYURPTVJlY3QiLCJzYWZlQXJlYVJlY3QiLCJBY3Rpb25TaGVldEFuaW1hdG9yIiwiTURBY3Rpb25TaGVldEFuaW1hdG9yIiwibWFza1RpbWluZyIsIm1hc2tEdXJhdGlvbiIsImFuaW1pdCIsIl9tYXNrIiwib3BhY2l0eSIsIl9zaGVldCIsImRlZmF1bHQiLCJ0cmFuc2Zvcm0iLCJJT1NBY3Rpb25TaGVldEFuaW1hdG9yIiwibGlmdEFtb3VudCIsImNsaWVudEhlaWdodCIsIkJhc2VEaWFsb2dFbGVtZW50Iiwic2hvdWxkU2hvdyIsIl9kb29yTG9jayIsIl9jYW5jZWwiLCJfc2VsZkNhbWVsTmFtZSIsIl9kZWZhdWx0REJCIiwiY2FsbFBhcmVudEhhbmRsZXIiLCJfYW5pbWF0b3JGYWN0b3J5IiwiX3VwZGF0ZUFuaW1hdG9yRmFjdG9yeSIsIl9ydW5uaW5nIiwiX3NldFZpc2libGUiLCJwYXJzZUFuaW1hdGlvbk9wdGlvbnNTdHJpbmciLCJjYW5jZWxlZCIsIl90b2dnbGVTdHlsZSIsImJhY2tncm91bmRDb2xvciIsIm9uRGV2aWNlQmFja0J1dHRvbiIsIl9iYWNrQnV0dG9uSGFuZGxlciIsIm9uTW9kaWZpZXJDaGFuZ2VkIiwiX3NjaGVtZSIsIl91cGRhdGVNYXNrIiwiX2FuaW1hdG9yRGljdCIsIkFjdGlvblNoZWV0RWxlbWVudCIsIl9jb21waWxlIiwic2hlZXQiLCJfdGl0bGUiLCJtYXNrIiwiaW5pdE1vZGlmaWVyIiwiX3VwZGF0ZVRpdGxlIiwiQWN0aW9uU2hlZXQiLCJCYXNlQnV0dG9uRWxlbWVudCIsIl9kZWZhdWx0Q2xhc3NOYW1lIiwiX2ljb24iLCJfdXBkYXRlUmlwcGxlIiwiX3JpcHBsZU9wdCIsIl91cGRhdGVJY29uIiwiQWN0aW9uU2hlZXRCdXR0b25FbGVtZW50IiwiQWN0aW9uU2hlZXRCdXR0b24iLCJBbGVydERpYWxvZ0FuaW1hdG9yIiwiQW5kcm9pZEFsZXJ0RGlhbG9nQW5pbWF0b3IiLCJfZGlhbG9nIiwiSU9TQWxlcnREaWFsb2dBbmltYXRvciIsIkFsZXJ0RGlhbG9nRWxlbWVudCIsIkFsZXJ0RGlhbG9nIiwiQWxlcnREaWFsb2dCdXR0b25FbGVtZW50IiwiQWxlcnREaWFsb2dCdXR0b24iLCJkZWZhdWx0Q2xhc3NOYW1lIiwiQmFja0J1dHRvbkVsZW1lbnQiLCJfb3B0aW9ucyIsIl9ib3VuZE9uQ2xpY2siLCJfb25DbGljayIsIm1kQmFja0J1dHRvbkljb24iLCJpb3NCYWNrQnV0dG9uSWNvbiIsInBvcFBhZ2UiLCJCYWNrQnV0dG9uIiwiQm90dG9tVG9vbGJhckVsZW1lbnQiLCJCb3R0b21Ub29sYmFyIiwiQnV0dG9uRWxlbWVudCIsIkJ1dHRvbiIsIkNhcmRFbGVtZW50IiwiQ2FyZCIsIkNhcm91c2VsSXRlbUVsZW1lbnQiLCJDYXJvdXNlbEl0ZW0iLCJkaXJlY3Rpb25NYXAiLCJTd2lwZXIiLCJGQUxTRSIsImdldEVsZW1lbnQiLCJzY3JvbGxIb29rIiwiaXRlbVNpemUiLCJnZXRBdXRvU2Nyb2xsUmF0aW8iLCJyYXRpbyIsInNob3VsZEJsb2NrIiwib25EcmFnU3RhcnQiLCJvbkRyYWciLCJvbkRyYWdFbmQiLCJvblJlc2l6ZSIsIl9zaG91bGRGaXhTY3JvbGwiLCJzd2lwZWFibGUiLCJhdXRvUmVmcmVzaCIsImluaXRpYWxpemVkIiwiYmxvY2tlciIsIl9tdXRhdGlvbk9ic2VydmVyIiwidXBkYXRlU3dpcGVhYmxlIiwidXBkYXRlQXV0b1JlZnJlc2giLCJfc2Nyb2xsIiwiX29mZnNldCIsIl9sYXN0QWN0aXZlSW5kZXgiLCJfdXBkYXRlTGF5b3V0IiwiX3NldHVwSW5pdGlhbEluZGV4Iiwic2V0dXBSZXNpemUiLCJ0YXJnZXRTaXplIiwiX3Jlc2V0Iiwic2V0QWN0aXZlSW5kZXgiLCJyb3VuZCIsIk51bWJlciIsImdldEluaXRpYWxJbmRleCIsIml0ZW1Db3VudCIsIml0ZW1OdW1TaXplIiwiX3Njcm9sbFRvIiwiX3NldFN3aXBpbmciLCJzY3JvbGwiLCJtYXhTY3JvbGwiLCJhcnJheU9mQXJyYXkiLCJjb250ZW50cyIsIl9jaGFuZ2VUbyIsImNvdW50Iiwic2l6ZSIsInNob3VsZFVwZGF0ZSIsInNob3VsZFdhdGNoIiwibmV3U2l6ZSIsImJsb2NrIiwicG9pbnRlckV2ZW50cyIsImlzRmlyc3QiLCJpc092ZXJTY3JvbGxhYmxlIiwiaXNMYXN0IiwiX2lnbm9yZURyYWciLCJjb25zdW1lZCIsImNvbnN1bWUiLCJfY2FuQ29uc3VtZUdlc3R1cmUiLCJzdGFydFgiLCJkaXN0RnJvbUVkZ2UiLCJnZXRCdWJibGVXaWR0aCIsIl9zdGFydGVkIiwidG9nZ2xlQmxvY2tlciIsIl9jb250aW51ZWQiLCJfZ2V0RGVsdGEiLCJ0aHJvdHRsZSIsIm5vcm1hbGl6ZWRTY3JvbGwiLCJfbm9ybWFsaXplU2Nyb2xsIiwiX3N0YXJ0TW9tZW50dW1TY3JvbGwiLCJfa2lsbE92ZXJTY3JvbGwiLCJfZ2V0VmVsb2NpdHkiLCJtYXRjaGVzRGlyZWN0aW9uIiwiZE0iLCJkaXIiLCJuZXh0U2Nyb2xsIiwiX2dldEF1dG9TY3JvbGwiLCJzd2lwZSIsImtpbGxPdmVyU2Nyb2xsIiwib3ZlclNjcm9sbEhvb2siLCJhY3RpdmVJbmRleCIsImdldEFjdGl2ZUluZGV4IiwibGFzdEFjdGl2ZUluZGV4IiwiY2hhbmdlIiwicHJlQ2hhbmdlSG9vayIsInBvc3RDaGFuZ2VIb29rIiwidG9GaXhlZCIsIl9nZXRUcmFuc2Zvcm0iLCJvZmZzZXQiLCJpc0F1dG9TY3JvbGxhYmxlIiwibGFzdFNjcm9sbCIsInNjcm9sbFJhdGlvIiwiX3RhcmdldFNpemUiLCJfaXRlbU51bVNpemUiLCJyZWZyZXNoSG9vayIsImF4aXMiLCJ0M2QiLCJuZXh0RWxlbWVudFNpYmxpbmciLCJpc0NlbnRlcmVkIiwiX2NhbGN1bGF0ZUl0ZW1TaXplIiwiQ2Fyb3VzZWxFbGVtZW50IiwiX3N3aXBlciIsImF1dG9TY3JvbGxSYXRpbyIsInZlcnRpY2FsIiwib3ZlcnNjcm9sbGFibGUiLCJjZW50ZXJlZCIsImF1dG9TY3JvbGwiLCJfb25PdmVyU2Nyb2xsIiwiX29uQ2hhbmdlIiwiX29uUmVmcmVzaCIsIl9vblN3aXBlIiwidXBkYXRlSXRlbVNpemUiLCJ3YWl0Rm9yQWN0aW9uIiwiY2Fyb3VzZWwiLCJpdGVtU2l6ZUF0dHIiLCJwYXJzZUZsb2F0IiwiQ2Fyb3VzZWwiLCJDb2xFbGVtZW50IiwiX3VwZGF0ZVdpZHRoIiwiQ29sIiwiRGlhbG9nQW5pbWF0b3IiLCJBbmRyb2lkRGlhbG9nQW5pbWF0b3IiLCJJT1NEaWFsb2dBbmltYXRvciIsImJvZHlIZWlnaHQiLCJTbGlkZURpYWxvZ0FuaW1hdG9yIiwiRGlhbG9nRWxlbWVudCIsIkRpYWxvZyIsIkZhYkVsZW1lbnQiLCJfaGlkZSIsIl9zaG93IiwiX21hbnVhbGx5SGlkZGVuIiwiX3RvZ2dsZSIsImlzQm90dG9tIiwidHJhbnNsYXRlIiwiZmFiT2Zmc2V0IiwiRmFiIiwiR2VzdHVyZURldGVjdG9yRWxlbWVudCIsImF1dG9QcmVmaXgiLCJJY29uRWxlbWVudCIsIl9jbGVhbkNsYXNzQXR0cmlidXRlIiwiX3VwZGF0ZSIsIl9idWlsZENsYXNzQW5kU3R5bGUiLCJfcGFyc2VBdHRyIiwiYXR0ciIsIm1kIiwibGFzdEljb24iLCJsYXN0TW9kaWZpZXIiLCJfcHJlZml4SWNvbiIsImN1c3RvbVByZWZpeFJFIiwiaWNvbk5hbWUiLCJyZW1vdmVQcm9wZXJ0eSIsImZvbnRTaXplIiwiTGF6eVJlcGVhdERlbGVnYXRlIiwidXNlckRlbGVnYXRlIiwidGVtcGxhdGVFbGVtZW50IiwiX3VzZXJEZWxlZ2F0ZSIsIl90ZW1wbGF0ZUVsZW1lbnQiLCJfcmVuZGVyIiwibG9hZEl0ZW1FbGVtZW50IiwiY3JlYXRlSXRlbUNvbnRlbnQiLCJjb3VudEl0ZW1zIiwidXBkYXRlSXRlbUNvbnRlbnQiLCJjYWxjdWxhdGVJdGVtSGVpZ2h0IiwiZGVzdHJveUl0ZW0iLCJpdGVtSGVpZ2h0IiwiTGF6eVJlcGVhdFByb3ZpZGVyIiwid3JhcHBlckVsZW1lbnQiLCJkZWxlZ2F0ZSIsIl93cmFwcGVyRWxlbWVudCIsIl9kZWxlZ2F0ZSIsIl9pbnNlcnRJbmRleCIsIl9wYWdlQ29udGVudCIsIl9maW5kUGFnZUNvbnRlbnRFbGVtZW50IiwibGFzdFNjcm9sbFRvcCIsInBhZGRpbmciLCJfdG9wUG9zaXRpb25zIiwiX3JlbmRlcmVkSXRlbXMiLCJfdW5rbm93bkl0ZW1IZWlnaHQiLCJfYWRkRXZlbnRMaXN0ZW5lcnMiLCJwYWdlQ29udGVudCIsIl9pdGVtSGVpZ2h0IiwidmlzaWJpbGl0eSIsInN0YXRpY0l0ZW1IZWlnaHQiLCJfZ2V0SXRlbUhlaWdodCIsImZvcmNlUmVuZGVyIiwiZm9yY2VTY3JvbGxEb3duIiwiZmlyc3RJdGVtSW5kZXgiLCJfZmlyc3RJdGVtUmVuZGVyZWQiLCJfY2FsY3VsYXRlUmVuZGVyZWRIZWlnaHQiLCJmb3JjZUZpcnN0SW5kZXgiLCJfcmVtb3ZlQWxsRWxlbWVudHMiLCJmb3JjZUxhc3RJbmRleCIsIl9jaGVja0l0ZW1IZWlnaHQiLCJpc1Njcm9sbFVwIiwia2VlcCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsIl9jb3VudEl0ZW1zIiwiX2NhbGN1bGF0ZVN0YXJ0SW5kZXgiLCJoYXNSZW5kZXJGdW5jdGlvbiIsIl9yZW5kZXJFbGVtZW50IiwiX3JlbW92ZUVsZW1lbnQiLCJ1cGRhdGVJdGVtIiwibGFzdEl0ZW1JbmRleCIsIl9sYXN0SXRlbVJlbmRlcmVkIiwiX3JlY2FsY3VsYXRlVG9wUG9zaXRpb25zIiwibWlkZGxlIiwiaW1tZWRpYXRlIiwiY2FsbE5vdyIsIl9kZWJvdW5jZSIsIl9ib3VuZE9uQ2hhbmdlIiwiX2JvdW5kRG91YmxlRmlyZU9uVG91Y2hlbmQiLCJfcGFyZW50RWxlbWVudCIsIl9yZW1vdmVFdmVudExpc3RlbmVycyIsInBhZGRpbmdUb3AiLCJMYXp5UmVwZWF0RWxlbWVudCIsIl9sYXp5UmVwZWF0UHJvdmlkZXIiLCJMYXp5UmVwZWF0IiwiTGlzdEhlYWRlckVsZW1lbnQiLCJMaXN0SGVhZGVyIiwiTGlzdFRpdGxlRWxlbWVudCIsIkxpc3RUaXRsZSIsIkxpc3RJdGVtQW5pbWF0b3IiLCJsaXN0SXRlbSIsIlNsaWRlTGlzdEl0ZW1BbmltYXRvciIsIl9hbmltYXRlRXhwYW5zaW9uIiwic2hvdWxkT3BlbiIsIm9sZEhlaWdodCIsImV4cGFuZGFibGVDb250ZW50Iiwib2xkRGlzcGxheSIsImNvbXB1dGVkU3R5bGUiLCJleHBhbnNpb25PcGVuVHJhbnNpdGlvbiIsInBhZGRpbmdCb3R0b20iLCJpY29uT3BlblRyYW5zaXRpb24iLCJyZXZlcnNlIiwiZXhwYW5kQ2hldnJvbiIsIkxpc3RJdGVtRWxlbWVudCIsInRvZ2dsZUV4cGFuc2lvbiIsIl9zaG91bGRJZ25vcmVUYXAiLCJzaG93RXhwYW5zaW9uIiwiaGlkZUV4cGFuc2lvbiIsInRvcENvbnRlbnQiLCJjZW50ZXJDb250ZW50IiwiX3RvcCIsImNoZXZyb24iLCJfZXhwYW5kaW5nIiwiZXhwYW5kZWQiLCJfc2V0dXBMaXN0ZW5lcnMiLCJfb3JpZ2luYWxCYWNrZ3JvdW5kQ29sb3IiLCJ0YXBwZWQiLCJfb25Ub3VjaCIsIl9vblJlbGVhc2UiLCJfb25EcmFnIiwidG91Y2hTdHlsZSIsImJveFNoYWRvdyIsIkxpc3RJdGVtIiwiTGlzdEVsZW1lbnQiLCJMaXN0IiwiSU5QVVRfQVRUUklCVVRFUyIsIkJhc2VJbnB1dEVsZW1lbnQiLCJfYm91bmREZWxlZ2F0ZUV2ZW50IiwiX2RlbGVnYXRlRXZlbnQiLCJfdGVtcGxhdGUiLCJfc2V0SW5wdXRJZCIsIl91cGRhdGVCb3VuZEF0dHJpYnV0ZXMiLCJfaW5wdXQiLCJ0b0lTT1N0cmluZyIsIklucHV0RWxlbWVudCIsIl9ib3VuZE9uSW5wdXQiLCJfYm91bmRPbkZvY3VzaW4iLCJfdXBkYXRlTGFiZWwiLCJfdXBkYXRlTGFiZWxDbGFzcyIsIl9oZWxwZXIiLCJpbm5lclRleHQiLCJJbnB1dCIsIkJhc2VDaGVja2JveEVsZW1lbnQiLCJjaGVja2VkIiwiQ2hlY2tib3hFbGVtZW50IiwiQ2hlY2tib3giLCJSYWRpb0VsZW1lbnQiLCJSYWRpbyIsIlNlYXJjaElucHV0RWxlbWVudCIsIlNlYXJjaElucHV0IiwiTW9kYWxBbmltYXRvciIsIm1vZGFsIiwiRmFkZU1vZGFsQW5pbWF0b3IiLCJMaWZ0TW9kYWxBbmltYXRvciIsIk1vZGFsRWxlbWVudCIsIk1vZGFsIiwid2lkdGhUb1B4Iiwib2Zmc2V0V2lkdGgiLCJTd2lwZVJldmVhbCIsImVsZW1lbnRIYW5kbGVyIiwiZ2V0VGhyZXNob2xkIiwiZ2V0U2lkZSIsImhhbmRsZUdlc3R1cmUiLCJnZXN0dXJlRGV0ZWN0b3IiLCJpZ25vcmVTd2lwZSIsIl93aWR0aCIsIl9zdGFydERpc3RhbmNlIiwiX2Rpc3RhbmNlIiwiaXNJbml0aWFsU3RhdGUiLCJkZWx0YSIsInN3aXBlTWlkIiwiaXNTd2lwZU1heCIsInN3aXBlTWF4Iiwic3dpcGVNaW4iLCJOYXZpZ2F0b3JBbmltYXRvciIsImVudGVyUGFnZSIsImxlYXZlUGFnZSIsIklPU1N3aXBlTmF2aWdhdG9yQW5pbWF0b3IiLCJkdXJhdGlvblJlc3RvcmUiLCJkdXJhdGlvblN3aXBlIiwidGltaW5nU3dpcGUiLCJyZXN0Iiwib3B0U3dpcGUiLCJvcHRSZXN0b3JlIiwic3dpcGVTaGFkb3ciLCJpc0RyYWdTdGFydCIsInVuYmxvY2siLCJiYWNrZ3JvdW5kTWFzayIsImRlY29tcCIsIl9kZWNvbXBvc2UiLCJlbnRlciIsImxlYXZlIiwiX2NhbGN1bGF0ZURlbHRhIiwic2hvdWxkQW5pbWF0ZVRvb2xiYXIiLCJfc2hvdWxkQW5pbWF0ZVRvb2xiYXIiLCJ0b29sYmFyIiwiX3NhdmVTdHlsZSIsIm92ZXJmbG93RWxlbWVudCIsIm1heFdpZHRoIiwiaXNTd2lwaW5nIiwiX2RyYWdTdGFydFNldHVwIiwic3dpcGVSYXRpbyIsImJvdHRvbVRvb2xiYXIiLCJiYWNrZ3JvdW5kIiwidG9vbGJhckNlbnRlciIsImJhY2tCdXR0b25MYWJlbCIsIm90aGVyIiwiX3NhdmVkU3R5bGUiLCJzYXZlIiwicmVzdG9yZSIsIl9yZXN0b3JlU3R5bGUiLCJ0cmFuc2xhdGUzZCIsIklPU1NsaWRlTmF2aWdhdG9yQW5pbWF0b3IiLCJfZ2V0VG9vbGJhckVsZW1lbnQiLCJfZ2V0VG9vbGJhckxlZnRJdGVtc0VsZW1lbnQiLCJfZ2V0VG9vbGJhclJpZ2h0SXRlbXNFbGVtZW50IiwiZXhjbHVkZUJhY2tCdXR0b24iLCJfZ2V0VG9vbGJhckNlbnRlckl0ZW1zRWxlbWVudCIsIl9nZXRUb29sYmFyQmFja0J1dHRvbkljb25FbGVtZW50IiwiX2dldFRvb2xiYXJCYWNrQnV0dG9uTGFiZWxFbGVtZW50IiwiX2dldENvbnRlbnRFbGVtZW50IiwiX2dldEJhY2tncm91bmRFbGVtZW50IiwiX2dldEJvdHRvbVRvb2xiYXJFbGVtZW50IiwidG9vbGJhcnMiLCJlbnRlclRvb2xiYXIiLCJsZWF2ZVRvb2xiYXIiLCJpc1N0YXRpYyIsImlzTWF0ZXJpYWwiLCJpc1RyYW5zcGFyZW50IiwiZGVjb21wb3NpdGlvbiIsInBhZ2VSZWN0IiwibGFiZWxSZWN0IiwiYmFja0J1dHRvbkljb24iLCJlbnRlclBhZ2VUYXJnZXQiLCJsZWF2ZVBhZ2VUYXJnZXQiLCJlbnRlclBhZ2VEZWNvbXBvc2l0aW9uIiwibGVhdmVQYWdlRGVjb21wb3NpdGlvbiIsInBvcFN3aXBlIiwiSU9TTGlmdE5hdmlnYXRvckFuaW1hdG9yIiwiSU9TRmFkZU5hdmlnYXRvckFuaW1hdG9yIiwiTURTbGlkZU5hdmlnYXRvckFuaW1hdG9yIiwiYmxhY2tNYXNrT3BhY2l0eSIsIk1ETGlmdE5hdmlnYXRvckFuaW1hdG9yIiwibWFza0NsZWFyIiwiTURGYWRlTmF2aWdhdG9yQW5pbWF0b3IiLCJ0aW1pbmdQb3AiLCJOb25lTmF2aWdhdG9yQW5pbWF0b3IiLCJyZXdyaXRhYmxlcyIsIm5hdmlnYXRvckVsZW1lbnQiLCJ2ZXJpZnlQYWdlRWxlbWVudCIsIk5hdmlnYXRvckVsZW1lbnQiLCJfaXNSdW5uaW5nIiwiX2luaXRpYWxpemVkIiwiX3BhZ2VMb2FkZXIiLCJfcGFnZU1hcCIsIl9wYWdlIiwiX29uRGV2aWNlQmFja0J1dHRvbiIsInN3aXBlQW5pbWF0b3IiLCJfc3dpcGUiLCJwcmV2aW91c0VsZW1lbnRTaWJsaW5nIiwiYXJlYSIsImlzQkIiLCJwdXNoZWRPcHRpb25zIiwiYW5pbWF0b3JGYWN0b3J5IiwibG9hZGVkIiwiX2dldFBhZ2VUYXJnZXQiLCJwdXNoUGFnZSIsIl91cGRhdGVMYXN0UGFnZUJhY2tCdXR0b24iLCJ1cGRhdGUiLCJfcHJlcGFyZVBhZ2VBbmRPcHRpb25zIiwidGltZXMiLCJfcmVtb3ZlUGFnZXMiLCJwb3BVcGRhdGUiLCJ1bmxvYWQiLCJfcG9wUGFnZSIsIl9lbWl0UHJlUG9wRXZlbnQiLCJ1cGRhdGVCYWNrQnV0dG9uIiwicGFnZUhUTUwiLCJfcHVzaFBhZ2UiLCJsb2FkIiwiX2VtaXRQcmVQdXNoRXZlbnQiLCJwYWdlTGVuZ3RoIiwiX3JlcGxhY2VQYWdlIiwicmVzb2x2ZWRWYWx1ZSIsIl9ub3JtYWxpemVJbmRleCIsImluc2VydFBhZ2UiLCJuZXdQYWdlIiwiX2xhc3RJbmRleE9mUGFnZSIsInBhZ2VOYW1lIiwiaXNDYW5jZWxlZCIsIl9lbWl0UHJlRXZlbnQiLCJ0ZW1wbGF0ZUhUTUwiLCJwYWdlTG9hZGVyIiwibGFzdEVsZW1lbnRDaGlsZCIsIk5hdmlnYXRvciIsIlRvb2xiYXJFbGVtZW50Iiwic2libGluZ0JhY2tncm91bmQiLCJzaWJsaW5nQ29udGVudCIsInNldFZpc2liaWxpdHkiLCJfZW5zdXJlVG9vbGJhckl0ZW1FbGVtZW50cyIsIl9lbnN1cmVUb29sYmFyRWxlbWVudCIsIlRvb2xiYXIiLCJQYWdlRWxlbWVudCIsIl9kZXJpdmVIb29rcyIsIl9iYWNrZ3JvdW5kRWxlbWVudCIsIl9lbGVtZW50U2hvdWxkQmVNb3ZlZCIsIl90cnlUb0ZpbGxTdGF0dXNCYXIiLCJmaXhlZEVsZW1lbnRzIiwib25Jbml0IiwiYmFja0J1dHRvbiIsIm92ZXJMaW1pdCIsIl9pbmZpbml0ZVNjcm9sbExpbWl0IiwiX29uSW5maW5pdGVTY3JvbGwiLCJfbG9hZGluZ0NvbnRlbnQiLCJvbkluZmluaXRlU2Nyb2xsIiwib25EZXN0cm95IiwiZXZlbnRzIiwiX2JvdW5kT25TY3JvbGwiLCJfb25TY3JvbGwiLCJQYWdlIiwiUG9wb3ZlckFuaW1hdG9yIiwicG9wb3ZlciIsImFuaW1hdGlvbnMiLCJfYW5pbWF0ZSIsImZhZGUiLCJNREZhZGVQb3BvdmVyQW5pbWF0b3IiLCJfYW5pbWF0ZUFsbCIsImluIiwiSU9TRmFkZVBvcG92ZXJBbmltYXRvciIsInBvc2l0aW9ucyIsIlBvcG92ZXJFbGVtZW50IiwiX2N1cnJlbnRUYXJnZXQiLCJfcG9zaXRpb25Qb3BvdmVyIiwiX2NsZWFyU3R5bGVzIiwicmFkaXVzIiwiX3JhZGl1cyIsImNvbnRlbnRFbGVtZW50IiwiX2NvbnRlbnQiLCJtYXJnaW4iLCJfbWFyZ2luIiwidGFyZ2V0UmVjdCIsImlzTUQiLCJjb3ZlciIsInBhcmVudERpbWVuc2lvbnMiLCJtYXhQb3NpdGlvbnMiLCJib3R0b20iLCJ0YXJnZXREaXN0YW5jZSIsInRhcmdldENlbnRlckRpc3RhbmNlRnJvbSIsIl9jYWxjdWxhdGVEaXJlY3Rpb25zIiwicHJpbWFyeURpcmVjdGlvbiIsInByaW1hcnkiLCJzZWNvbmRhcnlEaXJlY3Rpb24iLCJzZWNvbmRhcnkiLCJfY3VycmVudERpcmVjdGlvbiIsInNpemVOYW1lIiwiY29udGVudFNpemUiLCJ0YXJnZXRBbmRBcnJvd0xlbmd0aCIsInByaW1hcnlPZmZzZXQiLCJzZWNvbmRhcnlPZmZzZXQiLCJfcG9wb3ZlciIsIl9hcnJvdyIsImhhc0RlZmF1bHRDb250YWluZXIiLCJhcnJvdyIsIlBvcG92ZXIiLCJJTkRFVCIsIlByb2dyZXNzQmFyRWxlbWVudCIsIl9pc0NvbXBpbGVkIiwiX3ByaW1hcnkiLCJfc2Vjb25kYXJ5IiwiX3VwZGF0ZURldGVybWluYXRlIiwiX3VwZGF0ZVZhbHVlIiwiYmFyRWxlbWVudCIsIlByb2dyZXNzQmFyIiwiUHJvZ3Jlc3NDaXJjdWxhckVsZW1lbnQiLCJwZXIiLCJzdmciLCJQcm9ncmVzc0NpcmN1bGFyIiwiU1RBVEVfSU5JVElBTCIsIlNUQVRFX1BSRUFDVElPTiIsIlNUQVRFX0FDVElPTiIsInRocm93VHlwZSIsIlB1bGxIb29rRWxlbWVudCIsIl9vbkRyYWdTdGFydCIsIl9vbkRyYWdFbmQiLCJfc2V0U3RhdGUiLCJsaW5lSGVpZ2h0IiwiX3BhZ2VFbGVtZW50IiwidGFwWSIsIm1heFkiLCJkcmFnZ2FibGVBcmVhUmF0aW8iLCJfc3RhcnRTY3JvbGwiLCJfY3VycmVudFRyYW5zbGF0aW9uIiwidGgiLCJ0aHJlc2hvbGRIZWlnaHQiLCJfZmluaXNoIiwiX3RyYW5zbGF0ZVRvIiwiYW5pbWF0ZSIsIm9uQWN0aW9uIiwibm9FdmVudCIsImxhc3RTdGF0ZSIsIm1hcmdpblRvcCIsIl9vblB1bGwiLCJzY3JvbGxFbGVtZW50IiwiX2RyYWdMb2NrRGlzYWJsZWQiLCJzY3JvbGxUb2dnbGUiLCJnZFRvZ2dsZSIsIl9zZXRTdHlsZSIsIl9vbkFjdGlvbiIsIlB1bGxIb29rIiwiYWN0aXZlQ2xhc3NUb2tlbiIsIlJhbmdlRWxlbWVudCIsIl9vbk1vdXNlRG93biIsIl9vbk1vdXNlVXAiLCJfb25Ub3VjaFN0YXJ0IiwiX29uVG91Y2hFbmQiLCJfb25JbnB1dCIsIl9vbkRyYWdzdGFydCIsIl9vbkRyYWdlbmQiLCJfdXBkYXRlRGlzYWJsZWQiLCJmb2N1c1JpbmciLCJfZm9jdXNSaW5nIiwiYmFja2dyb3VuZFNpemUiLCJfcmF0aW8iLCJSYW5nZSIsIkFuaW1hdG9yQ1NTIiwiZmluYWwiLCJnZXRUaW1lIiwiaW5pdGlhbCIsInVwZGF0ZVN0eWxlcyIsImNsZWFyVGltZW91dCIsInRyYW5zaXRpb25EdXJhdGlvbiIsInN0b3BOZXh0IiwibmV3RHVyYXRpb24iLCJwYXNzZWQiLCJyZW1haW5pbmciLCJzcGVlZFVwVGltZSIsInN0b3AiLCJtaWxsaXNlY29uZHMiLCJzcGVlZCIsInRyYW5zaXRpb25Qcm9wZXJ0eSIsIl9vblN0b3BBbmltYXRpb25zIiwiX3F1ZXVlIiwiX2luZGV4Iiwic3RvcEFuaW1hdGlvbnMiLCJSaXBwbGVFbGVtZW50IiwiX29uVGFwIiwiX29uSG9sZCIsIl9hbmltYXRvciIsIl93YXZlIiwiZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSIsIl9iYWNrZ3JvdW5kIiwic2l6ZXMiLCJfZ2V0RWZmZWN0U2l6ZSIsIl9jZW50ZXIiLCJfbWluUiIsIl9jYWxjdWxhdGVDb29yZHMiLCJzdG9wQWxsIiwicmlwcGxlIiwiX3VwZGF0ZVBhcmVudCIsIl9yaXBwbGVBbmltYXRpb24iLCJfaG9sZGluZyIsIl9wYXJlbnROb2RlIiwicG4iLCJSaXBwbGUiLCJSb3dFbGVtZW50IiwiUm93IiwiU2VnbWVudEVsZW1lbnQiLCJfc2VnbWVudElkIiwiX3RhYmJhciIsIl9vblRhYmJhclByZUNoYW5nZSIsImdldEFjdGl2ZVRhYkluZGV4IiwiZ2V0QWN0aXZlQnV0dG9uSW5kZXgiLCJfc2V0Q2hlY2tlZCIsImZpcnN0RWxlbWVudENoaWxkIiwic2V0QWN0aXZlVGFiIiwiX3Bvc3RDaGFuZ2UiLCJTZWdtZW50IiwiU2VsZWN0RWxlbWVudCIsIl9kZXJpdmVHZXR0ZXJzIiwiX3NlbGVjdCIsInNlbCIsIm9wdGlvbiIsIlNlbGVjdCIsIlNwZWVkRGlhbEl0ZW1FbGVtZW50IiwiU3BlZWREaWFsSXRlbSIsIlNwZWVkRGlhbEVsZW1lbnQiLCJfaXRlbVNob3duIiwiX3VwZGF0ZURpcmVjdGlvbiIsInRvZ2dsZUl0ZW1zIiwiaW5saW5lIiwiX2ZhYiIsIml0ZW1zIiwiX2dldFRyYW5zbGF0ZSIsImhpZGVJdGVtcyIsInRvdGFsRGVsYXkiLCJpc09wZW4iLCJzaG93SXRlbXMiLCJTcGVlZERpYWwiLCJTcGxpdHRlckNvbnRlbnRFbGVtZW50Iiwib2xkQ29udGVudCIsIlNwbGl0dGVyQ29udGVudCIsIlNwbGl0dGVyTWFza0VsZW1lbnQiLCJfc2lkZXMiLCJzaWRlIiwibW9kZSIsIlNwbGl0dGVyTWFzayIsIlNwbGl0dGVyQW5pbWF0b3IiLCJzaWRlRWxlbWVudCIsInNwbGl0dGVyIiwiX3NpZGUiLCJfb3Bwb3NpdGVTaWRlIiwiY2xlYXJNYXNrIiwiT3ZlcmxheVNwbGl0dGVyQW5pbWF0b3IiLCJtaW51cyIsIlB1c2hTcGxpdHRlckFuaW1hdG9yIiwic2xpZGluZ0VsZW1lbnRzIiwiX3NsaWRpbmdFbGVtZW50cyIsIl9nZXRTbGlkaW5nRWxlbWVudHMiLCJSZXZlYWxTcGxpdHRlckFuaW1hdG9yIiwiX3NldFN0eWxlcyIsIl91bnNldFN0eWxlcyIsIl9nZW5lcmF0ZUJlaGluZFBhZ2VTdHlsZSIsImJlaGluZERpc3RhbmNlIiwiYmVoaW5kVHJhbnNmb3JtIiwiX2dldE1heFdpZHRoIiwibWVudVN0eWxlIiwiU3BsaXR0ZXJFbGVtZW50IiwiX2xheW91dCIsIl9nZXRTaWRlIiwiX29uTW9kZUNoYW5nZSIsIlNwbGl0dGVyIiwiU1BMSVRfTU9ERSIsIkNPTExBUFNFX01PREUiLCJDTE9TRURfU1RBVEUiLCJPUEVOX1NUQVRFIiwiQ0hBTkdJTkdfU1RBVEUiLCJzcGxpdHRlclNpZGVFbGVtZW50IiwiQ29sbGFwc2VEZXRlY3Rpb24iLCJjaGFuZ2VUYXJnZXQiLCJfdGFyZ2V0IiwiX29yaWVudGF0aW9uIiwiYWN0aXZhdGUiLCJfdXBkYXRlTW9kZSIsIl9tYXRjaCIsIl9xdWVyeVJlc3VsdCIsIm1hdGNoTWVkaWEiLCJhZGRMaXN0ZW5lciIsInJlbW92ZUxpc3RlbmVyIiwiU3BsaXR0ZXJTaWRlRWxlbWVudCIsIl9zdGF0ZSIsIl9sb2NrIiwiX2NvbGxhcHNlRGV0ZWN0aW9uIiwiX2FuaW1hdGlvbk9wdCIsImNsb3NlZCIsInZhbGlkRHJhZyIsIl9tb2RlIiwiX2lzT3RoZXJTaWRlT3BlbiIsImRlYWN0aXZhdGUiLCJ1cGRhdGVPcHRpb25zIiwiRklOQUxfU1RBVEUiLCJfZW1pdEV2ZW50IiwiX3VwZGF0ZUFuaW1hdGlvbiIsIlNwbGl0dGVyU2lkZSIsImxvY2F0aW9ucyIsIlN3aXRjaEVsZW1lbnQiLCJfbGFzdFRpbWVTdGFtcCIsIl9sb2NhdGlvbnMiLCJfc3RhcnRYIiwiX2VtaXRDaGFuZ2VFdmVudCIsImRlZmF1bHRFbGVtZW50Q2xhc3MiLCJfaGFuZGxlIiwiX2dldFBvc2l0aW9uIiwicHJldmlvdXNWYWx1ZSIsImNsaWNrIiwiU3dpdGNoIiwidGFiYmFyRWxlbWVudCIsImxlcnAiLCJ4MCIsIngxIiwidCIsIlRhYmJhckVsZW1lbnQiLCJfbG9hZEluYWN0aXZlIiwiX2dldEF1dG9TY3JvbGxSYXRpbyIsIl9vblByZUNoYW5nZSIsIl9vblBvc3RDaGFuZ2UiLCJfdGFiYmFyQm9yZGVyIiwiX3RhYmJhckVsZW1lbnQiLCJfdGFic1JlY3QiLCJ0YWJJdGVtIiwidGFicyIsIl9ub3JtYWxpemVFdmVudCIsImNhbmNlbCIsInNldEFjdGl2ZSIsInByZXZUYWIiLCJfYXV0b2dyb3ciLCJ0YWIiLCJ0YWJiYXIiLCJjcyIsImZpbGxlZCIsIm5leHRJbmRleCIsInByZXZJbmRleCIsIm5leHRUYWIiLCJzZXRUYWJiYXJWaXNpYmlsaXR5IiwiaXNBY3RpdmUiLCJpc1RvcCIsIl90YXJnZXRFbGVtZW50IiwiVGFiYmFyIiwiVGFiRWxlbWVudCIsIl9idXR0b24iLCJfdXBkYXRlQnV0dG9uQ29udGVudCIsImljb25XcmFwcGVyIiwiZml4IiwiYWN0aXZlIiwiX2hhc0xvYWRlZCIsIl9sb2FkZWRQYWdlIiwicGFnZVRhcmdldCIsInBhcmVudFRhcmdldCIsImR1bW15UGFnZSIsIl9sb2FkUGFnZUVsZW1lbnQiLCJUYWIiLCJUb2FzdEFuaW1hdG9yIiwiRmFkZVRvYXN0QW5pbWF0b3IiLCJBc2NlbmRUb2FzdEFuaW1hdG9yIiwibWVzc2FnZURlbGF5IiwiYXNjZW5zaW9uIiwiX2dldEZhYnMiLCJmYWIiLCJMaWZ0VG9hc3RBbmltYXRvciIsIkZhbGxUb2FzdEFuaW1hdG9yIiwiZmFsbEFtb3VudCIsImNsZWFuVXAiLCJjb3JyZWN0VG9wIiwiVG9hc3RFbGVtZW50IiwibWVzc2FnZUNsYXNzTmFtZSIsImJ1dHRvbkNsYXNzTmFtZSIsIlRvYXN0IiwiVG9vbGJhckJ1dHRvbkVsZW1lbnQiLCJUb29sYmFyQnV0dG9uIiwiX3N1cGVyU2VjcmV0T25zIl0sIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBLGtCQUFlLEVBQWY7O0FDQUE7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBaUJBLEFBRUE7Ozs7OztBQU1BLElBQU1BLFNBQVUsWUFBVztNQUNuQkMsU0FBU0MsT0FBT0MsZ0JBQVAsQ0FBd0JDLFNBQVNDLGVBQWpDLEVBQWtELEVBQWxELENBQWY7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
diff --git a/node_modules/onsenui/js/onsenui.min.js b/node_modules/onsenui/js/onsenui.min.js
new file mode 100644
index 0000000..574f6a9
--- /dev/null
+++ b/node_modules/onsenui/js/onsenui.min.js
@@ -0,0 +1,2 @@
+/* onsenui v2.10.7 - 2019-04-01 */
+!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?module.exports=e():"function"==typeof define&&define.amd?define(e):t.ons=e()}(this,function(){"use strict";var t,e,i={},r=(t=window.getComputedStyle(document.documentElement,""),e=(Array.prototype.slice.call(t).join("").match(/-(moz|webkit|ms)-/)||""===t.OLink&&["","o"])[1],function(t){return"-"+e+"-"+W.hyphenate(t)}),l=function(e,n){return Object.keys(n).forEach(function(t){t in e.style?e.style[t]=n[t]:r(t)in e.style?e.style[r(t)]=n[t]:W.warn("No such style property: "+t)}),e};l.clear=function(n){for(var i=(1<arguments.length&&void 0!==arguments[1]?arguments[1]:"").split(/\s+/).reduce(function(t,e){return t.concat([W.hyphenate(e),r(e)])},[]),o=[],t=function(t){var e=n.style[t];(0===i.length||i.some(function(t){return 0===e.indexOf(t)}))&&o.push(e)},e=n.style.length-1;0<=e;e--)t(e);o.forEach(function(t){return n.style[t]=""}),""===n.getAttribute("style")&&n.removeAttribute("style")};var u="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},h=function(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")},d=function(){function i(t,e){for(var n=0;n<e.length;n++){var i=e[n];i.enumerable=i.enumerable||!1,i.configurable=!0,"value"in i&&(i.writable=!0),Object.defineProperty(t,i.key,i)}}return function(t,e,n){return e&&i(t.prototype,e),n&&i(t,n),t}}(),s=function(t,e,n){return e in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t},f=Object.assign||function(t){for(var e=1;e<arguments.length;e++){var n=arguments[e];for(var i in n)Object.prototype.hasOwnProperty.call(n,i)&&(t[i]=n[i])}return t},p=function t(e,n,i){null===e&&(e=Function.prototype);var o=Object.getOwnPropertyDescriptor(e,n);if(void 0===o){var r=Object.getPrototypeOf(e);return null===r?void 0:t(r,n,i)}if("value"in o)return o.value;var a=o.get;return void 0!==a?a.call(i):void 0},a=function(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)},g=function(t,e){var n={};for(var i in t)0<=e.indexOf(i)||Object.prototype.hasOwnProperty.call(t,i)&&(n[i]=t[i]);return n},m=function(t,e){if(!t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!e||"object"!=typeof e&&"function"!=typeof e?t:e},_=function(t){if(Array.isArray(t)){for(var e=0,n=Array(t.length);e<t.length;e++)n[e]=t[e];return n}return Array.from(t)},n=window.HTMLElement,c=new(function(){function t(){h(this,t),this._selectedPlatform=null,this._ignorePlatformSelect=!1}return d(t,[{key:"select",value:function(t){"string"==typeof t&&(this._selectedPlatform=t.trim().toLowerCase())}},{key:"_getSelectedPlatform",value:function(){return this._ignorePlatformSelect?null:this._selectedPlatform}},{key:"_runOnActualPlatform",value:function(t){this._ignorePlatformSelect=!0;var e=t();return this._ignorePlatformSelect=!1,e}},{key:"isWebView",value:function(){if("loading"===document.readyState||"uninitialized"==document.readyState)throw new Error("isWebView() method is available after dom contents loaded.");return!!(window.cordova||window.phonegap||window.PhoneGap)}},{key:"isIPhone",value:function(){return/iPhone/i.test(navigator.userAgent)}},{key:"isIPhoneX",value:function(){return this.isIPhone()&&(375===window.screen.width&&812===window.screen.height||812===window.screen.width&&375===window.screen.height||414===window.screen.width&&896===window.screen.height||896===window.screen.width&&414===window.screen.height)}},{key:"isIPad",value:function(){return/iPad/i.test(navigator.userAgent)}},{key:"isIPod",value:function(){return/iPod/i.test(navigator.userAgent)}},{key:"isIOS",value:function(t){return!t&&this._getSelectedPlatform()?"ios"===this._getSelectedPlatform():"object"!==("undefined"==typeof device?"undefined":u(device))||/browser/i.test(device.platform)?/iPhone|iPad|iPod/i.test(navigator.userAgent):/iOS/i.test(device.platform)}},{key:"isIOS7above",value:function(){if("object"===("undefined"==typeof device?"undefined":u(device))&&!/browser/i.test(device.platform))return/iOS/i.test(device.platform)&&7<=parseInt(device.version.split(".")[0]);if(/iPhone|iPad|iPod/i.test(navigator.userAgent)){var t=(navigator.userAgent.match(/\b[0-9]+_[0-9]+(?:_[0-9]+)?\b/)||[""])[0].replace(/_/g,".");return 7<=parseInt(t.split(".")[0])}return!1}},{key:"isIOSSafari",value:function(){var t=window.navigator,e=t.userAgent;return!(!this.isIOS()||-1===e.indexOf("Safari")||-1===e.indexOf("Version")||t.standalone)}},{key:"isWKWebView",value:function(){var t=/constructor/i.test(n);return!(!(this.isIOS()&&window.webkit&&window.webkit.messageHandlers&&window.indexedDB)||t)}},{key:"isUIWebView",value:function(){return!(!this.isIOS()||this.isIOSSafari()||this.isWKWebView())}},{key:"isAndroidPhone",value:function(){return/Android/i.test(navigator.userAgent)&&/Mobile/i.test(navigator.userAgent)}},{key:"isAndroidTablet",value:function(){return/Android/i.test(navigator.userAgent)&&!/Mobile/i.test(navigator.userAgent)}},{key:"isAndroid",value:function(t){return!t&&this._getSelectedPlatform()?"android"===this._getSelectedPlatform():"object"!==("undefined"==typeof device?"undefined":u(device))||/browser/i.test(device.platform)?/Android/i.test(navigator.userAgent):/Android/i.test(device.platform)}},{key:"isWP",value:function(t){return!t&&this._getSelectedPlatform()?"wp"===this._getSelectedPlatform():"object"!==("undefined"==typeof device?"undefined":u(device))||/browser/i.test(device.platform)?/Windows Phone|IEMobile|WPDesktop/i.test(navigator.userAgent):/Win32NT|WinCE/i.test(device.platform)}},{key:"isBlackBerry",value:function(t){return!t&&this._getSelectedPlatform()?"blackberry"===this._getSelectedPlatform():"object"!==("undefined"==typeof device?"undefined":u(device))||/browser/i.test(device.platform)?/BlackBerry|RIM Tablet OS|BB10/i.test(navigator.userAgent):/BlackBerry/i.test(device.platform)}},{key:"isOpera",value:function(t){return!t&&this._getSelectedPlatform()?"opera"===this._getSelectedPlatform():!!window.opera||0<=navigator.userAgent.indexOf(" OPR/")}},{key:"isFirefox",value:function(t){return!t&&this._getSelectedPlatform()?"firefox"===this._getSelectedPlatform():"undefined"!=typeof InstallTrigger}},{key:"isSafari",value:function(t){return!t&&this._getSelectedPlatform()?"safari"===this._getSelectedPlatform():0<Object.prototype.toString.call(window.HTMLElement).indexOf("Constructor")||"[object SafariRemoteNotification]"===(!window.safari||safari.pushNotification).toString()}},{key:"isChrome",value:function(t){return!t&&this._getSelectedPlatform()?"chrome"===this._getSelectedPlatform():!(!window.chrome||window.opera||0<=navigator.userAgent.indexOf(" OPR/")||0<=navigator.userAgent.indexOf(" Edge/"))}},{key:"isIE",value:function(t){return!t&&this._getSelectedPlatform()?"ie"===this._getSelectedPlatform():!!document.documentMode}},{key:"isEdge",value:function(t){return!t&&this._getSelectedPlatform()?"edge"===this._getSelectedPlatform():0<=navigator.userAgent.indexOf(" Edge/")}},{key:"getMobileOS",value:function(){return this.isAndroid()?"android":this.isIOS()?"ios":this.isWP()?"wp":"other"}},{key:"getIOSDevice",value:function(){return this.isIPhone()?"iphone":this.isIPad()?"ipad":this.isIPod()?"ipod":"na"}}]),t}()),v=function(t){return W.throw("In PageAttributeExpression: "+t)},o={_variables:{},defineVariable:function(t,e){var n=2<arguments.length&&void 0!==arguments[2]&&arguments[2];"string"!=typeof t?v("Variable name must be a string"):"string"!=typeof e&&"function"!=typeof e?v("Variable value must be a string or a function"):this._variables.hasOwnProperty(t)&&!n&&v('"'+t+'" is already defined'),this._variables[t]=e},getVariable:function(t){return this._variables.hasOwnProperty(t)?this._variables[t]:null},removeVariable:function(t){delete this._variables[t]},getAllVariables:function(){return this._variables},_parsePart:function(t){var e=void 0,n=!1,i=0,o=[];0===t.length&&v("Unable to parse empty string");for(var r=0;r<t.length;r++){if("$"===(e=t.charAt(r))&&"{"===t.charAt(r+1))n&&v("Nested interpolation not supported"),0<t.substring(i,r).length&&o.push(t.substring(i,r)),i=r,n=!0;else if("}"===e){n||v("} must be preceeded by ${"),0<t.substring(i,r+1).length&&o.push(t.substring(i,r+1)),i=r+1,n=!1}}return n&&v("Unterminated interpolation"),o.push(t.substring(i,t.length)),o},_replaceToken:function(t){var e=t.match(/^\${(.*?)}$/);if(!e)return t;var n=e[1].trim(),i=this.getVariable(n);if(null!==i){if("string"==typeof i)return i;var o=i();return"string"!=typeof o&&v("Must return a string"),o}v('Variable "'+n+'" does not exist')},_replaceTokens:function(t){return t.map(this._replaceToken.bind(this))},_parseExpression:function(t){return t.split(",").map(function(t){return t.trim()}).map(this._parsePart.bind(this)).map(this._replaceTokens.bind(this)).map(function(t){return t.join("")})},evaluate:function(t){return t?this._parseExpression(t):[]}};o.defineVariable("mobileOS",c.getMobileOS()),o.defineVariable("iOSDevice",c.getIOSDevice()),o.defineVariable("runtime",function(){return c.isWebView()?"cordova":"browser"});var b={config:{autoStatusBarFill:!0,animationsDisabled:!1,warningsDisabled:!1}};b.nullElement=window.document.createElement("div"),b.isEnabledAutoStatusBarFill=function(){return!!b.config.autoStatusBarFill},b.normalizePageHTML=function(t){return(""+t).trim()},b.waitDOMContentLoaded=function(e){if("loading"===window.document.readyState||"uninitialized"==window.document.readyState){window.document.addEventListener("DOMContentLoaded",function t(){e(),window.document.removeEventListener("DOMContentLoaded",t)})}else setImmediate(e)},b.autoStatusBarFill=function(e){var t=function t(){b.shouldFillStatusBar()&&e(),document.removeEventListener("deviceready",t)};"object"===("undefined"==typeof device?"undefined":u(device))?document.addEventListener("deviceready",t):-1===["complete","interactive"].indexOf(document.readyState)?b.waitDOMContentLoaded(t):t()},b.shouldFillStatusBar=function(){return b.isEnabledAutoStatusBarFill()&&(c.isWebView()&&c.isIOS7above()&&!c.isIPhoneX()||document.body.querySelector(".ons-status-bar-mock.ios"))},b.templateStore={_storage:{},get:function(t){return b.templateStore._storage[t]||null},set:function(t,e){b.templateStore._storage[t]=e}},window.document.addEventListener("_templateloaded",function(t){"ons-template"===t.target.nodeName.toLowerCase()&&b.templateStore.set(t.templateId,t.template)},!1),b.waitDOMContentLoaded(function(){function t(t){for(var e=window.document.querySelectorAll(t),n=0;n<e.length;n++)b.templateStore.set(e[n].getAttribute("id"),e[n].textContent||e[n].content)}t('script[type="text/ons-template"]'),t('script[type="text/template"]'),t('script[type="text/ng-template"]'),t("template")}),b.getTemplateHTMLAsync=function(s){return new Promise(function(r,a){b.waitDOMContentLoaded(function(){var t=b.templateStore.get(s);if(t){if(t instanceof DocumentFragment)return r(t);var e="string"==typeof t?t:t[1];return r(b.normalizePageHTML(e))}var n=window.document.getElementById(s);if(n){var i=n.textContent||n.content;return r(i)}var o=new XMLHttpRequest;o.open("GET",s,!0),o.onload=function(){var t=o.responseText;if(400<=o.status&&o.status<600)a(t);else{var e=W.createFragment(t);W.arrayFrom(e.querySelectorAll("script")).forEach(function(t){var e=document.createElement("script");e.type=t.type||"text/javascript",e.appendChild(document.createTextNode(t.text||t.textContent||t.innerHTML)),t.parentNode.replaceChild(e,t)}),b.templateStore.set(s,e),r(e)}},o.onerror=function(){W.throw("Page template not found: "+s)},o.send(null)})})},b.getPageHTMLAsync=function(t){var n=o.evaluate(t);return function e(t){return"string"!=typeof t?Promise.reject("Must specify a page."):b.getTemplateHTMLAsync(t).catch(function(t){return 0===n.length?Promise.reject(t):e(n.shift())})}(n.shift())};var y=function(){function e(t){h(this,e),this._animators=t.animators,this._baseClass=t.baseClass,this._baseClassName=t.baseClassName||t.baseClass.name,this._animation=t.defaultAnimation||"default",this._animationOptions=t.defaultAnimationOptions||{},this._animators[this._animation]||W.throw("No such animation: "+this._animation)}return d(e,[{key:"setAnimationOptions",value:function(t){this._animationOptions=t}},{key:"newAnimator",value:function(){var t=0<arguments.length&&void 0!==arguments[0]?arguments[0]:{},e=arguments[1],n=null;if(t.animation instanceof this._baseClass)return t.animation;var i=null;if("string"==typeof t.animation&&(i=this._animators[t.animation]),!i&&e)n=e;else{i=i||this._animators[this._animation];var o=W.extend({},this._animationOptions,t.animationOptions||{},b.config.animationsDisabled?{duration:0,delay:0}:{});"function"==typeof(n=new i(o))&&(n=new n(o))}return n instanceof this._baseClass||W.throw('"animator" is not an instance of '+this._baseClassName),n}}],[{key:"parseAnimationOptionsString",value:function(e){try{if("string"==typeof e){var t=W.animationOptionsParse(e);if("object"===(void 0===t?"undefined":u(t))&&null!==t)return t;console.error('"animation-options" attribute must be a JSON object string: '+e)}return{}}catch(t){return console.error('"animation-options" attribute must be a JSON object string: '+e),{}}}}]),e}(),k=!0,w={quiet:"material--flat",light:"material--flat",outline:"material--flat",cta:"","large--quiet":"material--flat large","large--cta":"large",noborder:"",tappable:""},E={android:function(t){var e=t.tagName.toLowerCase();if(!W.hasModifier(t,"material")){var n=(t.getAttribute("modifier")||"").trim().split(/\s+/).map(function(t){return w.hasOwnProperty(t)?w[t]:t});n.unshift("material"),t.setAttribute("modifier",n.join(" ").trim())}-1===["ons-alert-dialog-button","ons-toolbar-button","ons-back-button","ons-button","ons-list-item","ons-fab","ons-speed-dial","ons-speed-dial-item","ons-tab"].indexOf(e)||t.hasAttribute("ripple")||t.querySelector("ons-ripple")||("ons-list-item"===e?t.hasAttribute("tappable")&&(t.setAttribute("ripple",""),t.removeAttribute("tappable")):t.setAttribute("ripple",""))},ios:function(t){W.removeModifier(t,"material")&&(W.removeModifier(t,"material--flat")&&W.addModifier(t,W.removeModifier(t,"large")?"large--quiet":"quiet"),t.getAttribute("modifier")||t.removeAttribute("modifier")),t.hasAttribute("ripple")&&("ons-list-item"===t.tagName.toLowerCase()&&t.setAttribute("tappable",""),t.removeAttribute("ripple"))}},C={android:!0},A=function(t,e){if(k&&!t.hasAttribute("disable-auto-styling")){var n=c.getMobileOS();if(E.hasOwnProperty(n)&&(C.hasOwnProperty(n)||e))return n}return null},S=function(t,e,n){return A(e,n)?t.split(/\s+/).map(function(t){return w.hasOwnProperty(t)?w[t]:t}).join(" "):t},P={isEnabled:function(){return k},enable:function(){return k=!0},disable:function(){return k=!1},prepare:function(t,e){var n=A(t,e);n&&E[n](t)},mapModifier:S,getPlatform:A,restoreModifier:function(t){if("android"===A(t)){var e=t.getAttribute("modifier")||"",n=S(e,t);if(/(^|\s+)material($|\s+)/i.test(e)||(n="material "+n),n!==e)return t.setAttribute("modifier",n.trim()),!0}return!1}},O=function(){function a(){h(this,a)}return d(a,null,[{key:"diff",value:function(n,i){n=e((""+n).trim()),i=e((""+i).trim());var t=Object.keys(n).reduce(function(t,e){return i[e]||t.push(e),t},[]);return{added:Object.keys(i).reduce(function(t,e){return n[e]||t.push(e),t},[]),removed:t};function e(t){var e={};return a.split(t).forEach(function(t){return e[t]=t}),e}}},{key:"applyDiffToClassList",value:function(t,e,n){t.added.map(function(t){return n.replace(/\*/g,t)}).forEach(function(t){return t.split(/\s+/).forEach(function(t){return e.add(t)})}),t.removed.map(function(t){return n.replace(/\*/g,t)}).forEach(function(t){return t.split(/\s+/).forEach(function(t){return e.remove(t)})})}},{key:"applyDiffToElement",value:function(i,o,r){Object.keys(r).forEach(function(t){for(var e=!t||W.match(o,t)?[o]:Array.prototype.filter.call(o.querySelectorAll(t),function(t){return!W.findParent(t,o.tagName,function(t){return t===o})}),n=0;n<e.length;n++)a.applyDiffToClassList(i,e[n].classList,r[t])})}},{key:"onModifierChanged",value:function(t,e,n,i){a.applyDiffToElement(a.diff(t,e),n,i),P.restoreModifier(n)}},{key:"refresh",value:function(t,e){a.applyDiffToElement(a.diff("",t.getAttribute("modifier")||""),t,e)}},{key:"initModifier",value:function(t,e){var n=t.getAttribute("modifier");"string"==typeof n&&a.applyDiffToElement({removed:[],added:a.split(n)},t,e)}},{key:"split",value:function(t){return"string"!=typeof t?[]:t.trim().split(/ +/).filter(function(t){return""!==t})}},{key:"addModifier",value:function(t,e){if(t.hasAttribute("modifier")){var n=a.split(t.getAttribute("modifier"));-1==n.indexOf(e)&&(n.push(e),t.setAttribute("modifier",n.join(" ")))}else t.setAttribute("modifier",e)}},{key:"removeModifier",value:function(t,e){if(t.hasAttribute("modifier")){var n=a.split(t.getAttribute("modifier")),i=n.indexOf(e);-1!==i&&(n.splice(i,1),t.setAttribute("modifier",n.join(" ")))}}}]),a}(),x={_ready:!1,_domContentLoaded:!1,_onDOMContentLoaded:function(){x._domContentLoaded=!0,c.isWebView()?window.document.addEventListener("deviceready",function(){x._ready=!0},!1):x._ready=!0},addBackButtonListener:function(t){if(!this._domContentLoaded)throw new Error("This method is available after DOMContentLoaded");this._ready?window.document.addEventListener("backbutton",t,!1):window.document.addEventListener("deviceready",function(){window.document.addEventListener("backbutton",t,!1)})},removeBackButtonListener:function(t){if(!this._domContentLoaded)throw new Error("This method is available after DOMContentLoaded");this._ready?window.document.removeEventListener("backbutton",t,!1):window.document.addEventListener("deviceready",function(){window.document.removeEventListener("backbutton",t,!1)})}};window.addEventListener("DOMContentLoaded",function(){return x._onDOMContentLoaded()},!1);var T,L={_store:{},_genId:(T=0,function(){return T++}),set:function(t,e){t.dataset.deviceBackButtonHandlerId&&this.remove(t);var n=t.dataset.deviceBackButtonHandlerId=L._genId();this._store[n]=e},remove:function(t){t.dataset.deviceBackButtonHandlerId&&(delete this._store[t.dataset.deviceBackButtonHandlerId],delete t.dataset.deviceBackButtonHandlerId)},get:function(t){if(t.dataset.deviceBackButtonHandlerId){var e=t.dataset.deviceBackButtonHandlerId;if(!this._store[e])throw new Error;return this._store[e]}},has:function(t){if(!t.dataset)return!1;var e=t.dataset.deviceBackButtonHandlerId;return!!this._store[e]}},M=new(function(){function t(){h(this,t),this._isEnabled=!1,this._boundCallback=this._callback.bind(this)}return d(t,[{key:"enable",value:function(){this._isEnabled||(x.addBackButtonListener(this._boundCallback),this._isEnabled=!0)}},{key:"disable",value:function(){this._isEnabled&&(x.removeBackButtonListener(this._boundCallback),this._isEnabled=!1)}},{key:"fireDeviceBackButtonEvent",value:function(){var t=document.createEvent("Event");t.initEvent("backbutton",!0,!0),document.dispatchEvent(t)}},{key:"_callback",value:function(){this._dispatchDeviceBackButtonEvent()}},{key:"createHandler",value:function(t,e){if(!(t instanceof HTMLElement))throw new Error("element must be an instance of HTMLElement");if(!(e instanceof Function))throw new Error("callback must be an instance of Function");var n={_callback:e,_element:t,disable:function(){L.remove(t)},setListener:function(t){this._callback=t},enable:function(){L.set(t,this)},isEnabled:function(){return L.get(t)===this},destroy:function(){L.remove(t),this._callback=this._element=null}};return n.enable(),n}},{key:"_dispatchDeviceBackButtonEvent",value:function(){var t=this._captureTree(),e=this._findHandlerLeafElement(t),n=L.get(e);n._callback(function e(t){return{_element:t,callParentHandler:function(){for(var t=this._element.parentNode;t;){if(n=L.get(t))return n._callback(e(t));t=t.parentNode}}}}(e))}},{key:"_captureTree",value:function(){return function n(t){var e={element:t,children:Array.prototype.concat.apply([],r(t.children).map(function(t){if("none"===t.style.display||!1===t._isShown)return[];if(0===t.children.length&&!L.has(t))return[];var e=n(t);return 0!==e.children.length||L.has(e.element)?[e]:[]}))};if(!L.has(e.element))for(var i=0;i<e.children.length;i++){var o=e.children[i];if(L.has(o.element))return o}return e}(document.body);function r(t){for(var e=[],n=0;n<t.length;n++)e.push(t[n]);return e}}},{key:"_findHandlerLeafElement",value:function(t){return function t(e){if(0===e.children.length)return e.element;if(1===e.children.length)return t(e.children[0]);return e.children.map(function(t){return t.element}).reduce(function(t,e){if(!t)return e;var n=parseInt(window.getComputedStyle(t,"").zIndex,10),i=parseInt(window.getComputedStyle(e,"").zIndex,10);if(!isNaN(n)&&!isNaN(i))return i<n?t:e;throw new Error("Capturing backbutton-handler is failure.")},null)}(t)}}]),t}());b.AnimatorFactory=y,b.ModifierUtil=O,b.dbbDispatcher=M;var D=function(t,e){return t.substr(0,e.length)===e},I=function(t,e){return t.substr(t.length-e.length,e.length)===e},N=function(t){return t.slice(1,-1)},B=function(t){return D(t,"{")&&I(t,"}")},j=function(t){return D(t,"[")&&I(t,"]")},H=function(t){return D(t,"'")&&I(t,"'")||D(t,'"')&&I(t,'"')},R=function(t,e,n){throw new Error("Unexpected token '"+t+"' at position "+(n.length-e.length-1)+" in string: '"+n+"'")},F=function(t,e,n){return"true"===t||"false"===t?"true"===t:H(t)?N(t):isNaN(t)?B(t)?z(N(t)):j(t)?V(N(t)):void R(t,e,n):+t},q=function(t){var e=(t=t.trim()).length;if(":"===t[0]||","===t[0])e=1;else if("{"===t[0]||"["===t[0]){for(var n=t.charCodeAt(0),i=1,o=1;o<t.length;o++)if(t.charCodeAt(o)===n)i++;else if(t.charCodeAt(o)===n+2&&0===--i){e=o+1;break}}else if("'"===t[0]||'"'===t[0]){for(var r=1;r<t.length;r++)if(t[r]===t[0]){e=r+1;break}}else for(var a=1;a<t.length;a++)if(-1!==[" ",",",":"].indexOf(t[a])){e=a;break}return t.slice(0,e)},z=function(t){for(var e=t=t.trim(),n={},i=!0,o=void 0,r=void 0,a=void 0;0<t.length;)if(r=a,a=q(t),t=t.slice(a.length,t.length).trim(),":"===a&&(!i||!r||","===r)||","===a&&i||":"!==a&&","!==a&&r&&","!==r&&":"!==r)R(a,t,e);else if(":"===a&&i&&r){if(r=H(r)?N(r):r,!/^[A-Z_$][A-Z0-9_$]*$/i.test(r))throw new Error("Invalid key token '"+r+"' at position 0 in string: '"+e+"'");o=r,i=!1}else","===a&&!i&&r&&(n[o]=F(r,t,e),i=!0);return a&&(n[o]=F(a,t,e)),n},V=function(t){for(var e=t=t.trim(),n=[],i=void 0,o=void 0;0<t.length;)i=o,o=q(t),t=t.slice(o.length,t.length).trim(),","!==o||i&&","!==i?","===o&&n.push(F(i,t,e)):R(o,t,e);return o&&(","!==o?n.push(F(o,t,e)):R(o,t,e)),n},W={},U="[Onsen UI]";W.globals={fabOffset:0,errorPrefix:U,supportsPassive:!1},c._runOnActualPlatform(function(){W.globals.actualMobileOS=c.getMobileOS(),W.globals.isUIWebView=c.isUIWebView(),W.globals.isWKWebView=c.isWKWebView()});try{var X=Object.defineProperty({},"passive",{get:function(){W.globals.supportsPassive=!0}});window.addEventListener("testPassive",null,X),window.removeEventListener("testPassive",null,X)}catch(t){}W.addEventListener=function(t,e,n,i,o){t.addEventListener(e,n,W.globals.supportsPassive?i:(i||{}).capture)},W.removeEventListener=function(t,e,n,i,o){t.removeEventListener(e,n,W.globals.supportsPassive?i:(i||{}).capture)},W.prepareQuery=function(e){return e instanceof Function?e:function(t){return W.match(t,e)}},W.match=function(t,e){return(t.matches||t.webkitMatchesSelector||t.mozMatchesSelector||t.msMatchesSelector).call(t,e)},W.findChild=function(t,e){for(var n=W.prepareQuery(e),i=0;i<t.childNodes.length;i++){var o=t.childNodes[i];if(o.nodeType===Node.ELEMENT_NODE&&n(o))return o}return null},W.findParent=function(t,e,n){for(var i=W.prepareQuery(e),o=t.parentNode;;){if(!o||o===document||o instanceof DocumentFragment||n&&n(o))return null;if(i(o))return o;o=o.parentNode}},W.isAttached=function(t){return document.body.contains(t)},W.hasAnyComponentAsParent=function(t){for(;t&&document.documentElement!==t;)if((t=t.parentNode)&&t.nodeName.toLowerCase().match(/(ons-navigator|ons-tabbar|ons-modal)/))return!0;return!1},W.getAllChildNodes=function(t){var e;return(e=[t]).concat.apply(e,_(Array.from(t.children).map(function(t){return W.getAllChildNodes(t)})))},W.isPageControl=function(t){return t.nodeName.match(/^ons-(navigator|splitter|tabbar|page)$/i)},W.propagateAction=function(t,e){for(var n=0;n<t.childNodes.length;n++){var i=t.childNodes[n];i[e]instanceof Function?i[e]():W.propagateAction(i,e)}},W.camelize=function(t){return t.toLowerCase().replace(/-([a-z])/g,function(t,e){return e.toUpperCase()})},W.hyphenate=function(t){return t.replace(/([a-zA-Z])([A-Z])/g,"$1-$2").toLowerCase()},W.create=function(){var t=0<arguments.length&&void 0!==arguments[0]?arguments[0]:"",e=1<arguments.length&&void 0!==arguments[1]?arguments[1]:{},n=t.split("."),i=document.createElement(n.shift()||"div");return n.length&&(i.className=n.join(" ")),l(i,e),i},W.createElement=function(t){var e=document.createElement("div");t instanceof DocumentFragment?e.appendChild(document.importNode(t,!0)):e.innerHTML=t.trim(),1<e.children.length&&W.throw("HTML template must contain a single root element");var n=e.children[0];return e.children[0].remove(),n},W.createFragment=function(t){var e=document.createElement("template");return e.innerHTML=t,document.importNode(e.content,!0)},W.extend=function(t){for(var e=arguments.length,n=Array(1<e?e-1:0),i=1;i<e;i++)n[i-1]=arguments[i];for(var o=0;o<n.length;o++)if(n[o])for(var r=Object.keys(n[o]),a=0;a<r.length;a++){var s=r[a];t[s]=n[o][s]}return t},W.arrayFrom=function(t){return Array.prototype.slice.apply(t)},W.parseJSONObjectSafely=function(t){var e=1<arguments.length&&void 0!==arguments[1]?arguments[1]:{};try{var n=JSON.parse(""+t);if("object"===(void 0===n?"undefined":u(n))&&null!==n)return n}catch(t){return e}return e},W.findFromPath=function(t){t=t.split(".");for(var e,n=window;e=t.shift();)n=n[e];return n},W.getTopPage=function(t){return t&&("ons-page"===t.tagName.toLowerCase()?t:t.topPage)||null},W.findToolbarPage=function(t){var e=W.getTopPage(t);if(e){if(e._canAnimateToolbar())return e;for(var n=0;n<e._contentElement.children.length;n++){var i=W.getTopPage(e._contentElement.children[n]);if(i&&!/ons-tabbar/i.test(e._contentElement.children[n].tagName))return W.findToolbarPage(i)}}return null},W.triggerElementEvent=function(t,e){var n=2<arguments.length&&void 0!==arguments[2]?arguments[2]:{},i=new CustomEvent(e,{bubbles:!0,cancelable:!0,detail:n});return Object.keys(n).forEach(function(t){i[t]=n[t]}),t.dispatchEvent(i),i},W.hasModifier=function(t,e){return!!t.hasAttribute("modifier")&&RegExp("(^|\\s+)"+e+"($|\\s+)","i").test(t.getAttribute("modifier"))},W.addModifier=function(t,e){var n=2<arguments.length&&void 0!==arguments[2]?arguments[2]:{};return n.autoStyle&&(e=P.mapModifier(e,t,n.forceAutoStyle)),!W.hasModifier(t,e)&&(t.setAttribute("modifier",((t.getAttribute("modifier")||"")+" "+e).trim()),!0)},W.removeModifier=function(t,e){var n=2<arguments.length&&void 0!==arguments[2]?arguments[2]:{};if(n.autoStyle&&(e=P.mapModifier(e,t,n.forceAutoStyle)),!t.getAttribute("modifier")||!W.hasModifier(t,e))return!1;var i=t.getAttribute("modifier").split(/\s+/).filter(function(t){return t&&t!==e});return i.length?t.setAttribute("modifier",i.join(" ")):t.removeAttribute("modifier"),!0},W.toggleModifier=function(){var t=2<arguments.length?arguments.length<=2?void 0:arguments[2]:{},e="boolean"==typeof t?t:t.force;("boolean"==typeof e?e:!W.hasModifier.apply(W,arguments))?W.addModifier.apply(W,arguments):W.removeModifier.apply(W,arguments)},W.restoreClass=function(e,t,n){t.split(/\s+/).forEach(function(t){return""!==t&&!e.classList.contains(t)&&e.classList.add(t)}),e.hasAttribute("modifier")&&O.refresh(e,n)},W.updateParentPosition=function(t){!t._parentUpdated&&t.parentElement&&("static"===window.getComputedStyle(t.parentElement).getPropertyValue("position")&&(t.parentElement.style.position="relative"),t._parentUpdated=!0)},W.toggleAttribute=function(t,e,n){n?t.setAttribute(e,"boolean"==typeof n?"":n):t.removeAttribute(e)},W.bindListeners=function(n,t){t.forEach(function(t){var e=t.replace(/^_[a-z]/,"_bound"+t[1].toUpperCase());n[e]=n[e]||n[t].bind(n)})},W.each=function(e,n){return Object.keys(e).forEach(function(t){return n(t,e[t])})},W.updateRipple=function(t,e){var n=2<arguments.length&&void 0!==arguments[2]?arguments[2]:{};void 0===e&&(e=t.hasAttribute("ripple"));var i=W.findChild(t,"ons-ripple");if(e){if(!i){var o=document.createElement("ons-ripple");Object.keys(n).forEach(function(t){return o.setAttribute(t,n[t])}),t.insertBefore(o,t.firstChild)}}else i&&i.remove()},W.animationOptionsParse=function(t){if(t=t.trim(),B(t))return z(N(t));if(j(t))return V(N(t));throw new Error("Provided string must be object or array like: "+t)},W.isInteger=function(t){return"number"==typeof t&&isFinite(t)&&Math.floor(t)===t},W.defer=function(){var n={};return n.promise=new Promise(function(t,e){n.resolve=t,n.reject=e}),n},W.warn=function(){for(var t=arguments.length,e=Array(t),n=0;n<t;n++)e[n]=arguments[n];var i;b.config.warningsDisabled||(i=console).warn.apply(i,[U].concat(e))},W.throw=function(t){throw new Error(U+" "+t)},W.throwAbstract=function(){return W.throw("Cannot instantiate abstract class")},W.throwMember=function(){return W.throw("Class member must be implemented")},W.throwPageLoader=function(){return W.throw("First parameter should be an instance of PageLoader")},W.throwAnimator=function(t){return W.throw('"Animator" param must inherit '+t+"Animator")};var Y=function(t){return t.cancelable&&t.preventDefault()};W.iosPreventScroll=function(n){if("ios"===W.globals.actualMobileOS){n.on("touchmove",Y),n.on("dragend",function t(e){n.off("touchmove",Y),n.off("dragend",t)})}},W.iosPageScrollFix=function(t){"ios"===W.globals.actualMobileOS&&(document.body.classList.toggle("ons-ios-scroll",t),W.globals.isUIWebView&&!b.config.forceUIWebViewScrollFix||document.body.classList.toggle("ons-ios-scroll-fix",t))},W.iosMaskScrollFix=function(t,e){W.globals.isUIWebView&&t[(e?"add":"remove")+"EventListener"]("touchmove",Y,!1)},W.isValidGesture=function(t){return void 0!==t.gesture&&(t.gesture.distance<=15||t.gesture.deltaTime<=100)},W.checkMissingImport=function(){for(var t=arguments.length,e=Array(t),n=0;n<t;n++)e[n]=arguments[n];e.forEach(function(t){i[t]||W.throw("Ons"+t+" is required but was not imported (Custom Elements)")})};var G,$,K,Q,J={};J.capitalize=function(t){return t.charAt(0).toUpperCase()+t.slice(1)},J.buildTransitionValue=function(e){return e.property=e.property||"all",e.duration=e.duration||.4,e.timing=e.timing||"linear",e.property.split(/ +/).map(function(t){return t+" "+e.duration+"s "+e.timing}).join(", ")},J.onceOnTransitionEnd=function(e,n){if(!e)return function(){};var i=function(t){e==t.target&&(t.stopPropagation(),o(),n())},o=function(){J._transitionEndEvents.forEach(function(t){e.removeEventListener(t,i,!1)})};return J._transitionEndEvents.forEach(function(t){e.addEventListener(t,i,!1)}),o},J._transitionEndEvents="ontransitionend"in window?["transitionend"]:"onwebkittransitionend"in window?["webkitTransitionEnd"]:"webkit"===J.vendorPrefix||"o"===J.vendorPrefix||"moz"===J.vendorPrefix||"ms"===J.vendorPrefix?[J.vendorPrefix+"TransitionEnd","transitionend"]:[],J._cssPropertyDict=function(){for(var t=window.getComputedStyle(document.documentElement,""),e={},n="A".charCodeAt(0),i="z".charCodeAt(0),o=function(t){return t.substr(1).toUpperCase()},r=0;r<t.length;r++){var a=t[r].replace(/^[-]+/,"").replace(/[-][a-z]/g,o).replace(/^moz/,"Moz");n<=a.charCodeAt(0)&&i>=a.charCodeAt(0)&&"cssText"!==a&&"parentText"!==a&&(e[a]=!0)}return e}(),J.hasCssProperty=function(t){return t in J._cssPropertyDict},J.vendorPrefix=(G=window.getComputedStyle(document.documentElement,""),(Array.prototype.slice.call(G).join("").match(/-(moz|webkit|ms)-/)||""===G.OLink&&["","o"])[1]),J.forceLayoutAtOnce=function(t,e){this.batchImmediate(function(){t.forEach(function(t){t.offsetHeight}),e()})},J.batchImmediate=($=[],function(t){0===$.length&&setImmediate(function(){var t=$.slice(0);$=[],t.forEach(function(t){t()})}),$.push(t)}),J.batchAnimationFrame=(K=[],Q=window.requestAnimationFrame||window.webkitRequestAnimationFrame||window.mozRequestAnimationFrame||window.oRequestAnimationFrame||window.msRequestAnimationFrame||function(t){setTimeout(t,1e3/60)},function(t){0===K.length&&Q(function(){var t=K.slice(0);K=[],t.forEach(function(t){t()})}),K.push(t)}),J.transitionPropertyName=function(){if(J.hasCssProperty("transitionDuration"))return"transition";if(J.hasCssProperty(J.vendorPrefix+"TransitionDuration"))return J.vendorPrefix+"Transition";throw new Error("Invalid state")}();var Z,tt,et,nt,it=function t(e,n){if(!(this instanceof t))return new t(e,n);if(e instanceof HTMLElement)this.elements=[e];else{if("[object Array]"!==Object.prototype.toString.call(e))throw new Error("First argument must be an array or an instance of HTMLElement.");this.elements=e}this.defaults=n,this.transitionQueue=[],this.lastStyleAttributeDict=[]};it.prototype={transitionQueue:void 0,elements:void 0,defaults:void 0,play:function(e){return"function"==typeof e&&this.transitionQueue.push(function(t){e(),t()}),this.startAnimation(),this},default:function(t,e,n){function i(t,e,n){return void 0!==t.duration&&(e=t.duration),void 0!==t.timing&&(n=t.timing),{css:t.css||t,duration:e,timing:n}}return this.saveStyle().queue(i(t,0,this.defaults.timing)).wait(void 0===n?this.defaults.delay:n).queue(i(e,this.defaults.duration,this.defaults.timing)).restoreStyle()},queue:function(t,e){var n=this.transitionQueue;if(t&&e&&(e.css=t,t=new it.Transition(e)),t instanceof Function||t instanceof it.Transition||(t=t.css?new it.Transition(t):new it.Transition({css:t})),t instanceof Function)n.push(t);else{if(!(t instanceof it.Transition))throw new Error("Invalid arguments");n.push(t.build())}return this},wait:function(e){return 0<e&&this.transitionQueue.push(function(t){setTimeout(t,1e3*e)}),this},saveStyle:function(){return this.transitionQueue.push(function(t){this.elements.forEach(function(t,e){for(var n=this.lastStyleAttributeDict[e]={},i=0;i<t.style.length;i++)n[t.style[i]]=t.style[t.style[i]]}.bind(this)),t()}.bind(this)),this},restoreStyle:function(r){var a=this;if((r=r||{}).transition&&!r.duration)throw new Error('"options.duration" is required when "options.transition" is enabled.');var s=J.transitionPropertyName;if(r.transition||r.duration&&0<r.duration){var l=r.transition||"all "+r.duration+"s "+(r.timing||"linear");this.transitionQueue.push(function(t){var e,n=this.elements,i=function(){n.forEach(function(t){t.style[s]=""})},o=J.onceOnTransitionEnd(n[0],function(){clearTimeout(e),i(),t()});e=setTimeout(function(){o(),i(),t()},1e3*r.duration*1.4),n.forEach(function(e,t){var n,i=a.lastStyleAttributeDict[t];if(!i)throw new Error("restoreStyle(): The style is not saved. Invoke saveStyle() before.");a.lastStyleAttributeDict[t]=void 0;for(var o=0,r=e.style.length;o<r;o++)n=e.style[o],void 0===i[n]&&(i[n]="");e.style[s]=l,Object.keys(i).forEach(function(t){t!==s&&(e.style[t]=i[t])}),e.style[s]=l})})}else this.transitionQueue.push(function(t){a.elements.forEach(function(e,t){e.style[s]="none";var n=a.lastStyleAttributeDict[t];if(!n)throw new Error("restoreStyle(): The style is not saved. Invoke saveStyle() before.");a.lastStyleAttributeDict[t]=void 0;for(var i=0;i<e.style.length;i++)e.style[i],void 0===n[e.style[i]]&&(n[e.style[i]]="");Object.keys(n).forEach(function(t){e.style[t]=n[t]})}),t()});return this},startAnimation:function(){return this._dequeueTransition(),this},_dequeueTransition:function(){var t=this.transitionQueue.shift();if(this._currentTransition)throw new Error("Current transition exists.");this._currentTransition=t;var e=this,n=!1;t&&t.call(this,function(){if(n)throw new Error("Invalid state: This callback is called twice.");n=!0,e._currentTransition=void 0,e._dequeueTransition()})}},it.runAll=function(){for(var t=0;t<arguments.length;t++)arguments[t].play()},(it.Transition=function(t){this.options=t||{},this.options.duration=this.options.duration||0,this.options.timing=this.options.timing||"linear",this.options.css=this.options.css||{},this.options.property=this.options.property||"all"}).prototype={build:function(){if(0===Object.keys(this.options.css).length)throw new Error("options.css is required.");var i,o,r=(i=this.options.css,o={},Object.keys(i).forEach(function(t){var e=i[t];if(J.hasCssProperty(t))o[t]=e;else{var n=J.vendorPrefix+J.capitalize(t);J.hasCssProperty(n)?o[n]=e:(o[n]=e,o[t]=e)}}),o);if(0<this.options.duration){var a=J.buildTransitionValue(this.options),s=this;return function(t){var e,n=this.elements,i=1e3*s.options.duration*1.4,o=J.onceOnTransitionEnd(n[0],function(){clearTimeout(e),t()});e=setTimeout(function(){o(),t()},i),n.forEach(function(e){e.style[J.transitionPropertyName]=a,Object.keys(r).forEach(function(t){e.style[t]=r[t]})})}}if(this.options.duration<=0)return function(t){var e=this.elements;e.forEach(function(e){e.style[J.transitionPropertyName]="",Object.keys(r).forEach(function(t){e.style[t]=r[t]})}),0<e.length?J.forceLayoutAtOnce(e,function(){J.batchAnimationFrame(t)}):J.batchAnimationFrame(t)}}};var ot=function t(e,n){return new t.Instance(e,n||{})};ot.defaults={behavior:{touchAction:"pan-y",touchCallout:"none",contentZooming:"none",userDrag:"none",tapHighlightColor:"rgba(0,0,0,0)"}},ot.DOCUMENT=document,ot.HAS_POINTEREVENTS=navigator.pointerEnabled||navigator.msPointerEnabled,ot.HAS_TOUCHEVENTS="ontouchstart"in window,ot.IS_MOBILE=/mobile|tablet|ip(ad|hone|od)|android|silk/i.test(navigator.userAgent),ot.NO_MOUSEEVENTS=ot.HAS_TOUCHEVENTS&&ot.IS_MOBILE||ot.HAS_POINTEREVENTS,ot.CALCULATE_INTERVAL=25;var rt,at,st,lt,ut,ct,ht,dt={},ft=ot.DIRECTION_DOWN="down",pt=ot.DIRECTION_LEFT="left",gt=ot.DIRECTION_UP="up",mt=ot.DIRECTION_RIGHT="right",_t=ot.POINTER_MOUSE="mouse",vt=ot.POINTER_TOUCH="touch",bt=ot.POINTER_PEN="pen",yt=ot.EVENT_START="start",kt=ot.EVENT_MOVE="move",wt=ot.EVENT_END="end",Et=ot.EVENT_RELEASE="release",Ct=ot.EVENT_TOUCH="touch";ot.READY=!1,ot.plugins=ot.plugins||{},ot.gestures=ot.gestures||{},tt=ot.utils={extend:function(t,e,n){for(var i in e)!e.hasOwnProperty(i)||void 0!==t[i]&&n||(t[i]=e[i]);return t},on:function(t,e,n,i){W.addEventListener(t,e,n,i,!0)},off:function(t,e,n,i){W.removeEventListener(t,e,n,i,!0)},each:function(t,e,n){var i,o;if("forEach"in t)t.forEach(e,n);else if(void 0!==t.length){for(i=0,o=t.length;i<o;i++)if(!1===e.call(n,t[i],i,t))return}else for(i in t)if(t.hasOwnProperty(i)&&!1===e.call(n,t[i],i,t))return},inStr:function(t,e){return-1<t.indexOf(e)},inArray:function(e,n,t){if(t){for(var i=0,o=e.length;i<o;i++)if(Object.keys(n).every(function(t){return e[i][t]===n[t]}))return i;return-1}if(e.indexOf)return e.indexOf(n);for(i=0,o=e.length;i<o;i++)if(e[i]===n)return i;return-1},toArray:function(t){return Array.prototype.slice.call(t,0)},hasParent:function(t,e){for(;t;){if(t==e)return!0;t=t.parentNode}return!1},getCenter:function(t){var e=[],n=[],i=[],o=[],r=Math.min,a=Math.max;return 1===t.length?{pageX:t[0].pageX,pageY:t[0].pageY,clientX:t[0].clientX,clientY:t[0].clientY}:(tt.each(t,function(t){e.push(t.pageX),n.push(t.pageY),i.push(t.clientX),o.push(t.clientY)}),{pageX:(r.apply(Math,e)+a.apply(Math,e))/2,pageY:(r.apply(Math,n)+a.apply(Math,n))/2,clientX:(r.apply(Math,i)+a.apply(Math,i))/2,clientY:(r.apply(Math,o)+a.apply(Math,o))/2})},getVelocity:function(t,e,n){return{x:Math.abs(e/t)||0,y:Math.abs(n/t)||0}},getAngle:function(t,e){var n=e.clientX-t.clientX,i=e.clientY-t.clientY;return 180*Math.atan2(i,n)/Math.PI},getDirection:function(t,e){var n=Math.abs(t.clientX-e.clientX);return Math.abs(t.clientY-e.clientY)<=n?0<t.clientX-e.clientX?pt:mt:0<t.clientY-e.clientY?gt:ft},getDistance:function(t,e){var n=e.clientX-t.clientX,i=e.clientY-t.clientY;return Math.sqrt(n*n+i*i)},getScale:function(t,e){return 2<=t.length&&2<=e.length?this.getDistance(e[0],e[1])/this.getDistance(t[0],t[1]):1},getRotation:function(t,e){return 2<=t.length&&2<=e.length?this.getAngle(e[1],e[0])-this.getAngle(t[1],t[0]):0},isVertical:function(t){return t==gt||t==ft},setPrefixedCss:function(t,e,n,i){var o=["","Webkit","Moz","O","ms"];e=tt.toCamelCase(e);for(var r=0;r<o.length;r++){var a=e;if(o[r]&&(a=o[r]+a.slice(0,1).toUpperCase()+a.slice(1)),a in t.style){t.style[a]=(null===i||i)&&n||"";break}}},toggleBehavior:function(n,t,i){if(t&&n&&n.style){tt.each(t,function(t,e){tt.setPrefixedCss(n,e,t,i)});var e=i&&function(){return!1};"none"==t.userSelect&&(n.onselectstart=e),"none"==t.userDrag&&(n.ondragstart=e)}},toCamelCase:function(t){return t.replace(/[_-]([a-z])/g,function(t){return t[1].toUpperCase()})}},Z=ot.event={preventMouseEvents:!1,started:!1,shouldDetect:!1,on:function(e,t,n,i,o){var r=t.split(" ");tt.each(r,function(t){tt.on(e,t,n,i),o&&o(t)})},off:function(e,t,n,i,o){var r=t.split(" ");tt.each(r,function(t){tt.off(e,t,n,i),o&&o(t)})},onTouch:function(r,a,s,t){var l=this,e=function(t){var e,n=t.type.toLowerCase(),i=ot.HAS_POINTEREVENTS,o=tt.inStr(n,"mouse");o&&l.preventMouseEvents||(o&&a==yt&&0===t.button?(l.preventMouseEvents=!1,l.shouldDetect=!0):i&&a==yt?l.shouldDetect=1===t.buttons||nt.matchType(vt,t):o||a!=yt||(l.preventMouseEvents=!0,l.shouldDetect=!0),i&&a!=wt&&nt.updatePointer(a,t),l.shouldDetect&&(e=l.doDetect.call(l,t,a,r,s)),e==wt&&(l.preventMouseEvents=!1,l.shouldDetect=!1,nt.reset()),i&&a==wt&&nt.updatePointer(a,t))};return this.on(r,dt[a],e,t),e},doDetect:function(t,e,n,i){var o=this.getTouchList(t,e),r=o.length,a=e,s=o.trigger,l=r;e==yt?s=Ct:e==wt&&(s=Et,l=o.length-(t.changedTouches?t.changedTouches.length:1)),0<l&&this.started&&(a=kt),this.started=!0;var u=this.collectEventData(n,a,o,t);return e!=wt&&i.call(et,u),s&&(u.changedLength=l,u.eventType=s,i.call(et,u),u.eventType=a,delete u.changedLength),a==wt&&(i.call(et,u),this.started=!1),a},determineEventTypes:function(){var t;return t=ot.HAS_POINTEREVENTS?window.PointerEvent?["pointerdown","pointermove","pointerup pointercancel lostpointercapture"]:["MSPointerDown","MSPointerMove","MSPointerUp MSPointerCancel MSLostPointerCapture"]:ot.NO_MOUSEEVENTS?["touchstart","touchmove","touchend touchcancel"]:["touchstart mousedown","touchmove mousemove","touchend touchcancel mouseup"],dt[yt]=t[0],dt[kt]=t[1],dt[wt]=t[2],dt},getTouchList:function(t,e){if(ot.HAS_POINTEREVENTS)return nt.getTouchList();if(t.touches){if(e==kt)return t.touches;var n=[],i=[].concat(tt.toArray(t.touches),tt.toArray(t.changedTouches)),o=[];return tt.each(i,function(t){-1===tt.inArray(n,t.identifier)&&o.push(t),n.push(t.identifier)}),o}return t.identifier=1,[t]},collectEventData:function(t,e,n,i){var o=vt;return tt.inStr(i.type,"mouse")||nt.matchType(_t,i)?o=_t:nt.matchType(bt,i)&&(o=bt),{center:tt.getCenter(n),timeStamp:Date.now(),target:i.target,touches:n,eventType:e,pointerType:o,srcEvent:i,preventDefault:function(){var t=this.srcEvent;t.preventManipulation&&t.preventManipulation(),t.preventDefault&&t.preventDefault()},stopPropagation:function(){this.srcEvent.stopPropagation()},stopDetect:function(){return et.stopDetect()}}}},nt=ot.PointerEvent={pointers:{},getTouchList:function(){var e=[];return tt.each(this.pointers,function(t){e.push(t)}),e},updatePointer:function(t,e){t==wt||t!=wt&&1!==e.buttons?delete this.pointers[e.pointerId]:(e.identifier=e.pointerId,this.pointers[e.pointerId]=e)},matchType:function(t,e){if(!e.pointerType)return!1;var n=e.pointerType,i={};return i[_t]=n===(e.MSPOINTER_TYPE_MOUSE||_t),i[vt]=n===(e.MSPOINTER_TYPE_TOUCH||vt),i[bt]=n===(e.MSPOINTER_TYPE_PEN||bt),i[t]},reset:function(){this.pointers={}}},et=ot.detection={gestures:[],current:null,previous:null,stopped:!1,startDetect:function(t,e){this.current||(this.stopped=!1,this.current={inst:t,startEvent:tt.extend({},e),lastEvent:!1,lastCalcEvent:!1,futureCalcEvent:!1,lastCalcData:{},name:""},this.detect(e))},detect:function(e){if(this.current&&!this.stopped){e=this.extendEventData(e);var n=this.current.inst,i=n.options;return tt.each(this.gestures,function(t){!this.stopped&&n.enabled&&i[t.name]&&t.handler.call(t,e,n)},this),this.current&&(this.current.lastEvent=e),e.eventType==wt&&this.stopDetect(),e}},stopDetect:function(){this.previous=tt.extend({},this.current),this.current=null,this.stopped=!0},getCalculatedData:function(t,e,n,i,o){var r=this.current,a=!1,s=r.lastCalcEvent,l=r.lastCalcData;s&&t.timeStamp-s.timeStamp>ot.CALCULATE_INTERVAL&&(e=s.center,n=t.timeStamp-s.timeStamp,i=t.center.clientX-s.center.clientX,o=t.center.clientY-s.center.clientY,a=!0),t.eventType!=Ct&&t.eventType!=Et||(r.futureCalcEvent=t),r.lastCalcEvent&&!a||(l.velocity=tt.getVelocity(n,i,o),l.angle=tt.getAngle(e,t.center),l.direction=tt.getDirection(e,t.center),r.lastCalcEvent=r.futureCalcEvent||t,r.futureCalcEvent=t),t.velocityX=l.velocity.x,t.velocityY=l.velocity.y,t.interimAngle=l.angle,t.interimDirection=l.direction},extendEventData:function(t){var e=this.current,n=e.startEvent,i=e.lastEvent||n;t.eventType!=Ct&&t.eventType!=Et||(n.touches=[],tt.each(t.touches,function(t){n.touches.push({clientX:t.clientX,clientY:t.clientY})}));var o=t.timeStamp-n.timeStamp,r=t.center.clientX-n.center.clientX,a=t.center.clientY-n.center.clientY;return this.getCalculatedData(t,i.center,o,r,a),tt.extend(t,{startEvent:n,deltaTime:o,deltaX:r,deltaY:a,distance:tt.getDistance(n.center,t.center),angle:tt.getAngle(n.center,t.center),direction:tt.getDirection(n.center,t.center),scale:tt.getScale(n.touches,t.touches),rotation:tt.getRotation(n.touches,t.touches)}),t},register:function(t){var e=t.defaults||{};return void 0===e[t.name]&&(e[t.name]=!0),tt.extend(ot.defaults,e,!0),t.index=t.index||1e3,this.gestures.push(t),this.gestures.sort(function(t,e){return t.index<e.index?-1:t.index>e.index?1:0}),this.gestures}},(ot.Instance=function(t,n){var e=this,i=n&&n.passive?{passive:!0}:void 0;!function(t){ot.READY||(Z.determineEventTypes(),tt.each(ot.gestures,function(t){et.register(t)}),Z.onTouch(ot.DOCUMENT,kt,et.detect,t),Z.onTouch(ot.DOCUMENT,wt,et.detect,t),ot.READY=!0)}(i),this.element=t,this.enabled=!0,tt.each(n,function(t,e){delete n[e],n[tt.toCamelCase(e)]=t}),this.options=tt.extend(tt.extend({},ot.defaults),n||{}),this.options.listenerOptions=i,this.options.behavior&&tt.toggleBehavior(this.element,this.options.behavior,!0),this.eventStartHandler=Z.onTouch(t,yt,function(t){e.enabled&&t.eventType==yt?et.startDetect(e,t):t.eventType==Ct&&et.detect(t)},i),this.eventHandlers=[]}).prototype={on:function(t,e,n){var i=this;return Z.on(i.element,t,e,W.extend({},i.options.listenerOptions,n),function(t){i.eventHandlers.push({gesture:t,handler:e})}),i},off:function(t,n,e){var i=this;return Z.off(i.element,t,n,W.extend({},i.options.listenerOptions,e),function(t){var e=tt.inArray(i.eventHandlers,{gesture:t,handler:n},!0);0<=e&&i.eventHandlers.splice(e,1)}),i},trigger:function(t,e){e||(e={});var n=ot.DOCUMENT.createEvent("Event");n.initEvent(t,!0,!0),n.gesture=e;var i=this.element;return tt.hasParent(e.target,i)&&(i=e.target),i.dispatchEvent(n),this},enable:function(t){return this.enabled=t,this},dispose:function(){var t,e;for(tt.toggleBehavior(this.element,this.options.behavior,!1),t=-1;e=this.eventHandlers[++t];)tt.off(this.element,e.gesture,e.handler);return this.eventHandlers=[],Z.off(this.element,dt[yt],this.eventStartHandler),null}},at=!(rt="drag"),ot.gestures.Drag={name:rt,index:50,handler:function(t,e){var n=et.current;if(!(0<e.options.dragMaxTouches&&t.touches.length>e.options.dragMaxTouches))switch(t.eventType){case yt:at=!1;break;case kt:if(t.distance<e.options.dragMinDistance&&n.name!=rt)return;var i=n.startEvent.center;if(n.name!=rt&&(n.name=rt,e.options.dragDistanceCorrection&&0<t.distance)){var o=Math.abs(e.options.dragMinDistance/t.distance);i.pageX+=t.deltaX*o,i.pageY+=t.deltaY*o,i.clientX+=t.deltaX*o,i.clientY+=t.deltaY*o,t=et.extendEventData(t)}(n.lastEvent.dragLockToAxis||e.options.dragLockToAxis&&e.options.dragLockMinDistance<=t.distance)&&(t.dragLockToAxis=!0);var r=n.lastEvent.direction;t.dragLockToAxis&&r!==t.direction&&(tt.isVertical(r)?t.direction=t.deltaY<0?gt:ft:t.direction=t.deltaX<0?pt:mt),at||(e.trigger(rt+"start",t),at=!0),e.trigger(rt,t),e.trigger(rt+t.direction,t);var a=tt.isVertical(t.direction);(e.options.dragBlockVertical&&a||e.options.dragBlockHorizontal&&!a)&&t.preventDefault();break;case Et:at&&t.changedLength<=e.options.dragMaxTouches&&(e.trigger(rt+"end",t),at=!1);break;case wt:at=!1}},defaults:{dragMinDistance:10,dragDistanceCorrection:!0,dragMaxTouches:1,dragBlockHorizontal:!1,dragBlockVertical:!1,dragLockToAxis:!1,dragLockMinDistance:25}},ot.gestures.Gesture={name:"gesture",index:1337,handler:function(t,e){e.trigger(this.name,t)}},st="hold",ot.gestures.Hold={name:st,index:10,defaults:{holdTimeout:500,holdThreshold:2},handler:function(t,e){var n=e.options,i=et.current;switch(t.eventType){case yt:clearTimeout(lt),i.name=st,lt=setTimeout(function(){i&&i.name==st&&e.trigger(st,t)},n.holdTimeout);break;case kt:t.distance>n.holdThreshold&&clearTimeout(lt);break;case Et:clearTimeout(lt)}}},ot.gestures.Release={name:"release",index:1/0,handler:function(t,e){t.eventType==Et&&e.trigger(this.name,t)}},ot.gestures.Swipe={name:"swipe",index:40,defaults:{swipeMinTouches:1,swipeMaxTouches:1,swipeVelocityX:.6,swipeVelocityY:.6},handler:function(t,e){if(t.eventType==Et){var n=t.touches.length,i=e.options;if(n<i.swipeMinTouches||n>i.swipeMaxTouches)return;(t.velocityX>i.swipeVelocityX||t.velocityY>i.swipeVelocityY)&&(e.trigger(this.name,t),e.trigger(this.name+t.direction,t))}}},ut=!1,ot.gestures.Tap={name:"tap",index:100,handler:function(t,e){var n,i,o=e.options,r=et.current,a=et.previous;switch(t.eventType){case yt:ut=!1;break;case kt:ut=ut||t.distance>o.tapMaxDistance;break;case wt:!tt.inStr(t.srcEvent.type,"cancel")&&t.deltaTime<o.tapMaxTime&&!ut&&(n=a&&a.lastEvent&&t.timeStamp-a.lastEvent.timeStamp,i=!1,a&&"tap"==a.name&&n&&n<o.doubleTapInterval&&t.distance<o.doubleTapDistance&&(e.trigger("doubletap",t),i=!0),i&&!o.tapAlways||(r.name="tap",e.trigger(r.name,t)))}},defaults:{tapMaxTime:250,tapMaxDistance:10,tapAlways:!0,doubleTapDistance:20,doubleTapInterval:300}},ot.gestures.Touch={name:"touch",index:-1/0,defaults:{preventDefault:!1,preventMouse:!1},handler:function(t,e){e.options.preventMouse&&t.pointerType==_t?t.stopDetect():(e.options.preventDefault&&t.preventDefault(),t.eventType==Ct&&e.trigger("touch",t))}},ht=!(ct="transform"),ot.gestures.Transform={name:ct,index:45,defaults:{transformMinScale:.01,transformMinRotation:1},handler:function(t,e){switch(t.eventType){case yt:ht=!1;break;case kt:if(t.touches.length<2)return;var n=Math.abs(1-t.scale),i=Math.abs(t.rotation);if(n<e.options.transformMinScale&&i<e.options.transformMinRotation)return;et.current.name=ct,ht||(e.trigger(ct+"start",t),ht=!0),e.trigger(ct,t),i>e.options.transformMinRotation&&e.trigger("rotate",t),n>e.options.transformMinScale&&(e.trigger("pinch",t),e.trigger("pinch"+(t.scale<1?"in":"out"),t));break;case Et:ht&&t.changedLength<2&&(e.trigger(ct+"end",t),ht=!1)}}};var At=void 0,St=void 0;function Pt(t){At.set(t,!0)}function Ot(t){var e=St.get(t,[])||[];St.delete(t),e.forEach(function(t){return t()})}function xt(e){var t=1<arguments.length&&void 0!==arguments[1]?arguments[1]:function(){};(void 0===At&&(At=new WeakMap,St=new WeakMap),function(t,e){St.has(t)||St.set(t,[]),St.get(t).push(e)}(e,t),function(t){return 0<t.childNodes.length&&Pt(t),At.has(t)}(e))?Ot(e):(new MutationObserver(function(t){Pt(e),Ot(e)}).observe(e,{childList:!0,characterData:!0}),setImmediate(function(){Pt(e),Ot(e)}))}var Tt=new(function(){function t(){h(this,t),this.queue=[]}return d(t,[{key:"add",value:function(t,e){var n=this;this.queue.push(t),1===this.queue.length&&setImmediate(this.queue[0]),e.then(function(){n.queue.shift(),0<n.queue.length&&setTimeout(n.queue[0],1e3/30)})}}]),t}()),Lt=function(e,n){["id","class","animation"].forEach(function(t){return n.hasOwnProperty(t)&&e.setAttribute(t,n[t])}),n.modifier&&W.addModifier(e,n.modifier)},Mt=function(t){var e=1<arguments.length&&void 0!==arguments[1]?arguments[1]:{},n=2<arguments.length&&void 0!==arguments[2]?arguments[2]:{};return e=f({},e),"string"==typeof t?e.message=t:e=t,e&&(e.message||e.messageHTML)||W.throw("Notifications must contain a message"),(e.hasOwnProperty("buttonLabels")||e.hasOwnProperty("buttonLabel"))&&(e.buttonLabels=e.buttonLabels||e.buttonLabel,Array.isArray(e.buttonLabels)||(e.buttonLabels=[e.buttonLabels||""])),W.extend({compile:function(t){return t},callback:function(t){return t},animation:"default",cancelable:!1,primaryButtonIndex:(e.buttonLabels||n.buttonLabels||[]).length-1},n,e)},Dt={_createAlertDialog:function(){for(var t=arguments.length,e=Array(t),n=0;n<t;n++)e[n]=arguments[n];return new Promise(function(n){var i=Mt.apply(void 0,e);W.checkMissingImport("AlertDialog","AlertDialogButton");var t="";i.isPrompt&&(t='\n      <input\n        class="text-input text-input--underbar"\n        type="'+(i.inputType||"text")+'"\n        placeholder="'+(i.placeholder||"")+'"\n        value="'+(i.defaultValue||"")+'"\n        style="width: 100%; margin-top: 10px;"\n      />\n    ');var o="";i.buttonLabels.forEach(function(t,e){o+='\n      <ons-alert-dialog-button\n        class="\n          '+(e===i.primaryButtonIndex?" alert-dialog-button--primal":"")+"\n          "+(i.buttonLabels.length<=2?" alert-dialog-button--rowfooter":"")+'\n        "\n        style="position: relative;">\n        '+t+"\n      </ons-alert-dialog-button>\n    "});var r={},a=function(){r.dialog.onDialogCancel&&r.dialog.removeEventListener("dialog-cancel",r.dialog.onDialogCancel),Object.keys(r).forEach(function(t){return delete r[t]}),r=null,i.destroy instanceof Function&&i.destroy()};r.dialog=document.createElement("ons-alert-dialog"),r.dialog.innerHTML='\n    <div class="alert-dialog-mask"\n      style="\n        '+(i.maskColor?"background-color: "+i.maskColor:"")+'\n      "></div>\n    <div class="alert-dialog">\n      <div class="alert-dialog-container">\n        <div class="alert-dialog-title">\n          '+(i.title||"")+'\n        </div>\n        <div class="alert-dialog-content">\n          '+(i.message||i.messageHTML)+"\n          "+t+'\n        </div>\n        <div class="\n          alert-dialog-footer\n          '+(i.buttonLabels.length<=2?" alert-dialog-footer--rowfooter":"")+'\n        ">\n          '+o+"\n        </div>\n      </div>\n    </div>\n  ",xt(r.dialog),Lt(r.dialog,i),i.isPrompt&&i.submitOnEnter&&(r.input=r.dialog.querySelector(".text-input"),r.input.onkeypress=function(t){13===t.keyCode&&r.dialog.hide().then(function(){if(r){var t=r.input.value;a(),i.callback(t),n(t)}})}),r.footer=r.dialog.querySelector(".alert-dialog-footer"),W.arrayFrom(r.dialog.querySelectorAll(".alert-dialog-button")).forEach(function(t,e){t.onclick=function(){r.dialog.hide().then(function(){if(r){var t=e;i.isPrompt&&(t=e===i.primaryButtonIndex?r.input.value:null),r.dialog.remove(),a(),i.callback(t),n(t)}})},r.footer.appendChild(t)}),i.cancelable&&(r.dialog.cancelable=!0,r.dialog.onDialogCancel=function(){setImmediate(function(){r.dialog.remove(),a()});var t=i.isPrompt?null:-1;i.callback(t),n(t)},r.dialog.addEventListener("dialog-cancel",r.dialog.onDialogCancel,!1)),document.body.appendChild(r.dialog),i.compile(r.dialog),setImmediate(function(){r.dialog.show().then(function(){if(r.input&&i.isPrompt&&i.autofocus){var t=r.input.value.length;r.input.focus(),r.input.setSelectionRange(t,t)}})})})},alert:function(t,e){return Dt._createAlertDialog(t,e,{buttonLabels:["OK"],title:"Alert"})},confirm:function(t,e){return Dt._createAlertDialog(t,e,{buttonLabels:["Cancel","OK"],title:"Confirm"})},prompt:function(t,e){return Dt._createAlertDialog(t,e,{buttonLabels:["OK"],title:"Alert",isPrompt:!0,autofocus:!0,submitOnEnter:!0})},toast:function(o,r){var a=new Promise(function(e){W.checkMissingImport("Toast"),r=Mt(o,r,{timeout:0,force:!1});var n=W.createElement("\n      <ons-toast>\n        "+r.message+"\n        "+(r.buttonLabels?"<button>"+r.buttonLabels[0]+"</button>":"")+"\n      </ons-toast>\n    ");Lt(n,r);var t=function(t){n&&n.hide().then(function(){n&&(n.remove(),n=null,r.callback(t),e(t))})};r.buttonLabels&&(W.findChild(n._toast,"button").onclick=function(){return t(0)}),document.body.appendChild(n),r.compile(n);var i=function(){n.parentElement&&n.show(r).then(function(){r.timeout&&setTimeout(function(){return t(-1)},r.timeout)})};setImmediate(function(){return r.force?i():Tt.add(i,a)})});return a}},It=function(){};It.prototype={on:function(t,e){this._events=this._events||{},this._events[t]=this._events[t]||[],this._events[t].push(e)},once:function(e,n){var i=this;this.on(e,function t(){return i.off(e,t),n.apply(null,arguments)})},off:function(t,e){this._events=this._events||{},t in this._events!=!1&&(this._events[t]=this._events[t].filter(function(t){return!!e&&e!==t}))},emit:function(t){if(this._events=this._events||{},t in this._events!=!1)for(var e=0;e<this._events[t].length;e++)this._events[t][e].apply(this,Array.prototype.slice.call(arguments,1))}},It.mixin=function(t){for(var e=["on","once","off","emit"],n=0;n<e.length;n++)"function"==typeof t?t.prototype[e[n]]=It.prototype[e[n]]:t[e[n]]=It.prototype[e[n]]};var Nt,Bt=((window.MicroEvent=It).mixin(Nt={_isPortrait:!1,isPortrait:function(){return this._isPortrait()},isLandscape:function(){return!this.isPortrait()},_init:function(){return document.addEventListener("DOMContentLoaded",this._onDOMContentLoaded.bind(this),!1),"orientation"in window?window.addEventListener("orientationchange",this._onOrientationChange.bind(this),!1):window.addEventListener("resize",this._onResize.bind(this),!1),this._isPortrait=function(){return window.innerHeight>window.innerWidth},this},_onDOMContentLoaded:function(){this._installIsPortraitImplementation(),this.emit("change",{isPortrait:this.isPortrait()})},_installIsPortraitImplementation:function(){var t=window.innerWidth<window.innerHeight;"orientation"in window?window.orientation%180==0?this._isPortrait=function(){return 0===Math.abs(window.orientation%180)?t:!t}:this._isPortrait=function(){return 90===Math.abs(window.orientation%180)?t:!t}:this._isPortrait=function(){return window.innerHeight>window.innerWidth}},_onOrientationChange:function(){var n=this,i=this._isPortrait(),o=0,r=setInterval(function(){o++;var t=window.innerWidth,e=window.innerHeight;i&&t<=e||!i&&e<=t?(n.emit("change",{isPortrait:i}),clearInterval(r)):50===o&&(n.emit("change",{isPortrait:i}),clearInterval(r))},20)},_onResize:function(){this.emit("change",{isPortrait:this.isPortrait()})}}),Nt)._init(),jt={add:function(e){for(var t=arguments.length,n=Array(1<t?t-1:0),i=1;i<t;i++)n[i-1]=arguments[i];return n.forEach(function(t){return W.addModifier(e,t)})},remove:function(e){for(var t=arguments.length,n=Array(1<t?t-1:0),i=1;i<t;i++)n[i-1]=arguments[i];return n.forEach(function(t){return W.removeModifier(e,t)})},contains:W.hasModifier,toggle:W.toggleModifier},Ht=new It;Ht._visible=!1;var Rt=function(){Ht._visible=!0,Ht.emit("show")},Ft=function(){Ht._visible=!1,Ht.emit("hide")},qt=function(){W.warn("ons-keyboard: Cordova Keyboard plugin is not present.")};document.addEventListener("deviceready",function(){("undefined"!=typeof Keyboard?(Keyboard.onshow=Rt,Keyboard.onhide=Ft,Ht.emit("init",{visible:Keyboard.isVisible}),1):void 0!==cordova.plugins&&void 0!==cordova.plugins.Keyboard&&(window.addEventListener("native.keyboardshow",Rt),window.addEventListener("native.keyboardhide",Ft),Ht.emit("init",{visible:cordova.plugins.Keyboard.isVisible}),1))||((document.querySelector("[ons-keyboard-active]")||document.querySelector("[ons-keyboard-inactive]"))&&qt(),Ht.on=qt)});var zt,Vt=(zt=0,function(){return zt++}),Wt=function(){function e(){var t=0<arguments.length&&void 0!==arguments[0]?arguments[0]:{};h(this,e),this._lockList=[],this._waitList=[],this._log=t.log||function(){}}return d(e,[{key:"lock",value:function(){var e=this,t=function t(){e._unlock(t)};return t.id=Vt(),this._lockList.push(t),this._log("lock: "+t.id),t}},{key:"_unlock",value:function(t){var e=this._lockList.indexOf(t);if(-1===e)throw new Error("This function is not registered in the lock list.");this._lockList.splice(e,1),this._log("unlock: "+t.id),this._tryToFreeWaitList()}},{key:"_tryToFreeWaitList",value:function(){for(;!this.isLocked()&&0<this._waitList.length;)this._waitList.shift()()}},{key:"waitUnlock",value:function(t){if(!(t instanceof Function))throw new Error("The callback param must be a function.");this.isLocked()?this._waitList.push(t):t()}},{key:"isLocked",value:function(){return 0<this._lockList.length}}]),e}();function Ut(t,n){var e=t.page,i=t.parent;t.params;b.getPageHTMLAsync(e).then(function(t){var e=W.createElement(t);i.appendChild(e),n(e)})}function Xt(t){t._destroy instanceof Function?t._destroy():t.remove()}var Yt,Gt=function(){function n(t,e){h(this,n),this._loader=t instanceof Function?t:Ut,this._unloader=e instanceof Function?e:Xt}return d(n,[{key:"load",value:function(t,e){var n=t.page,i=t.parent,o=t.params,r=void 0===o?{}:o;this._loader({page:n,parent:i,params:r},function(t){if(!(t instanceof Element))throw Error("pageElement must be an instance of Element.");e(t)})}},{key:"unload",value:function(t){if(!(t instanceof Element))throw Error("pageElement must be an instance of Element.");this._unloader(t)}},{key:"internalLoader",set:function(t){if(!(t instanceof Function))throw Error("First parameter must be an instance of Function");this._loader=t},get:function(){return this._loader}}]),n}(),$t=new Gt,Kt=new Gt(function(t,e){var n=t.page,i=t.parent,o=(t.params,W.createElement(n.trim()));i.appendChild(o),e(o)},Xt),Qt={animit:it,defaultPageLoader:$t,elements:i,GestureDetector:ot,modifier:jt,notification:Dt,orientation:Bt,pageAttributeExpression:o,PageLoader:Gt,platform:c,softwareKeyboard:Ht,_autoStyle:P,_internal:b,_readyLock:new Wt,_util:W};Qt.platform.select((window.location.search.match(/platform=([\w-]+)/)||[])[1]),Yt=Qt._readyLock.lock(),window.addEventListener("DOMContentLoaded",function(){Qt.isWebView()?window.document.addEventListener("deviceready",Yt,!1):Yt()},!1);var Jt=function(t){return W.throw("This method must be called "+(t?"after":"before")+" ons.isReady() is true")};Qt.isReady=function(){return!Qt._readyLock.isLocked()},Qt.isWebView=Qt.platform.isWebView,Qt.ready=function(t){Qt.isReady()?t():Qt._readyLock.waitUnlock(t)},Qt.setDefaultDeviceBackButtonListener=function(t){Qt.isReady()||Jt(!0),Qt._defaultDeviceBackButtonHandler.setListener(t)},Qt.disableDeviceBackButtonHandler=function(){Qt.isReady()||Jt(!0),b.dbbDispatcher.disable()},Qt.enableDeviceBackButtonHandler=function(){Qt.isReady()||Jt(!0),b.dbbDispatcher.enable()},Qt.fireDeviceBackButtonEvent=function(){b.dbbDispatcher.fireDeviceBackButtonEvent()},Qt.enableAutoStatusBarFill=function(){Qt.isReady()&&Jt(!1),b.config.autoStatusBarFill=!0},Qt.disableAutoStatusBarFill=function(){Qt.isReady()&&Jt(!1),b.config.autoStatusBarFill=!1},Qt.mockStatusBar=function(){Qt.isReady()&&Jt(!1);var t=function(){if(!document.body.children[0]||!document.body.children[0].classList.contains("ons-status-bar-mock")){var t=c.isAndroid(),e=function(t){return'<i class="'+t.split("-")[0]+" "+t+'"></i>'},n=t?e("zmdi-twitter")+" "+e("zmdi-google-play"):"No SIM "+e("fa-wifi"),i=t?"":"12:28 PM",o=t?e("zmdi-network")+" "+e("zmdi-wifi")+" "+e("zmdi-battery")+" 12:28 PM":"80% "+e("fa-battery-three-quarters");document.body.insertBefore(W.createElement('<div class="ons-status-bar-mock '+(t?"android":"ios")+'"><div>'+n+"</div><div>"+i+"</div><div>"+o+"</div></div>"),document.body.firstChild)}};document.body?t():b.waitDOMContentLoaded(t)},Qt.disableAnimations=function(){b.config.animationsDisabled=!0},Qt.enableAnimations=function(){b.config.animationsDisabled=!1},Qt._disableWarnings=function(){b.config.warningsDisabled=!0},Qt._enableWarnings=function(){b.config.warningsDisabled=!1},Qt.disableAutoStyling=P.disable,Qt.enableAutoStyling=P.enable,Qt.disableIconAutoPrefix=function(){W.checkMissingImport("Icon"),i.Icon.setAutoPrefix(!1)},Qt.forceUIWebViewScrollFix=function(){var t=!(0<arguments.length&&void 0!==arguments[0])||arguments[0];b.config.forceUIWebViewScrollFix=t},Qt.forcePlatformStyling=function(t){Qt.enableAutoStyling(),Qt.platform.select(t||"ios"),Qt._util.arrayFrom(document.querySelectorAll("*")).forEach(function(t){"ons-if"===t.tagName.toLowerCase()?t._platformUpdate():t.tagName.match(/^ons-/i)&&(P.prepare(t,!0),"ons-tabbar"===t.tagName.toLowerCase()&&t._updatePosition())})},Qt.preload=function(){var t=0<arguments.length&&void 0!==arguments[0]?arguments[0]:[];return Promise.all((t instanceof Array?t:[t]).map(function(t){return"string"!=typeof t&&W.throw("Expected string arguments but got "+(void 0===t?"undefined":u(t))),b.getTemplateHTMLAsync(t)}))},Qt.createElement=function(t){var n=1<arguments.length&&void 0!==arguments[1]?arguments[1]:{},e=function(t){var e=Qt._util.createElement(t);(e.remove(),n.append)&&((n.append instanceof HTMLElement?n.append:document.body).insertBefore(e,n.insertBefore||null),n.link instanceof Function&&n.link(e));return e};return"<"===(t=t.trim()).charAt(0)?e(t):b.getPageHTMLAsync(t).then(e)},Qt.createPopover=Qt.createDialog=Qt.createAlertDialog=function(t){var e=1<arguments.length&&void 0!==arguments[1]?arguments[1]:{};return Qt.createElement(t,f({append:!0},e))},Qt.openActionSheet=function(){var s=0<arguments.length&&void 0!==arguments[0]?arguments[0]:{};return new Promise(function(i){W.checkMissingImport("ActionSheet"),function(n){var t=function(t){var e=1<arguments.length&&void 0!==arguments[1]?arguments[1]:"Function";return W.throw('"options.'+t+'" must be an instance of '+e)},e=function(t){return Object.hasOwnProperty.call(n,t)},i=function(t){var e=1<arguments.length&&void 0!==arguments[1]?arguments[1]:Function;return n[t]instanceof e},o="buttons",r="callback",a="compile",s="destroy";(!e(o)||!i(o,Array))&&t(o,"Array"),e(r)&&!i(r)&&t(r),e(a)&&!i(a)&&t(a),e(s)&&!i(s)&&t(s)}(s);var o=W.createElement("\n    <ons-action-sheet\n      "+(s.title?'title="'+s.title+'"':"")+"\n      "+(s.cancelable?"cancelable":"")+"\n      "+(s.modifier?'modifier="'+s.modifier+'"':"")+"\n      "+(s.maskColor?'mask-color="'+s.maskColor+'"':"")+"\n      "+(s.id?'id="'+s.id+'"':"")+"\n      "+(s.class?'class="'+s.class+'"':"")+'\n    >\n      <div class="action-sheet"></div>\n    </ons-action-sheet>\n  '),r=function t(e){var n=1<arguments.length&&void 0!==arguments[1]?arguments[1]:-1;o&&(s.destroy&&s.destroy(o),o.removeEventListener("dialog-cancel",t,!1),o.remove(),o=null,s.callback&&s.callback(n),i(n))};o.addEventListener("dialog-cancel",r,!1);var a=document.createDocumentFragment();s.buttons.forEach(function(t,e){var n="string"==typeof t?{label:t}:f({},t);s.destructive===e&&(n.modifier=(n.modifier||"")+" destructive");var i=W.createElement("\n      <ons-action-sheet-button\n        "+(n.icon?'icon="'+n.icon+'"':"")+"\n        "+(n.modifier?'modifier="'+n.modifier+'"':"")+"\n      >\n        "+n.label+"\n      </ons-action-sheet-button>\n    ");i.onclick=function(t){return o.hide().then(function(){return r(t,e)})},a.appendChild(i)}),W.findChild(o,".action-sheet").appendChild(a),document.body.appendChild(o),s.compile&&s.compile(el.dialog),setImmediate(function(){return o.show({animation:s.animation,animationOptions:s.animationOptions})})})},Qt.resolveLoadingPlaceholder=function(e,n){var t=Qt._util.arrayFrom(window.document.querySelectorAll("[ons-loading-placeholder]"));0===t.length&&W.throw("No ons-loading-placeholder exists"),t.filter(function(t){return!t.getAttribute("page")}).forEach(function(t){t.setAttribute("ons-loading-placeholder",e),Qt._resolveLoadingPlaceholder(t,e,n)})},Qt._setupLoadingPlaceHolders=function(){Qt.ready(function(){Qt._util.arrayFrom(window.document.querySelectorAll("[ons-loading-placeholder]")).forEach(function(t){var e=t.getAttribute("ons-loading-placeholder");"string"==typeof e&&Qt._resolveLoadingPlaceholder(t,e)})})},Qt._resolveLoadingPlaceholder=function(e,t){var n=2<arguments.length&&void 0!==arguments[2]?arguments[2]:function(t,e){return e()};t&&Qt.createElement(t).then(function(t){t.style.display="none",e.appendChild(t),n(t,function(){for(;e.firstChild&&e.firstChild!==t;)e.removeChild(e.firstChild);t.style.display=""})}).catch(function(t){return Promise.reject("Unabled to resolve placeholder: "+t)})};var Zt="currentScript"in document?function(){return document.currentScript}:function(){return document.scripts[document.scripts.length-1]};function te(t,e){return t(e={exports:{}},e.exports),e.exports}Qt.getScriptPage=function(){return Zt()&&/ons-page/i.test(Zt().parentElement.tagName)&&Zt().parentElement||null};var ee=te(function(n){!function(){function s(o,t){var e;if(t=t||{},this.trackingClick=!1,this.trackingClickStart=0,this.targetElement=null,this.touchStartX=0,this.touchStartY=0,this.lastTouchIdentifier=0,this.touchBoundary=t.touchBoundary||10,this.layer=o,this.tapDelay=t.tapDelay||200,this.tapTimeout=t.tapTimeout||700,!s.notNeeded(o)){for(var n=["onMouse","onClick","onTouchStart","onTouchMove","onTouchEnd","onTouchCancel"],i=0,r=n.length;i<r;i++)this[n[i]]=a(this[n[i]],this);l&&(o.addEventListener("mouseover",this.onMouse,!0),o.addEventListener("mousedown",this.onMouse,!0),o.addEventListener("mouseup",this.onMouse,!0)),o.addEventListener("click",this.onClick,!0),o.addEventListener("touchstart",this.onTouchStart,!1),o.addEventListener("touchmove",this.onTouchMove,!1),o.addEventListener("touchend",this.onTouchEnd,!1),o.addEventListener("touchcancel",this.onTouchCancel,!1),Event.prototype.stopImmediatePropagation||(o.removeEventListener=function(t,e,n){var i=Node.prototype.removeEventListener;"click"===t?i.call(o,t,e.hijacked||e,n):i.call(o,t,e,n)},o.addEventListener=function(t,e,n){var i=Node.prototype.addEventListener;"click"===t?i.call(o,t,e.hijacked||(e.hijacked=function(t){t.propagationStopped||e(t)}),n):i.call(o,t,e,n)}),"function"==typeof o.onclick&&(e=o.onclick,o.addEventListener("click",function(t){e(t)},!1),o.onclick=null)}function a(t,e){return function(){return t.apply(e,arguments)}}}var t=0<=navigator.userAgent.indexOf("Windows Phone"),l=0<navigator.userAgent.indexOf("Android")&&!t,u=/iP(ad|hone|od)/.test(navigator.userAgent)&&!t,c=u&&/OS 4_\d(_\d)?/.test(navigator.userAgent),h=u&&/OS [6-7]_\d/.test(navigator.userAgent),o=0<navigator.userAgent.indexOf("BB10"),e=["email","number","password","search","tel","text","url"];s.prototype.needsClick=function(t){switch(t.nodeName.toLowerCase()){case"button":case"select":case"textarea":if(t.disabled)return!0;break;case"input":if(u&&"file"===t.type||t.disabled)return!0;break;case"label":case"iframe":case"video":return!0}return/\bneedsclick\b/.test(t.className)},s.prototype.needsFocus=function(t){switch(t.nodeName.toLowerCase()){case"textarea":return!0;case"select":return!l;case"input":switch(t.type){case"button":case"checkbox":case"file":case"image":case"radio":case"submit":return!1}return!t.disabled&&!t.readOnly;default:return/\bneedsfocus\b/.test(t.className)}},s.prototype.sendClick=function(t,e){var n,i;document.activeElement&&document.activeElement!==t&&document.activeElement.blur(),i=e.changedTouches[0],(n=document.createEvent("MouseEvents")).initMouseEvent(this.determineEventType(t),!0,!0,window,1,i.screenX,i.screenY,i.clientX,i.clientY,!1,!1,!1,!1,0,null),n.forwardedTouchEvent=!0,t.dispatchEvent(n)},s.prototype.determineEventType=function(t){return l&&"select"===t.tagName.toLowerCase()?"mousedown":"click"},s.prototype.focus=function(t){var e;u&&t.setSelectionRange&&0!==t.type.indexOf("date")&&"time"!==t.type&&"month"!==t.type&&"email"!==t.type&&"number"!==t.type?(e=t.value.length,t.setSelectionRange(e,e)):t.focus()},s.prototype.updateScrollParent=function(t){var e,n;if(!(e=t.fastClickScrollParent)||!e.contains(t)){n=t;do{if(n.scrollHeight>n.offsetHeight){e=n,t.fastClickScrollParent=n;break}n=n.parentElement}while(n)}e&&(e.fastClickLastScrollTop=e.scrollTop)},s.prototype.getTargetElementFromEventTarget=function(t){return t.nodeType===Node.TEXT_NODE?t.parentNode:t},s.prototype.isTextField=function(t){return"textarea"===t.tagName.toLowerCase()||-1!==e.indexOf(t.type)},s.prototype.onTouchStart=function(t){var e,n;if(1<t.targetTouches.length)return!0;if(e=this.getTargetElementFromEventTarget(t.target),n=t.targetTouches[0],e.isContentEditable)return!0;if(u){if(e===document.activeElement&&this.isTextField(e))return!0;if(!c){if(n.identifier&&n.identifier===this.lastTouchIdentifier)return t.preventDefault(),!1;this.lastTouchIdentifier=n.identifier,this.updateScrollParent(e)}}return this.trackingClick=!0,this.trackingClickStart=t.timeStamp,this.targetElement=e,this.touchStartX=n.pageX,this.touchStartY=n.pageY,t.timeStamp-this.lastClickTime<this.tapDelay&&-1<t.timeStamp-this.lastClickTime&&t.preventDefault(),!0},s.prototype.touchHasMoved=function(t){var e=t.changedTouches[0],n=this.touchBoundary;return Math.abs(e.pageX-this.touchStartX)>n||Math.abs(e.pageY-this.touchStartY)>n},s.prototype.onTouchMove=function(t){return this.trackingClick&&(this.targetElement!==this.getTargetElementFromEventTarget(t.target)||this.touchHasMoved(t))&&(this.trackingClick=!1,this.targetElement=null),!0},s.prototype.findControl=function(t){return void 0!==t.control?t.control:t.htmlFor?document.getElementById(t.htmlFor):t.querySelector("button, input:not([type=hidden]), keygen, meter, output, progress, select, textarea")},s.prototype.onTouchEnd=function(t){var e,n,i,o,r,a=this.targetElement;if(!this.trackingClick)return!0;if(t.timeStamp-this.lastClickTime<this.tapDelay&&-1<t.timeStamp-this.lastClickTime)return this.cancelNextClick=!0;if(t.timeStamp-this.trackingClickStart>this.tapTimeout)return!0;if(this.cancelNextClick=!1,this.lastClickTime=t.timeStamp,n=this.trackingClickStart,this.trackingClick=!1,this.trackingClickStart=0,h&&(r=t.changedTouches[0],(a=document.elementFromPoint(r.pageX-window.pageXOffset,r.pageY-window.pageYOffset)||a).fastClickScrollParent=this.targetElement.fastClickScrollParent),"label"===(i=a.tagName.toLowerCase())){if(e=this.findControl(a)){if(this.focus(a),l)return!1;a=e}}else if(this.needsFocus(a))return 100<t.timeStamp-n||u&&window.top!==window&&"input"===i?this.targetElement=null:(this.focus(a),this.sendClick(a,t),c&&"select"===i||(this.targetElement=null,t.preventDefault())),!1;return!(!u||c||!(o=a.fastClickScrollParent)||o.fastClickLastScrollTop===o.scrollTop)||(this.needsClick(a)||(t.preventDefault(),this.sendClick(a,t)),!1)},s.prototype.onTouchCancel=function(){this.trackingClick=!1,this.targetElement=null},s.prototype.onMouse=function(t){return!this.targetElement||(!!t.forwardedTouchEvent||(!t.cancelable||(!(!this.needsClick(this.targetElement)||this.cancelNextClick)||(t.stopImmediatePropagation?t.stopImmediatePropagation():t.propagationStopped=!0,t.stopPropagation(),t.preventDefault(),!1))))},s.prototype.onClick=function(t){var e;return this.trackingClick?(this.targetElement=null,!(this.trackingClick=!1)):"submit"===t.target.type&&0===t.detail||((e=this.onMouse(t))||(this.targetElement=null),e)},s.prototype.destroy=function(){var t=this.layer;l&&(t.removeEventListener("mouseover",this.onMouse,!0),t.removeEventListener("mousedown",this.onMouse,!0),t.removeEventListener("mouseup",this.onMouse,!0)),t.removeEventListener("click",this.onClick,!0),t.removeEventListener("touchstart",this.onTouchStart,!1),t.removeEventListener("touchmove",this.onTouchMove,!1),t.removeEventListener("touchend",this.onTouchEnd,!1),t.removeEventListener("touchcancel",this.onTouchCancel,!1)},s.notNeeded=function(t){var e,n,i;if(void 0===window.ontouchstart)return!0;if(n=+(/Chrome\/([0-9]+)/.exec(navigator.userAgent)||[,0])[1]){if(!l)return!0;if(e=document.querySelector("meta[name=viewport]")){if(-1!==e.content.indexOf("user-scalable=no"))return!0;if(31<n&&document.documentElement.scrollWidth<=window.outerWidth)return!0}}if(o&&10<=(i=navigator.userAgent.match(/Version\/([0-9]*)\.([0-9]*)/))[1]&&3<=i[2]&&(e=document.querySelector("meta[name=viewport]"))){if(-1!==e.content.indexOf("user-scalable=no"))return!0;if(document.documentElement.scrollWidth<=window.outerWidth)return!0}return"none"===t.style.msTouchAction||"manipulation"===t.style.touchAction||(!!(27<=+(/Firefox\/([0-9]+)/.exec(navigator.userAgent)||[,0])[1]&&(e=document.querySelector("meta[name=viewport]"))&&(-1!==e.content.indexOf("user-scalable=no")||document.documentElement.scrollWidth<=window.outerWidth))||("none"===t.style.touchAction||"manipulation"===t.style.touchAction))},s.attach=function(t,e){return new s(t,e)},n.exports?(n.exports=s.attach,n.exports.FastClick=s):window.FastClick=s}()}).FastClick;window.customElements&&(window.customElements.forcePolyfill=!0);var ne=te(function(t){var e=t.exports="undefined"!=typeof window&&window.Math==Math?window:"undefined"!=typeof self&&self.Math==Math?self:Function("return this")();"number"==typeof __g&&(__g=e)}),ie=te(function(t){var e=t.exports={version:"2.6.5"};"number"==typeof __e&&(__e=e)}),oe=(ie.version,function(t){return"object"===(void 0===t?"undefined":u(t))?null!==t:"function"==typeof t}),re=function(t){if(!oe(t))throw TypeError(t+" is not an object!");return t},ae=function(t){try{return!!t()}catch(t){return!0}},se=!ae(function(){return 7!=Object.defineProperty({},"a",{get:function(){return 7}}).a}),le=ne.document,ue=oe(le)&&oe(le.createElement),ce=function(t){return ue?le.createElement(t):{}},he=!se&&!ae(function(){return 7!=Object.defineProperty(ce("div"),"a",{get:function(){return 7}}).a}),de=function(t,e){if(!oe(t))return t;var n,i;if(e&&"function"==typeof(n=t.toString)&&!oe(i=n.call(t)))return i;if("function"==typeof(n=t.valueOf)&&!oe(i=n.call(t)))return i;if(!e&&"function"==typeof(n=t.toString)&&!oe(i=n.call(t)))return i;throw TypeError("Can't convert object to primitive value")},fe=Object.defineProperty,pe={f:se?Object.defineProperty:function(t,e,n){if(re(t),e=de(e,!0),re(n),he)try{return fe(t,e,n)}catch(t){}if("get"in n||"set"in n)throw TypeError("Accessors not supported!");return"value"in n&&(t[e]=n.value),t}},ge=function(t,e){return{enumerable:!(1&t),configurable:!(2&t),writable:!(4&t),value:e}},me=se?function(t,e,n){return pe.f(t,e,ge(1,n))}:function(t,e,n){return t[e]=n,t},_e={}.hasOwnProperty,ve=function(t,e){return _e.call(t,e)},be=0,ye=Math.random(),ke=function(t){return"Symbol(".concat(void 0===t?"":t,")_",(++be+ye).toString(36))},we=te(function(t){var e="__core-js_shared__",n=ne[e]||(ne[e]={});(t.exports=function(t,e){return n[t]||(n[t]=void 0!==e?e:{})})("versions",[]).push({version:ie.version,mode:"global",copyright:"© 2019 Denis Pushkarev (zloirock.ru)"})}),Ee=we("native-function-to-string",Function.toString),Ce=te(function(t){var r=ke("src"),e="toString",a=(""+Ee).split(e);ie.inspectSource=function(t){return Ee.call(t)},(t.exports=function(t,e,n,i){var o="function"==typeof n;o&&(ve(n,"name")||me(n,"name",e)),t[e]!==n&&(o&&(ve(n,r)||me(n,r,t[e]?""+t[e]:a.join(String(e)))),t===ne?t[e]=n:i?t[e]?t[e]=n:me(t,e,n):(delete t[e],me(t,e,n)))})(Function.prototype,e,function(){return"function"==typeof this&&this[r]||Ee.call(this)})}),Ae=function(t){if("function"!=typeof t)throw TypeError(t+" is not a function!");return t},Se=function(i,o,t){if(Ae(i),void 0===o)return i;switch(t){case 1:return function(t){return i.call(o,t)};case 2:return function(t,e){return i.call(o,t,e)};case 3:return function(t,e,n){return i.call(o,t,e,n)}}return function(){return i.apply(o,arguments)}},Pe="prototype",Oe=function t(e,n,i){var o,r,a,s,l=e&t.F,u=e&t.G,c=e&t.P,h=e&t.B,d=u?ne:e&t.S?ne[n]||(ne[n]={}):(ne[n]||{})[Pe],f=u?ie:ie[n]||(ie[n]={}),p=f[Pe]||(f[Pe]={});for(o in u&&(i=n),i)a=((r=!l&&d&&void 0!==d[o])?d:i)[o],s=h&&r?Se(a,ne):c&&"function"==typeof a?Se(Function.call,a):a,d&&Ce(d,o,a,e&t.U),f[o]!=a&&me(f,o,s),c&&p[o]!=a&&(p[o]=a)};ne.core=ie,Oe.F=1,Oe.G=2,Oe.S=4,Oe.P=8,Oe.B=16,Oe.W=32,Oe.U=64,Oe.R=128;var xe=Oe,Te={f:{}.propertyIsEnumerable},Le={}.toString,Me=function(t){return Le.call(t).slice(8,-1)},De=Object("z").propertyIsEnumerable(0)?Object:function(t){return"String"==Me(t)?t.split(""):Object(t)},Ie=function(t){if(null==t)throw TypeError("Can't call method on  "+t);return t},Ne=function(t){return De(Ie(t))},Be=Object.getOwnPropertyDescriptor,je={f:se?Be:function(t,e){if(t=Ne(t),e=de(e,!0),he)try{return Be(t,e)}catch(t){}if(ve(t,e))return ge(!Te.f.call(t,e),t[e])}},He=function(t,e){if(re(t),!oe(e)&&null!==e)throw TypeError(e+": can't set as prototype!")},Re={set:Object.setPrototypeOf||("__proto__"in{}?function(t,n,i){try{(i=Se(Function.call,je.f(Object.prototype,"__proto__").set,2))(t,[]),n=!(t instanceof Array)}catch(t){n=!0}return function(t,e){return He(t,e),n?t.__proto__=e:i(t,e),t}}({},!1):void 0),check:He};xe(xe.S,"Object",{setPrototypeOf:Re.set});ie.Object.setPrototypeOf;var Fe=te(function(t){var e=we("wks"),n=ne.Symbol,i="function"==typeof n;(t.exports=function(t){return e[t]||(e[t]=i&&n[t]||(i?n:ke)("Symbol."+t))}).store=e}),qe=Fe("toStringTag"),ze="Arguments"==Me(function(){return arguments}()),Ve=function(t){var e,n,i;return void 0===t?"Undefined":null===t?"Null":"string"==typeof(n=function(t,e){try{return t[e]}catch(t){}}(e=Object(t),qe))?n:ze?Me(e):"Object"==(i=Me(e))&&"function"==typeof e.callee?"Arguments":i},We={};We[Fe("toStringTag")]="z",We+""!="[object z]"&&Ce(Object.prototype,"toString",function(){return"[object "+Ve(this)+"]"},!0);var Ue,Xe=Math.ceil,Ye=Math.floor,Ge=function(t){return isNaN(t=+t)?0:(0<t?Ye:Xe)(t)},$e={},Ke=Math.min,Qe=function(t){return 0<t?Ke(Ge(t),9007199254740991):0},Je=Math.max,Ze=Math.min,tn=we("keys"),en=function(t){return tn[t]||(tn[t]=ke(t))},nn=(Ue=!1,function(t,e,n){var i,o=Ne(t),r=Qe(o.length),a=function(t,e){return(t=Ge(t))<0?Je(t+e,0):Ze(t,e)}(n,r);if(Ue&&e!=e){for(;a<r;)if((i=o[a++])!=i)return!0}else for(;a<r;a++)if((Ue||a in o)&&o[a]===e)return Ue||a||0;return!Ue&&-1}),on=en("IE_PROTO"),rn="constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf".split(","),an=Object.keys||function(t){return function(t,e){var n,i=Ne(t),o=0,r=[];for(n in i)n!=on&&ve(i,n)&&r.push(n);for(;e.length>o;)ve(i,n=e[o++])&&(~nn(r,n)||r.push(n));return r}(t,rn)},sn=se?Object.defineProperties:function(t,e){re(t);for(var n,i=an(e),o=i.length,r=0;r<o;)pe.f(t,n=i[r++],e[n]);return t},ln=ne.document,un=ln&&ln.documentElement,cn=en("IE_PROTO"),hn=function(){},dn="prototype",fn=function(){var t,e=ce("iframe"),n=rn.length;for(e.style.display="none",un.appendChild(e),e.src="javascript:",(t=e.contentWindow.document).open(),t.write("<script>document.F=Object<\/script>"),t.close(),fn=t.F;n--;)delete fn[dn][rn[n]];return fn()},pn=Object.create||function(t,e){var n;return null!==t?(hn[dn]=re(t),n=new hn,hn[dn]=null,n[cn]=t):n=fn(),void 0===e?n:sn(n,e)},gn=pe.f,mn=Fe("toStringTag"),_n=function(t,e,n){t&&!ve(t=n?t:t.prototype,mn)&&gn(t,mn,{configurable:!0,value:e})},vn={};me(vn,Fe("iterator"),function(){return this});var bn,yn=function(t){return Object(Ie(t))},kn=en("IE_PROTO"),wn=Object.prototype,En=Object.getPrototypeOf||function(t){return t=yn(t),ve(t,kn)?t[kn]:"function"==typeof t.constructor&&t instanceof t.constructor?t.constructor.prototype:t instanceof Object?wn:null},Cn=Fe("iterator"),An=!([].keys&&"next"in[].keys()),Sn="values",Pn=function(){return this},On=function(t,e,n,i,o,r,a){!function(t,e,n){t.prototype=pn(vn,{next:ge(1,n)}),_n(t,e+" Iterator")}(n,e,i);var s,l,u,c=function(t){if(!An&&t in p)return p[t];switch(t){case"keys":case Sn:return function(){return new n(this,t)}}return function(){return new n(this,t)}},h=e+" Iterator",d=o==Sn,f=!1,p=t.prototype,g=p[Cn]||p["@@iterator"]||o&&p[o],m=g||c(o),_=o?d?c("entries"):m:void 0,v="Array"==e&&p.entries||g;if(v&&(u=En(v.call(new t)))!==Object.prototype&&u.next&&(_n(u,h,!0),"function"!=typeof u[Cn]&&me(u,Cn,Pn)),d&&g&&g.name!==Sn&&(f=!0,m=function(){return g.call(this)}),(An||f||!p[Cn])&&me(p,Cn,m),$e[e]=m,$e[h]=Pn,o)if(s={values:d?m:c(Sn),keys:r?m:c("keys"),entries:_},a)for(l in s)l in p||Ce(p,l,s[l]);else xe(xe.P+xe.F*(An||f),e,s);return s},xn=(bn=!0,function(t,e){var n,i,o=String(Ie(t)),r=Ge(e),a=o.length;return r<0||a<=r?bn?"":void 0:(n=o.charCodeAt(r))<55296||56319<n||r+1===a||(i=o.charCodeAt(r+1))<56320||57343<i?bn?o.charAt(r):n:bn?o.slice(r,r+2):i-56320+(n-55296<<10)+65536});On(String,"String",function(t){this._t=String(t),this._i=0},function(){var t,e=this._t,n=this._i;return n>=e.length?{value:void 0,done:!0}:(t=xn(e,n),this._i+=t.length,{value:t,done:!1})});var Tn=Fe("unscopables"),Ln=Array.prototype;null==Ln[Tn]&&me(Ln,Tn,{});var Mn=function(t){Ln[Tn][t]=!0},Dn=function(t,e){return{value:e,done:!!t}},In=On(Array,"Array",function(t,e){this._t=Ne(t),this._i=0,this._k=e},function(){var t=this._t,e=this._k,n=this._i++;return!t||n>=t.length?(this._t=void 0,Dn(1)):Dn(0,"keys"==e?n:"values"==e?t[n]:[n,t[n]])},"values");$e.Arguments=$e.Array,Mn("keys"),Mn("values"),Mn("entries");for(var Nn=Fe("iterator"),Bn=Fe("toStringTag"),jn=$e.Array,Hn={CSSRuleList:!0,CSSStyleDeclaration:!1,CSSValueList:!1,ClientRectList:!1,DOMRectList:!1,DOMStringList:!1,DOMTokenList:!0,DataTransferItemList:!1,FileList:!1,HTMLAllCollection:!1,HTMLCollection:!1,HTMLFormElement:!1,HTMLSelectElement:!1,MediaList:!0,MimeTypeArray:!1,NamedNodeMap:!1,NodeList:!0,PaintRequestList:!1,Plugin:!1,PluginArray:!1,SVGLengthList:!1,SVGNumberList:!1,SVGPathSegList:!1,SVGPointList:!1,SVGStringList:!1,SVGTransformList:!1,SourceBufferList:!1,StyleSheetList:!0,TextTrackCueList:!1,TextTrackList:!1,TouchList:!1},Rn=an(Hn),Fn=0;Fn<Rn.length;Fn++){var qn,zn=Rn[Fn],Vn=Hn[zn],Wn=ne[zn],Un=Wn&&Wn.prototype;if(Un&&(Un[Nn]||me(Un,Nn,jn),Un[Bn]||me(Un,Bn,zn),$e[zn]=jn,Vn))for(qn in In)Un[qn]||Ce(Un,qn,In[qn],!0)}var Xn=function(t,e,n){for(var i in e)Ce(t,i,e[i],n);return t},Yn=function(t,e,n,i){if(!(t instanceof e)||void 0!==i&&i in t)throw TypeError(n+": incorrect invocation!");return t},Gn=function(e,t,n,i){try{return i?t(re(n)[0],n[1]):t(n)}catch(t){var o=e.return;throw void 0!==o&&re(o.call(e)),t}},$n=Fe("iterator"),Kn=Array.prototype,Qn=function(t){return void 0!==t&&($e.Array===t||Kn[$n]===t)},Jn=Fe("iterator"),Zn=ie.getIteratorMethod=function(t){if(null!=t)return t[Jn]||t["@@iterator"]||$e[Ve(t)]},ti=te(function(t){var d={},f={},e=t.exports=function(t,e,n,i,o){var r,a,s,l,u=o?function(){return t}:Zn(t),c=Se(n,i,e?2:1),h=0;if("function"!=typeof u)throw TypeError(t+" is not iterable!");if(Qn(u)){for(r=Qe(t.length);h<r;h++)if((l=e?c(re(a=t[h])[0],a[1]):c(t[h]))===d||l===f)return l}else for(s=u.call(t);!(a=s.next()).done;)if((l=Gn(s,c,a.value,e))===d||l===f)return l};e.BREAK=d,e.RETURN=f}),ei=Fe("species"),ni=te(function(t){var n=ke("meta"),e=pe.f,i=0,o=Object.isExtensible||function(){return!0},r=!ae(function(){return o(Object.preventExtensions({}))}),a=function(t){e(t,n,{value:{i:"O"+ ++i,w:{}}})},s=t.exports={KEY:n,NEED:!1,fastKey:function(t,e){if(!oe(t))return"symbol"==(void 0===t?"undefined":u(t))?t:("string"==typeof t?"S":"P")+t;if(!ve(t,n)){if(!o(t))return"F";if(!e)return"E";a(t)}return t[n].i},getWeak:function(t,e){if(!ve(t,n)){if(!o(t))return!0;if(!e)return!1;a(t)}return t[n].w},onFreeze:function(t){return r&&s.NEED&&o(t)&&!ve(t,n)&&a(t),t}}}),ii=(ni.KEY,ni.NEED,ni.fastKey,ni.getWeak,ni.onFreeze,function(t,e){if(!oe(t)||t._t!==e)throw TypeError("Incompatible receiver, "+e+" required!");return t}),oi=pe.f,ri=ni.fastKey,ai=se?"_s":"size",si=function(t,e){var n,i=ri(e);if("F"!==i)return t._i[i];for(n=t._f;n;n=n.n)if(n.k==e)return n},li={getConstructor:function(t,r,n,i){var o=t(function(t,e){Yn(t,o,r,"_i"),t._t=r,t._i=pn(null),t._f=void 0,t._l=void 0,t[ai]=0,null!=e&&ti(e,n,t[i],t)});return Xn(o.prototype,{clear:function(){for(var t=ii(this,r),e=t._i,n=t._f;n;n=n.n)n.r=!0,n.p&&(n.p=n.p.n=void 0),delete e[n.i];t._f=t._l=void 0,t[ai]=0},delete:function(t){var e=ii(this,r),n=si(e,t);if(n){var i=n.n,o=n.p;delete e._i[n.i],n.r=!0,o&&(o.n=i),i&&(i.p=o),e._f==n&&(e._f=i),e._l==n&&(e._l=o),e[ai]--}return!!n},forEach:function(t){ii(this,r);for(var e,n=Se(t,1<arguments.length?arguments[1]:void 0,3);e=e?e.n:this._f;)for(n(e.v,e.k,this);e&&e.r;)e=e.p},has:function(t){return!!si(ii(this,r),t)}}),se&&oi(o.prototype,"size",{get:function(){return ii(this,r)[ai]}}),o},def:function(t,e,n){var i,o,r=si(t,e);return r?r.v=n:(t._l=r={i:o=ri(e,!0),k:e,v:n,p:i=t._l,n:void 0,r:!1},t._f||(t._f=r),i&&(i.n=r),t[ai]++,"F"!==o&&(t._i[o]=r)),t},getEntry:si,setStrong:function(t,n,e){On(t,n,function(t,e){this._t=ii(t,n),this._k=e,this._l=void 0},function(){for(var t=this,e=t._k,n=t._l;n&&n.r;)n=n.p;return t._t&&(t._l=n=n?n.n:t._t._f)?Dn(0,"keys"==e?n.k:"values"==e?n.v:[n.k,n.v]):(t._t=void 0,Dn(1))},e?"entries":"values",!e,!0),function(t){var e=ne[t];se&&e&&!e[ei]&&pe.f(e,ei,{configurable:!0,get:function(){return this}})}(n)}},ui=Fe("iterator"),ci=!1;try{[7][ui]().return=function(){ci=!0}}catch(t){}var hi=function(t,e){if(!e&&!ci)return!1;var n=!1;try{var i=[7],o=i[ui]();o.next=function(){return{done:n=!0}},i[ui]=function(){return o},t(i)}catch(t){}return n},di=Re.set,fi=function(i,t,e,n,o,r){var a=ne[i],s=a,l=o?"set":"add",u=s&&s.prototype,c={},h=function(t){var n=u[t];Ce(u,t,"delete"==t?function(t){return!(r&&!oe(t))&&n.call(this,0===t?0:t)}:"has"==t?function(t){return!(r&&!oe(t))&&n.call(this,0===t?0:t)}:"get"==t?function(t){return r&&!oe(t)?void 0:n.call(this,0===t?0:t)}:"add"==t?function(t){return n.call(this,0===t?0:t),this}:function(t,e){return n.call(this,0===t?0:t,e),this})};if("function"==typeof s&&(r||u.forEach&&!ae(function(){(new s).entries().next()}))){var d=new s,f=d[l](r?{}:-0,1)!=d,p=ae(function(){d.has(1)}),g=hi(function(t){new s(t)}),m=!r&&ae(function(){for(var t=new s,e=5;e--;)t[l](e,e);return!t.has(-0)});g||(((s=t(function(t,e){Yn(t,s,i);var n=function(t,e,n){var i,o=e.constructor;return o!==n&&"function"==typeof o&&(i=o.prototype)!==n.prototype&&oe(i)&&di&&di(t,i),t}(new a,t,s);return null!=e&&ti(e,o,n[l],n),n})).prototype=u).constructor=s),(p||m)&&(h("delete"),h("has"),o&&h("get")),(m||f)&&h(l),r&&u.clear&&delete u.clear}else s=n.getConstructor(t,i,o,l),Xn(s.prototype,e),ni.NEED=!0;return _n(s,i),c[i]=s,xe(xe.G+xe.W+xe.F*(s!=a),c),r||n.setStrong(s,i,o),s},pi=(fi("Set",function(t){return function(){return t(this,0<arguments.length?arguments[0]:void 0)}},{add:function(t){return li.def(ii(this,"Set"),t=0===t?0:t,t)}},li),function(t){return function(){if(Ve(this)!=t)throw TypeError(t+"#toJSON isn't generic");return function(t,e){var n=[];return ti(t,!1,n.push,n,e),n}(this)}});xe(xe.P+xe.R,"Set",{toJSON:pi("Set")});var gi=function(t){xe(xe.S,t,{of:function(){for(var t=arguments.length,e=new Array(t);t--;)e[t]=arguments[t];return new this(e)}})};gi("Set");var mi=function(t){xe(xe.S,t,{from:function(t){var e,n,i,o,r=arguments[1];return Ae(this),(e=void 0!==r)&&Ae(r),null==t?new this:(n=[],e?(i=0,o=Se(r,arguments[2],2),ti(t,!1,function(t){n.push(o(t,i++))})):ti(t,!1,n.push,n),new this(n))}})};mi("Set");ie.Set,fi("Map",function(t){return function(){return t(this,0<arguments.length?arguments[0]:void 0)}},{get:function(t){var e=li.getEntry(ii(this,"Map"),t);return e&&e.v},set:function(t,e){return li.def(ii(this,"Map"),0===t?0:t,e)}},li,!0);xe(xe.P+xe.R,"Map",{toJSON:pi("Map")}),gi("Map"),mi("Map");ie.Map;var _i=Array.isArray||function(t){return"Array"==Me(t)},vi=Fe("species"),bi=function(t,e){return new(function(t){var e;return _i(t)&&("function"!=typeof(e=t.constructor)||e!==Array&&!_i(e.prototype)||(e=void 0),oe(e)&&null===(e=e[vi])&&(e=void 0)),void 0===e?Array:e}(t))(e)},yi=function(h,t){var d=1==h,f=2==h,p=3==h,g=4==h,m=6==h,_=5==h||m,v=t||bi;return function(t,e,n){for(var i,o,r=yn(t),a=De(r),s=Se(e,n,3),l=Qe(a.length),u=0,c=d?v(t,l):f?v(t,0):void 0;u<l;u++)if((_||u in a)&&(o=s(i=a[u],u,r),h))if(d)c[u]=o;else if(o)switch(h){case 3:return!0;case 5:return i;case 6:return u;case 2:c.push(i)}else if(g)return!1;return m?-1:p||g?g:c}},ki={f:Object.getOwnPropertySymbols},wi=Object.assign,Ei=!wi||ae(function(){var t={},e={},n=Symbol(),i="abcdefghijklmnopqrst";return t[n]=7,i.split("").forEach(function(t){e[t]=t}),7!=wi({},t)[n]||Object.keys(wi({},e)).join("")!=i})?function(t,e){for(var n=yn(t),i=arguments.length,o=1,r=ki.f,a=Te.f;o<i;)for(var s,l=De(arguments[o++]),u=r?an(l).concat(r(l)):an(l),c=u.length,h=0;h<c;)a.call(l,s=u[h++])&&(n[s]=l[s]);return n}:wi,Ci=ni.getWeak,Ai=yi(5),Si=yi(6),Pi=0,Oi=function(t){return t._l||(t._l=new xi)},xi=function(){this.a=[]},Ti=function(t,e){return Ai(t.a,function(t){return t[0]===e})};xi.prototype={get:function(t){var e=Ti(this,t);if(e)return e[1]},has:function(t){return!!Ti(this,t)},set:function(t,e){var n=Ti(this,t);n?n[1]=e:this.a.push([t,e])},delete:function(e){var t=Si(this.a,function(t){return t[0]===e});return~t&&this.a.splice(t,1),!!~t}};var Li={getConstructor:function(t,n,i,o){var r=t(function(t,e){Yn(t,r,n,"_i"),t._t=n,t._i=Pi++,t._l=void 0,null!=e&&ti(e,i,t[o],t)});return Xn(r.prototype,{delete:function(t){if(!oe(t))return!1;var e=Ci(t);return!0===e?Oi(ii(this,n)).delete(t):e&&ve(e,this._i)&&delete e[this._i]},has:function(t){if(!oe(t))return!1;var e=Ci(t);return!0===e?Oi(ii(this,n)).has(t):e&&ve(e,this._i)}}),r},def:function(t,e,n){var i=Ci(re(e),!0);return!0===i?Oi(t).set(e,n):i[t._i]=n,t},ufstore:Oi};te(function(t){var r,e=yi(0),n=!ne.ActiveXObject&&"ActiveXObject"in ne,i="WeakMap",o=ni.getWeak,a=Object.isExtensible,s=Li.ufstore,l=function(t){return function(){return t(this,0<arguments.length?arguments[0]:void 0)}},u={get:function(t){if(oe(t)){var e=o(t);return!0===e?s(ii(this,i)).get(t):e?e[this._i]:void 0}},set:function(t,e){return Li.def(ii(this,i),t,e)}},c=t.exports=fi(i,l,u,Li,!0,!0);n&&(r=Li.getConstructor(l,i),Ei(r.prototype,u),ni.NEED=!0,e(["delete","has","get","set"],function(i){var t=c.prototype,o=t[i];Ce(t,i,function(t,e){if(!oe(t)||a(t))return o.call(this,t,e);this._f||(this._f=new r);var n=this._f[i](t,e);return"set"==i?this:n})}))});gi("WeakMap"),mi("WeakMap");ie.WeakMap;var Mi=function(t,e,n){e in t?pe.f(t,e,ge(0,n)):t[e]=n};xe(xe.S+xe.F*!hi(function(t){}),"Array",{from:function(t){var e,n,i,o,r=yn(t),a="function"==typeof this?this:Array,s=arguments.length,l=1<s?arguments[1]:void 0,u=void 0!==l,c=0,h=Zn(r);if(u&&(l=Se(l,2<s?arguments[2]:void 0,2)),null==h||a==Array&&Qn(h))for(n=new a(e=Qe(r.length));c<e;c++)Mi(n,c,u?l(r[c],c):r[c]);else for(o=h.call(r),n=new a;!(i=o.next()).done;c++)Mi(n,c,u?Gn(o,l,[i.value,c],!0):i.value);return n.length=c,n}});ie.Array.from;var Di=new Set(["annotation-xml","color-profile","font-face","font-face-src","font-face-uri","font-face-format","font-face-name","missing-glyph"]);function Ii(t){var e=Di.has(t),n=/^[a-z][.0-9_a-z]*-[\-.0-9_a-z]*$/.test(t);return!e&&n}function Ni(t){var e=t.isConnected;if(void 0!==e)return e;for(var n=t;n&&!(n.__CE_isImportDocument||n instanceof Document);)n=n.parentNode||(window.ShadowRoot&&n instanceof ShadowRoot?n.host:void 0);return!(!n||!(n.__CE_isImportDocument||n instanceof Document))}function Bi(t,e){for(var n=e;n&&n!==t&&!n.nextSibling;)n=n.parentNode;return n&&n!==t?n.nextSibling:null}function ji(t,e){for(var n,i,o=2<arguments.length&&void 0!==arguments[2]?arguments[2]:new Set,r=t;r;){if(r.nodeType===Node.ELEMENT_NODE){var a=r;e(a);var s=a.localName;if("link"===s&&"import"===a.getAttribute("rel")){var l=a.import;if(l instanceof Node&&!o.has(l)){o.add(l);for(var u=l.firstChild;u;u=u.nextSibling)ji(u,e,o)}r=Bi(t,a);continue}if("template"===s){r=Bi(t,a);continue}var c=a.__CE_shadowRoot;if(c)for(var h=c.firstChild;h;h=h.nextSibling)ji(h,e,o)}n=t,r=(i=r).firstChild?i.firstChild:Bi(n,i)}}function Hi(t,e,n){t[e]=n}var Ri=1,Fi=2,qi=function(){function t(){h(this,t),this._localNameToDefinition=new Map,this._constructorToDefinition=new Map,this._patches=[],this._hasPatches=!1}return d(t,[{key:"setDefinition",value:function(t,e){this._localNameToDefinition.set(t,e),this._constructorToDefinition.set(e.constructor,e)}},{key:"localNameToDefinition",value:function(t){return this._localNameToDefinition.get(t)}},{key:"constructorToDefinition",value:function(t){return this._constructorToDefinition.get(t)}},{key:"addPatch",value:function(t){this._hasPatches=!0,this._patches.push(t)}},{key:"patchTree",value:function(t){var e=this;this._hasPatches&&ji(t,function(t){return e.patch(t)})}},{key:"patch",value:function(t){if(this._hasPatches&&!t.__CE_patched){t.__CE_patched=!0;for(var e=0;e<this._patches.length;e++)this._patches[e](t)}}},{key:"connectTree",value:function(t){var e=[];ji(t,function(t){return e.push(t)});for(var n=0;n<e.length;n++){var i=e[n];i.__CE_state===Ri?Ni(i)&&this.connectedCallback(i):this.upgradeElement(i)}}},{key:"disconnectTree",value:function(t){var e=[];ji(t,function(t){return e.push(t)});for(var n=0;n<e.length;n++){var i=e[n];i.__CE_state===Ri&&this.disconnectedCallback(i)}}},{key:"patchAndUpgradeTree",value:function(t){var n=this,i=1<arguments.length&&void 0!==arguments[1]?arguments[1]:new Set,o=[];if(ji(t,function(e){if("link"===e.localName&&"import"===e.getAttribute("rel")){var t=e.import;t instanceof Node&&"complete"===t.readyState?(t.__CE_isImportDocument=!0,t.__CE_hasRegistry=!0):e.addEventListener("load",function(){var t=e.import;t.__CE_documentLoadHandled||(t.__CE_documentLoadHandled=!0,t.__CE_isImportDocument=!0,t.__CE_hasRegistry=!0,i.delete(t),n.patchAndUpgradeTree(t,i))})}else o.push(e)},i),this._hasPatches)for(var e=0;e<o.length;e++)this.patch(o[e]);for(var r=0;r<o.length;r++)this.upgradeElement(o[r])}},{key:"upgradeElement",value:function(e){if(void 0===e.__CE_state){var t=this.localNameToDefinition(e.localName);if(t){t.constructionStack.push(e);var n=t.constructor;try{try{if(new n!==e)throw new Error("The custom element constructor did not produce the element being upgraded.")}finally{t.constructionStack.pop()}}catch(t){throw e.__CE_state=Fi,t}if(e.__CE_state=Ri,(e.__CE_definition=t).attributeChangedCallback)for(var i=t.observedAttributes,o=0;o<i.length;o++){var r=i[o],a=e.getAttribute(r);null!==a&&this.attributeChangedCallback(e,r,null,a,null)}Ni(e)&&this.connectedCallback(e)}}}},{key:"connectedCallback",value:function(t){var e=t.__CE_definition;e.connectedCallback&&e.connectedCallback.call(t),t.__CE_isConnectedCallbackCalled=!0}},{key:"disconnectedCallback",value:function(t){t.__CE_isConnectedCallbackCalled||this.connectedCallback(t);var e=t.__CE_definition;e.disconnectedCallback&&e.disconnectedCallback.call(t),t.__CE_isConnectedCallbackCalled=void 0}},{key:"attributeChangedCallback",value:function(t,e,n,i,o){var r=t.__CE_definition;r.attributeChangedCallback&&-1<r.observedAttributes.indexOf(e)&&r.attributeChangedCallback.call(t,e,n,i,o)}}]),t}(),zi=function(){function n(t,e){h(this,n),this._internals=t,this._document=e,this._observer=void 0,this._internals.patchAndUpgradeTree(this._document),"loading"===this._document.readyState&&(this._observer=new MutationObserver(this._handleMutations.bind(this)),this._observer.observe(this._document,{childList:!0,subtree:!0}))}return d(n,[{key:"disconnect",value:function(){this._observer&&this._observer.disconnect()}},{key:"_handleMutations",value:function(t){var e=this._document.readyState;"interactive"!==e&&"complete"!==e||this.disconnect();for(var n=0;n<t.length;n++)for(var i=t[n].addedNodes,o=0;o<i.length;o++){var r=i[o];this._internals.patchAndUpgradeTree(r)}}}]),n}(),Vi=function(){function t(){var e=this;h(this,t),this._value=void 0,this._resolve=void 0,this._promise=new Promise(function(t){e._resolve=t,e._value&&t(e._value)})}return d(t,[{key:"resolve",value:function(t){if(this._value)throw new Error("Already resolved.");this._value=t,this._resolve&&this._resolve(t)}},{key:"toPromise",value:function(){return this._promise}}]),t}(),Wi=function(){function e(t){h(this,e),this._elementDefinitionIsRunning=!1,this._internals=t,this._whenDefinedDeferred=new Map,this._flushCallback=function(t){return t()},this._flushPending=!1,this._unflushedLocalNames=[],this._documentConstructionObserver=new zi(t,document)}return d(e,[{key:"define",value:function(t,e){var n=this;if(!(e instanceof Function))throw new TypeError("Custom element constructors must be functions.");if(!Ii(t))throw new SyntaxError("The element name '"+t+"' is not valid.");if(this._internals.localNameToDefinition(t))throw new Error("A custom element with name '"+t+"' has already been defined.");if(this._elementDefinitionIsRunning)throw new Error("A custom element is already being defined.");this._elementDefinitionIsRunning=!0;var i=void 0,o=void 0,r=void 0,a=void 0,s=void 0;try{var l=function(t){var e=u[t];if(void 0!==e&&!(e instanceof Function))throw new Error("The '"+t+"' callback must be a function.");return e},u=e.prototype;if(!(u instanceof Object))throw new TypeError("The custom element constructor's prototype is not an object.");i=l("connectedCallback"),o=l("disconnectedCallback"),r=l("adoptedCallback"),a=l("attributeChangedCallback"),s=e.observedAttributes||[]}catch(t){return}finally{this._elementDefinitionIsRunning=!1}var c={localName:t,constructor:e,connectedCallback:i,disconnectedCallback:o,adoptedCallback:r,attributeChangedCallback:a,observedAttributes:s,constructionStack:[]};this._internals.setDefinition(t,c),this._unflushedLocalNames.push(t),this._flushPending||(this._flushPending=!0,this._flushCallback(function(){return n._flush()}))}},{key:"_flush",value:function(){if(!1!==this._flushPending)for(this._flushPending=!1,this._internals.patchAndUpgradeTree(document);0<this._unflushedLocalNames.length;){var t=this._unflushedLocalNames.shift(),e=this._whenDefinedDeferred.get(t);e&&e.resolve(void 0)}}},{key:"get",value:function(t){var e=this._internals.localNameToDefinition(t);if(e)return e.constructor}},{key:"whenDefined",value:function(t){if(!Ii(t))return Promise.reject(new SyntaxError("'"+t+"' is not a valid custom element name."));var e=this._whenDefinedDeferred.get(t);if(e)return e.toPromise();var n=new Vi;return this._whenDefinedDeferred.set(t,n),this._internals.localNameToDefinition(t)&&-1===this._unflushedLocalNames.indexOf(t)&&n.resolve(void 0),n.toPromise()}},{key:"polyfillWrapFlushCallback",value:function(e){this._documentConstructionObserver.disconnect();var n=this._flushCallback;this._flushCallback=function(t){return e(function(){return n(t)})}}}]),e}();(window.CustomElementRegistry=Wi).prototype.define=Wi.prototype.define,Wi.prototype.get=Wi.prototype.get,Wi.prototype.whenDefined=Wi.prototype.whenDefined,Wi.prototype.polyfillWrapFlushCallback=Wi.prototype.polyfillWrapFlushCallback;var Ui,Xi,Yi={Document_createElement:window.Document.prototype.createElement,Document_createElementNS:window.Document.prototype.createElementNS,Document_importNode:window.Document.prototype.importNode,Document_prepend:window.Document.prototype.prepend,Document_append:window.Document.prototype.append,Node_cloneNode:window.Node.prototype.cloneNode,Node_appendChild:window.Node.prototype.appendChild,Node_insertBefore:window.Node.prototype.insertBefore,Node_removeChild:window.Node.prototype.removeChild,Node_replaceChild:window.Node.prototype.replaceChild,Node_textContent:Object.getOwnPropertyDescriptor(window.Node.prototype,"textContent"),Element_attachShadow:window.Element.prototype.attachShadow,Element_innerHTML:Object.getOwnPropertyDescriptor(window.Element.prototype,"innerHTML"),Element_getAttribute:window.Element.prototype.getAttribute,Element_setAttribute:window.Element.prototype.setAttribute,Element_removeAttribute:window.Element.prototype.removeAttribute,Element_getAttributeNS:window.Element.prototype.getAttributeNS,Element_setAttributeNS:window.Element.prototype.setAttributeNS,Element_removeAttributeNS:window.Element.prototype.removeAttributeNS,Element_insertAdjacentElement:window.Element.prototype.insertAdjacentElement,Element_prepend:window.Element.prototype.prepend,Element_append:window.Element.prototype.append,Element_before:window.Element.prototype.before,Element_after:window.Element.prototype.after,Element_replaceWith:window.Element.prototype.replaceWith,Element_remove:window.Element.prototype.remove,HTMLElement:window.HTMLElement,HTMLElement_innerHTML:Object.getOwnPropertyDescriptor(window.HTMLElement.prototype,"innerHTML"),HTMLElement_insertAdjacentElement:window.HTMLElement.prototype.insertAdjacentElement},Gi=new function t(){h(this,t)},$i=function(s,t,l){t.prepend=function(){for(var t=arguments.length,e=Array(t),n=0;n<t;n++)e[n]=arguments[n];var i=e.filter(function(t){return t instanceof Node&&Ni(t)});l.prepend.apply(this,e);for(var o=0;o<i.length;o++)s.disconnectTree(i[o]);if(Ni(this))for(var r=0;r<e.length;r++){var a=e[r];a instanceof Element&&s.connectTree(a)}},t.append=function(){for(var t=arguments.length,e=Array(t),n=0;n<t;n++)e[n]=arguments[n];var i=e.filter(function(t){return t instanceof Node&&Ni(t)});l.append.apply(this,e);for(var o=0;o<i.length;o++)s.disconnectTree(i[o]);if(Ni(this))for(var r=0;r<e.length;r++){var a=e[r];a instanceof Element&&s.connectTree(a)}}},Ki=window.customElements;if(!Ki||Ki.forcePolyfill||"function"!=typeof Ki.define||"function"!=typeof Ki.get){var Qi=new qi;Ui=Qi,window.HTMLElement=function(){function t(){var t=this.constructor,e=Ui.constructorToDefinition(t);if(!e)throw new Error("The custom element being constructed was not registered with `customElements`.");var n=e.constructionStack;if(0===n.length){var i=Yi.Document_createElement.call(document,e.localName);return Object.setPrototypeOf(i,t.prototype),i.__CE_state=Ri,i.__CE_definition=e,Ui.patch(i),i}var o=n.length-1,r=n[o];if(r===Gi)throw new Error("The HTMLElement constructor was either called reentrantly for this constructor or called multiple times.");return n[o]=Gi,Object.setPrototypeOf(r,t.prototype),Ui.patch(r),r}return t.prototype=Yi.HTMLElement.prototype,t}(),function(o){Hi(Document.prototype,"createElement",function(t){if(this.__CE_hasRegistry){var e=o.localNameToDefinition(t);if(e)return new e.constructor}var n=Yi.Document_createElement.call(this,t);return o.patch(n),n}),Hi(Document.prototype,"importNode",function(t,e){var n=Yi.Document_importNode.call(this,t,e);return this.__CE_hasRegistry?o.patchAndUpgradeTree(n):o.patchTree(n),n});Hi(Document.prototype,"createElementNS",function(t,e){if(this.__CE_hasRegistry&&(null===t||"http://www.w3.org/1999/xhtml"===t)){var n=o.localNameToDefinition(e);if(n)return new n.constructor}var i=Yi.Document_createElementNS.call(this,t,e);return o.patch(i),i}),$i(o,Document.prototype,{prepend:Yi.Document_prepend,append:Yi.Document_append})}(Qi),function(l){function e(t,a){Object.defineProperty(t,"textContent",{enumerable:a.enumerable,configurable:!0,get:a.get,set:function(t){if(this.nodeType!==Node.TEXT_NODE){var e=void 0;if(this.firstChild){var n=this.childNodes,i=n.length;if(0<i&&Ni(this)){e=new Array(i);for(var o=0;o<i;o++)e[o]=n[o]}}if(a.set.call(this,t),e)for(var r=0;r<e.length;r++)l.disconnectTree(e[r])}else a.set.call(this,t)}})}Hi(Node.prototype,"insertBefore",function(t,e){if(t instanceof DocumentFragment){var n=Array.prototype.slice.apply(t.childNodes),i=Yi.Node_insertBefore.call(this,t,e);if(Ni(this))for(var o=0;o<n.length;o++)l.connectTree(n[o]);return i}var r=Ni(t),a=Yi.Node_insertBefore.call(this,t,e);return r&&l.disconnectTree(t),Ni(this)&&l.connectTree(t),a}),Hi(Node.prototype,"appendChild",function(t){if(t instanceof DocumentFragment){var e=Array.prototype.slice.apply(t.childNodes),n=Yi.Node_appendChild.call(this,t);if(Ni(this))for(var i=0;i<e.length;i++)l.connectTree(e[i]);return n}var o=Ni(t),r=Yi.Node_appendChild.call(this,t);return o&&l.disconnectTree(t),Ni(this)&&l.connectTree(t),r}),Hi(Node.prototype,"cloneNode",function(t){var e=Yi.Node_cloneNode.call(this,t);return this.ownerDocument.__CE_hasRegistry?l.patchAndUpgradeTree(e):l.patchTree(e),e}),Hi(Node.prototype,"removeChild",function(t){var e=Ni(t),n=Yi.Node_removeChild.call(this,t);return e&&l.disconnectTree(t),n}),Hi(Node.prototype,"replaceChild",function(t,e){if(t instanceof DocumentFragment){var n=Array.prototype.slice.apply(t.childNodes),i=Yi.Node_replaceChild.call(this,t,e);if(Ni(this)){l.disconnectTree(e);for(var o=0;o<n.length;o++)l.connectTree(n[o])}return i}var r=Ni(t),a=Yi.Node_replaceChild.call(this,t,e),s=Ni(this);return s&&l.disconnectTree(e),r&&l.disconnectTree(t),s&&l.connectTree(t),a}),Yi.Node_textContent&&Yi.Node_textContent.get?e(Node.prototype,Yi.Node_textContent):l.addPatch(function(t){e(t,{enumerable:!0,configurable:!0,get:function(){for(var t=[],e=0;e<this.childNodes.length;e++)t.push(this.childNodes[e].textContent);return t.join("")},set:function(t){for(;this.firstChild;)Yi.Node_removeChild.call(this,this.firstChild);Yi.Node_appendChild.call(this,document.createTextNode(t))}})})}(Qi),function(s){function e(t,a){Object.defineProperty(t,"innerHTML",{enumerable:a.enumerable,configurable:!0,get:a.get,set:function(t){var e=this,n=Ni(this),i=void 0;if(n&&(i=[],ji(this,function(t){t!==e&&i.push(t)})),a.set.call(this,t),i)for(var o=0;o<i.length;o++){var r=i[o];r.__CE_state===Ri&&s.disconnectedCallback(r)}return this.ownerDocument.__CE_hasRegistry?s.patchAndUpgradeTree(this):s.patchTree(this),t}})}if(Yi.Element_attachShadow?Hi(Element.prototype,"attachShadow",function(t){var e=Yi.Element_attachShadow.call(this,t);return this.__CE_shadowRoot=e}):console.warn("Custom Elements: `Element#attachShadow` was not patched."),Yi.Element_innerHTML&&Yi.Element_innerHTML.get)e(Element.prototype,Yi.Element_innerHTML);else if(Yi.HTMLElement_innerHTML&&Yi.HTMLElement_innerHTML.get)e(HTMLElement.prototype,Yi.HTMLElement_innerHTML);else{var n=Yi.Document_createElement.call(document,"div");s.addPatch(function(t){e(t,{enumerable:!0,configurable:!0,get:function(){return Yi.Node_cloneNode.call(this,!0).innerHTML},set:function(t){var e="template"===this.localName?this.content:this;for(n.innerHTML=t;0<e.childNodes.length;)Yi.Node_removeChild.call(e,e.childNodes[0]);for(;0<n.childNodes.length;)Yi.Node_appendChild.call(e,n.childNodes[0])}})})}function t(t,o){Hi(t,"insertAdjacentElement",function(t,e){var n=Ni(e),i=o.call(this,t,e);return n&&s.disconnectTree(e),Ni(i)&&s.connectTree(e),i})}Hi(Element.prototype,"setAttribute",function(t,e){if(this.__CE_state!==Ri)return Yi.Element_setAttribute.call(this,t,e);var n=Yi.Element_getAttribute.call(this,t);Yi.Element_setAttribute.call(this,t,e),e=Yi.Element_getAttribute.call(this,t),s.attributeChangedCallback(this,t,n,e,null)}),Hi(Element.prototype,"setAttributeNS",function(t,e,n){if(this.__CE_state!==Ri)return Yi.Element_setAttributeNS.call(this,t,e,n);var i=Yi.Element_getAttributeNS.call(this,t,e);Yi.Element_setAttributeNS.call(this,t,e,n),n=Yi.Element_getAttributeNS.call(this,t,e),s.attributeChangedCallback(this,e,i,n,t)}),Hi(Element.prototype,"removeAttribute",function(t){if(this.__CE_state!==Ri)return Yi.Element_removeAttribute.call(this,t);var e=Yi.Element_getAttribute.call(this,t);Yi.Element_removeAttribute.call(this,t),null!==e&&s.attributeChangedCallback(this,t,e,null,null)}),Hi(Element.prototype,"removeAttributeNS",function(t,e){if(this.__CE_state!==Ri)return Yi.Element_removeAttributeNS.call(this,t,e);var n=Yi.Element_getAttributeNS.call(this,t,e);Yi.Element_removeAttributeNS.call(this,t,e);var i=Yi.Element_getAttributeNS.call(this,t,e);n!==i&&s.attributeChangedCallback(this,e,n,i,t)}),Yi.HTMLElement_insertAdjacentElement?t(HTMLElement.prototype,Yi.HTMLElement_insertAdjacentElement):Yi.Element_insertAdjacentElement?t(Element.prototype,Yi.Element_insertAdjacentElement):console.warn("Custom Elements: `Element#insertAdjacentElement` was not patched."),$i(s,Element.prototype,{prepend:Yi.Element_prepend,append:Yi.Element_append}),function(l,t,u){t.before=function(){for(var t=arguments.length,e=Array(t),n=0;n<t;n++)e[n]=arguments[n];var i=e.filter(function(t){return t instanceof Node&&Ni(t)});u.before.apply(this,e);for(var o=0;o<i.length;o++)l.disconnectTree(i[o]);if(Ni(this))for(var r=0;r<e.length;r++){var a=e[r];a instanceof Element&&l.connectTree(a)}},t.after=function(){for(var t=arguments.length,e=Array(t),n=0;n<t;n++)e[n]=arguments[n];var i=e.filter(function(t){return t instanceof Node&&Ni(t)});u.after.apply(this,e);for(var o=0;o<i.length;o++)l.disconnectTree(i[o]);if(Ni(this))for(var r=0;r<e.length;r++){var a=e[r];a instanceof Element&&l.connectTree(a)}},t.replaceWith=function(){for(var t=arguments.length,e=Array(t),n=0;n<t;n++)e[n]=arguments[n];var i=e.filter(function(t){return t instanceof Node&&Ni(t)}),o=Ni(this);u.replaceWith.apply(this,e);for(var r=0;r<i.length;r++)l.disconnectTree(i[r]);if(o){l.disconnectTree(this);for(var a=0;a<e.length;a++){var s=e[a];s instanceof Element&&l.connectTree(s)}}},t.remove=function(){var t=Ni(this);u.remove.call(this),t&&l.disconnectTree(this)}}(s,Element.prototype,{before:Yi.Element_before,after:Yi.Element_after,replaceWith:Yi.Element_replaceWith,remove:Yi.Element_remove})}(Qi),document.__CE_hasRegistry=!0;var Ji=new Wi(Qi);Object.defineProperty(window,"customElements",{configurable:!0,enumerable:!0,value:Ji})}!function(t){if(!t.JsMutationObserver){var o,l=new WeakMap;if(/Trident|Edge/.test(navigator.userAgent))o=setTimeout;else if(window.setImmediate)o=window.setImmediate;else{var n=[],i=String(Math.random());window.addEventListener("message",function(t){if(t.data===i){var e=n;n=[],e.forEach(function(t){t()})}}),o=function(t){n.push(t),window.postMessage(i,"*")}}var h,d,r=!1,a=[],e=0;u.prototype={observe:function(t,e){if(t=function(t){return window.ShadowDOMPolyfill&&window.ShadowDOMPolyfill.wrapIfNeeded(t)||t}(t),!e.childList&&!e.attributes&&!e.characterData||e.attributeOldValue&&!e.attributes||e.attributeFilter&&e.attributeFilter.length&&!e.attributes||e.characterDataOldValue&&!e.characterData)throw new SyntaxError;var n,i=l.get(t);i||l.set(t,i=[]);for(var o=0;o<i.length;o++)if(i[o].observer===this){(n=i[o]).removeListeners(),n.options=e;break}n||(n=new _(this,t,e),i.push(n),this.nodes_.push(t)),n.addListeners()},disconnect:function(){this.nodes_.forEach(function(t){for(var e=l.get(t),n=0;n<e.length;n++){var i=e[n];if(i.observer===this){i.removeListeners(),e.splice(n,1);break}}},this),this.records_=[]},takeRecords:function(){var t=this.records_;return this.records_=[],t}},_.prototype={enqueue:function(t){var e=this.observer.records_,n=e.length;if(0<e.length){var i=m(e[n-1],t);if(i)return void(e[n-1]=i)}else!function(t){a.push(t),r||(r=!0,o(s))}(this.observer);e[n]=t},addListeners:function(){this.addListeners_(this.target)},addListeners_:function(t){var e=this.options;e.attributes&&t.addEventListener("DOMAttrModified",this,!0),e.characterData&&t.addEventListener("DOMCharacterDataModified",this,!0),e.childList&&t.addEventListener("DOMNodeInserted",this,!0),(e.childList||e.subtree)&&t.addEventListener("DOMNodeRemoved",this,!0)},removeListeners:function(){this.removeListeners_(this.target)},removeListeners_:function(t){var e=this.options;e.attributes&&t.removeEventListener("DOMAttrModified",this,!0),e.characterData&&t.removeEventListener("DOMCharacterDataModified",this,!0),e.childList&&t.removeEventListener("DOMNodeInserted",this,!0),(e.childList||e.subtree)&&t.removeEventListener("DOMNodeRemoved",this,!0)},addTransientObserver:function(t){if(t!==this.target){this.addListeners_(t),this.transientObservedNodes.push(t);var e=l.get(t);e||l.set(t,e=[]),e.push(this)}},removeTransientObservers:function(){var t=this.transientObservedNodes;this.transientObservedNodes=[],t.forEach(function(t){this.removeListeners_(t);for(var e=l.get(t),n=0;n<e.length;n++)if(e[n]===this){e.splice(n,1);break}},this)},handleEvent:function(t){switch(t.stopImmediatePropagation(),t.type){case"DOMAttrModified":var e=t.attrName,n=t.relatedNode.namespaceURI,i=t.target;(r=new p("attributes",i)).attributeName=e,r.attributeNamespace=n;var o=t.attrChange===MutationEvent.ADDITION?null:t.prevValue;f(i,function(t){if(t.attributes&&(!t.attributeFilter||!t.attributeFilter.length||-1!==t.attributeFilter.indexOf(e)||-1!==t.attributeFilter.indexOf(n)))return t.attributeOldValue?g(o):r});break;case"DOMCharacterDataModified":var r=p("characterData",i=t.target);o=t.prevValue;f(i,function(t){if(t.characterData)return t.characterDataOldValue?g(o):r});break;case"DOMNodeRemoved":this.addTransientObserver(t.target);case"DOMNodeInserted":var a,s,l=t.target;s="DOMNodeInserted"===t.type?(a=[l],[]):(a=[],[l]);var u=l.previousSibling,c=l.nextSibling;(r=p("childList",t.target.parentNode)).addedNodes=a,r.removedNodes=s,r.previousSibling=u,r.nextSibling=c,f(t.relatedNode,function(t){if(t.childList)return r})}h=d=void 0}},t.JsMutationObserver=u,t.MutationObserver||((t.MutationObserver=u)._isPolyfilled=!0)}function s(){r=!1;var t=a;a=[],t.sort(function(t,e){return t.uid_-e.uid_});var n=!1;t.forEach(function(t){var e=t.takeRecords();!function(n){n.nodes_.forEach(function(t){var e=l.get(t);e&&e.forEach(function(t){t.observer===n&&t.removeTransientObservers()})})}(t),e.length&&(t.callback_(e,t),n=!0)}),n&&s()}function f(t,e){for(var n=t;n;n=n.parentNode){var i=l.get(n);if(i)for(var o=0;o<i.length;o++){var r=i[o],a=r.options;if(n===t||a.subtree){var s=e(a);s&&r.enqueue(s)}}}}function u(t){this.callback_=t,this.nodes_=[],this.records_=[],this.uid_=++e}function c(t,e){this.type=t,this.target=e,this.addedNodes=[],this.removedNodes=[],this.previousSibling=null,this.nextSibling=null,this.attributeName=null,this.attributeNamespace=null,this.oldValue=null}function p(t,e){return h=new c(t,e)}function g(t){return d||((d=function(t){var e=new c(t.type,t.target);return e.addedNodes=t.addedNodes.slice(),e.removedNodes=t.removedNodes.slice(),e.previousSibling=t.previousSibling,e.nextSibling=t.nextSibling,e.attributeName=t.attributeName,e.attributeNamespace=t.attributeNamespace,e.oldValue=t.oldValue,e}(h)).oldValue=t,d)}function m(t,e){return t===e?t:d&&function(t){return t===d||t===h}(t)?d:null}function _(t,e,n){this.observer=t,this.target=e,this.options=n,this.transientObservedNodes=[]}}(self),function(n,i){if(!n.setImmediate){var t,o,e,r,a,s=1,l={},u=!1,c=n.document,h=Object.getPrototypeOf&&Object.getPrototypeOf(n);h=h&&h.setTimeout?h:n,t="[object process]"==={}.toString.call(n.process)?function(){var t=d(arguments);return process.nextTick(f(p,t)),t}:function(){if(n.postMessage&&!n.importScripts){var t=!0,e=n.onmessage;return n.onmessage=function(){t=!1},n.postMessage("","*"),n.onmessage=e,t}}()?(r="setImmediate$"+Math.random()+"$",a=function(t){t.source===n&&"string"==typeof t.data&&0===t.data.indexOf(r)&&p(+t.data.slice(r.length))},n.addEventListener?n.addEventListener("message",a,!1):n.attachEvent("onmessage",a),function(){var t=d(arguments);return n.postMessage(r+t,"*"),t}):n.MessageChannel?((e=new MessageChannel).port1.onmessage=function(t){p(t.data)},function(){var t=d(arguments);return e.port2.postMessage(t),t}):c&&"onreadystatechange"in c.createElement("script")?(o=c.documentElement,function(){var t=d(arguments),e=c.createElement("script");return e.onreadystatechange=function(){p(t),e.onreadystatechange=null,o.removeChild(e),e=null},o.appendChild(e),t}):function(){var t=d(arguments);return setTimeout(f(p,t),0),t},h.setImmediate=t,h.clearImmediate=g}function d(t){return l[s]=f.apply(i,t),s++}function f(t){var e=[].slice.call(arguments,1);return function(){"function"==typeof t?t.apply(i,e):new Function(""+t)()}}function p(t){if(u)setTimeout(f(p,t),0);else{var e=l[t];if(e){u=!0;try{e()}finally{g(t),u=!1}}}}function g(t){delete l[t]}}(self),Xi={ensureViewportElement:function(){var t=document.querySelector("meta[name=viewport]");return t||((t=document.createElement("meta")).name="viewport",document.head.appendChild(t)),t},setup:function(){var t=Xi.ensureViewportElement();t&&(t.hasAttribute("content")||t.setAttribute("content","width=device-width,initial-scale=1,maximum-scale=1,minimum-scale=1,user-scalable=no"))}},window.Viewport=Xi;var Zi=function(t){function e(){return h(this,e),m(this,(e.__proto__||Object.getPrototypeOf(e)).call(this))}return a(e,t),e}(function(){if("function"==typeof HTMLElement)return HTMLElement;var t=function(){};return t.prototype=document.createElement("div"),t}()),to=function(t){function e(){h(this,e);var t=m(this,(e.__proto__||Object.getPrototypeOf(e)).call(this));for(t.template=t.innerHTML;t.firstChild;)t.removeChild(t.firstChild);return t}return a(e,Zi),d(e,[{key:"connectedCallback",value:function(){this.parentNode&&this.parentNode!==document.body&&W.warn("ons-template (id = "+this.getAttribute("id")+") must be located just under document.body"+(this.parentNode.outerHTML?":\n\n"+this.parentNode.outerHTML:"."));var t=new CustomEvent("_templateloaded",{bubbles:!0,cancelable:!0});t.template=this.template,t.templateId=this.getAttribute("id"),this.dispatchEvent(t)}}]),e}();i.Template=to,customElements.define("ons-template",to);var eo=function(t){function e(){h(this,e);var t=m(this,(e.__proto__||Object.getPrototypeOf(e)).call(this));return xt(t,function(){if(null!==c._getSelectedPlatform())t._platformUpdate();else if(!t._isAllowedPlatform()){for(;t.childNodes[0];)t.childNodes[0].remove();t._platformUpdate()}}),t._onOrientationChange(),t}return a(e,Zi),d(e,[{key:"connectedCallback",value:function(){Bt.on("change",this._onOrientationChange.bind(this))}},{key:"attributeChangedCallback",value:function(t){"orientation"===t&&this._onOrientationChange()}},{key:"disconnectedCallback",value:function(){Bt.off("change",this._onOrientationChange)}},{key:"_platformUpdate",value:function(){this.style.display=this._isAllowedPlatform()?"":"none"}},{key:"_isAllowedPlatform",value:function(){return!this.getAttribute("platform")||0<=this.getAttribute("platform").split(/\s+/).indexOf(c.getMobileOS())}},{key:"_onOrientationChange",value:function(){if(this.hasAttribute("orientation")&&this._isAllowedPlatform()){var t=this.getAttribute("orientation").toLowerCase(),e=Bt.isPortrait()?"portrait":"landscape";this.style.display=t===e?"":"none"}}}],[{key:"observedAttributes",get:function(){return["orientation"]}}]),e}();i.If=eo,customElements.define("ons-if",eo);var no=function(){function e(){var t=0<arguments.length&&void 0!==arguments[0]?arguments[0]:{};h(this,e),this.timing=t.timing||"linear",this.duration=t.duration||0,this.delay=t.delay||0,this.def={timing:this.timing,duration:this.duration,delay:this.delay}}return d(e,null,[{key:"extend",value:function(){var t=0<arguments.length&&void 0!==arguments[0]?arguments[0]:{},e=this,n=function(){e.apply(this,arguments),W.extend(this,t)};return n.prototype=this.prototype,n}}]),e}(),io={isIPhoneXPortraitPatchActive:function(){return null!=document.documentElement.getAttribute("onsflag-iphonex-portrait")&&window.innerWidth<window.innerHeight},isIPhoneXLandscapePatchActive:function(){return null!=document.documentElement.getAttribute("onsflag-iphonex-landscape")&&window.innerWidth>=window.innerHeight},getSafeAreaLengths:function(){return io.isIPhoneXPortraitPatchActive()?{top:44,right:0,bottom:34,left:0}:io.isIPhoneXLandscapePatchActive()?{top:0,right:44,bottom:21,left:44}:{top:0,right:0,bottom:0,left:0}},getSafeAreaDOMRect:function(){var t=void 0;return t=io.isIPhoneXPortraitPatchActive()?{x:0,y:44,width:window.innerWidth,height:window.innerHeight-78}:io.isIPhoneXLandscapePatchActive()?{x:44,y:0,width:window.innerWidth-88,height:window.innerHeight-21}:{x:0,y:0,width:window.innerWidth,height:window.innerHeight},f({},t,{left:t.x,top:t.y,right:t.x+t.width,bottom:t.y+t.height})}},oo=function(t){function s(){var t=0<arguments.length&&void 0!==arguments[0]?arguments[0]:{},e=t.timing,n=void 0===e?"linear":e,i=t.delay,o=void 0===i?0:i,r=t.duration,a=void 0===r?.2:r;return h(this,s),m(this,(s.__proto__||Object.getPrototypeOf(s)).call(this,{timing:n,delay:o,duration:a}))}return a(s,no),d(s,[{key:"show",value:function(t,e){e()}},{key:"hide",value:function(t,e){e()}}]),s}(),ro=function(t){function l(){var t=0<arguments.length&&void 0!==arguments[0]?arguments[0]:{},e=t.timing,n=void 0===e?"ease":e,i=t.delay,o=void 0===i?0:i,r=t.duration,a=void 0===r?.4:r;h(this,l);var s=m(this,(l.__proto__||Object.getPrototypeOf(l)).call(this,{timing:n,delay:o,duration:a}));return s.maskTiming="linear",s.maskDuration=.2,s}return a(l,oo),d(l,[{key:"show",value:function(t,e){it.runAll(it(t._mask).queue({opacity:0}).wait(this.delay).queue({opacity:1},{duration:this.maskDuration,timing:this.maskTiming}),it(t._sheet,this.def).default({transform:"translate3d(0, 80%, 0)",opacity:0},{transform:"translate3d(0, 0, 0)",opacity:1}).queue(function(t){e&&e(),t()}))}},{key:"hide",value:function(t,e){it.runAll(it(t._mask).queue({opacity:1}).wait(this.delay).queue({opacity:0},{duration:this.maskDuration,timing:this.maskTiming}),it(t._sheet,this.def).default({transform:"translate3d(0, 0, 0)",opacity:1},{transform:"translate3d(0, 80%, 0)",opacity:0}).queue(function(t){e&&e(),t()}))}}]),l}(),ao=function(t){function l(){var t=0<arguments.length&&void 0!==arguments[0]?arguments[0]:{},e=t.timing,n=void 0===e?"ease":e,i=t.delay,o=void 0===i?0:i,r=t.duration,a=void 0===r?.3:r;h(this,l);var s=m(this,(l.__proto__||Object.getPrototypeOf(l)).call(this,{timing:n,delay:o,duration:a}));return s.maskTiming="linear",s.maskDuration=.2,io.isIPhoneXPortraitPatchActive()?s.liftAmount="calc(100% + 48px)":io.isIPhoneXLandscapePatchActive()?s.liftAmount="calc(100% + 33px)":s.liftAmount=document.body.clientHeight/2-1+"px",s}return a(l,oo),d(l,[{key:"show",value:function(t,e){it.runAll(it(t._mask).queue({opacity:0}).wait(this.delay).queue({opacity:1},{duration:this.maskDuration,timing:this.maskTiming}),it(t._sheet,this.def).default({transform:"translate3d(0, "+this.liftAmount+", 0)"},{transform:"translate3d(0, 0, 0)"}).queue(function(t){e&&e(),t()}))}},{key:"hide",value:function(t,e){it.runAll(it(t._mask).queue({opacity:1}).wait(this.delay).queue({opacity:0},{duration:this.maskDuration,timing:this.maskTiming}),it(t._sheet,this.def).default({transform:"translate3d(0, 0, 0)"},{transform:"translate3d(0, "+this.liftAmount+", 0)"}).queue(function(t){e&&e(),t()}))}}]),l}(),so=function(t){function n(){h(this,n);var e=m(this,(n.__proto__||Object.getPrototypeOf(n)).call(this));return e.constructor===n&&W.throwAbstract(),e._visible=!1,e._doorLock=new Wt,e._cancel=e._cancel.bind(e),e._selfCamelName=W.camelize(e.tagName.slice(4)),e._defaultDBB=function(t){return e.cancelable?e._cancel():t.callParentHandler()},e._animatorFactory=e._updateAnimatorFactory(),e}return a(n,Zi),d(n,[{key:"_updateAnimatorFactory",value:function(){W.throwMember()}},{key:"_toggleStyle",value:function(t){this.style.display=t?"block":"none"}},{key:"_scheme",get:function(){W.throwMember()}}]),d(n,[{key:"_cancel",value:function(){var t=this;this.cancelable&&!this._running&&(this._running=!0,this.hide().then(function(){t._running=!1,W.triggerElementEvent(t,"dialog-cancel")},function(){return t._running=!1}))}},{key:"show",value:function(){for(var t=arguments.length,e=Array(t),n=0;n<t;n++)e[n]=arguments[n];return this._setVisible.apply(this,[!0].concat(e))}},{key:"hide",value:function(){for(var t=arguments.length,e=Array(t),n=0;n<t;n++)e[n]=arguments[n];return this._setVisible.apply(this,[!1].concat(e))}},{key:"toggle",value:function(){for(var t=arguments.length,e=Array(t),n=0;n<t;n++)e[n]=arguments[n];return this._setVisible.apply(this,[!this.visible].concat(e))}},{key:"_setVisible",value:function(i){var t,o=this,r=1<arguments.length&&void 0!==arguments[1]?arguments[1]:{},a=i?"show":"hide";(r=f({},r)).animationOptions=W.extend(r.animationOptions||{},y.parseAnimationOptionsString(this.getAttribute("animation-options")));var e=!1;return W.triggerElementEvent(this,"pre"+a,(s(t={},this._selfCamelName,this),s(t,"cancel",function(){return e=!0}),t)),e?Promise.reject("Canceled in pre"+a+" event."):new Promise(function(n){o._doorLock.waitUnlock(function(){var t=o._doorLock.lock(),e=o._animatorFactory.newAnimator(r);i&&o._toggleStyle(!0,r),o._visible=i,W.iosPageScrollFix(i),xt(o,function(){e[a](o,function(){!i&&o._toggleStyle(!1,r),t(),W.propagateAction(o,"_"+a),W.triggerElementEvent(o,"post"+a,s({},o._selfCamelName,o)),r.callback instanceof Function&&r.callback(o),n(o)})})})})}},{key:"_updateMask",value:function(){var t=this;xt(this,function(){t._mask&&t.getAttribute("mask-color")&&(t._mask.style.backgroundColor=t.getAttribute("mask-color"))})}},{key:"connectedCallback",value:function(){var t=this;"function"==typeof this._defaultDBB&&(this.onDeviceBackButton=this._defaultDBB.bind(this)),xt(this,function(){t._mask&&(t._mask.addEventListener("click",t._cancel,!1),W.iosMaskScrollFix(t._mask,!0))})}},{key:"disconnectedCallback",value:function(){this._backButtonHandler&&(this._backButtonHandler.destroy(),this._backButtonHandler=null),this._mask&&(this._mask.removeEventListener("click",this._cancel,!1),W.iosMaskScrollFix(this._mask,!1))}},{key:"attributeChangedCallback",value:function(t,e,n){switch(t){case"modifier":O.onModifierChanged(e,n,this,this._scheme);break;case"animation":this._animatorFactory=this._updateAnimatorFactory();break;case"mask-color":this._updateMask()}}},{key:"onDeviceBackButton",get:function(){return this._backButtonHandler},set:function(t){this._backButtonHandler&&this._backButtonHandler.destroy(),this._backButtonHandler=M.createHandler(this,t)}},{key:"visible",get:function(){return this._visible}},{key:"disabled",set:function(t){return W.toggleAttribute(this,"disabled",t)},get:function(){return this.hasAttribute("disabled")}},{key:"cancelable",set:function(t){return W.toggleAttribute(this,"cancelable",t)},get:function(){return this.hasAttribute("cancelable")}}],[{key:"observedAttributes",get:function(){return["modifier","animation","mask-color"]}},{key:"events",get:function(){return["preshow","postshow","prehide","posthide","dialog-cancel"]}}]),n}(),lo={".action-sheet":"action-sheet--*",".action-sheet-mask":"action-sheet-mask--*",".action-sheet-title":"action-sheet-title--*"},uo={default:function(){return c.isAndroid()?ro:ao},none:oo},co=function(t){function i(){h(this,i);var t=m(this,(i.__proto__||Object.getPrototypeOf(i)).call(this));return xt(t,function(){return t._compile()}),t}return a(i,so),d(i,[{key:"_updateAnimatorFactory",value:function(){return new y({animators:uo,baseClass:oo,baseClassName:"ActionSheetAnimator",defaultAnimation:this.getAttribute("animation")})}},{key:"_compile",value:function(){if(P.prepare(this),this.style.display="none",this.style.zIndex=10001,!this._sheet){var t=document.createElement("div");for(t.classList.add("action-sheet");this.firstChild;)t.appendChild(this.firstChild);this.appendChild(t)}if(!this._title&&this.hasAttribute("title")){var e=document.createElement("div");e.innerHTML=this.getAttribute("title"),e.classList.add("action-sheet-title"),this._sheet.insertBefore(e,this._sheet.firstChild)}if(!this._mask){var n=document.createElement("div");n.classList.add("action-sheet-mask"),this.insertBefore(n,this.firstChild)}this._sheet.style.zIndex=20001,this._mask.style.zIndex=2e4,O.initModifier(this,this._scheme)}},{key:"_updateTitle",value:function(){this._title&&(this._title.innerHTML=this.getAttribute("title"))}},{key:"attributeChangedCallback",value:function(t,e,n){"title"===t?this._updateTitle():p(i.prototype.__proto__||Object.getPrototypeOf(i.prototype),"attributeChangedCallback",this).call(this,t,e,n)}},{key:"_scheme",get:function(){return lo}},{key:"_mask",get:function(){return W.findChild(this,".action-sheet-mask")}},{key:"_sheet",get:function(){return W.findChild(this,".action-sheet")}},{key:"_title",get:function(){return this.querySelector(".action-sheet-title")}}],[{key:"registerAnimator",value:function(t,e){e.prototype instanceof oo||W.throwAnimator("ActionSheet"),uo[t]=e}},{key:"observedAttributes",get:function(){return[].concat(_(p(i.__proto__||Object.getPrototypeOf(i),"observedAttributes",this)),["title"])}},{key:"animators",get:function(){return uo}},{key:"ActionSheetAnimator",get:function(){return oo}}]),i}();i.ActionSheet=co,customElements.define("ons-action-sheet",co);var ho=function(t){function e(){h(this,e);var t=m(this,(e.__proto__||Object.getPrototypeOf(e)).call(this));return t.constructor===e&&W.throwAbstract(),xt(t,function(){return t._compile()}),t}return a(e,Zi),d(e,[{key:"_scheme",get:function(){W.throwMember()}},{key:"_defaultClassName",get:function(){W.throwMember()}},{key:"_rippleOpt",get:function(){return[this]}}]),d(e,[{key:"_compile",value:function(){if(P.prepare(this),this.classList.add(this._defaultClassName),!this._icon&&this.hasAttribute("icon")){W.checkMissingImport("Icon");var t=W.createElement('<ons-icon icon="'+this.getAttribute("icon")+'"></ons-icon>');t.classList.add(this._defaultClassName.replace("button","icon")),this.insertBefore(t,this.firstChild)}this._updateRipple(),O.initModifier(this,this._scheme)}},{key:"_updateIcon",value:function(){this._icon&&this._icon.setAttribute("icon",this.getAttribute("icon"))}},{key:"_updateRipple",value:function(){this._rippleOpt&&W.updateRipple.apply(W,_(this._rippleOpt))}},{key:"attributeChangedCallback",value:function(t,e,n){switch(t){case"class":W.restoreClass(this,this._defaultClassName,this._scheme);break;case"modifier":O.onModifierChanged(e,n,this,this._scheme);break;case"icon":this._updateIcon();break;case"ripple":this.classList.contains(this._defaultClassName)&&this._updateRipple()}}},{key:"disabled",set:function(t){return W.toggleAttribute(this,"disabled",t)},get:function(){return this.hasAttribute("disabled")}},{key:"_icon",get:function(){return W.findChild(this,"ons-icon")}}],[{key:"observedAttributes",get:function(){return["modifier","class","icon","ripple"]}}]),e}(),fo=function(t){function e(){return h(this,e),m(this,(e.__proto__||Object.getPrototypeOf(e)).apply(this,arguments))}return a(e,ho),d(e,[{key:"_scheme",get:function(){return{"":"action-sheet-button--*",".action-sheet-icon":"action-sheet-icon--*"}}},{key:"_defaultClassName",get:function(){return"action-sheet-button"}},{key:"_rippleOpt",get:function(){}}]),e}();i.ActionSheetButton=fo,customElements.define("ons-action-sheet-button",fo);var po=function(t){function s(){var t=0<arguments.length&&void 0!==arguments[0]?arguments[0]:{},e=t.timing,n=void 0===e?"linear":e,i=t.delay,o=void 0===i?0:i,r=t.duration,a=void 0===r?.2:r;return h(this,s),m(this,(s.__proto__||Object.getPrototypeOf(s)).call(this,{timing:n,delay:o,duration:a}))}return a(s,no),d(s,[{key:"show",value:function(t,e){e()}},{key:"hide",value:function(t,e){e()}}]),s}(),go=function(t){function s(){var t=0<arguments.length&&void 0!==arguments[0]?arguments[0]:{},e=t.timing,n=void 0===e?"cubic-bezier(.1, .7, .4, 1)":e,i=t.duration,o=void 0===i?.2:i,r=t.delay,a=void 0===r?0:r;return h(this,s),m(this,(s.__proto__||Object.getPrototypeOf(s)).call(this,{duration:o,timing:n,delay:a}))}return a(s,po),d(s,[{key:"show",value:function(t,e){e=e||function(){},it.runAll(it(t._mask,this.def).default({opacity:0},{opacity:1}),it(t._dialog,this.def).default({transform:"translate3d(-50%, -50%, 0) scale3d(.9, .9, 1)",opacity:0},{transform:"translate3d(-50%, -50%, 0) scale3d(1, 1, 1)",opacity:1}).queue(function(t){e(),t()}))}},{key:"hide",value:function(t,e){e=e||function(){},it.runAll(it(t._mask,this.def).default({opacity:1},{opacity:0}),it(t._dialog,this.def).default({transform:"translate3d(-50%, -50%, 0) scale3d(1, 1, 1)",opacity:1},{transform:"translate3d(-50%, -50%, 0) scale3d(.9, .9, 1)",opacity:0}).queue(function(t){e(),t()}))}}]),s}(),mo=function(t){function s(){var t=0<arguments.length&&void 0!==arguments[0]?arguments[0]:{},e=t.timing,n=void 0===e?"cubic-bezier(.1, .7, .4, 1)":e,i=t.duration,o=void 0===i?.2:i,r=t.delay,a=void 0===r?0:r;return h(this,s),m(this,(s.__proto__||Object.getPrototypeOf(s)).call(this,{duration:o,timing:n,delay:a}))}return a(s,po),d(s,[{key:"show",value:function(t,e){e=e||function(){},it.runAll(it(t._mask,this.def).default({opacity:0},{opacity:1}),it(t._dialog,this.def).default({transform:"translate3d(-50%, -50%, 0) scale3d(1.3, 1.3, 1)",opacity:0},{transform:"translate3d(-50%, -50%, 0) scale3d(1, 1, 1)",opacity:1}).queue(function(t){e(),t()}))}},{key:"hide",value:function(t,e){e=e||function(){},it.runAll(it(t._mask,this.def).default({opacity:1},{opacity:0}),it(t._dialog,this.def).default({opacity:1},{opacity:0}).queue(function(t){e(),t()}))}}]),s}(),_o={".alert-dialog":"alert-dialog--*",".alert-dialog-container":"alert-dialog-container--*",".alert-dialog-title":"alert-dialog-title--*",".alert-dialog-content":"alert-dialog-content--*",".alert-dialog-footer":"alert-dialog-footer--*",".alert-dialog-footer--rowfooter":"alert-dialog-footer--rowfooter--*",".alert-dialog-button--rowfooter":"alert-dialog-button--rowfooter--*",".alert-dialog-button--primal":"alert-dialog-button--primal--*",".alert-dialog-button":"alert-dialog-button--*","ons-alert-dialog-button":"alert-dialog-button--*",".alert-dialog-mask":"alert-dialog-mask--*",".text-input":"text-input--*"},vo={none:po,default:function(){return c.isAndroid()?go:mo},fade:function(){return c.isAndroid()?go:mo}},bo=function(t){function e(){h(this,e);var t=m(this,(e.__proto__||Object.getPrototypeOf(e)).call(this));return xt(t,function(){return t._compile()}),t}return a(e,so),d(e,[{key:"_updateAnimatorFactory",value:function(){return new y({animators:vo,baseClass:po,baseClassName:"AlertDialogAnimator",defaultAnimation:this.getAttribute("animation")})}},{key:"_compile",value:function(){P.prepare(this),this.style.display="none",this.style.zIndex=10001;var t=document.createDocumentFragment();if(!this._mask&&!this._dialog)for(;this.firstChild;)t.appendChild(this.firstChild);if(!this._mask){var e=document.createElement("div");e.classList.add("alert-dialog-mask"),this.insertBefore(e,this.children[0])}if(!this._dialog){var n=document.createElement("div");n.classList.add("alert-dialog"),this.insertBefore(n,null)}if(!W.findChild(this._dialog,".alert-dialog-container")){var i=document.createElement("div");i.classList.add("alert-dialog-container"),this._dialog.appendChild(i)}this._dialog.children[0].appendChild(t),this._dialog.style.zIndex=20001,this._mask.style.zIndex=2e4,O.initModifier(this,this._scheme)}},{key:"_scheme",get:function(){return _o}},{key:"_mask",get:function(){return W.findChild(this,".alert-dialog-mask")}},{key:"_dialog",get:function(){return W.findChild(this,".alert-dialog")}},{key:"_titleElement",get:function(){return W.findChild(this._dialog.children[0],".alert-dialog-title")}},{key:"_contentElement",get:function(){return W.findChild(this._dialog.children[0],".alert-dialog-content")}}],[{key:"registerAnimator",value:function(t,e){e.prototype instanceof po||W.throwAnimator("AlertDialog"),vo[t]=e}},{key:"animators",get:function(){return vo}},{key:"AlertDialogAnimator",get:function(){return po}}]),e}();i.AlertDialog=bo,customElements.define("ons-alert-dialog",bo);var yo=function(t){function e(){return h(this,e),m(this,(e.__proto__||Object.getPrototypeOf(e)).apply(this,arguments))}return a(e,ho),d(e,[{key:"_scheme",get:function(){return{"":"alert-dialog-button--*"}}},{key:"_defaultClassName",get:function(){return"alert-dialog-button"}},{key:"_rippleOpt",get:function(){return[this,void 0,{modifier:"light-gray"}]}}]),e}();i.AlertDialogButton=yo,customElements.define("ons-alert-dialog-button",yo);var ko="back-button",wo={"":"back-button--*",".back-button__icon":"back-button--*__icon",".back-button__label":"back-button--*__label"},Eo=function(t){function e(){h(this,e);var t=m(this,(e.__proto__||Object.getPrototypeOf(e)).call(this));return xt(t,function(){t._compile()}),t._options={},t._boundOnClick=t._onClick.bind(t),t}return a(e,Zi),d(e,[{key:"_updateIcon",value:function(){(0<arguments.length&&void 0!==arguments[0]?arguments[0]:W.findChild(this,".back-button__icon")).innerHTML="android"===P.getPlatform(this)||W.hasModifier(this,"material")?'<?xml version="1.0" encoding="UTF-8"?>\n<svg width="16px" height="16px" viewBox="0 0 16 16" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">\n    <title>md-back-button-icon</title>\n    <desc>Created with Sketch.</desc>\n    <defs></defs>\n    <g id="toolbar-back-button" stroke="none" stroke-width="1" fill-rule="evenodd">\n        <g id="android" transform="translate(-32.000000, -32.000000)" fill-rule="nonzero">\n            <polygon id="md-back-button-icon" points="48 39 35.83 39 41.42 33.41 40 32 32 40 40 48 41.41 46.59 35.83 41 48 41"></polygon>\n        </g>\n    </g>\n</svg>\n':'<?xml version="1.0" encoding="UTF-8"?>\n<svg width="13px" height="21px" viewBox="0 0 13 21" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">\n    <title>ios-back-button-icon</title>\n    <desc>Created with Sketch.</desc>\n    <defs></defs>\n    <g id="toolbar-back-button" stroke="none" stroke-width="1" fill-rule="evenodd">\n        <g id="ios" transform="translate(-34.000000, -30.000000)">\n            <polygon id="ios-back-button-icon" points="34 40.5 44.5 30 46.5 32 38 40.5 46.5 49 44.5 51"></polygon>\n        </g>\n    </g>\n</svg>\n'}},{key:"_compile",value:function(){if(P.prepare(this),this.classList.add(ko),!W.findChild(this,".back-button__label")){for(var t=W.create("span.back-button__label");this.childNodes[0];)t.appendChild(this.childNodes[0]);this.appendChild(t)}if(!W.findChild(this,".back-button__icon")){var e=W.create("span.back-button__icon");this._updateIcon(e),this.insertBefore(e,this.children[0])}W.updateRipple(this,void 0,{center:"",size:"contain",background:"transparent"}),O.initModifier(this,wo)}},{key:"_onClick",value:function(){if(this.onClick)this.onClick.apply(this);else{var t=W.findParent(this,"ons-navigator");t&&t.popPage(this.options)}}},{key:"connectedCallback",value:function(){this.addEventListener("click",this._boundOnClick,!1)}},{key:"attributeChangedCallback",value:function(t,e,n){switch(t){case"class":W.restoreClass(this,ko,wo);break;case"modifier":O.onModifierChanged(e,n,this,wo)&&this._updateIcon()}}},{key:"disconnectedCallback",value:function(){this.removeEventListener("click",this._boundOnClick,!1)}},{key:"show",value:function(){this.style.display="inline-block"}},{key:"hide",value:function(){this.style.display="none"}},{key:"options",get:function(){return this._options},set:function(t){this._options=t}}],[{key:"observedAttributes",get:function(){return["modifier","class"]}}]),e}();i.BackButton=Eo,customElements.define("ons-back-button",Eo);var Co="bottom-bar",Ao={"":"bottom-bar--*"},So=function(t){function e(){h(this,e);var t=m(this,(e.__proto__||Object.getPrototypeOf(e)).call(this));return t.classList.add(Co),O.initModifier(t,Ao),t}return a(e,Zi),d(e,[{key:"attributeChangedCallback",value:function(t,e,n){switch(t){case"class":W.restoreClass(this,Co,Ao);break;case"modifier":O.onModifierChanged(e,n,this,Ao)}}}],[{key:"observedAttributes",get:function(){return["modifier","class"]}}]),e}();i.BottomToolbar=So,customElements.define("ons-bottom-toolbar",So);var Po=function(t){function e(){return h(this,e),m(this,(e.__proto__||Object.getPrototypeOf(e)).apply(this,arguments))}return a(e,ho),d(e,[{key:"_scheme",get:function(){return{"":"button--*"}}},{key:"_defaultClassName",get:function(){return"button"}}]),e}();i.Button=Po,customElements.define("ons-button",Po);var Oo={"":"card--*",".card__title":"card--*__title",".card__content":"card--*__content"},xo=function(t){function e(){h(this,e);var t=m(this,(e.__proto__||Object.getPrototypeOf(e)).call(this));return xt(t,function(){t._compile()}),t}return a(e,Zi),d(e,[{key:"_compile",value:function(){for(var t=0;t<this.children.length;t++){var e=this.children[t];e.classList.contains("title")?e.classList.add("card__title"):e.classList.contains("content")&&e.classList.add("card__content")}P.prepare(this),this.classList.add("card"),O.initModifier(this,Oo)}},{key:"attributeChangedCallback",value:function(t,e,n){switch(t){case"class":W.restoreClass(this,"card",Oo);break;case"modifier":O.onModifierChanged(e,n,this,Oo)}}}],[{key:"observedAttributes",get:function(){return["modifier","class"]}}]),e}();i.Card=xo,customElements.define("ons-card",xo);var To={"":"carousel-item--*"},Lo=function(t){function e(){h(this,e);var t=m(this,(e.__proto__||Object.getPrototypeOf(e)).call(this));return t.style.width="100%",O.initModifier(t,To),t}return a(e,Zi),d(e,[{key:"attributeChangedCallback",value:function(t,e,n){if("modifier"===t)return O.onModifierChanged(e,n,this,To)}}],[{key:"observedAttributes",get:function(){return["modifier"]}}]),e}();i.CarouselItem=Lo,customElements.define("ons-carousel-item",Lo);var Mo={vertical:{axis:"Y",size:"Height",dir:["up","down"],t3d:["0px, ","px, 0px"]},horizontal:{axis:"X",size:"Width",dir:["left","right"],t3d:["","px, 0px, 0px"]}},Do=function(){function t(e){var n=this;h(this,t);var i=function(){return!1};"getInitialIndex getBubbleWidth isVertical isOverScrollable isCentered\n    isAutoScrollable refreshHook preChangeHook postChangeHook overScrollHook".split(/\s+/).forEach(function(t){return n[t]=e[t]||i}),this.getElement=e.getElement,this.scrollHook=e.scrollHook,this.itemSize=e.itemSize||"100%",this.getAutoScrollRatio=function(){var t=e.getAutoScrollRatio&&e.getAutoScrollRatio.apply(e,arguments);return((t="number"==typeof t&&t==t?t:.5)<0||1<t)&&W.throw("Invalid auto-scroll-ratio "+t+". Must be between 0 and 1"),t},this.shouldBlock="other"===W.globals.actualMobileOS,this.onDragStart=this.onDragStart.bind(this),this.onDrag=this.onDrag.bind(this),this.onDragEnd=this.onDragEnd.bind(this),this.onResize=this.onResize.bind(this),this._shouldFixScroll="ios"===W.globals.actualMobileOS}return d(t,[{key:"init",value:function(){var t=this,e=0<arguments.length&&void 0!==arguments[0]?arguments[0]:{},n=e.swipeable,i=e.autoRefresh;this.initialized=!0,this.target=this.getElement().children[0],this.blocker=this.getElement().children[1],this.target&&this.blocker||W.throw('Expected "target" and "blocker" elements to exist before initializing Swiper'),this.shouldBlock||(this.blocker.style.display="none"),this.getElement().classList.add("ons-swiper"),this.target.classList.add("ons-swiper-target"),this.blocker.classList.add("ons-swiper-blocker"),this._gestureDetector=new ot(this.getElement(),{dragMinDistance:1,dragLockToAxis:!0,passive:!this._shouldFixScroll}),this._mutationObserver=new MutationObserver(function(){return t.refresh()}),this.updateSwipeable(n),this.updateAutoRefresh(i),this._scroll=this._offset=this._lastActiveIndex=0,this._updateLayout(),this._setupInitialIndex(),setImmediate(function(){return t.initialized&&t._setupInitialIndex()}),window===window.parent&&0!==this.offsetHeight||window.requestAnimationFrame(function(){return t.initialized&&t.onResize()})}},{key:"dispose",value:function(){this.initialized=!1,this.updateSwipeable(!1),this.updateAutoRefresh(!1),this._gestureDetector&&this._gestureDetector.dispose(),this.target=this.blocker=this._gestureDetector=this._mutationObserver=null,this.setupResize(!1)}},{key:"onResize",value:function(){var t=this._scroll/this.targetSize;this._reset(),this.setActiveIndex(t),this.refresh()}},{key:"_calculateItemSize",value:function(){var t=this.itemSize.match(/^(\d+)(px|%)/);t||W.throw("Invalid state: swiper's size unit must be '%' or 'px'");var e=parseInt(t[1],10);return"%"===t[2]?Math.round(e/100*this.targetSize):e}},{key:"_setupInitialIndex",value:function(){this._reset(),this._lastActiveIndex=Math.max(Math.min(Number(this.getInitialIndex()),this.itemCount),0),this._scroll=this._offset+this.itemNumSize*this._lastActiveIndex,this._scrollTo(this._scroll)}},{key:"_setSwiping",value:function(t){this.target.classList.toggle("swiping",t)}},{key:"setActiveIndex",value:function(t){var e=this,n=1<arguments.length&&void 0!==arguments[1]?arguments[1]:{};this._setSwiping(!0),t=Math.max(0,Math.min(t,this.itemCount-1));var i,o=Math.max(0,Math.min(this.maxScroll,this._offset+this.itemNumSize*t));if(c.isUIWebView()){var r=(i=W.arrayFrom(this.target.children).map(function(t){return W.arrayFrom(t.children).filter(function(t){return t.classList.contains("page__content")})}),Array.prototype.concat.apply([],i)),a=new Map;return new Promise(function(t){r.forEach(function(t){a.set(t,t.getAttribute("class")),t.classList.add("page__content--suppress-layer-creation")}),requestAnimationFrame(t)}).then(function(){return e._changeTo(o,n)}).then(function(){return new Promise(function(t){r.forEach(function(t){t.setAttribute("class",a.get(t))}),requestAnimationFrame(t)})})}return this._changeTo(o,n)}},{key:"getActiveIndex",value:function(){var t=0<arguments.length&&void 0!==arguments[0]?arguments[0]:this._scroll;t-=this._offset;var e=this.itemCount,n=this.itemNumSize;if(0===this.itemNumSize||!W.isInteger(t))return this._lastActiveIndex;if(t<=0)return 0;for(var i=0;i<e;i++)if(n*i<=t&&t<n*(i+1))return i;return e-1}},{key:"setupResize",value:function(t){window[(t?"add":"remove")+"EventListener"]("resize",this.onResize,!0)}},{key:"show",value:function(){var t=this;this.setupResize(!0),this.onResize(),setTimeout(function(){return t.target&&t.target.classList.add("active")},1e3/60)}},{key:"hide",value:function(){this.setupResize(!1),this.target.classList.remove("active")}},{key:"updateSwipeable",value:function(t){if(this._gestureDetector){var e=t?"on":"off";this._gestureDetector[e]("drag",this.onDrag),this._gestureDetector[e]("dragstart",this.onDragStart),this._gestureDetector[e]("dragend",this.onDragEnd)}}},{key:"updateAutoRefresh",value:function(t){this._mutationObserver&&(t?this._mutationObserver.observe(this.target,{childList:!0}):this._mutationObserver.disconnect())}},{key:"updateItemSize",value:function(t){this.itemSize=t||"100%",this.refresh()}},{key:"toggleBlocker",value:function(t){this.blocker.style.pointerEvents=t?"auto":"none"}},{key:"_canConsumeGesture",value:function(t){var e=t.direction,n=0===this._scroll&&!this.isOverScrollable(),i=this._scroll===this.maxScroll&&!this.isOverScrollable();return this.isVertical()?"down"===e&&!n||"up"===e&&!i:"right"===e&&!n||"left"===e&&!i}},{key:"onDragStart",value:function(t){var e=this;if(this._ignoreDrag=t.consumed||!W.isValidGesture(t),!this._ignoreDrag){var n=t.consume;if(t.consume=function(){n&&n(),e._ignoreDrag=!0},this._canConsumeGesture(t.gesture)){var i=t.gesture.center&&t.gesture.center.clientX||0,o=this.getBubbleWidth()||0,r=function(){n&&n(),t.consumed=!0,e._started=!0,e.shouldBlock&&e.toggleBlocker(!0),e._setSwiping(!0),W.iosPreventScroll(e._gestureDetector)};i<o||i>this.targetSize-o?setImmediate(function(){return!e._ignoreDrag&&r()}):r()}}}},{key:"onDrag",value:function(t){t.gesture&&!this._ignoreDrag&&this._started&&(this._continued=!0,t.stopPropagation(),this._scrollTo(this._scroll-this._getDelta(t),{throttle:!0}))}},{key:"onDragEnd",value:function(t){if(this._started=!1,t.gesture&&!this._ignoreDrag&&this._continued){this._continued=!1,t.stopPropagation();var e=this._scroll-this._getDelta(t),n=this._normalizeScroll(e);e===n?this._startMomentumScroll(e,t):this._killOverScroll(n),this.shouldBlock&&this.toggleBlocker(!1)}else this._ignoreDrag=!0}},{key:"_startMomentumScroll",value:function(t,e){var n=this._getVelocity(e),i=e.gesture.interimDirection===this.dM.dir[this._getDelta(e)<0?0:1],o=this._getAutoScroll(t,n,i),r=Math.abs(o-t)/(n+.01)/1e3;r=Math.min(.25,Math.max(.1,r)),this._changeTo(o,{swipe:!0,animationOptions:{duration:r,timing:"cubic-bezier(.4, .7, .5, 1)"}})}},{key:"_killOverScroll",value:function(t){var e=this;this._scroll=t;var n=this.dM.dir[Number(0<t)],i=function(){return e._changeTo(t,{animationOptions:{duration:.4,timing:"cubic-bezier(.1, .4, .1, 1)"}})};this.overScrollHook({direction:n,killOverScroll:i})||i()}},{key:"_changeTo",value:function(t){var e=this,n=1<arguments.length&&void 0!==arguments[1]?arguments[1]:{},i={activeIndex:this.getActiveIndex(t),lastActiveIndex:this._lastActiveIndex,swipe:n.swipe||!1},o=i.activeIndex!==i.lastActiveIndex,r=o&&this.preChangeHook(i);return this._scroll=r?this._offset+i.lastActiveIndex*this.itemNumSize:t,this._lastActiveIndex=r?i.lastActiveIndex:i.activeIndex,this._scrollTo(this._scroll,n).then(function(){if(t!==e._scroll||r){if(n.reject)return e._setSwiping(!1),Promise.reject("Canceled")}else e._setSwiping(!1),o&&e.postChangeHook(i)})}},{key:"_scrollTo",value:function(e){var n=this,t=1<arguments.length&&void 0!==arguments[1]?arguments[1]:{};if(t.throttle){if(e<0)e=this.isOverScrollable()?Math.round(.35*e):0;else{var i=this.maxScroll;i<e&&(e=this.isOverScrollable()?i+Math.round(.35*(e-i)):i)}}var o="none"===t.animation?{}:t.animationOptions;return this.scrollHook&&0<this.itemNumSize&&this.scrollHook((e/this.itemNumSize).toFixed(2),t.animationOptions||{}),new Promise(function(t){return it(n.target).queue({transform:n._getTransform(e)},o).play(t)})}},{key:"_getAutoScroll",value:function(n,t,e){var i=this.maxScroll,o=this._offset,r=this.itemNumSize;if(!this.isAutoScrollable())return Math.max(0,Math.min(i,n));for(var a=[],s=o;s<i;s+=r)a.push(s);a.push(i);var l=(a=a.sort(function(t,e){return Math.abs(t-n)-Math.abs(e-n)}).filter(function(t,e){return!e||t!==a[e-1]}))[0],u=this._lastActiveIndex*r+o,c=Math.abs(n-u)/r;return c<=this.getAutoScrollRatio(e,t,r)?l=u:c<1&&a[0]===u&&1<a.length&&(l=a[1]),Math.max(0,Math.min(i,l))}},{key:"_reset",value:function(){this._targetSize=this._itemNumSize=void 0}},{key:"_normalizeScroll",value:function(t){return Math.max(Math.min(t,this.maxScroll),0)}},{key:"refresh",value:function(){if(this._reset(),this._updateLayout(),W.isInteger(this._scroll)){var t=this._normalizeScroll(this._scroll);t!==this._scroll?this._killOverScroll(t):this._changeTo(t)}else this._setupInitialIndex();this.refreshHook()}},{key:"_getDelta",value:function(t){return t.gesture["delta"+this.dM.axis]}},{key:"_getVelocity",value:function(t){return t.gesture["velocity"+this.dM.axis]}},{key:"_getTransform",value:function(t){return"translate3d("+this.dM.t3d[0]+-t+this.dM.t3d[1]+")"}},{key:"_updateLayout",value:function(){this.dM=Mo[this.isVertical()?"vertical":"horizontal"],this.target.classList.toggle("ons-swiper-target--vertical",this.isVertical());for(var t=this.target.children[0];t;t=t.nextElementSibling)t.style[this.dM.size.toLowerCase()]=this.itemSize;this.isCentered()&&(this._offset=(this.targetSize-this.itemNumSize)/-2||0)}},{key:"itemCount",get:function(){return this.target.children.length}},{key:"itemNumSize",get:function(){return"number"==typeof this._itemNumSize&&this._itemNumSize==this._itemNumSize||(this._itemNumSize=this._calculateItemSize()),this._itemNumSize}},{key:"maxScroll",get:function(){var t=this.itemCount*this.itemNumSize-this.targetSize;return Math.ceil(t<0?0:t)}},{key:"targetSize",get:function(){return this._targetSize||(this._targetSize=this.target["offset"+this.dM.size]),this._targetSize}}]),t}(),Io=function(t){function e(){h(this,e);var t=m(this,(e.__proto__||Object.getPrototypeOf(e)).call(this));return xt(t,function(){return t._compile()}),t}return a(e,Zi),d(e,[{key:"_compile",value:function(){var t=this.children[0]&&"ONS-CAROUSEL-ITEM"!==this.children[0].tagName&&this.children[0]||document.createElement("div");if(!t.parentNode){for(;this.firstChild;)t.appendChild(this.firstChild);this.appendChild(t)}!this.children[1]&&this.appendChild(document.createElement("div")),this.appendChild=this.appendChild.bind(t),this.insertBefore=this.insertBefore.bind(t)}},{key:"connectedCallback",value:function(){var t=this;this._swiper||(this._swiper=new Do({getElement:function(){return t},getInitialIndex:function(){return t.getAttribute("initial-index")},getAutoScrollRatio:function(){return t.autoScrollRatio},isVertical:function(){return t.vertical},isOverScrollable:function(){return t.overscrollable},isCentered:function(){return t.centered},isAutoScrollable:function(){return t.autoScroll},itemSize:this.itemSize,overScrollHook:this._onOverScroll.bind(this),preChangeHook:this._onChange.bind(this,"prechange"),postChangeHook:this._onChange.bind(this,"postchange"),refreshHook:this._onRefresh.bind(this),scrollHook:function(){return t._onSwipe&&t._onSwipe.apply(t,arguments)}}),xt(this,function(){return t._swiper.init({swipeable:t.hasAttribute("swipeable"),autoRefresh:t.hasAttribute("auto-refresh")})}))}},{key:"disconnectedCallback",value:function(){this._swiper&&this._swiper.initialized&&(this._swiper.dispose(),this._swiper=null)}},{key:"attributeChangedCallback",value:function(t,e,n){if(this._swiper)switch(t){case"swipeable":this._swiper.updateSwipeable(this.hasAttribute("swipeable"));break;case"auto-refresh":this._swiper.updateAutoRefresh(this.hasAttribute("auto-refresh"));break;case"item-height":this.vertical&&this._swiper.updateItemSize(this.itemSize);break;case"item-width":this.vertical||this._swiper.updateItemSize(this.itemSize);break;case"direction":this._swiper.refresh()}}},{key:"_show",value:function(){this._swiper.show()}},{key:"_hide",value:function(){this._swiper.hide()}},{key:"_onOverScroll",value:function(t){var e=t.direction,n=t.killOverScroll,i=!1;return W.triggerElementEvent(this,"overscroll",{carousel:this,activeIndex:this.getActiveIndex(),direction:e,waitToReturn:function(t){i=!0,t.then(n)}}),i}},{key:"_onChange",value:function(t,e){var n=e.activeIndex,i=e.lastActiveIndex;W.triggerElementEvent(this,t,{carousel:this,activeIndex:n,lastActiveIndex:i})}},{key:"_onRefresh",value:function(){W.triggerElementEvent(this,"refresh",{carousel:this})}},{key:"setActiveIndex",value:function(t){var e=this,n=1<arguments.length&&void 0!==arguments[1]?arguments[1]:{};return n=f({animation:this.getAttribute("animation"),animationOptions:this.hasAttribute("animation-options")?W.animationOptionsParse(this.getAttribute("animation-options")):{duration:.3,timing:"cubic-bezier(.4, .7, .5, 1)"}},n),this._swiper.setActiveIndex(t,n).then(function(){return n.callback instanceof Function&&n.callback(e),Promise.resolve(e)})}},{key:"getActiveIndex",value:function(){return this._swiper.getActiveIndex()}},{key:"next",value:function(t){return this.setActiveIndex(this.getActiveIndex()+1,t)}},{key:"prev",value:function(t){return this.setActiveIndex(this.getActiveIndex()-1,t)}},{key:"first",value:function(t){return this.setActiveIndex(0,t)}},{key:"last",value:function(t){this.setActiveIndex(Math.max(this.itemCount-1,0),t)}},{key:"refresh",value:function(){this._swiper.refresh()}},{key:"itemCount",get:function(){return this._swiper.itemCount}},{key:"swipeable",get:function(){return this.hasAttribute("swipeable")},set:function(t){return W.toggleAttribute(this,"swipeable",t)}},{key:"onSwipe",get:function(){return this._onSwipe},set:function(t){!t||t instanceof Function||W.throw('"onSwipe" must be a function'),this._onSwipe=t}},{key:"autoScroll",get:function(){return this.hasAttribute("auto-scroll")},set:function(t){return W.toggleAttribute(this,"auto-scroll",t)}},{key:"vertical",get:function(){return"vertical"===this.getAttribute("direction")}},{key:"itemSize",get:function(){var t=(this.getAttribute("item-"+(this.vertical?"height":"width"))||"").trim();return t.match(/^\d+(px|%)$/)?t:"100%"}},{key:"autoScrollRatio",get:function(){return parseFloat(this.getAttribute("auto-scroll-ratio"))},set:function(t){this.setAttribute("auto-scroll-ratio",t)}},{key:"disabled",get:function(){return this.hasAttribute("disabled")},set:function(t){return W.toggleAttribute(this,"disabled",t)}},{key:"overscrollable",get:function(){return this.hasAttribute("overscrollable")},set:function(t){return W.toggleAttribute(this,"overscrollable",t)}},{key:"centered",get:function(){return this.hasAttribute("centered")},set:function(t){return W.toggleAttribute(this,"centered",t)}}],[{key:"observedAttributes",get:function(){return["swipeable","auto-refresh","direction","item-height","item-width"]}},{key:"events",get:function(){return["postchange","refresh","overscroll"]}}]),e}();i.Carousel=Io,customElements.define("ons-carousel",Io);var No=function(t){function e(){h(this,e);var t=m(this,(e.__proto__||Object.getPrototypeOf(e)).call(this));return t.getAttribute("width")&&t._updateWidth(),t}return a(e,Zi),d(e,[{key:"attributeChangedCallback",value:function(t,e,n){"width"===t&&this._updateWidth()}},{key:"_updateWidth",value:function(){var t=this.getAttribute("width");t?(t=t.trim().match(/^\d+$/)?t+"%":t,l(this,{flex:"0 0 "+t,maxWidth:t})):l.clear(this,"flex maxWidth")}}],[{key:"observedAttributes",get:function(){return["width"]}}]),e}();i.Col=No,customElements.define("ons-col",No);var Bo=function(t){function s(){var t=0<arguments.length&&void 0!==arguments[0]?arguments[0]:{},e=t.timing,n=void 0===e?"linear":e,i=t.delay,o=void 0===i?0:i,r=t.duration,a=void 0===r?.2:r;return h(this,s),m(this,(s.__proto__||Object.getPrototypeOf(s)).call(this,{timing:n,delay:o,duration:a}))}return a(s,no),d(s,[{key:"show",value:function(t,e){e()}},{key:"hide",value:function(t,e){e()}}]),s}(),jo=function(t){function s(){var t=0<arguments.length&&void 0!==arguments[0]?arguments[0]:{},e=t.timing,n=void 0===e?"ease-in-out":e,i=t.delay,o=void 0===i?0:i,r=t.duration,a=void 0===r?.3:r;return h(this,s),m(this,(s.__proto__||Object.getPrototypeOf(s)).call(this,{timing:n,delay:o,duration:a}))}return a(s,Bo),d(s,[{key:"show",value:function(t,e){e=e||function(){},it.runAll(it(t._mask,this.def).default({opacity:0},{opacity:1}),it(t._dialog,this.def).default({transform:"translate3d(-50%, -60%, 0)",opacity:0},{transform:"translate3d(-50%, -50%, 0)",opacity:1}).queue(function(t){e(),t()}))}},{key:"hide",value:function(t,e){e=e||function(){},it.runAll(it(t._mask,this.def).default({opacity:1},{opacity:0}),it(t._dialog,this.def).default({transform:"translate3d(-50%, -50%, 0)",opacity:1},{transform:"translate3d(-50%, -60%, 0)",opacity:0}).queue(function(t){e(),t()}))}}]),s}(),Ho=function(t){function l(){var t=0<arguments.length&&void 0!==arguments[0]?arguments[0]:{},e=t.timing,n=void 0===e?"ease-in-out":e,i=t.delay,o=void 0===i?0:i,r=t.duration,a=void 0===r?.2:r;h(this,l);var s=m(this,(l.__proto__||Object.getPrototypeOf(l)).call(this,{timing:n,delay:o,duration:a}));return s.bodyHeight=document.body.clientHeight,s}return a(l,Bo),d(l,[{key:"show",value:function(t,e){e=e||function(){},it.runAll(it(t._mask,this.def).default({opacity:0},{opacity:1}),it(t._dialog,this.def).default({transform:"translate3d(-50%, "+(this.bodyHeight/2-1)+"px, 0)"},{transform:"translate3d(-50%, -50%, 0)"}).queue(function(t){e(),t()}))}},{key:"hide",value:function(t,e){e=e||function(){},it.runAll(it(t._mask,this.def).default({opacity:1},{opacity:0}),it(t._dialog,this.def).default({transform:"translate3d(-50%, -50%, 0)"},{transform:"translate3d(-50%, "+(this.bodyHeight/2-1)+"px, 0)"}).queue(function(t){e(),t()}))}}]),l}(),Ro=function(t){function l(){var t=0<arguments.length&&void 0!==arguments[0]?arguments[0]:{},e=t.timing,n=void 0===e?"cubic-bezier(.1, .7, .4, 1)":e,i=t.delay,o=void 0===i?0:i,r=t.duration,a=void 0===r?.2:r;h(this,l);var s=m(this,(l.__proto__||Object.getPrototypeOf(l)).call(this,{timing:n,delay:o,duration:a}));return s.bodyHeight=document.body.clientHeight,s}return a(l,Bo),d(l,[{key:"show",value:function(t,e){e=e||function(){},it.runAll(it(t._mask,this.def).default({opacity:0},{opacity:1}),it(t._dialog,this.def).default({transform:"translate3d(-50%, "+(-this.bodyHeight/2+1-t._dialog.clientHeight)+"px, 0)"},{transform:"translate3d(-50%, -50%, 0)"}).queue(function(t){e(),t()}))}},{key:"hide",value:function(t,e){e=e||function(){},it.runAll(it(t._mask,this.def).default({opacity:1},{opacity:0}),it(t._dialog,this.def).default({transform:"translate3d(-50%, -50%, 0)"},{transform:"translate3d(-50%, "+(-this.bodyHeight/2+1-t._dialog.clientHeight)+"px, 0)"}).queue(function(t){e(),t()}))}}]),l}(),Fo={".dialog":"dialog--*",".dialog-container":"dialog-container--*",".dialog-mask":"dialog-mask--*"},qo={default:function(){return c.isAndroid()?jo:Ho},slide:Ro,none:Bo},zo=function(t){function e(){h(this,e);var t=m(this,(e.__proto__||Object.getPrototypeOf(e)).call(this));return xt(t,function(){return t._compile()}),t}return a(e,so),d(e,[{key:"_updateAnimatorFactory",value:function(){return new y({animators:qo,baseClass:Bo,baseClassName:"DialogAnimator",defaultAnimation:this.getAttribute("animation")})}},{key:"_compile",value:function(){if(P.prepare(this),this.style.display="none",this.style.zIndex=10001,!this._dialog){var t=document.createElement("div");t.classList.add("dialog");var e=document.createElement("div");for(e.classList.add("dialog-container");this.firstChild;)e.appendChild(this.firstChild);t.appendChild(e),this.appendChild(t)}if(!this._mask){var n=document.createElement("div");n.classList.add("dialog-mask"),this.insertBefore(n,this.firstChild)}this._dialog.style.zIndex=20001,this._mask.style.zIndex=2e4,this.setAttribute("status-bar-fill",""),O.initModifier(this,this._scheme)}},{key:"_scheme",get:function(){return Fo}},{key:"_mask",get:function(){return W.findChild(this,".dialog-mask")}},{key:"_dialog",get:function(){return W.findChild(this,".dialog")}}],[{key:"registerAnimator",value:function(t,e){e.prototype instanceof Bo||W.throwAnimator("Dialog"),qo[t]=e}},{key:"animators",get:function(){return qo}},{key:"DialogAnimator",get:function(){return Bo}}]),e}();i.Dialog=zo,customElements.define("ons-dialog",zo);var Vo={"":"fab--*",".fab__icon":"fab--*__icon"},Wo=function(t){function e(){h(this,e);var t=m(this,(e.__proto__||Object.getPrototypeOf(e)).call(this));return t._hide(),t.classList.add("fab"),xt(t,function(){t._compile()}),t}return a(e,Zi),d(e,[{key:"_compile",value:function(){if(P.prepare(this),!W.findChild(this,".fab__icon")){var e=document.createElement("span");e.classList.add("fab__icon"),W.arrayFrom(this.childNodes).forEach(function(t){t.tagName&&"ons-ripple"===t.tagName.toLowerCase()||e.appendChild(t)}),this.appendChild(e)}this._updateRipple(),O.initModifier(this,Vo),this._updatePosition()}},{key:"connectedCallback",value:function(){var t=this;setImmediate(function(){return t._show()})}},{key:"attributeChangedCallback",value:function(t,e,n){switch(t){case"class":W.restoreClass(this,"fab",Vo);break;case"modifier":O.onModifierChanged(e,n,this,Vo);break;case"ripple":this._updateRipple();break;case"position":this._updatePosition()}}},{key:"_show",value:function(){this._manuallyHidden||this._toggle(!0)}},{key:"_hide",value:function(){var t=this;setImmediate(function(){return t._toggle(!1)})}},{key:"_updateRipple",value:function(){W.updateRipple(this)}},{key:"_updatePosition",value:function(){var t=this.getAttribute("position");switch(this.classList.remove("fab--top__left","fab--bottom__right","fab--bottom__left","fab--top__right","fab--top__center","fab--bottom__center"),t){case"top right":case"right top":this.classList.add("fab--top__right");break;case"top left":case"left top":this.classList.add("fab--top__left");break;case"bottom right":case"right bottom":this.classList.add("fab--bottom__right");break;case"bottom left":case"left bottom":this.classList.add("fab--bottom__left");break;case"center top":case"top center":this.classList.add("fab--top__center");break;case"center bottom":case"bottom center":this.classList.add("fab--bottom__center")}}},{key:"show",value:function(){this.toggle(!0)}},{key:"hide",value:function(){this.toggle(!1)}},{key:"toggle",value:function(){var t=0<arguments.length&&void 0!==arguments[0]?arguments[0]:!this.visible;this._manuallyHidden=!t,this._toggle(t)}},{key:"_toggle",value:function(){var t=0<arguments.length&&void 0!==arguments[0]?arguments[0]:!this.visible,e=0<=(this.getAttribute("position")||"").indexOf("bottom")?"translate3d(0px, -"+(W.globals.fabOffset||0)+"px, 0px)":"";l(this,{transform:e+" scale("+Number(t)+")"})}},{key:"disabled",set:function(t){return W.toggleAttribute(this,"disabled",t)},get:function(){return this.hasAttribute("disabled")}},{key:"visible",get:function(){return-1===this.style.transform.indexOf("scale(0)")&&"none"!==this.style.display}}],[{key:"observedAttributes",get:function(){return["modifier","ripple","position","class"]}}]),e}();i.Fab=Wo,customElements.define("ons-fab",Wo);var Uo=function(t){function e(){h(this,e);var t=m(this,(e.__proto__||Object.getPrototypeOf(e)).call(this));return t._gestureDetector=new ot(t,{passive:!0}),t}return a(e,Zi),e}();i.GestureDetector=Uo,customElements.define("ons-gesture-detector",Uo);var Xo="fa",Yo=function(t){function e(){h(this,e);var t=m(this,(e.__proto__||Object.getPrototypeOf(e)).call(this));return xt(t,function(){t._compile()}),t}return a(e,Zi),d(e,[{key:"attributeChangedCallback",value:function(t,e,n){this._cleanClassAttribute("icon"===t?e:this.getAttribute("icon"),"modifier"===t?e:void 0),this._update()}},{key:"_compile",value:function(){P.prepare(this),this._update()}},{key:"_update",value:function(){var e=this,t=this._buildClassAndStyle(this._parseAttr("icon"),this._parseAttr("size")),n=t.classList,i=t.style;W.extend(this.style,i),n.forEach(function(t){return e.classList.add(t)})}},{key:"_parseAttr",value:function(t){var e=1<arguments.length&&void 0!==arguments[1]?arguments[1]:this.getAttribute("modifier")||"",n=(this.getAttribute(t)||t||"").split(/\s*,\s*/),i=n[0],o=n[1];return o=(o||"").split(/\s*:\s*/),(e&&RegExp("(^|\\s+)"+o[0]+"($|\\s+)","i").test(e)?o[1]:i)||""}},{key:"_cleanClassAttribute",value:function(t,e){var n=this,i=this._prefixIcon(this._parseAttr(t,e)),o=i.className,r=i.prefix,a=new RegExp("^(fa$|fa-|ion-|zmdi$|zmdi-|ons-icon--"+(o!==r?"|"+r+"$|"+r+"-":"|"+o+"$"||"")+")");W.arrayFrom(this.classList).filter(function(t){return a.test(t)}).forEach(function(t){return n.classList.remove(t)})}},{key:"_prefixIcon",value:function(t){var e=Xo+(Xo?"-":"")+t;return{className:e,prefix:e.split("-")[0]}}},{key:"_buildClassAndStyle",value:function(t,e){var n=["ons-icon"],i={};if(0===t.indexOf("ion-"))n.push(t),n.push("ons-icon--ion");else if(0===t.indexOf("fa-"))n.push(t),this.classList.contains("far")||this.classList.contains("fab")||this.classList.contains("fal")||n.push("fa");else if(0===t.indexOf("md-"))n.push("zmdi"),n.push("zmdi-"+t.split(/-(.+)?/)[1]);else{var o=this._prefixIcon(t),r=o.className,a=o.prefix;a&&n.push(a),r&&n.push(r)}return e.match(/^[1-5]x|lg$/)?(n.push("ons-icon--"+e),this.style.removeProperty("font-size")):i.fontSize=e,{classList:n,style:i}}}],[{key:"setAutoPrefix",value:function(t){Xo=t?"string"==typeof t&&t||"fa":""}},{key:"observedAttributes",get:function(){return["icon","size","modifier","class"]}}]),e}();i.Icon=Yo,customElements.define("ons-icon",Yo);var Go=function(){function n(t){var e=1<arguments.length&&void 0!==arguments[1]?arguments[1]:null;h(this,n),"object"===(void 0===t?"undefined":u(t))&&null!==t||W.throw('"delegate" parameter must be an object'),this._userDelegate=t,e instanceof Element||null===e||W.throw('"templateElement" parameter must be an instance of Element or null'),this._templateElement=e}return d(n,[{key:"hasRenderFunction",value:function(){return this._userDelegate._render instanceof Function}},{key:"_render",value:function(){this._userDelegate._render.apply(this._userDelegate,arguments)}},{key:"loadItemElement",value:function(t,e){if(this._userDelegate.loadItemElement instanceof Function)this._userDelegate.loadItemElement(t,e);else{var n=this._userDelegate.createItemContent(t,this._templateElement);n instanceof Element||W.throw('"createItemContent" must return an instance of Element'),e({element:n})}}},{key:"countItems",value:function(){var t=this._userDelegate.countItems();return"number"!=typeof t&&W.throw('"countItems" must return a number'),t}},{key:"updateItem",value:function(t,e){this._userDelegate.updateItemContent instanceof Function&&this._userDelegate.updateItemContent(t,e)}},{key:"calculateItemHeight",value:function(t){if(this._userDelegate.calculateItemHeight instanceof Function){var e=this._userDelegate.calculateItemHeight(t);return"number"!=typeof e&&W.throw('"calculateItemHeight" must return a number'),e}return 0}},{key:"destroyItem",value:function(t,e){this._userDelegate.destroyItem instanceof Function&&this._userDelegate.destroyItem(t,e)}},{key:"destroy",value:function(){this._userDelegate.destroy instanceof Function&&this._userDelegate.destroy(),this._userDelegate=this._templateElement=null}},{key:"itemHeight",get:function(){return this._userDelegate.itemHeight}}]),n}(),$o=function(){function n(t,e){h(this,n),e instanceof Go||W.throw('"delegate" parameter must be an instance of LazyRepeatDelegate'),this._wrapperElement=t,this._delegate=e,this._insertIndex=this._wrapperElement.children[0]&&"ONS-LAZY-REPEAT"===this._wrapperElement.children[0].tagName?1:0,"ons-list"===t.tagName.toLowerCase()&&t.classList.add("lazy-list"),this._pageContent=this._findPageContentElement(t),this._pageContent||W.throw("LazyRepeat must be descendant of a Page element"),this.lastScrollTop=this._pageContent.scrollTop,this.padding=0,this._topPositions=[0],this._renderedItems={},this._delegate.itemHeight||this._delegate.calculateItemHeight(0)||(this._unknownItemHeight=!0),this._addEventListeners(),this._onChange()}return d(n,[{key:"_findPageContentElement",value:function(t){var e=W.findParent(t,".page__content");if(e)return e;var n=W.findParent(t,"ons-page");if(n){var i=W.findChild(n,".content");if(i)return i}return null}},{key:"_checkItemHeight",value:function(n){var i=this;this._delegate.loadItemElement(0,function(t){i._unknownItemHeight||W.throw("Invalid state"),i._wrapperElement.appendChild(t.element);var e=function(){i._delegate.destroyItem(0,t),t.element&&t.element.remove(),delete i._unknownItemHeight,n()};i._itemHeight=t.element.offsetHeight,0<i._itemHeight?e():(i._wrapperElement.style.visibility="hidden",t.element.style.visibility="hidden",setImmediate(function(){i._itemHeight=t.element.offsetHeight,0==i._itemHeight&&W.throw('Invalid state: "itemHeight" must be greater than zero'),i._wrapperElement.style.visibility="",e()}))})}},{key:"_countItems",value:function(){return this._delegate.countItems()}},{key:"_getItemHeight",value:function(t){return this._renderedItems.hasOwnProperty(t)?(this._renderedItems[t].hasOwnProperty("height")||(this._renderedItems[t].height=this._renderedItems[t].element.offsetHeight),this._renderedItems[t].height):this._topPositions[t+1]&&this._topPositions[t]?this._topPositions[t+1]-this._topPositions[t]:this.staticItemHeight||this._delegate.calculateItemHeight(t)}},{key:"_calculateRenderedHeight",value:function(){var n=this;return Object.keys(this._renderedItems).reduce(function(t,e){return t+n._getItemHeight(+e)},0)}},{key:"_onChange",value:function(){this._render()}},{key:"_lastItemRendered",value:function(){return Math.max.apply(Math,_(Object.keys(this._renderedItems)))}},{key:"_firstItemRendered",value:function(){return Math.min.apply(Math,_(Object.keys(this._renderedItems)))}},{key:"refresh",value:function(){var t={forceScrollDown:!0},e=this._firstItemRendered();W.isInteger(e)&&(this._wrapperElement.style.height=this._topPositions[e]+this._calculateRenderedHeight()+"px",this.padding=this._topPositions[e],t.forceFirstIndex=e),this._removeAllElements(),this._render(t),this._wrapperElement.style.height="inherit"}},{key:"_render",value:function(){var e=this,t=0<arguments.length&&void 0!==arguments[0]?arguments[0]:{},n=t.forceScrollDown,i=void 0!==n&&n,o=t.forceFirstIndex,r=t.forceLastIndex;if(this._unknownItemHeight)return this._checkItemHeight(this._render.bind(this,arguments[0]));var a=!i&&this.lastScrollTop>this._pageContent.scrollTop;this.lastScrollTop=this._pageContent.scrollTop;for(var s={},l=this._wrapperElement.getBoundingClientRect().top,u=4*window.innerHeight-l,c=this._countItems(),h=o||Math.max(0,this._calculateStartIndex(l)-30),d=h,f=this._topPositions[d];d<c&&f<u;d++)d>=this._topPositions.length&&(this._topPositions.length+=100),this._topPositions[d]=f,f+=this._getItemHeight(d);if(this._delegate.hasRenderFunction&&this._delegate.hasRenderFunction())return this._delegate._render(h,d,function(){e.padding=e._topPositions[h]});if(a)for(var p=d-1;h<=p;p--)s[p]=!0,this._renderElement(p,a);else for(var g=r||Math.max.apply(Math,[d-1].concat(_(Object.keys(this._renderedItems)))),m=h;m<=g;m++)s[m]=!0,this._renderElement(m,a);Object.keys(this._renderedItems).forEach(function(t){return s[t]||e._removeElement(t,a)})}},{key:"_renderElement",value:function(e,n){var i=this,t=this._renderedItems[e];t?this._delegate.updateItem(e,t):this._delegate.loadItemElement(e,function(t){n?(i._wrapperElement.insertBefore(t.element,i._wrapperElement.children[i._insertIndex]),i.padding=i._topPositions[e],t.height=i._topPositions[e+1]-i._topPositions[e]):i._wrapperElement.appendChild(t.element),i._renderedItems[e]=t})}},{key:"_removeElement",value:function(t){var e=!(1<arguments.length&&void 0!==arguments[1])||arguments[1];t=+t;var n=this._renderedItems[t];this._delegate.destroyItem(t,n),e?this._topPositions[t+1]=void 0:this.padding=this.padding+this._getItemHeight(t),n.element.parentElement&&n.element.parentElement.removeChild(n.element),delete this._renderedItems[t]}},{key:"_removeAllElements",value:function(){var e=this;Object.keys(this._renderedItems).forEach(function(t){return e._removeElement(t)})}},{key:"_recalculateTopPositions",value:function(t,e){for(var n=t;n<=e;n++)this._topPositions[n+1]=this._topPositions[n]+this._getItemHeight(n)}},{key:"_calculateStartIndex",value:function(t){var e=this._firstItemRendered(),n=this._lastItemRendered();this._recalculateTopPositions(e,n);for(var i=0,o=this._countItems()-1;;){var r=Math.floor((i+o)/2),a=t+this._topPositions[r];if(o<i)return 0;if(a<=0&&0<a+this._getItemHeight(r))return r;isNaN(a)||0<=a?o=r-1:i=r+1}}},{key:"_debounce",value:function(i,o,r){var a=void 0;return function(){var t=this,e=arguments,n=r&&!a;clearTimeout(a),n?i.apply(this,arguments):a=setTimeout(function(){a=null,i.apply(t,e)},o)}}},{key:"_doubleFireOnTouchend",value:function(){this._render(),this._debounce(this._render.bind(this),100)}},{key:"_addEventListeners",value:function(){W.bindListeners(this,["_onChange","_doubleFireOnTouchend"]),c.isIOS()&&(this._boundOnChange=this._debounce(this._boundOnChange,30)),this._pageContent.addEventListener("scroll",this._boundOnChange,!0),c.isIOS()&&(W.addEventListener(this._pageContent,"touchmove",this._boundOnChange,{capture:!0,passive:!0}),this._pageContent.addEventListener("touchend",this._boundDoubleFireOnTouchend,!0)),window.document.addEventListener("resize",this._boundOnChange,!0)}},{key:"_removeEventListeners",value:function(){this._pageContent.removeEventListener("scroll",this._boundOnChange,!0),c.isIOS()&&(W.removeEventListener(this._pageContent,"touchmove",this._boundOnChange,{capture:!0,passive:!0}),this._pageContent.removeEventListener("touchend",this._boundDoubleFireOnTouchend,!0)),window.document.removeEventListener("resize",this._boundOnChange,!0)}},{key:"destroy",value:function(){this._removeAllElements(),this._delegate.destroy(),this._parentElement=this._delegate=this._renderedItems=null,this._removeEventListeners()}},{key:"padding",get:function(){return parseInt(this._wrapperElement.style.paddingTop,10)},set:function(t){this._wrapperElement.style.paddingTop=t+"px"}},{key:"staticItemHeight",get:function(){return this._delegate.itemHeight||this._itemHeight}}]),n}(),Ko=function(t){function e(){return h(this,e),m(this,(e.__proto__||Object.getPrototypeOf(e)).apply(this,arguments))}return a(e,Zi),d(e,[{key:"connectedCallback",value:function(){this.hasAttribute("delegate")&&(this.delegate=window[this.getAttribute("delegate")])}},{key:"refresh",value:function(){this._lazyRepeatProvider&&this._lazyRepeatProvider.refresh()}},{key:"attributeChangedCallback",value:function(t,e,n){}},{key:"disconnectedCallback",value:function(){this._lazyRepeatProvider&&(this._lazyRepeatProvider.destroy(),this._lazyRepeatProvider=null)}},{key:"delegate",set:function(t){this._lazyRepeatProvider&&this._lazyRepeatProvider.destroy(),!this._templateElement&&this.children[0]&&(this._templateElement=this.removeChild(this.children[0]));var e=new Go(t,this._templateElement||null);this._lazyRepeatProvider=new $o(this.parentElement,e)},get:function(){W.throw("No delegate getter")}}]),e}();b.LazyRepeatDelegate=Go,b.LazyRepeatProvider=$o,i.LazyRepeat=Ko,customElements.define("ons-lazy-repeat",Ko);var Qo="list-header",Jo={"":"list-header--*"},Zo=function(t){function e(){h(this,e);var t=m(this,(e.__proto__||Object.getPrototypeOf(e)).call(this));return t._compile(),t}return a(e,Zi),d(e,[{key:"_compile",value:function(){P.prepare(this),this.classList.add(Qo),O.initModifier(this,Jo)}},{key:"attributeChangedCallback",value:function(t,e,n){switch(t){case"class":W.restoreClass(this,Qo,Jo);break;case"modifier":O.onModifierChanged(e,n,this,Jo)}}}],[{key:"observedAttributes",get:function(){return["modifier","class"]}}]),e}();i.ListHeader=Zo,customElements.define("ons-list-header",Zo);var tr="list-title",er={"":"list-title--*"},nr=function(t){function e(){h(this,e);var t=m(this,(e.__proto__||Object.getPrototypeOf(e)).call(this));return t._compile(),t}return a(e,Zi),d(e,[{key:"_compile",value:function(){P.prepare(this),this.classList.add(tr),O.initModifier(this,er)}},{key:"attributeChangedCallback",value:function(t,e,n){switch(t){case"class":W.restoreClass(this,tr,er);break;case"modifier":O.onModifierChanged(e,n,this,er)}}}],[{key:"observedAttributes",get:function(){return["modifier","class"]}}]),e}();i.ListTitle=nr,customElements.define("ons-list-title",nr);var ir=function(t){function s(){var t=0<arguments.length&&void 0!==arguments[0]?arguments[0]:{},e=t.timing,n=void 0===e?"linear":e,i=t.delay,o=void 0===i?0:i,r=t.duration,a=void 0===r?.2:r;return h(this,s),m(this,(s.__proto__||Object.getPrototypeOf(s)).call(this,{timing:n,delay:o,duration:a}))}return a(s,no),d(s,[{key:"showExpansion",value:function(t,e){e()}},{key:"hideExpansion",value:function(t,e){e()}}]),s}(),or=function(t){function e(){return h(this,e),m(this,(e.__proto__||Object.getPrototypeOf(e)).apply(this,arguments))}return a(e,ir),d(e,[{key:"showExpansion",value:function(t,e){this._animateExpansion(t,!0,e)}},{key:"hideExpansion",value:function(t,e){this._animateExpansion(t,!1,e)}},{key:"_animateExpansion",value:function(t,e,n){var i,o=t.expandableContent.style.height,r=t.expandableContent.style.display;t.expandableContent.style.height="auto",t.expandableContent.style.display="block";var a,s=window.getComputedStyle(t.expandableContent),l=[{height:0,paddingTop:0,paddingBottom:0},{height:s.height,paddingTop:s.paddingTop,paddingBottom:s.paddingBottom}],u=[{transform:"rotate(45deg)"},{transform:"rotate(225deg)"}];(t.expandableContent.style.height=o,(i=it(t.expandableContent,{duration:this.duration,property:"height padding-top padding-bottom"})).default.apply(i,_(e?l:l.reverse())).play(function(){t.expandableContent.style.display=r,n&&n()}),t.expandChevron)&&(a=it(t.expandChevron,{duration:this.duration,property:"transform"})).default.apply(a,_(e?u:u.reverse())).play()}}]),e}(),rr="list-item",ar={".list-item":"list-item--*",".list-item__left":"list-item--*__left",".list-item__center":"list-item--*__center",".list-item__right":"list-item--*__right",".list-item__label":"list-item--*__label",".list-item__title":"list-item--*__title",".list-item__subtitle":"list-item--*__subtitle",".list-item__thumbnail":"list-item--*__thumbnail",".list-item__icon":"list-item--*__icon"},sr={default:or,none:ir},lr=function(t){function n(){h(this,n);var t=m(this,(n.__proto__||Object.getPrototypeOf(n)).call(this));t._animatorFactory=t._updateAnimatorFactory(),t.toggleExpansion=t.toggleExpansion.bind(t);var e=/^ons-(?!col$|row$|if$)/i;return t._shouldIgnoreTap=function(t){return t.hasAttribute("prevent-tap")||e.test(t.tagName)},t.show=t.showExpansion,t.hide=t.hideExpansion,xt(t,function(){t._compile()}),t}return a(n,Zi),d(n,[{key:"_compile",value:function(){P.prepare(this),this.classList.add(rr);var e=void 0,n=void 0,i=[];Array.from(this.childNodes).forEach(function(t){t.nodeType!==Node.ELEMENT_NODE?i.push(t):t.classList.contains("top")?e=t:t.classList.contains("expandable-content")?n=t:i.push(t),"ONS-RIPPLE"!==t.nodeName&&t.remove()}),i=e?Array.from(e.childNodes):i;var o=void 0,r=void 0,a=void 0,s=[];if(i.forEach(function(t){t.nodeType!==Node.ELEMENT_NODE?s.push(t):t.classList.contains("left")?o=t:t.classList.contains("right")?r=t:t.classList.contains("center")?a=t:s.push(t)}),this.hasAttribute("expandable")){if(this.classList.add("list-item--expandable"),e||(e=document.createElement("div")).classList.add("top"),e.classList.add("list-item__top"),this.appendChild(e),this._top=e,n&&(n.classList.add("list-item__expandable-content"),this.appendChild(n)),!r){(r=document.createElement("div")).classList.add("list-item__right","right");var t=document.createElement("span");t.classList.add("list-item__expand-chevron"),r.appendChild(t)}}else e=this;a||((a=document.createElement("div")).classList.add("center"),s.forEach(function(t){return a.appendChild(t)})),a.classList.add("list-item__center"),e.appendChild(a),o&&(o.classList.add("list-item__left"),e.appendChild(o)),r&&(r.classList.add("list-item__right"),e.appendChild(r)),W.updateRipple(this),O.initModifier(this,ar)}},{key:"showExpansion",value:function(){var t=this;this.hasAttribute("expandable")&&!this._expanding&&(this.expanded=!0,this._expanding=!0,this._animatorFactory.newAnimator().showExpansion(this,function(){t.classList.add("expanded"),t._expanding=!1}))}},{key:"hideExpansion",value:function(){var t=this;this.hasAttribute("expandable")&&!this._expanding&&(this.expanded=!1,this._expanding=!0,this._animatorFactory.newAnimator().hideExpansion(this,function(){t.classList.remove("expanded"),t._expanding=!1}))}},{key:"toggleExpansion",value:function(){this.classList.contains("expanded")?this.hideExpansion():this.showExpansion(),this.dispatchEvent(new Event("expansion"))}},{key:"_updateAnimatorFactory",value:function(){return new y({animators:sr,baseClass:ir,baseClassName:"ListItemAnimator",defaultAnimation:this.getAttribute("animation")||"default"})}},{key:"attributeChangedCallback",value:function(t,e,n){switch(t){case"class":W.restoreClass(this,rr,ar);break;case"modifier":O.onModifierChanged(e,n,this,ar);break;case"ripple":W.updateRipple(this);break;case"animation":this._animatorFactory=this._updateAnimatorFactory()}}},{key:"connectedCallback",value:function(){var t=this;xt(this,function(){t._setupListeners(!0),t._originalBackgroundColor=t.style.backgroundColor,t.tapped=!1})}},{key:"disconnectedCallback",value:function(){this._setupListeners(!1)}},{key:"_setupListeners",value:function(t){var e=(t?"add":"remove")+"EventListener";W[e](this,"touchstart",this._onTouch,{passive:!0}),W[e](this,"touchmove",this._onRelease,{passive:!0}),this[e]("touchcancel",this._onRelease),this[e]("touchend",this._onRelease),this[e]("touchleave",this._onRelease),this[e]("drag",this._onDrag),this[e]("mousedown",this._onTouch),this[e]("mouseup",this._onRelease),this[e]("mouseout",this._onRelease),this._top&&this._top[e]("click",this.toggleExpansion)}},{key:"_onDrag",value:function(t){var e=t.gesture;this.hasAttribute("lock-on-drag")&&-1<["left","right"].indexOf(e.direction)&&e.preventDefault()}},{key:"_onTouch",value:function(t){var e=this;if(!(this.tapped||this!==t.target&&(this._shouldIgnoreTap(t.target)||W.findParent(t.target,this._shouldIgnoreTap,function(t){return t===e})))){this.tapped=!0;var n={transition:"background-color 0.0s linear 0.02s, box-shadow 0.0s linear 0.02s"};this.hasAttribute("tappable")&&(this.style.backgroundColor&&(this._originalBackgroundColor=this.style.backgroundColor),n.backgroundColor=this.getAttribute("tap-background-color")||"#d9d9d9",n.boxShadow="0px -1px 0px 0px "+n.backgroundColor),l(this,n)}}},{key:"_onRelease",value:function(){this.tapped=!1,this.style.backgroundColor=this._originalBackgroundColor||"",l.clear(this,"transition boxShadow")}},{key:"expandableContent",get:function(){return this.querySelector(".list-item__expandable-content")}},{key:"expandChevron",get:function(){return this.querySelector(".list-item__expand-chevron")}}],[{key:"observedAttributes",get:function(){return["modifier","class","ripple","animation"]}}]),n}();i.ListItem=lr,customElements.define("ons-list-item",lr);var ur={"":"list--*"},cr=function(t){function e(){h(this,e);var t=m(this,(e.__proto__||Object.getPrototypeOf(e)).call(this));return t._compile(),t}return a(e,Zi),d(e,[{key:"_compile",value:function(){P.prepare(this),this.classList.add("list"),O.initModifier(this,ur)}},{key:"attributeChangedCallback",value:function(t,e,n){switch(t){case"class":W.restoreClass(this,"list",ur);break;case"modifier":O.onModifierChanged(e,n,this,ur)}}}],[{key:"observedAttributes",get:function(){return["modifier","class"]}}]),e}();i.List=cr,customElements.define("ons-list",cr);var hr=["autocapitalize","autocomplete","autocorrect","autofocus","disabled","inputmode","max","maxlength","min","minlength","name","pattern","placeholder","readonly","required","size","step","validator","value"],dr=function(t){function e(){h(this,e);var t=m(this,(e.__proto__||Object.getPrototypeOf(e)).call(this));return t.constructor===e&&W.throwAbstract(),xt(t,function(){return t._compile()}),t._boundDelegateEvent=t._delegateEvent.bind(t),t}return a(e,Zi),d(e,[{key:"_update",value:function(){}},{key:"_scheme",get:function(){W.throwMember()}},{key:"_template",get:function(){W.throwMember()}},{key:"type",get:function(){W.throwMember()}}]),d(e,[{key:"_compile",value:function(){P.prepare(this),this._defaultClassName&&this.classList.add(this._defaultClassName),0===this.children.length&&(this.appendChild(W.createFragment(this._template)),this._setInputId(),this._updateBoundAttributes(),O.initModifier(this,this._scheme))}},{key:"_updateBoundAttributes",value:function(){var e=this;hr.forEach(function(t){e.hasAttribute(t)?e._input.setAttribute(t,e.getAttribute(t)):e._input.removeAttribute(t)}),this._update()}},{key:"_delegateEvent",value:function(t){var e=new CustomEvent(t.type,{bubbles:!1,cancelable:!0});return this.dispatchEvent(e)}},{key:"_setInputId",value:function(){this.hasAttribute("input-id")&&(this._input.id=this.getAttribute("input-id"))}},{key:"connectedCallback",value:function(){var t=this;xt(this,function(){t._input.addEventListener("focus",t._boundDelegateEvent),t._input.addEventListener("blur",t._boundDelegateEvent)})}},{key:"disconnectedCallback",value:function(){var t=this;xt(this,function(){t._input.removeEventListener("focus",t._boundDelegateEvent),t._input.removeEventListener("blur",t._boundDelegateEvent)})}},{key:"attributeChangedCallback",value:function(t,e,n){var i=this;switch(t){case"modifier":xt(this,function(){return O.onModifierChanged(e,n,i,i._scheme)});break;case"input-id":xt(this,function(){return i._setInputId()});break;case"class":W.restoreClass(this,this._defaultClassName,this._scheme)}0<=hr.indexOf(t)&&xt(this,function(){return i._updateBoundAttributes()})}},{key:"_defaultClassName",get:function(){return""}},{key:"_input",get:function(){return this.querySelector("input")}},{key:"value",get:function(){return null===this._input?this.getAttribute("value"):this._input.value},set:function(t){var e=this;xt(this,function(){t instanceof Date&&(t=t.toISOString().substring(0,10)),e._input.value=t,e._update()})}},{key:"disabled",set:function(t){return W.toggleAttribute(this,"disabled",t)},get:function(){return this.hasAttribute("disabled")}}],[{key:"observedAttributes",get:function(){return["modifier","input-id","class"].concat(hr)}}]),e}(),fr={".text-input":"text-input--*",".text-input__label":"text-input--*__label"},pr=function(t){function o(){h(this,o);var t=m(this,(o.__proto__||Object.getPrototypeOf(o)).call(this));return t._boundOnInput=t._update.bind(t),t._boundOnFocusin=t._update.bind(t),t}return a(o,dr),d(o,[{key:"_update",value:function(){this._updateLabel(),this._updateLabelClass()}},{key:"_updateLabel",value:function(){var t=this.getAttribute("placeholder")||"";void 0!==this._helper.textContent?this._helper.textContent=t:this._helper.innerText=t}},{key:"_updateLabelClass",value:function(){""===this.value?this._helper.classList.remove("text-input--material__label--active"):this._helper.classList.add("text-input--material__label--active")}},{key:"connectedCallback",value:function(){var t=this;p(o.prototype.__proto__||Object.getPrototypeOf(o.prototype),"connectedCallback",this).call(this),xt(this,function(){t._input.addEventListener("input",t._boundOnInput),t._input.addEventListener("focusin",t._boundOnFocusin)});var e=this.getAttribute("type");0<=["checkbox","radio"].indexOf(e)&&W.warn('Warn: <ons-input type="'+e+'"> is deprecated since v2.4.0. Use <ons-'+e+"> instead.")}},{key:"disconnectedCallback",value:function(){var t=this;p(o.prototype.__proto__||Object.getPrototypeOf(o.prototype),"disconnectedCallback",this).call(this),xt(this,function(){t._input.removeEventListener("input",t._boundOnInput),t._input.removeEventListener("focusin",t._boundOnFocusin)})}},{key:"attributeChangedCallback",value:function(t,e,n){var i=this;switch(t){case"type":xt(this,function(){return i._input.setAttribute("type",i.type)});break;default:p(o.prototype.__proto__||Object.getPrototypeOf(o.prototype),"attributeChangedCallback",this).call(this,t,e,n)}}},{key:"_scheme",get:function(){return fr}},{key:"_template",get:function(){return'\n      <input type="'+this.type+'" class="text-input">\n      <span class="text-input__label"></span>\n    '}},{key:"type",get:function(){var t=this.getAttribute("type");return["checkbox","radio"].indexOf(t)<0&&t||"text"}},{key:"_helper",get:function(){return this.querySelector("span")}}],[{key:"observedAttributes",get:function(){return[].concat(_(p(o.__proto__||Object.getPrototypeOf(o),"observedAttributes",this)),["type"])}}]),o}();i.Input=pr,customElements.define("ons-input",pr);var gr=function(t){function i(){h(this,i);var t=m(this,(i.__proto__||Object.getPrototypeOf(i)).call(this));return t.constructor===i&&util.throwAbstract(),xt(t,function(){t.attributeChangedCallback("checked",null,t.getAttribute("checked"))}),t}return a(i,dr),d(i,[{key:"attributeChangedCallback",value:function(t,e,n){switch(t){case"checked":this.checked=null!==n;break;default:p(i.prototype.__proto__||Object.getPrototypeOf(i.prototype),"attributeChangedCallback",this).call(this,t,e,n)}}},{key:"_template",get:function(){return'\n      <input type="'+this.type+'" class="'+this._defaultClassName+'__input">\n      <span class="'+this._defaultClassName+'__checkmark"></span>\n    '}},{key:"_helper",get:function(){return this.querySelector("span")}},{key:"checked",get:function(){return this._input.checked},set:function(t){var e=this;xt(this,function(){e._input.checked=t})}}],[{key:"observedAttributes",get:function(){return[].concat(_(p(i.__proto__||Object.getPrototypeOf(i),"observedAttributes",this)),["checked"])}}]),i}(),mr={".checkbox":"checkbox--*",".checkbox__input":"checkbox--*__input",".checkbox__checkmark":"checkbox--*__checkmark"},_r=function(t){function e(){return h(this,e),m(this,(e.__proto__||Object.getPrototypeOf(e)).apply(this,arguments))}return a(e,gr),d(e,[{key:"_scheme",get:function(){return mr}},{key:"_defaultClassName",get:function(){return"checkbox"}},{key:"type",get:function(){return"checkbox"}}]),e}();i.Checkbox=_r,customElements.define("ons-checkbox",_r);var vr={".radio-button":"radio-button--*",".radio-button__input":"radio-button--*__input",".radio-button__checkmark":"radio-button--*__checkmark"},br=function(t){function e(){return h(this,e),m(this,(e.__proto__||Object.getPrototypeOf(e)).apply(this,arguments))}return a(e,gr),d(e,[{key:"_scheme",get:function(){return vr}},{key:"_defaultClassName",get:function(){return"radio-button"}},{key:"type",get:function(){return"radio"}}]),e}();i.Radio=br,customElements.define("ons-radio",br);var yr={".search-input":"search-input--*"},kr=function(t){function e(){return h(this,e),m(this,(e.__proto__||Object.getPrototypeOf(e)).apply(this,arguments))}return a(e,dr),d(e,[{key:"_scheme",get:function(){return yr}},{key:"_template",get:function(){return'\n      <input type="'+this.type+'" class="search-input">\n    '}},{key:"type",get:function(){return"search"}}]),e}();i.SearchInput=kr,customElements.define("ons-search-input",kr);var wr=function(t){function s(){var t=0<arguments.length&&void 0!==arguments[0]?arguments[0]:{},e=t.timing,n=void 0===e?"linear":e,i=t.delay,o=void 0===i?0:i,r=t.duration,a=void 0===r?.2:r;return h(this,s),m(this,(s.__proto__||Object.getPrototypeOf(s)).call(this,{timing:n,delay:o,duration:a}))}return a(s,no),d(s,[{key:"show",value:function(t,e){e()}},{key:"hide",value:function(t,e){e()}}]),s}(),Er=function(t){function s(){var t=0<arguments.length&&void 0!==arguments[0]?arguments[0]:{},e=t.timing,n=void 0===e?"linear":e,i=t.delay,o=void 0===i?0:i,r=t.duration,a=void 0===r?.3:r;return h(this,s),m(this,(s.__proto__||Object.getPrototypeOf(s)).call(this,{timing:n,delay:o,duration:a}))}return a(s,wr),d(s,[{key:"show",value:function(t,e){e=e||function(){},it(t,this.def).default({opacity:0},{opacity:1}).queue(function(t){e(),t()}).play()}},{key:"hide",value:function(t,e){e=e||function(){},it(t,this.def).default({opacity:1},{opacity:0}).queue(function(t){e(),t()}).play()}}]),s}(),Cr=function(t){function s(){var t=0<arguments.length&&void 0!==arguments[0]?arguments[0]:{},e=t.timing,n=void 0===e?"cubic-bezier( .1, .7, .1, 1)":e,i=t.delay,o=void 0===i?0:i,r=t.duration,a=void 0===r?.4:r;return h(this,s),m(this,(s.__proto__||Object.getPrototypeOf(s)).call(this,{timing:n,delay:o,duration:a}))}return a(s,wr),d(s,[{key:"show",value:function(t,e){e=e||function(){},it(t,this.def).default({transform:"translate3d(0, 100%, 0)"},{transform:"translate3d(0, 0, 0)"}).queue(function(t){e(),t()}).play()}},{key:"hide",value:function(t,e){e=e||function(){},it(t,this.def).default({transform:"translate3d(0, 0, 0)"},{transform:"translate3d(0, 100%, 0)"}).queue(function(t){e(),t()}).play()}}]),s}(),Ar={"":"modal--*",modal__content:"modal--*__content"},Sr={default:wr,fade:Er,lift:Cr,none:wr},Pr=function(t){function i(){h(this,i);var t=m(this,(i.__proto__||Object.getPrototypeOf(i)).call(this));return t._defaultDBB=function(){},xt(t,function(){return t._compile()}),t}return a(i,so),d(i,[{key:"_updateAnimatorFactory",value:function(){return new y({animators:Sr,baseClass:wr,baseClassName:"ModalAnimator",defaultAnimation:this.getAttribute("animation")})}},{key:"_compile",value:function(){if(this.style.display="none",this.style.zIndex=10001,this.classList.add("modal"),!W.findChild(this,".modal__content")){var t=document.createElement("div");for(t.classList.add("modal__content");this.childNodes[0];){var e=this.childNodes[0];this.removeChild(e),t.insertBefore(e,null)}this.appendChild(t)}O.initModifier(this,this._scheme)}},{key:"_toggleStyle",value:function(t){this.style.display=t?"table":"none"}},{key:"connectedCallback",value:function(){p(i.prototype.__proto__||Object.getPrototypeOf(i.prototype),"connectedCallback",this).call(this)}},{key:"disconnectedCallback",value:function(){p(i.prototype.__proto__||Object.getPrototypeOf(i.prototype),"disconnectedCallback",this).call(this)}},{key:"attributeChangedCallback",value:function(t,e,n){"class"===t?W.restoreClass(this,"modal",Ar):p(i.prototype.__proto__||Object.getPrototypeOf(i.prototype),"attributeChangedCallback",this).call(this,t,e,n)}},{key:"_scheme",get:function(){return Ar}}],[{key:"registerAnimator",value:function(t,e){e.prototype instanceof wr||W.throwAnimator("Modal"),Sr[t]=e}},{key:"observedAttributes",get:function(){return[].concat(_(p(i.__proto__||Object.getPrototypeOf(i),"observedAttributes",this)),["class"])}},{key:"animators",get:function(){return Sr}},{key:"ModalAnimator",get:function(){return wr}}]),i}();i.Modal=Pr,customElements.define("ons-modal",Pr);var Or=function(){function t(e){var n=this;h(this,t),"element ignoreSwipe isInitialState onDragCallback swipeMax swipeMin swipeMid".split(/\s+/).forEach(function(t){return n[t]=e[t]}),this.elementHandler=e.elementHandler||e.element,this.getThreshold=e.getThreshold||function(){return.5},this.getSide=e.getSide||function(){return"left"},this.handleGesture=this.handleGesture.bind(this),this._shouldFixScroll="ios"===W.globals.actualMobileOS}return d(t,[{key:"update",value:function(){var t=0<arguments.length&&void 0!==arguments[0]?arguments[0]:this.element.hasAttribute("swipeable");this.gestureDetector||(this.gestureDetector=new ot(this.elementHandler,{dragMinDistance:1,passive:!this._shouldFixScroll}));var e=t?"on":"off";this.gestureDetector[e]("drag dragstart dragend",this.handleGesture)}},{key:"handleGesture",value:function(t){t.gesture&&("dragstart"===t.type?this.onDragStart(t):this._ignoreDrag||("dragend"===t.type?this.onDragEnd(t):this.onDrag(t)))}},{key:"onDragStart",value:function(t){var e=this;this._ignoreDrag=t.consumed||!W.isValidGesture(t)||this.ignoreSwipe(t,"left"===e.getSide()?t.gesture.center.clientX:window.innerWidth-t.gesture.center.clientX),this._ignoreDrag||(t.consume&&t.consume(),t.consumed=!0,this._width=function(t){var e=[parseInt(t,10),/px/.test(t)],n=e[0];return e[1]?n:Math.round(document.body.offsetWidth*n/100)}(this.element.style.width||"100%"),this._startDistance=this._distance=this.isInitialState instanceof Function&&!this.isInitialState()?this._width:0,W.iosPreventScroll(this.gestureDetector))}},{key:"onDrag",value:function(t){t.stopPropagation();var e="left"===this.getSide()?t.gesture.deltaX:-t.gesture.deltaX,n=Math.max(0,Math.min(this._width,this._startDistance+e));n!==this._distance&&(this._distance=n,this.swipeMid(this._distance,this._width))}},{key:"onDragEnd",value:function(t){t.stopPropagation();var e=t.gesture.interimDirection;this.getSide()!==e&&this._distance>this._width*this.getThreshold()?this.swipeMax():this.swipeMin()}},{key:"dispose",value:function(){this.gestureDetector&&this.gestureDetector.dispose(),this.gestureDetector=this.element=this.elementHandler=null}}]),t}(),xr=function(t){function e(t){return h(this,e),t=W.extend({timing:"linear",duration:"0.4",delay:"0"},t||{}),m(this,(e.__proto__||Object.getPrototypeOf(e)).call(this,t))}return a(e,no),d(e,[{key:"push",value:function(t,e,n){n()}},{key:"pop",value:function(t,e,n){n()}},{key:"block",value:function(t){var e=W.createElement('\n      <div style="position: absolute; background-color: transparent; width: 100%; height: 100%; z-index: 100000"></div>\n    ');return t.parentNode.appendChild(e),function(){return e.remove()}}}]),e}(),Tr=function(t){function u(){var t=0<arguments.length&&void 0!==arguments[0]?arguments[0]:{},e=t.durationRestore,n=void 0===e?.1:e,i=t.durationSwipe,o=void 0===i?.15:i,r=t.timingSwipe,a=void 0===r?"linear":r,s=g(t,["durationRestore","durationSwipe","timingSwipe"]);h(this,u);var l=m(this,(u.__proto__||Object.getPrototypeOf(u)).call(this,f({},s)));return l.constructor===u&&W.throwAbstract(),l.durationRestore=n,l.durationSwipe=o,l.timingSwipe=a,l.optSwipe={timing:a,duration:o},l.optRestore={timing:a,duration:n},l.swipeShadow=W.createElement('<div style="position: absolute; height: 100%; width: 12px; right: 100%; top: 0; bottom: 0; z-index: -1;background: linear-gradient(to right, transparent 0, rgba(0,0,0,.04) 40%, rgba(0,0,0,.12) 80%, rgba(0,0,0,.16) 100%);"></div>'),l.isDragStart=!0,l}return a(u,xr),d(u,null,[{key:"swipeable",get:function(){return!0}}]),d(u,[{key:"_decompose",value:function(){W.throwMember()}},{key:"_shouldAnimateToolbar",value:function(){W.throwMember()}},{key:"_calculateDelta",value:function(){W.throwMember()}},{key:"_dragStartSetup",value:function(t,e){this.isDragStart=!1,this.unblock=p(u.prototype.__proto__||Object.getPrototypeOf(u.prototype),"block",this).call(this,e),t.parentElement.insertBefore(this.backgroundMask,t),this.target={enter:W.findToolbarPage(t)||t,leave:W.findToolbarPage(e)||e},this.decomp={enter:this._decompose(this.target.enter),leave:this._decompose(this.target.leave)},this.delta=this._calculateDelta(e,this.decomp.leave),this.shouldAnimateToolbar=this._shouldAnimateToolbar(this.target.enter,this.target.leave),this.shouldAnimateToolbar?(this.swipeShadow.style.top=this.decomp.leave.toolbar.offsetHeight+"px",this.target.leave.appendChild(this.swipeShadow),this._saveStyle(this.target.enter,this.target.leave)):(e.appendChild(this.swipeShadow),this._saveStyle(t,e)),e.classList.add("overflow-visible"),this.overflowElement=e,this.decomp.leave.content.classList.add("content-swiping")}},{key:"translate",value:function(t,e,n,i){this.isSwiping=!0,"none"===n.style.display&&(n.style.display=""),this.isDragStart&&(this.maxWidth=e,this._dragStartSetup(n,i));var o=(t-e)/e;this.shouldAnimateToolbar?it.runAll(it([this.decomp.enter.content,this.decomp.enter.bottomToolbar,this.decomp.enter.background]).queue({transform:"translate3d("+25*o+"%, 0, 0)",opacity:1+10*o/100}),it(this.decomp.enter.toolbarCenter).queue({transform:"translate3d("+this.delta.title*o+"px, 0, 0)",opacity:1+o}),it(this.decomp.enter.backButtonLabel).queue({opacity:1+10*o/100,transform:"translate3d("+this.delta.label*o+"px, 0, 0)"}),it(this.decomp.enter.other).queue({opacity:1+o}),it([this.decomp.leave.content,this.decomp.leave.bottomToolbar,this.decomp.leave.background,this.swipeShadow]).queue({transform:"translate3d("+t+"px, 0, 0)"}),it(this.decomp.leave.toolbar).queue({opacity:-1*o}),it(this.decomp.leave.toolbarCenter).queue({transform:"translate3d("+125*(1+o)+"%, 0, 0)"}),it(this.decomp.leave.backButtonLabel).queue({opacity:-1*o,transform:"translate3d("+this.delta.title*(1+o)+"px, 0, 0)"}),it(this.swipeShadow).queue({opacity:-1*o})):it.runAll(it(i).queue({transform:"translate3d("+t+"px, 0, 0)"}),it(n).queue({transform:"translate3d("+25*o+"%, 0, 0)",opacity:1+10*o/100}),it(this.swipeShadow).queue({opacity:-1*o}))}},{key:"restore",value:function(e,n,i){var o=this;this.isDragStart||(this.shouldAnimateToolbar?it.runAll(it([this.decomp.enter.content,this.decomp.enter.bottomToolbar,this.decomp.enter.background]).queue({transform:"translate3d(-25%, 0, 0)",opacity:.9},this.optRestore),it(this.decomp.enter.toolbarCenter).queue({transform:"translate3d(-"+this.delta.title+"px, 0, 0)",transition:"opacity "+this.durationRestore+"s linear, transform "+this.durationRestore+"s "+this.timingSwipe,opacity:0}),it(this.decomp.enter.backButtonLabel).queue({transform:"translate3d(-"+this.delta.label+"px, 0, 0)"},this.optRestore),it(this.decomp.enter.other).queue({opacity:0},this.optRestore),it([this.decomp.leave.content,this.decomp.leave.bottomToolbar,this.decomp.leave.background,this.swipeShadow]).queue({transform:"translate3d(0, 0, 0)"},this.optRestore),it(this.decomp.leave.toolbar).queue({opacity:1},this.optRestore),it(this.decomp.leave.toolbarCenter).queue({transform:"translate3d(0, 0, 0)"},this.optRestore),it(this.decomp.leave.backButtonLabel).queue({opacity:1,transform:"translate3d(0, 0, 0)",transition:"opacity "+this.durationRestore+"s linear, transform "+this.durationRestore+"s "+this.timingSwipe}),it(this.swipeShadow).queue({opacity:0},this.optRestore).queue(function(t){o._reset(o.target.enter,o.target.leave),e.style.display="none",i&&i(),t()})):it.runAll(it(e).queue({transform:"translate3D(-25%, 0, 0)",opacity:.9},this.optRestore),it(n).queue({transform:"translate3D(0, 0, 0)"},this.optRestore).queue(function(t){o._reset(e,n),e.style.display="none",i&&i(),t()})))}},{key:"popSwipe",value:function(e,n,i){var o=this;this.isDragStart||(this.shouldAnimateToolbar?it.runAll(it([this.decomp.enter.content,this.decomp.enter.bottomToolbar,this.decomp.enter.background]).queue({transform:"translate3d(0, 0, 0)",opacity:1},this.optSwipe),it(this.decomp.enter.toolbarCenter).queue({transform:"translate3d(0, 0, 0)",transition:"opacity "+this.durationSwipe+"s linear, transform "+this.durationSwipe+"s "+this.timingSwipe,opacity:1}),it(this.decomp.enter.backButtonLabel).queue({transform:"translate3d(0, 0, 0)"},this.optSwipe),it(this.decomp.enter.other).queue({opacity:1},this.optSwipe),it([this.decomp.leave.content,this.decomp.leave.bottomToolbar,this.decomp.leave.background]).queue({transform:"translate3d(100%, 0, 0)"},this.optSwipe),it(this.decomp.leave.toolbar).queue({opacity:0},this.optSwipe),it(this.decomp.leave.toolbarCenter).queue({transform:"translate3d(125%, 0, 0)"},this.optSwipe),it(this.decomp.leave.backButtonLabel).queue({opacity:0,transform:"translate3d("+this.delta.title+"px, 0, 0)",transition:"opacity "+this.durationSwipe+"s linear, transform "+this.durationSwipe+"s "+this.timingSwipe}),it(this.swipeShadow).queue({opacity:0,transform:"translate3d("+this.maxWidth+"px, 0, 0)"},this.optSwipe).queue(function(t){o._reset(o.target.enter,o.target.leave),i&&i(),t()})):it.runAll(it(e).queue({transform:"translate3D(0, 0, 0)",opacity:1},this.optSwipe),it(n).queue({transform:"translate3D(100%, 0, 0)"},this.optSwipe).queue(function(t){o._reset(e,n),i&&i(),t()})))}},{key:"_saveStyle",value:function(){var n=this;this._savedStyle=new WeakMap;for(var i=function(t){return n._savedStyle.set(t,t.getAttribute("style"))},t=arguments.length,e=Array(t),o=0;o<t;o++)e[o]=arguments[o];e.forEach(i),Object.keys(this.decomp).forEach(function(e){Object.keys(n.decomp[e]).forEach(function(t){(n.decomp[e][t]instanceof Array?n.decomp[e][t]:[n.decomp[e][t]]).forEach(i)})})}},{key:"_restoreStyle",value:function(){for(var n=this,i=function(t){null===n._savedStyle.get(t)?t.removeAttribute("style"):t.setAttribute("style",n._savedStyle.get(t)),n._savedStyle.delete(t)},t=arguments.length,e=Array(t),o=0;o<t;o++)e[o]=arguments[o];e.forEach(i),Object.keys(this.decomp).forEach(function(e){Object.keys(n.decomp[e]).forEach(function(t){(n.decomp[e][t]instanceof Array?n.decomp[e][t]:[n.decomp[e][t]]).forEach(i)})})}},{key:"_reset",value:function(){this.isSwiping=!1,this._savedStyle&&this._restoreStyle.apply(this,arguments),this.unblock&&this.unblock(),this.swipeShadow.remove(),this.backgroundMask.remove(),this.overflowElement.classList.remove("overflow-visible"),this.decomp.leave.content.classList.remove("content-swiping"),this.decomp=this.target=this.overflowElement=this._savedStyle=null,this.isDragStart=!0}}]),u}(),Lr=function(){return"translate3d("+(0<arguments.length&&void 0!==arguments[0]?arguments[0]:0)+", "+(1<arguments.length&&void 0!==arguments[1]?arguments[1]:0)+", "+(2<arguments.length&&void 0!==arguments[2]?arguments[2]:0)+")"},Mr=function(t){function c(){var t=0<arguments.length&&void 0!==arguments[0]?arguments[0]:{},e=t.timing,n=void 0===e?"cubic-bezier(0.3, .4, 0, .9)":e,i=t.delay,o=void 0===i?0:i,r=t.duration,a=void 0===r?.4:r,s=g(t,["timing","delay","duration"]);h(this,c);var l=m(this,(c.__proto__||Object.getPrototypeOf(c)).call(this,f({timing:n,delay:o,duration:a},s)));return l.backgroundMask=W.createElement('<div style="position: absolute; width: 100%; height: 100%;background-color: black; z-index: 2"></div>'),l}return a(c,Tr),d(c,[{key:"_decompose",value:function(t){var e=t._getToolbarElement(),n=e._getToolbarLeftItemsElement(),i=e._getToolbarRightItemsElement(),o=function(t){for(var e=[],n=0;n<t.length;n++)"ons-back-button"!==t[n].nodeName.toLowerCase()&&e.push(t[n]);return e},r=[].concat(0===n.children.length?n:o(n.children)).concat(0===i.children.length?i:o(i.children));return{toolbarCenter:e._getToolbarCenterItemsElement(),backButtonIcon:e._getToolbarBackButtonIconElement(),backButtonLabel:e._getToolbarBackButtonLabelElement(),other:r,content:t._getContentElement(),background:t._getBackgroundElement(),toolbar:e,bottomToolbar:t._getBottomToolbarElement()}}},{key:"_shouldAnimateToolbar",value:function(t,e){var n=t._canAnimateToolbar()&&e._canAnimateToolbar(),i=t._getToolbarElement(),o=e._getToolbarElement(),r=i.hasAttribute("static")||o.hasAttribute("static"),a=W.hasModifier(i,"material")||W.hasModifier(o,"material"),s=W.hasModifier(i,"transparent")||W.hasModifier(o,"transparent");return n&&!r&&!a&&!s}},{key:"_calculateDelta",value:function(t,e){var n=void 0,i=void 0,o=t.getBoundingClientRect();if(e.backButtonLabel.classList.contains("back-button__label")){var r=e.backButtonLabel.getBoundingClientRect();n=Math.round(o.width/2-r.width/2-r.left)}else n=Math.round(o.width/2*.6);return e.backButtonIcon.classList.contains("back-button__icon")&&(i=e.backButtonIcon.getBoundingClientRect().right-2),{title:n,label:i}}},{key:"push",value:function(r,a,s){var l=this;this.backgroundMask.remove(),a.parentNode.insertBefore(this.backgroundMask,a);var u=p(c.prototype.__proto__||Object.getPrototypeOf(c.prototype),"block",this).call(this,r);xt(r,function(){var t=W.findToolbarPage(r)||r,e=W.findToolbarPage(a)||a,n=l._decompose(t),i=l._decompose(e),o=l._calculateDelta(a,n);l._shouldAnimateToolbar(t,e)?it.runAll(it([n.content,n.bottomToolbar,n.background],l.def).default({transform:Lr("100%")},{transform:Lr()}),it(n.toolbar,l.def).default({opacity:0},{opacity:1}),it(n.toolbarCenter,l.def).default({transform:Lr("125%"),opacity:1},{transform:Lr(),opacity:1}),it(n.backButtonLabel,l.def).default({transform:Lr(o.title+"px"),opacity:0},{transform:Lr(),opacity:1,transition:"opacity "+l.duration+"s linear, transform "+l.duration+"s "+l.timing}),it(n.other,l.def).default({opacity:0},{css:{opacity:1},timing:"linear"}),it([i.content,i.bottomToolbar,i.background],l.def).default({transform:Lr(),opacity:1},{transform:Lr("-25%"),opacity:.9}).queue(function(t){l.backgroundMask.remove(),u(),s(),t()}),it(i.toolbarCenter,l.def).default({transform:Lr(),opacity:1},{transform:Lr("-"+o.title+"px"),opacity:0,transition:"opacity "+l.duration+"s linear, transform "+l.duration+"s "+l.timing}),it(i.backButtonLabel,l.def).default({transform:Lr(),opacity:1},{transform:Lr("-"+o.label+"px"),opacity:0}),it(i.other,l.def).default({opacity:1},{css:{opacity:0},timing:"linear"})):it.runAll(it(r,l.def).default({transform:Lr("100%")},{transform:Lr()}),it(a,l.def).default({transform:Lr(),opacity:1},{transform:Lr("-25%"),opacity:.9}).queue(function(t){l.backgroundMask.remove(),u(),s(),t()}))})}},{key:"pop",value:function(t,e,n){var i=this;if(this.isSwiping)return this.popSwipe(t,e,n);this.backgroundMask.remove(),t.parentNode.insertBefore(this.backgroundMask,t);var o=p(c.prototype.__proto__||Object.getPrototypeOf(c.prototype),"block",this).call(this,t),r=W.findToolbarPage(t)||t,a=W.findToolbarPage(e)||e,s=this._decompose(r),l=this._decompose(a),u=this._calculateDelta(e,l);this._shouldAnimateToolbar(r,a)?it.runAll(it([s.content,s.bottomToolbar,s.background],this.def).default({transform:Lr("-25%"),opacity:.9},{transform:Lr(),opacity:1}),it(s.toolbarCenter,this.def).default({transform:Lr("-"+u.title+"px"),opacity:0},{transform:Lr(),opacity:1,transition:"opacity "+this.duration+"s linear, transform "+this.duration+"s "+this.timing}),it(s.backButtonLabel,this.def).default({transform:Lr("-"+u.label+"px")},{transform:Lr()}),it(s.other,this.def).default({opacity:0},{css:{opacity:1},timing:"linear"}),it([l.content,l.bottomToolbar,l.background],this.def).default({transform:Lr()},{transform:Lr("100%")}).wait(0).queue(function(t){i.backgroundMask.remove(),o(),n(),t()}),it(l.toolbar,this.def).default({opacity:1},{opacity:0}),it(l.toolbarCenter,this.def).default({transform:Lr()},{transform:Lr("125%")}),it(l.backButtonLabel,this.def).default({transform:Lr(),opacity:1},{transform:Lr(u.title+"px"),opacity:0,transition:"opacity "+this.duration+"s linear, transform "+this.duration+"s "+this.timing})):it.runAll(it(t,this.def).default({transform:Lr("-25%"),opacity:.9},{transform:Lr(),opacity:1}),it(e,this.def).default({transform:Lr()},{transform:Lr("100%")}).queue(function(t){i.backgroundMask.remove(),o(),n(),t()}))}}]),c}(),Dr=function(t){function l(){var t=0<arguments.length&&void 0!==arguments[0]?arguments[0]:{},e=t.timing,n=void 0===e?"cubic-bezier(.1, .7, .1, 1)":e,i=t.delay,o=void 0===i?0:i,r=t.duration,a=void 0===r?.4:r;h(this,l);var s=m(this,(l.__proto__||Object.getPrototypeOf(l)).call(this,{timing:n,delay:o,duration:a}));return s.backgroundMask=W.createElement('<div style="position: absolute; width: 100%; height: 100%;background: linear-gradient(black, white);"></div>'),s}return a(l,xr),d(l,[{key:"push",value:function(t,e,n){var i=this;this.backgroundMask.remove(),e.parentNode.insertBefore(this.backgroundMask,e);var o=p(l.prototype.__proto__||Object.getPrototypeOf(l.prototype),"block",this).call(this,t);it.runAll(it(t,this.def).default({transform:"translate3D(0, 100%, 0)"},{transform:"translate3D(0, 0, 0)"}),it(e,this.def).default({transform:"translate3D(0, 0, 0)",opacity:1},{transform:"translate3D(0, -10%, 0)",opacity:.9}).queue(function(t){i.backgroundMask.remove(),o(),n(),t()}))}},{key:"pop",value:function(t,e,n){var i=this;this.backgroundMask.remove(),t.parentNode.insertBefore(this.backgroundMask,t);var o=p(l.prototype.__proto__||Object.getPrototypeOf(l.prototype),"block",this).call(this,t);it.runAll(it(t,this.def).default({transform:"translate3D(0, -43px, 0)",opacity:.9},{transform:"translate3D(0, 0, 0)",opacity:1}).queue(function(t){i.backgroundMask.remove(),o(),n(),t()}),it(e,this.def).default({transform:"translate3D(0, 0, 0)"},{transform:"translate3D(0, 100%, 0)"}))}}]),l}(),Ir="translate3d(0, 0, 0)",Nr=function(t){function s(){var t=0<arguments.length&&void 0!==arguments[0]?arguments[0]:{},e=t.timing,n=void 0===e?"linear":e,i=t.delay,o=void 0===i?0:i,r=t.duration,a=void 0===r?.4:r;return h(this,s),m(this,(s.__proto__||Object.getPrototypeOf(s)).call(this,{timing:n,delay:o,duration:a}))}return a(s,xr),d(s,[{key:"push",value:function(t,e,n){var i=p(s.prototype.__proto__||Object.getPrototypeOf(s.prototype),"block",this).call(this,t);it.runAll(it(t,this.def).default({transform:Ir,opacity:0},{transform:Ir,opacity:1}).queue(function(t){i(),n(),t()}))}},{key:"pop",value:function(t,e,n){var i=p(s.prototype.__proto__||Object.getPrototypeOf(s.prototype),"block",this).call(this,t);it.runAll(it(e,this.def).default({transform:Ir,opacity:1},{transform:Ir,opacity:0}).queue(function(t){i(),n(),t()}))}}]),s}(),Br=function(t){function l(){var t=0<arguments.length&&void 0!==arguments[0]?arguments[0]:{},e=t.timing,n=void 0===e?"cubic-bezier(.1, .7, .4, 1)":e,i=t.delay,o=void 0===i?0:i,r=t.duration,a=void 0===r?.3:r;h(this,l);var s=m(this,(l.__proto__||Object.getPrototypeOf(l)).call(this,{timing:n,delay:o,duration:a}));return s.blackMaskOpacity=.4,s.backgroundMask=W.createElement('<div style="position: absolute; width: 100%; height: 100%; z-index: 2;background-color: black; opacity: 0;"></div>'),s}return a(l,xr),d(l,[{key:"push",value:function(t,e,n){var i=this;this.backgroundMask.remove(),e.parentElement.insertBefore(this.backgroundMask,e.nextSibling);var o=p(l.prototype.__proto__||Object.getPrototypeOf(l.prototype),"block",this).call(this,t);it.runAll(it(this.backgroundMask,this.def).default({transform:"translate3d(0, 0, 0)",opacity:0},{opacity:this.blackMaskOpacity}).queue(function(t){i.backgroundMask.remove(),t()}),it(t,this.def).default({transform:"translate3d(100%, 0, 0)"},{transform:"translate3d(0, 0, 0)"}),it(e,this.def).default({transform:"translate3d(0, 0, 0)"},{transform:"translate3d(-45%, 0, 0)"}).queue(function(t){o(),n(),t()}))}},{key:"pop",value:function(t,e,n){var i=this;this.backgroundMask.remove(),t.parentNode.insertBefore(this.backgroundMask,t.nextSibling);var o=p(l.prototype.__proto__||Object.getPrototypeOf(l.prototype),"block",this).call(this,t);it.runAll(it(this.backgroundMask,this.def).default({transform:"translate3d(0, 0, 0)",opacity:this.blackMaskOpacity},{opacity:0}).queue(function(t){i.backgroundMask.remove(),t()}),it(t,this.def).default({transform:"translate3d(-45%, 0, 0)",opacity:.9},{transform:"translate3d(0, 0, 0)",opacity:1}),it(e,this.def).default({transform:"translate3d(0, 0, 0)"},{transform:"translate3d(100%, 0, 0)"}).queue(function(t){o(),n(),t()}))}}]),l}(),jr=function(t){function l(){var t=0<arguments.length&&void 0!==arguments[0]?arguments[0]:{},e=t.timing,n=void 0===e?"cubic-bezier(.1, .7, .1, 1)":e,i=t.delay,o=void 0===i?.05:i,r=t.duration,a=void 0===r?.4:r;h(this,l);var s=m(this,(l.__proto__||Object.getPrototypeOf(l)).call(this,{timing:n,delay:o,duration:a}));return s.backgroundMask=W.createElement('<div style="position: absolute; width: 100%; height: 100%;background-color: black;"></div>'),s}return a(l,xr),d(l,[{key:"push",value:function(t,e,n){var i=this;this.backgroundMask.remove(),e.parentNode.insertBefore(this.backgroundMask,e);var o=p(l.prototype.__proto__||Object.getPrototypeOf(l.prototype),"block",this).call(this,t),r=it(this.backgroundMask).wait(this.delay+this.duration).queue(function(t){i.backgroundMask.remove(),t()});it.runAll(r,it(t,this.def).default({transform:"translate3d(0, 100%, 0)"},{transform:"translate3d(0, 0, 0)"}),it(e,this.def).default({opacity:1},{opacity:.4}).queue(function(t){o(),n(),t()}))}},{key:"pop",value:function(t,e,n){var i=this;this.backgroundMask.remove(),t.parentNode.insertBefore(this.backgroundMask,t);var o=p(l.prototype.__proto__||Object.getPrototypeOf(l.prototype),"block",this).call(this,t);it.runAll(it(this.backgroundMask).wait(this.delay+this.duration).queue(function(t){i.backgroundMask.remove(),t()}),it(t,this.def).default({opacity:.4},{opacity:1}).queue(function(t){o(),n(),t()}),it(e,this.def).default({transform:"translate3d(0, 0, 0)"},{transform:"translate3d(0, 100%, 0)"}))}}]),l}(),Hr=function(t){function c(){var t=0<arguments.length&&void 0!==arguments[0]?arguments[0]:{},e=t.timing,n=void 0===e?"cubic-bezier(0.4, 0, 0.2, 1)":e,i=t.timingPop,o=void 0===i?"cubic-bezier(0.4, 0, 1, 1)":i,r=t.delay,a=void 0===r?0:r,s=t.duration,l=void 0===s?.2:s;h(this,c);var u=m(this,(c.__proto__||Object.getPrototypeOf(c)).call(this,{timing:n,delay:a,duration:l}));return u.timingPop=o,u}return a(c,xr),d(c,[{key:"push",value:function(t,e,n){var i=p(c.prototype.__proto__||Object.getPrototypeOf(c.prototype),"block",this).call(this,t);it.runAll(it(t,this.def).default({transform:"translate3D(0, 42px, 0)",opacity:0},{transform:"translate3D(0, 0, 0)",opacity:1}).queue(function(t){i(),n(),t()}))}},{key:"pop",value:function(t,e,n){var i=p(c.prototype.__proto__||Object.getPrototypeOf(c.prototype),"block",this).call(this,t);it.runAll(it(e,this.def).default({transform:"translate3D(0, 0, 0)",opacity:1},{css:{transform:"translate3D(0, 38px, 0)",opacity:0},timing:this.timingPop}).queue(function(t){i(),n(),t()}))}}]),c}(),Rr=function(t){function e(t){return h(this,e),m(this,(e.__proto__||Object.getPrototypeOf(e)).call(this,t))}return a(e,xr),d(e,[{key:"push",value:function(t,e,n){n()}},{key:"pop",value:function(t,e,n){n()}}]),e}(),Fr={default:function(){return c.isAndroid()?Hr:Mr},slide:function(){return c.isAndroid()?Br:Mr},lift:function(){return c.isAndroid()?jr:Dr},fade:function(){return c.isAndroid()?Hr:Nr},"slide-ios":Mr,"slide-md":Br,"lift-ios":Dr,"lift-md":jr,"fade-ios":Nr,"fade-md":Hr,none:Rr},qr={ready:function(t,e){e()}},zr=function(t){return"ONS-PAGE"!==t.nodeName&&W.throw("Only page elements can be children of navigator")},Vr=function(t){function e(){h(this,e);var t=m(this,(e.__proto__||Object.getPrototypeOf(e)).call(this));return t._isRunning=!1,t._initialized=!1,t._pageLoader=$t,t._pageMap=new WeakMap,t._updateAnimatorFactory(),t}return a(e,Zi),d(e,[{key:"animatorFactory",get:function(){return this._animatorFactory}}]),d(e,[{key:"_getPageTarget",value:function(){return this._page||this.getAttribute("page")}},{key:"connectedCallback",value:function(){var a=this;if(this.onDeviceBackButton=this._onDeviceBackButton.bind(this),!c.isAndroid()||"force"===this.getAttribute("swipeable")){var s=void 0;this._swipe=new Or({element:this,getThreshold:function(){return Math.max(.2,parseFloat(a.getAttribute("swipe-threshold"))||0)},swipeMax:function(){a._onSwipe&&a._onSwipe(1,{duration:s.durationSwipe,timing:s.timingSwipe}),a[a.swipeMax?"swipeMax":"popPage"]({animator:s}),s=null},swipeMid:function(t,e){a._onSwipe&&a._onSwipe(t/e),s.translate(t,e,a.topPage.previousElementSibling,a.topPage)},swipeMin:function(){a._onSwipe&&a._onSwipe(0,{duration:s.durationRestore,timing:s.timingSwipe}),s.restore(a.topPage.previousElementSibling,a.topPage),s=null},ignoreSwipe:function(t,e){if(!a._isRunning&&1<a.children.length){var n=parseInt(a.getAttribute("swipe-target-width")||25,10);if("right"===t.gesture.direction&&e<n){var i=function(t){return/ons-back-button/i.test(t.tagName)};if(!i(t.target)&&!W.findParent(t.target,i,function(t){return/ons-page/i.test(t.tagName)})){var o=(a.topPage.pushedOptions||{}).animation||a.animatorFactory._animation,r=Fr[o]instanceof Function?Fr[o].call():Fr[o];if(void 0!==r&&r.swipeable)return s=new r,!1}}}return!0}}),this.attributeChangedCallback("swipeable")}if(!this._initialized){this._initialized=!0;var i=W.defer();this.loaded=i.promise,qr.ready(this,function(){var t=!W.hasAnyComponentAsParent(a),e={animation:"none",show:t};if(0===a.pages.length&&a._getPageTarget())a.pushPage(a._getPageTarget(),e).then(function(){return i.resolve()});else if(0<a.pages.length){for(var n=0;n<a.pages.length;n++)zr(a.pages[n]);a.topPage&&xt(a.topPage,function(){return setTimeout(function(){i.resolve(),t&&a.topPage._show(),a._updateLastPageBackButton()},0)})}else xt(a,function(){0===a.pages.length&&a._getPageTarget()?a.pushPage(a._getPageTarget(),e).then(function(){return i.resolve()}):i.resolve()})})}}},{key:"_updateAnimatorFactory",value:function(){this._animatorFactory=new y({animators:Fr,baseClass:xr,baseClassName:"NavigatorAnimator",defaultAnimation:this.getAttribute("animation")})}},{key:"disconnectedCallback",value:function(){this._backButtonHandler.destroy(),this._backButtonHandler=null,this._swipe&&this._swipe.dispose(),this._swipe=null}},{key:"attributeChangedCallback",value:function(t,e,n){switch(t){case"animation":this._updateAnimatorFactory();break;case"swipeable":this._swipe&&this._swipe.update()}}},{key:"popPage",value:function(){var e=this,t=0<arguments.length&&void 0!==arguments[0]?arguments[0]:{};t=this._preparePageAndOptions(null,t).options,W.isInteger(t.times)&&1<t.times&&this._removePages(t.times);return this._popPage(t,function(){return new Promise(function(t){e._pageLoader.unload(e.pages[e.pages.length-1]),t()})})}},{key:"_popPage",value:function(i){var o=this,r=1<arguments.length&&void 0!==arguments[1]?arguments[1]:function(){return Promise.resolve()};if(this._isRunning)return Promise.reject("popPage is already running.");if(this.pages.length<=1)return Promise.reject("ons-navigator's page stack is empty.");if(this._emitPrePopEvent())return Promise.reject("Canceled in prepop event.");var a=this.pages.length;return this._isRunning=!0,this.pages[a-2].updateBackButton(0<a-2),new Promise(function(t){var e=o.pages[a-1],n=o.pages[a-2];(i=W.extend({},o.options||{},e.pushedOptions||{},i)).data&&(n.data=W.extend({},n.data||{},i.data||{}));e._hide(),n.style.display="",(i.animator||o._animatorFactory.newAnimator(i)).pop(o.pages[a-2],o.pages[a-1],function(){r().then(function(){o._isRunning=!1,n._show(),W.triggerElementEvent(o,"postpop",{leavePage:e,enterPage:n,navigator:o}),i.callback&&i.callback(n),t(n)})})}).catch(function(){return o._isRunning=!1})}},{key:"pushPage",value:function(n){var i=this,o=1<arguments.length&&void 0!==arguments[1]?arguments[1]:{},t=this._preparePageAndOptions(n,o);n=t.page,o=t.options;var r=function(t){zr(t),i._pageMap.set(t,n),(t=W.extend(t,{data:o.data})).style.visibility="hidden"};return o.pageHTML?this._pushPage(o,function(){return new Promise(function(e){Kt.load({page:o.pageHTML,parent:i,params:o.data},function(t){r(t),e()})})}):this._pushPage(o,function(){return new Promise(function(e){i._pageLoader.load({page:n,parent:i,params:o.data},function(t){r(t),e()})})})}},{key:"_pushPage",value:function(){var o=this,r=0<arguments.length&&void 0!==arguments[0]?arguments[0]:{},t=1<arguments.length&&void 0!==arguments[1]?arguments[1]:function(){return Promise.resolve()};if(this._isRunning)return Promise.reject("pushPage is already running.");if(this._emitPrePushEvent())return Promise.reject("Canceled in prepush event.");this._isRunning=!0;var e=y.parseAnimationOptionsString(this.getAttribute("animation-options"));r=W.extend({},this.options||{},{animationOptions:e},r);var a=this._animatorFactory.newAnimator(r);return t().then(function(){var t=o.pages.length,n=o.pages[t-1],i=r.leavePage||o.pages[t-2];return zr(n),n.updateBackButton(t>(r._replacePage?2:1)),n.pushedOptions=W.extend({},n.pushedOptions||{},r||{}),n.data=W.extend({},n.data||{},r.data||{}),n.unload=n.unload||r.unload,new Promise(function(t){var e=function(){(o._isRunning=!1)!==r.show&&setImmediate(function(){return n._show()}),W.triggerElementEvent(o,"postpush",{leavePage:i,enterPage:n,navigator:o}),i&&(i.style.display="none"),r.callback&&r.callback(n),t(n)};n.style.visibility="",i?(i._hide(),a.push(n,i,e)):e()})}).catch(function(t){throw o._isRunning=!1,t})}},{key:"replacePage",value:function(t){var e=this,n=1<arguments.length&&void 0!==arguments[1]?arguments[1]:{};return this.pushPage(t,n).then(function(t){return 1<e.pages.length&&e._pageLoader.unload(e.pages[e.pages.length-2]),e._updateLastPageBackButton(),Promise.resolve(t)})}},{key:"insertPage",value:function(n,i){var o=this,r=2<arguments.length&&void 0!==arguments[2]?arguments[2]:{},t=this._preparePageAndOptions(i,r);if(i=t.page,r=t.options,(n=this._normalizeIndex(n))>=this.pages.length)return this.pushPage(i,r);i="string"==typeof r.pageHTML?r.pageHTML:i;var a="string"==typeof r.pageHTML?Kt:this._pageLoader;return new Promise(function(e){a.load({page:i,parent:o},function(t){zr(t),o._pageMap.set(t,i),t=W.extend(t,{data:r.data,pushedOptions:r}),r.animationOptions=W.extend({},y.parseAnimationOptionsString(o.getAttribute("animation-options")),r.animationOptions||{}),t.style.display="none",o.insertBefore(t,o.pages[n]),o.topPage.updateBackButton(!0),setTimeout(function(){t=null,e(o.pages[n])},1e3/60)})})}},{key:"removePage",value:function(i){var o=this,t=1<arguments.length&&void 0!==arguments[1]?arguments[1]:{};return(i=this._normalizeIndex(i))<this.pages.length-1?new Promise(function(t){var e=o.pages[i],n=o.topPage;o._pageMap.delete(e),o._pageLoader.unload(e),1===o.pages.length&&o.topPage.updateBackButton(!1),t(n)}):this.popPage(t)}},{key:"resetToPage",value:function(t){var e=this,n=1<arguments.length&&void 0!==arguments[1]?arguments[1]:{},i=this._preparePageAndOptions(t,n);if(t=i.page,(n=i.options).animator||n.animation||n.pop||(n.animation="none"),n.page||n.pageHTML||!this._getPageTarget()||(t=n.page=this._getPageTarget()),n.pop)return this._removePages(),this.insertPage(0,t,{data:n.data}).then(function(){return e.popPage(n)});var o=n.callback;return n.callback=function(t){e._removePages(),t.updateBackButton(!1),o&&o(t)},this.pushPage(t,n)}},{key:"bringPageTop",value:function(t){var e=1<arguments.length&&void 0!==arguments[1]?arguments[1]:{};-1===["number","string"].indexOf(void 0===t?"undefined":u(t))&&W.throw("First argument must be a page name or the index of an existing page. You supplied "+t);var n="number"==typeof t?this._normalizeIndex(t):this._lastIndexOfPage(t),i=this.pages[n];return n<0?this.pushPage(t,e):(e=this._preparePageAndOptions(i,e).options,n===this.pages.length-1?Promise.resolve(i):(i||W.throw("Failed to find item "+t),this._isRunning?Promise.reject("pushPage is already running."):this._emitPrePushEvent()?Promise.reject("Canceled in prepush event."):(i.style.display="",i.style.visibility="hidden",i.parentNode.appendChild(i),this._pushPage(e))))}},{key:"_preparePageAndOptions",value:function(t){var e=1<arguments.length&&void 0!==arguments[1]?arguments[1]:{};return"object"!=(void 0===e?"undefined":u(e))&&W.throw("options must be an object. You supplied "+e),null==t&&e.page&&(t=e.page),{page:t,options:e=W.extend({},this.options||{},e,{page:t})}}},{key:"_removePages",value:function(t){var e=this.pages,n=void 0===t?0:e.length-t;n=n<0?1:n;for(var i=e.length-2;n<=i;i--)this._pageMap.delete(e[i]),this._pageLoader.unload(e[i])}},{key:"_updateLastPageBackButton",value:function(){var t=this.pages.length-1;0<=t&&this.pages[t].updateBackButton(0<t)}},{key:"_normalizeIndex",value:function(t){return 0<=t?t:Math.abs(this.pages.length+t)%this.pages.length}},{key:"_onDeviceBackButton",value:function(t){1<this.pages.length?this.popPage():t.callParentHandler()}},{key:"_lastIndexOfPage",value:function(t){var e=void 0;for(e=this.pages.length-1;0<=e&&t!==this._pageMap.get(this.pages[e]);e--);return e}},{key:"_emitPreEvent",value:function(t){var e=1<arguments.length&&void 0!==arguments[1]?arguments[1]:{},n=!1;return W.triggerElementEvent(this,"pre"+t,W.extend({navigator:this,currentPage:this.pages[this.pages.length-1],cancel:function(){return n=!0}},e)),n}},{key:"_emitPrePushEvent",value:function(){return this._emitPreEvent("push")}},{key:"_emitPrePopEvent",value:function(){var t=this.pages.length;return this._emitPreEvent("pop",{leavePage:this.pages[t-1],enterPage:this.pages[t-2]})}},{key:"_createPageElement",value:function(t){var e=W.createElement(b.normalizePageHTML(t));return zr(e),e}},{key:"_show",value:function(){var t=this;this.loaded.then(function(){return t.topPage&&t.topPage._show()})}},{key:"_hide",value:function(){this.topPage&&this.topPage._hide()}},{key:"_destroy",value:function(){for(var t=this.pages.length-1;0<=t;t--)this._pageLoader.unload(this.pages[t]);this.remove()}},{key:"pageLoader",get:function(){return this._pageLoader},set:function(t){t instanceof Gt||W.throwPageLoader(),this._pageLoader=t}},{key:"page",get:function(){return this._page},set:function(t){this._page=t}},{key:"onDeviceBackButton",get:function(){return this._backButtonHandler},set:function(t){this._backButtonHandler&&this._backButtonHandler.destroy(),this._backButtonHandler=M.createHandler(this,t)}},{key:"topPage",get:function(){for(var t=this.lastElementChild;t&&"ONS-PAGE"!==t.tagName;)t=t.previousElementSibling;return t}},{key:"pages",get:function(){return W.arrayFrom(this.children).filter(function(t){return"ONS-PAGE"===t.tagName})}},{key:"onSwipe",get:function(){return this._onSwipe},set:function(t){!t||t instanceof Function||W.throw('"onSwipe" must be a function'),this._onSwipe=t}},{key:"options",get:function(){return this._options},set:function(t){this._options=t}},{key:"_isRunning",set:function(t){this.setAttribute("_is-running",t?"true":"false")},get:function(){return JSON.parse(this.getAttribute("_is-running"))}}],[{key:"registerAnimator",value:function(t,e){e.prototype instanceof xr||W.throwAnimator("Navigator"),Fr[t]=e}},{key:"observedAttributes",get:function(){return["animation","swipeable"]}},{key:"animators",get:function(){return Fr}},{key:"NavigatorAnimator",get:function(){return xr}},{key:"events",get:function(){return["prepush","postpush","prepop","postpop"]}},{key:"rewritables",get:function(){return qr}}]),e}();i.Navigator=Vr,customElements.define("ons-navigator",Vr);var Wr="toolbar",Ur={"":"toolbar--*",".toolbar__left":"toolbar--*__left",".toolbar__center":"toolbar--*__center",".toolbar__right":"toolbar--*__right"},Xr=function(t){function e(){h(this,e);var t=m(this,(e.__proto__||Object.getPrototypeOf(e)).call(this));return xt(t,function(){t._compile()}),t}return a(e,Zi),d(e,[{key:"attributeChangedCallback",value:function(t,e,n){switch(t){case"class":W.restoreClass(this,Wr,Ur);break;case"modifier":O.onModifierChanged(e,n,this,Ur)}}},{key:"setVisibility",value:function(n){var i=this;xt(this,function(){if(i.style.display=n?"":"none",i.parentNode){var t=W.findChild(i.parentNode,".page__background");t&&(t.style.top=n?null:0);var e=W.findChild(i.parentNode,".page__content");e&&(e.style.top=n?null:0)}})}},{key:"show",value:function(){this.setVisibility(!0)}},{key:"hide",value:function(){this.setVisibility(!1)}},{key:"_getToolbarLeftItemsElement",value:function(){return this.querySelector(".left")||b.nullElement}},{key:"_getToolbarCenterItemsElement",value:function(){return this.querySelector(".center")||b.nullElement}},{key:"_getToolbarRightItemsElement",value:function(){return this.querySelector(".right")||b.nullElement}},{key:"_getToolbarBackButtonLabelElement",value:function(){return this.querySelector("ons-back-button .back-button__label")||b.nullElement}},{key:"_getToolbarBackButtonIconElement",value:function(){return this.querySelector("ons-back-button .back-button__icon")||b.nullElement}},{key:"_compile",value:function(){P.prepare(this),this.classList.add(Wr),this._ensureToolbarItemElements(),O.initModifier(this,Ur)}},{key:"_ensureToolbarItemElements",value:function(){for(var t=this.childNodes.length-1;0<=t;t--)1!=this.childNodes[t].nodeType&&this.removeChild(this.childNodes[t]);var e=this._ensureToolbarElement("center");if(e.classList.add("toolbar__title"),1!==this.children.length||!this.children[0].classList.contains("center")){var n=this._ensureToolbarElement("left"),i=this._ensureToolbarElement("right");this.children[0]===n&&this.children[1]===e&&this.children[2]===i||(this.appendChild(n),this.appendChild(e),this.appendChild(i))}}},{key:"_ensureToolbarElement",value:function(t){if(W.findChild(this,".toolbar__"+t)){var e=W.findChild(this,".toolbar__"+t);return e.classList.add(t),e}var n=W.findChild(this,"."+t)||W.create("."+t);return n.classList.add("toolbar__"+t),n}}],[{key:"observedAttributes",get:function(){return["modifier","class"]}}]),e}();i.Toolbar=Xr,customElements.define("ons-toolbar",Xr);var Yr={"":"page--*",".page__content":"page--*__content",".page__background":"page--*__background"},Gr=function(t){function e(){h(this,e);var t=m(this,(e.__proto__||Object.getPrototypeOf(e)).call(this));return t._deriveHooks(),t._defaultClassName="page",t.classList.add("page"),t._initialized=!1,xt(t,function(){t._compile(),t._isShown=!1,t._contentElement=t._getContentElement(),t._backgroundElement=t._getBackgroundElement()}),t}return a(e,Zi),d(e,[{key:"_compile",value:function(){var e=this;P.prepare(this);var t=W.findChild(this,"ons-toolbar"),n=W.findChild(this,".page__background")||W.findChild(this,".background")||document.createElement("div");n.classList.add("page__background"),this.insertBefore(n,!t&&this.firstChild||t&&t.nextSibling);var i=W.findChild(this,".page__content")||W.findChild(this,".content")||document.createElement("div");i.classList.add("page__content"),i.parentElement||W.arrayFrom(this.childNodes).forEach(function(t){(1!==t.nodeType||e._elementShouldBeMoved(t))&&i.appendChild(t)}),this._tryToFillStatusBar(i),this.insertBefore(i,n.nextSibling),t&&W.hasModifier(t,"transparent")||1!==i.children.length||!W.isPageControl(i.children[0])||(this._defaultClassName+=" page--wrapper",this.attributeChangedCallback("class")),W.findChild(this,"ons-bottom-toolbar")&&(this._defaultClassName+=" page-with-bottom-toolbar",this.attributeChangedCallback("class")),O.initModifier(this,Yr)}},{key:"_elementShouldBeMoved",value:function(t){if(t.classList.contains("page__background"))return!1;var e=t.tagName.toLowerCase();if("ons-fab"===e)return!t.hasAttribute("position");return t.hasAttribute("inline")||-1===["script","ons-toolbar","ons-bottom-toolbar","ons-modal","ons-speed-dial","ons-dialog","ons-alert-dialog","ons-popover","ons-action-sheet"].indexOf(e)}},{key:"_tryToFillStatusBar",value:function(){var t=this,e=0<arguments.length&&void 0!==arguments[0]?arguments[0]:this._contentElement;b.autoStatusBarFill(function(){W.toggleAttribute(t,"status-bar-fill",!W.findParent(t,function(t){return t.hasAttribute("status-bar-fill")})&&(t._canAnimateToolbar(e)||!W.findChild(e,W.isPageControl)))})}},{key:"_canAnimateToolbar",value:function(){var t=0<arguments.length&&void 0!==arguments[0]?arguments[0]:this._contentElement;return!!W.findChild(this,"ons-toolbar")||!!W.findChild(t,function(t){return W.match(t,"ons-toolbar")&&!t.hasAttribute("inline")})}},{key:"connectedCallback",value:function(){var t=this;W.isAttached(this)&&xt(this,function(){t._tryToFillStatusBar(),t.hasAttribute("on-infinite-scroll")&&t.attributeChangedCallback("on-infinite-scroll",null,t.getAttribute("on-infinite-scroll")),t._initialized||(t._initialized=!0,setImmediate(function(){t.onInit&&t.onInit(),W.triggerElementEvent(t,"init")}),W.hasAnyComponentAsParent(t)||setImmediate(function(){return t._show()}))})}},{key:"updateBackButton",value:function(t){this.backButton&&(t?this.backButton.show():this.backButton.hide())}},{key:"_onScroll",value:function(){var t=this,e=this._contentElement,n=(e.scrollTop+e.clientHeight)/e.scrollHeight>=this._infiniteScrollLimit;this._onInfiniteScroll&&!this._loadingContent&&n&&(this._loadingContent=!0,this._onInfiniteScroll(function(){return t._loadingContent=!1}))}},{key:"_getContentElement",value:function(){var t=W.findChild(this,".page__content");if(t)return t;W.throw('Fail to get ".page__content" element')}},{key:"_getBackgroundElement",value:function(){var t=W.findChild(this,".page__background");if(t)return t;W.throw('Fail to get ".page__background" element')}},{key:"_getBottomToolbarElement",value:function(){return W.findChild(this,"ons-bottom-toolbar")||b.nullElement}},{key:"_getToolbarElement",value:function(){return W.findChild(this,"ons-toolbar")||document.createElement("ons-toolbar")}},{key:"attributeChangedCallback",value:function(t,e,n){var i=this;switch(t){case"class":W.restoreClass(this,this._defaultClassName,Yr);break;case"modifier":O.onModifierChanged(e,n,this,Yr);break;case"on-infinite-scroll":this.onInfiniteScroll=null===n?null:function(t){var e=W.findFromPath(n);(i.onInfiniteScroll=e)(t)}}}},{key:"_show",value:function(){!this._isShown&&W.isAttached(this)&&(this._isShown=!0,this.setAttribute("shown",""),this.onShow&&this.onShow(),W.triggerElementEvent(this,"show"),W.propagateAction(this,"_show"))}},{key:"_hide",value:function(){this._isShown&&(this._isShown=!1,this.removeAttribute("shown"),this.onHide&&this.onHide(),W.triggerElementEvent(this,"hide"),W.propagateAction(this,"_hide"))}},{key:"_destroy",value:function(){this._hide(),this.onDestroy&&this.onDestroy(),W.triggerElementEvent(this,"destroy"),this.onDeviceBackButton&&this.onDeviceBackButton.destroy(),W.propagateAction(this,"_destroy"),this.remove()}},{key:"_deriveHooks",value:function(){var n=this;this.constructor.events.forEach(function(t){var e="on"+t.charAt(0).toUpperCase()+t.slice(1);Object.defineProperty(n,e,{configurable:!0,enumerable:!0,get:function(){return n["_"+e]},set:function(t){t instanceof Function||W.throw('"'+e+'" hook must be a function'),n["_"+e]=t.bind(n)}})})}},{key:"name",set:function(t){this.setAttribute("name",t)},get:function(){return this.getAttribute("name")}},{key:"backButton",get:function(){return this.querySelector("ons-back-button")}},{key:"onInfiniteScroll",set:function(t){var e=this;!t||t instanceof Function||W.throw('"onInfiniteScroll" must be function or null'),xt(this,function(){t?e._onInfiniteScroll||(e._infiniteScrollLimit=.9,e._boundOnScroll=e._onScroll.bind(e),setImmediate(function(){return e._contentElement.addEventListener("scroll",e._boundOnScroll)})):e._contentElement.removeEventListener("scroll",e._boundOnScroll),e._onInfiniteScroll=t})},get:function(){return this._onInfiniteScroll}},{key:"onDeviceBackButton",get:function(){return this._backButtonHandler},set:function(t){this._backButtonHandler&&this._backButtonHandler.destroy(),this._backButtonHandler=M.createHandler(this,t)}},{key:"scrollTop",get:function(){return this._contentElement.scrollTop},set:function(t){this._contentElement.scrollTop=t}}],[{key:"observedAttributes",get:function(){return["modifier","on-infinite-scroll","class"]}},{key:"events",get:function(){return["init","show","hide","destroy"]}}]),e}();i.Page=Gr,customElements.define("ons-page",Gr);var $r=function(t){function s(){var t=0<arguments.length&&void 0!==arguments[0]?arguments[0]:{},e=t.timing,n=void 0===e?"cubic-bezier(.1, .7, .4, 1)":e,i=t.delay,o=void 0===i?0:i,r=t.duration,a=void 0===r?.2:r;return h(this,s),m(this,(s.__proto__||Object.getPrototypeOf(s)).call(this,{timing:n,delay:o,duration:a}))}return a(s,no),d(s,[{key:"show",value:function(t,e){e()}},{key:"hide",value:function(t,e){e()}},{key:"_animate",value:function(t,e){var n=e.from,i=e.to,o=e.options,r=e.callback,a=e.restore,s=void 0!==a&&a,l=e.animation;return o=W.extend({},this.options,o),l&&(n=l.from,i=l.to),l=it(t),s&&(l=l.saveStyle()),l=l.queue(n).wait(this.delay).queue({css:i,duration:this.duration,timing:this.timing}),s&&(l=l.restoreStyle()),r&&(l=l.queue(function(t){r(),t()})),l}},{key:"_animateAll",value:function(e,n){var i=this;Object.keys(n).forEach(function(t){return i._animate(e[t],n[t]).play()})}}]),s}(),Kr={out:{from:{opacity:1},to:{opacity:0}},in:{from:{opacity:0},to:{opacity:1}}},Qr=function(t){function e(){return h(this,e),m(this,(e.__proto__||Object.getPrototypeOf(e)).apply(this,arguments))}return a(e,$r),d(e,[{key:"show",value:function(t,e){this._animateAll(t,{_mask:Kr.in,_popover:{animation:Kr.in,restore:!0,callback:e}})}},{key:"hide",value:function(t,e){this._animateAll(t,{_mask:Kr.out,_popover:{animation:Kr.out,restore:!0,callback:e}})}}]),e}(),Jr=function(t){function e(){return h(this,e),m(this,(e.__proto__||Object.getPrototypeOf(e)).apply(this,arguments))}return a(e,Qr),d(e,[{key:"show",value:function(t,e){this._animateAll(t,{_mask:Kr.in,_popover:{from:{transform:"scale3d(1.3, 1.3, 1.0)",opacity:0},to:{transform:"scale3d(1.0, 1.0,  1.0)",opacity:1},restore:!0,callback:e}})}}]),e}(),Zr={".popover":"popover--*",".popover-mask":"popover-mask--*",".popover__content":"popover--*__content",".popover__arrow":"popover--*__arrow"},ta={default:function(){return c.isAndroid()?Qr:Jr},none:$r,"fade-ios":Jr,"fade-md":Qr},ea={up:"bottom",left:"right",down:"top",right:"left"},na=function(t){function i(){h(this,i);var t=m(this,(i.__proto__||Object.getPrototypeOf(i)).call(this));return t._boundOnChange=t._onChange.bind(t),xt(t,function(){t._compile(),t.style.display="none"}),t}return a(i,so),d(i,[{key:"_updateAnimatorFactory",value:function(){return new y({animators:ta,baseClass:$r,baseClassName:"PopoverAnimator",defaultAnimation:this.getAttribute("animation")||"default"})}},{key:"_toggleStyle",value:function(t){var e=1<arguments.length&&void 0!==arguments[1]?arguments[1]:{};t?(this.style.display="block",this._currentTarget=e.target,this._positionPopover(e.target)):(this.style.display="none",this._clearStyles())}},{key:"_positionPopover",value:function(t){var e=this._radius,n=this._content,i=this._margin,o=io.getSafeAreaLengths(),r=io.getSafeAreaDOMRect(),a=t.getBoundingClientRect(),s=W.hasModifier(this,"material"),l=s&&this.hasAttribute("cover-target"),u=(W.findParent(this,"ons-page")||document.body).getBoundingClientRect(),c=Math.max(u.top,r.top),h=Math.max(u.left,r.left),d=Math.min(u.bottom,r.bottom),f=Math.min(u.right,r.right),p={top:a.top-(c+i),left:a.left-(h+i),bottom:d-i-a.bottom,right:f-i-a.right},g={top:a.top+Math.round(a.height/2)-(c+i),left:a.left+Math.round(a.width/2)-(h+i),bottom:d-i-a.bottom+Math.round(a.height/2),right:f-i-a.right+Math.round(a.width/2)},m=this._calculateDirections(p),_=m.vertical,v=m.primary,b=m.secondary;this._currentDirection=v,W.addModifier(this,v);var y,k=_?"width":"height",w=(y=window.getComputedStyle(n),{width:parseInt(y.getPropertyValue("width"),10),height:parseInt(y.getPropertyValue("height"),10)}),E=l?0:(_?a.height:a.width)+(s?0:14),C=Math.max(o[v]+i,o[v]+i+p[v]+E),A=Math.max(o[b]+i,o[b]+i+g[b]-w[k]/2);this._popover.style[v]=C+"px",this._popover.style[b]=A+"px",this._arrow.style[b]=Math.max(e,o[b]+i+g[b]-A)+"px"}},{key:"_calculateDirections",value:function(n){var t=(this.getAttribute("direction")||"up down left right").split(/\s+/).map(function(t){return ea[t]}).sort(function(t,e){return n[t]-n[e]})[0],e="top"==t||"bottom"==t;return{vertical:e,primary:t,secondary:e?n.left<n.right?"left":"right":n.top<n.bottom?"top":"bottom"}}},{key:"_clearStyles",value:function(){var e=this;this._currentDirection=null,["top","bottom","left","right"].forEach(function(t){e._arrow.style[t]=e._content.style[t]=e._popover.style[t]="",W.removeModifier(e,t)})}},{key:"_onChange",value:function(){var t=this;setImmediate(function(){t._currentTarget&&t._positionPopover(t._currentTarget)})}},{key:"_compile",value:function(){if(P.prepare(this),!this._popover||!this._mask){if(this._popover&&this._content){if(!this._mask){var t=document.createElement("div");t.classList.add("popover-mask"),this.insertBefore(t,this.firstChild)}if(!this._arrow){var e=document.createElement("div");e.classList.add("popover__arrow"),this._popover.appendChild(e)}}else{for(var n=W.createFragment('\n        <div class="popover-mask"></div>\n        <div class="popover">\n          <div class="popover__content"></div>\n          <div class="popover__arrow"></div>\n        </div>\n      '),i=n.querySelector(".popover__content");this.childNodes[0];)i.appendChild(this.childNodes[0]);this.appendChild(n)}this.hasAttribute("style")&&(this._popover.setAttribute("style",this.getAttribute("style")),this.removeAttribute("style")),O.initModifier(this,this._scheme)}}},{key:"show",value:function(t){var e=1<arguments.length&&void 0!==arguments[1]?arguments[1]:{};return"string"==typeof(e=!t||"object"!==(void 0===t?"undefined":u(t))||t instanceof Event||t instanceof HTMLElement?f({},e,{target:t}):f({},t)).target?e.target=document.querySelector(e.target):e.target instanceof Event&&(e.target=e.target.target),e.target instanceof HTMLElement||W.throw("Invalid target type or undefined"),p(i.prototype.__proto__||Object.getPrototypeOf(i.prototype),"show",this).call(this,e)}},{key:"connectedCallback",value:function(){var t=this;p(i.prototype.__proto__||Object.getPrototypeOf(i.prototype),"connectedCallback",this).call(this),window.addEventListener("resize",this._boundOnChange,!1),this._margin=this._margin||parseInt(window.getComputedStyle(this).getPropertyValue("top")),this._margin=this._margin||6,xt(this,function(){t._radius=parseInt(window.getComputedStyle(t._content).getPropertyValue("border-top-left-radius"))})}},{key:"disconnectedCallback",value:function(){p(i.prototype.__proto__||Object.getPrototypeOf(i.prototype),"disconnectedCallback",this).call(this),window.removeEventListener("resize",this._boundOnChange,!1)}},{key:"attributeChangedCallback",value:function(t,e,n){if("direction"===t)return this._boundOnChange();"modifier"===t&&this._currentDirection&&W.addModifier(this,this._currentDirection),p(i.prototype.__proto__||Object.getPrototypeOf(i.prototype),"attributeChangedCallback",this).call(this,t,e,n)}},{key:"_scheme",get:function(){return Zr}},{key:"_mask",get:function(){return W.findChild(this,".popover-mask")}},{key:"_popover",get:function(){return W.findChild(this,".popover")}},{key:"_content",get:function(){return W.findChild(this._popover,".popover__content")}},{key:"_arrow",get:function(){return W.findChild(this._popover,".popover__arrow")}}],[{key:"registerAnimator",value:function(t,e){e.prototype instanceof $r||W.throwAnimator("Popover"),ta[t]=e}},{key:"observedAttributes",get:function(){return[].concat(_(p(i.__proto__||Object.getPrototypeOf(i),"observedAttributes",this)),["direction"])}},{key:"animators",get:function(){return ta}},{key:"PopoverAnimator",get:function(){return $r}}]),i}();i.Popover=na,customElements.define("ons-popover",na);var ia={".progress-bar":"progress-bar--*",".progress-bar__primary":"progress-bar--*__primary",".progress-bar__secondary":"progress-bar--*__secondary"},oa=W.createElement('\n  <div class="progress-bar">\n    <div class="progress-bar__secondary"></div>\n    <div class="progress-bar__primary"></div>\n  </div>\n'),ra="indeterminate",aa=function(t){function e(){h(this,e);var t=m(this,(e.__proto__||Object.getPrototypeOf(e)).call(this));return xt(t,function(){return t._compile()}),t}return a(e,Zi),d(e,[{key:"_compile",value:function(){this._isCompiled()?this._template=W.findChild(this,".progress-bar"):this._template=oa.cloneNode(!0),this._primary=W.findChild(this._template,".progress-bar__primary"),this._secondary=W.findChild(this._template,".progress-bar__secondary"),this._updateDeterminate(),this._updateValue(),this.appendChild(this._template),P.prepare(this),O.initModifier(this,ia)}},{key:"_isCompiled",value:function(){if(!W.findChild(this,".progress-bar"))return!1;var t=W.findChild(this,".progress-bar");return!!W.findChild(t,".progress-bar__secondary")&&!!W.findChild(t,".progress-bar__primary")}},{key:"attributeChangedCallback",value:function(t,e,n){"modifier"===t?(O.onModifierChanged(e,n,this,ia),this.hasAttribute(ra)&&this._updateDeterminate()):"value"===t||"secondary-value"===t?this._updateValue():t===ra&&this._updateDeterminate()}},{key:"_updateDeterminate",value:function(){var t=this;xt(this,function(){return W.toggleModifier(t,ra,{force:t.hasAttribute(ra)})})}},{key:"_updateValue",value:function(){var t=this;xt(this,function(){t._primary.style.width=t.hasAttribute("value")?t.getAttribute("value")+"%":"0%",t._secondary.style.width=t.hasAttribute("secondary-value")?t.getAttribute("secondary-value")+"%":"0%"})}},{key:"value",set:function(t){("number"!=typeof t||t<0||100<t)&&W.throw("Invalid value"),this.setAttribute("value",Math.floor(t))},get:function(){return parseInt(this.getAttribute("value")||"0")}},{key:"secondaryValue",set:function(t){("number"!=typeof t||t<0||100<t)&&W.throw("Invalid value"),this.setAttribute("secondary-value",Math.floor(t))},get:function(){return parseInt(this.getAttribute("secondary-value")||"0")}},{key:"indeterminate",set:function(t){t?this.setAttribute(ra,""):this.removeAttribute(ra)},get:function(){return this.hasAttribute(ra)}}],[{key:"observedAttributes",get:function(){return["modifier","value","secondary-value",ra]}}]),e}();i.ProgressBar=aa,customElements.define("ons-progress-bar",aa);var sa={".progress-circular":"progress-circular--*",".progress-circular__background":"progress-circular--*__background",".progress-circular__primary":"progress-circular--*__primary",".progress-circular__secondary":"progress-circular--*__secondary"},la=W.createElement('\n  <svg class="progress-circular">\n    <circle class="progress-circular__background" />\n    <circle class="progress-circular__secondary" cx="50%" cy="50%" r="40%" />\n    <circle class="progress-circular__primary" cx="50%" cy="50%" r="40%" />\n  </svg>\n'),ua="indeterminate",ca=function(t){function e(){h(this,e);var t=m(this,(e.__proto__||Object.getPrototypeOf(e)).call(this));return xt(t,function(){return t._compile()}),t}return a(e,Zi),d(e,[{key:"attributeChangedCallback",value:function(t,e,n){"modifier"===t?(O.onModifierChanged(e,n,this,sa),this.hasAttribute(ua)&&this._updateDeterminate()):"value"===t||"secondary-value"===t?this._updateValue():t===ua&&this._updateDeterminate()}},{key:"_updateDeterminate",value:function(){var t=this;xt(this,function(){return W.toggleModifier(t,ua,{force:t.hasAttribute(ua)})})}},{key:"_updateValue",value:function(){var e=this;this.hasAttribute("value")&&xt(this,function(){var t=Math.ceil(251.32*e.getAttribute("value")*.01);e._primary.style["stroke-dasharray"]=t+"%, 251.32%"}),this.hasAttribute("secondary-value")?xt(this,function(){var t=Math.ceil(251.32*e.getAttribute("secondary-value")*.01);e._secondary.style.display=null,e._secondary.style["stroke-dasharray"]=t+"%, 251.32%"}):xt(this,function(){e._secondary.style.display="none"})}},{key:"_compile",value:function(){this._isCompiled()?this._template=W.findChild(this,".progress-circular"):this._template=la.cloneNode(!0),this._primary=W.findChild(this._template,".progress-circular__primary"),this._secondary=W.findChild(this._template,".progress-circular__secondary"),this._updateDeterminate(),this._updateValue(),this.appendChild(this._template),P.prepare(this),O.initModifier(this,sa)}},{key:"_isCompiled",value:function(){if(!W.findChild(this,".progress-circular"))return!1;var t=W.findChild(this,".progress-circular");return!!W.findChild(t,".progress-circular__secondary")&&!!W.findChild(t,".progress-circular__primary")}},{key:"value",set:function(t){("number"!=typeof t||t<0||100<t)&&W.throw("Invalid value"),this.setAttribute("value",Math.floor(t))},get:function(){return parseInt(this.getAttribute("value")||"0")}},{key:"secondaryValue",set:function(t){("number"!=typeof t||t<0||100<t)&&W.throw("Invalid value"),this.setAttribute("secondary-value",Math.floor(t))},get:function(){return parseInt(this.getAttribute("secondary-value")||"0")}},{key:"indeterminate",set:function(t){t?this.setAttribute(ua,""):this.removeAttribute(ua)},get:function(){return this.hasAttribute(ua)}}],[{key:"observedAttributes",get:function(){return["modifier","value","secondary-value",ua]}}]),e}();i.ProgressCircular=ca,customElements.define("ons-progress-circular",ca);var ha="initial",da=function(t,e){return W.throw('"'+t+'" must be '+e)},fa=function(t){function e(){h(this,e);var t=m(this,(e.__proto__||Object.getPrototypeOf(e)).call(this));return t._shouldFixScroll=W.globals.isUIWebView,t._onDrag=t._onDrag.bind(t),t._onDragStart=t._onDragStart.bind(t),t._onDragEnd=t._onDragEnd.bind(t),t._onScroll=t._onScroll.bind(t),t._setState(ha,!0),t._hide(),t}return a(e,Zi),d(e,[{key:"_setStyle",value:function(){var t=this.height+"px";l(this,{height:t,lineHeight:t}),""===this.style.display&&this._show()}},{key:"_onScroll",value:function(t){var e=this._pageElement;e.scrollTop<0&&(e.scrollTop=0)}},{key:"_canConsumeGesture",value:function(t){return"up"===t.direction||"down"===t.direction}},{key:"_onDragStart",value:function(t){var e=this;if(t.gesture&&!this.disabled){var n=t.gesture.center.clientY+this._pageElement.scrollTop,i=window.innerHeight,o=this._shouldFixScroll?.8:1;if(this._ignoreDrag=t.consumed||i*o<n,!this._ignoreDrag){var r=t.consume;t.consume=function(){r&&r(),e._ignoreDrag=!0,e._hide()},this._canConsumeGesture(t.gesture)&&(r&&r(),t.consumed=!0,this._show())}this._startScroll=this._pageElement.scrollTop}}},{key:"_onDrag",value:function(t){var e=this;if(t.gesture&&!this.disabled&&!this._ignoreDrag&&this._canConsumeGesture(t.gesture)){"none"===this.style.display&&this._show(),t.stopPropagation();var n=t.gesture.center.clientY+this._pageElement.scrollTop,i=window.innerHeight;this._shouldFixScroll&&(this._pageElement.scrollTop=this._startScroll-t.gesture.deltaY,("up"!==t.gesture.interimDirection||n<=.5*i)&&t.gesture.preventDefault());var o=Math.max(t.gesture.deltaY-this._startScroll,0);if(o!==this._currentTranslation){var r=this.thresholdHeight;0<r&&r<=o?(t.gesture.stopDetect(),setImmediate(function(){return e._finish()})):o>=this.height?this._setState("preaction"):this._setState(ha),this._translateTo(o)}}}},{key:"_onDragEnd",value:function(t){!t.gesture||this.disabled||this._ignoreDrag||(t.stopPropagation(),0<this._currentTranslation&&(this._currentTranslation>this.height?this._finish():this._translateTo(0,{animate:!0})))}},{key:"_finish",value:function(){var t=this;this._setState("action"),this._translateTo(this.height,{animate:!0}),(this.onAction||function(t){return t()})(function(){t._translateTo(0,{animate:!0}),t._setState(ha)})}},{key:"_setState",value:function(t,e){var n=this.state;this.setAttribute("state",t),e||n===this.state||W.triggerElementEvent(this,"changestate",{pullHook:this,state:t,lastState:n})}},{key:"_show",value:function(){var t=this;setImmediate(function(){t.style.display="",t._pageElement&&(t._pageElement.style.marginTop="-"+t.height+"px")})}},{key:"_hide",value:function(){this.style.display="none",this._pageElement&&(this._pageElement.style.marginTop="")}},{key:"_translateTo",value:function(t){var e=1<arguments.length&&void 0!==arguments[1]?arguments[1]:{};if(0!=this._currentTranslation||0!=t){this._currentTranslation=t;var n=e.animate?{duration:.3,timing:"cubic-bezier(.1, .7, .1, 1)"}:{};this._onPull&&this._onPull((t/this.height).toFixed(2),n);var i=this.hasAttribute("fixed-content")?this:this._pageElement;it(i).queue({transform:"translate3d(0px, "+t+"px, 0px)"},n).play(function(){0===t&&l.clear(i,"transition transform"),e.callback instanceof Function&&e.callback()})}}},{key:"_disableDragLock",value:function(){this._dragLockDisabled=!0,this._setupListeners(!0)}},{key:"_setupListeners",value:function(t){var n=this,e=function(t){return n._pageElement[t+"EventListener"]("scroll",n._onScroll,!1)},i=function(t){var e={passive:!0};n._gestureDetector[t]("drag",n._onDrag,e),n._gestureDetector[t]("dragstart",n._onDragStart,e),n._gestureDetector[t]("dragend",n._onDragEnd,e)};this._gestureDetector&&(i("off"),this._gestureDetector.dispose(),this._gestureDetector=null),e("remove"),t&&(this._gestureDetector=new ot(this._pageElement,{dragMinDistance:1,dragDistanceCorrection:!1,dragLockToAxis:!this._dragLockDisabled,passive:!this._shouldFixScroll}),i("on"),e("add"))}},{key:"connectedCallback",value:function(){this._currentTranslation=0,this._pageElement=this.parentNode,this._setupListeners(!0),this._setStyle()}},{key:"disconnectedCallback",value:function(){this._hide(),this._setupListeners(!1)}},{key:"attributeChangedCallback",value:function(t,e,n){"height"===t&&this._pageElement&&this._setStyle()}},{key:"onAction",get:function(){return this._onAction},set:function(t){!t||t instanceof Function||da("onAction","function or null"),this._onAction=t}},{key:"onPull",get:function(){return this._onPull},set:function(t){!t||t instanceof Function||da("onPull","function or null"),this._onPull=t}},{key:"height",set:function(t){W.isInteger(t)||da("height","integer"),this.setAttribute("height",t+"px")},get:function(){return parseInt(this.getAttribute("height")||"64",10)}},{key:"thresholdHeight",set:function(t){W.isInteger(t)||da("thresholdHeight","integer"),this.setAttribute("threshold-height",t+"px")},get:function(){return parseInt(this.getAttribute("threshold-height")||"96",10)}},{key:"state",get:function(){return this.getAttribute("state")}},{key:"pullDistance",get:function(){return this._currentTranslation}},{key:"disabled",set:function(t){return W.toggleAttribute(this,"disabled",t)},get:function(){return this.hasAttribute("disabled")}}],[{key:"observedAttributes",get:function(){return["height"]}},{key:"events",get:function(){return["changestate"]}}]),e}();i.PullHook=fa,customElements.define("ons-pull-hook",fa);var pa={"":"range--*",".range__input":"range--*__input",".range__focus-ring":"range--*__focus-ring"},ga="range__input--active",ma=function(t){function i(){h(this,i);var t=m(this,(i.__proto__||Object.getPrototypeOf(i)).call(this));return t._onMouseDown=t._onMouseDown.bind(t),t._onMouseUp=t._onMouseUp.bind(t),t._onTouchStart=t._onTouchStart.bind(t),t._onTouchEnd=t._onTouchEnd.bind(t),t._onInput=t._update.bind(t),t._onDragstart=t._onDragstart.bind(t),t._onDragend=t._onDragend.bind(t),t}return a(i,dr),d(i,[{key:"_compile",value:function(){p(i.prototype.__proto__||Object.getPrototypeOf(i.prototype),"_compile",this).call(this),this._updateDisabled(this.hasAttribute("disabled"))}},{key:"_update",value:function(){var e=this._input,n=this._focusRing;e.style.backgroundSize=100*this._ratio+"% 2px",n.value=this.value,""===e.min&&"0"===e.value||e.min===e.value?e.setAttribute("_zero",""):e.removeAttribute("_zero"),["min","max"].forEach(function(t){return n[t]=e[t]})}},{key:"_onMouseDown",value:function(t){var e=this;this._input.classList.add(ga),setImmediate(function(){return e._input.focus()})}},{key:"_onTouchStart",value:function(t){this._onMouseDown()}},{key:"_onMouseUp",value:function(t){this._input.classList.remove(ga)}},{key:"_onTouchEnd",value:function(t){this._onMouseUp(t)}},{key:"_onDragstart",value:function(t){t.consumed=!0,t.gesture.stopPropagation(),this._input.classList.add(ga),this.addEventListener("drag",this._onDrag)}},{key:"_onDrag",value:function(t){t.stopPropagation()}},{key:"_onDragend",value:function(t){this._input.classList.remove(ga),this.removeEventListener("drag",this._onDrag)}},{key:"attributeChangedCallback",value:function(t,e,n){"disabled"===t&&this._updateDisabled(n),p(i.prototype.__proto__||Object.getPrototypeOf(i.prototype),"attributeChangedCallback",this).call(this,t,e,n)}},{key:"_updateDisabled",value:function(t){t?this.classList.add("range--disabled"):this.classList.remove("range--disabled")}},{key:"connectedCallback",value:function(){this._setupListeners(!0)}},{key:"disconnectedCallback",value:function(){this._setupListeners(!1)}},{key:"_setupListeners",value:function(t){var e=(t?"add":"remove")+"EventListener";W[e](this,"touchstart",this._onTouchStart,{passive:!0}),this[e]("mousedown",this._onMouseDown),this[e]("mouseup",this._onMouseUp),this[e]("touchend",this._onTouchEnd),this[e]("dragstart",this._onDragstart),this[e]("dragend",this._onDragend),this[e]("input",this._onInput)}},{key:"_scheme",get:function(){return pa}},{key:"_template",get:function(){return'\n      <input type="'+this.type+'" class="'+this._defaultClassName+'__input">\n      <input type="range" class="range__focus-ring" tabIndex="-1">\n    '}},{key:"_defaultClassName",get:function(){return"range"}},{key:"type",get:function(){return"range"}},{key:"_focusRing",get:function(){return this.children[1]}},{key:"_ratio",get:function(){var t=""===this._input.min?0:parseInt(this._input.min),e=""===this._input.max?100:parseInt(this._input.max);return(this.value-t)/(e-t)}}],[{key:"observedAttributes",get:function(){return["disabled"].concat(_(dr.observedAttributes))}}]),i}();i.Range=ma,customElements.define("ons-range",ma);var _a=function(){function t(){h(this,t),this._queue=[],this._index=0}return d(t,[{key:"animate",value:function(i,o){var r=2<arguments.length&&void 0!==arguments[2]?arguments[2]:200,a=(new Date).getTime(),s={},l=!1,n=!1,u=!1,c=Object.keys(o),h={stop:function(){var t=0<arguments.length&&void 0!==arguments[0]?arguments[0]:{};u&&clearTimeout(u);var e=Math.min(1,((new Date).getTime()-a)/r);return c.forEach(function(t){i.style[t]=(1-e)*s[t]+e*o[t]+("opacity"==t?"":"px")}),i.style.transitionDuration="0s",t.stopNext?n=!1:l||(l=!0,n&&n()),h},then:function(t){return n=t,l&&n&&n(),h},speed:function(t){if(b.config.animationsDisabled&&(t=0),!l){u&&clearTimeout(u);var e=((new Date).getTime()-a)/r,n=t*(1-e);c.forEach(function(t){i.style[t]=(1-e)*s[t]+e*o[t]+("opacity"==t?"":"px")}),function(){var t=window.getComputedStyle(i);c.forEach(t.getPropertyValue.bind(t)),t=i.offsetHeight}(),a=i.speedUpTime,r=n,i.style.transitionDuration=r/1e3+"s",c.forEach(function(t){i.style[t]=o[t]+("opacity"==t?"":"px")}),u=setTimeout(h.stop,n)}return h},finish:function(){var t=0<arguments.length&&void 0!==arguments[0]?arguments[0]:50,e=((new Date).getTime()-a)/r;return h.speed(t/(1-e)),h}};if(i.hasAttribute("disabled")||l||b.config.animationsDisabled)return h;var d=window.getComputedStyle(i);return c.forEach(function(t){var e=parseFloat(d.getPropertyValue(t));s[t]=isNaN(e)?0:e}),l||(i.style.transitionProperty=c.join(","),i.style.transitionDuration=r/1e3+"s",c.forEach(function(t){i.style[t]=o[t]+("opacity"==t?"":"px")})),u=setTimeout(h.stop,r),this._onStopAnimations(i,h.stop),h}}]),d(t,[{key:"_onStopAnimations",value:function(e,n){var i=this._queue,o=this._index++;i[e]=i[e]||[],i[e][o]=function(t){return delete i[e][o],i[e]&&0==i[e].length&&delete i[e],n(t)}}},{key:"stopAnimations",value:function(t){var e=this,n=1<arguments.length&&void 0!==arguments[1]?arguments[1]:{};if(Array.isArray(t))return t.forEach(function(t){e.stopAnimations(t,n)});(this._queue[t]||[]).forEach(function(t){t(n||{})})}},{key:"stopAll",value:function(){var t=0<arguments.length&&void 0!==arguments[0]?arguments[0]:{};this.stopAnimations(Object.keys(this._queue),t)}},{key:"fade",value:function(t){var e=1<arguments.length&&void 0!==arguments[1]?arguments[1]:200;return this.animate(t,{opacity:0},e)}}]),t}(),va={"":"ripple--*",".ripple__wave":"ripple--*__wave",".ripple__background":"ripple--*__background"},ba=function(t){function n(){h(this,n);var e=m(this,(n.__proto__||Object.getPrototypeOf(n)).call(this));return e._onTap=e._onTap.bind(e),e._onHold=e._onHold.bind(e),e._onDragStart=e._onDragStart.bind(e),e._onRelease=e._onRelease.bind(e),xt(e,function(){return e._compile()}),e._animator=new _a,["color","center","start-radius","background","modifier"].forEach(function(t){e.attributeChangedCallback(t,null,e.getAttribute(t))}),e}return a(n,Zi),d(n,[{key:"_compile",value:function(){this.classList.add("ripple"),this._wave=this.getElementsByClassName("ripple__wave")[0],this._background=this.getElementsByClassName("ripple__background")[0],this._background&&this._wave||(this._wave=W.create(".ripple__wave"),this._background=W.create(".ripple__background"),this.appendChild(this._wave),this.appendChild(this._background)),O.initModifier(this,va)}},{key:"_getEffectSize",value:function(){if(this.hasAttribute("size")){var t=this.getAttribute("size");if(-1!==["cover","contain"].indexOf(t))return t}return"cover"}},{key:"_calculateCoords",value:function(t){var e=void 0,n=void 0,i=void 0,o=void 0,r=void 0,a=this.getBoundingClientRect(),s=this._getEffectSize(),l=function(){return W.throw("Ripple invalid state")};return this._center?(e=a.width/2,n=a.height/2,"cover"===s?r=Math.sqrt(e*e+n*n):"contain"===s?r=Math.min(e,n):l()):(e=("number"==typeof t.clientX?t.clientX:t.changedTouches[0].clientX)-a.left,n=("number"==typeof t.clientY?t.clientY:t.changedTouches[0].clientY)-a.top,i=Math.max(n,a.height-n),o=Math.max(e,a.width-e),"cover"===s?r=Math.sqrt(i*i+o*o):"contain"===s?r=Math.min(Math.round(i/2),Math.round(o/2)):l()),{x:e,y:n,r:r}}},{key:"_rippleAnimation",value:function(t){var e=1<arguments.length&&void 0!==arguments[1]?arguments[1]:300,n=this._animator,i=this._wave,o=this._background,r=this._minR,a=this._calculateCoords(t),s=a.x,l=a.y,u=a.r;return n.stopAll({stopNext:1}),n.animate(o,{opacity:1},e),W.extend(i.style,{opacity:1,top:l-r+"px",left:s-r+"px",width:2*r+"px",height:2*r+"px"}),n.animate(i,{top:l-u,left:s-u,height:2*u,width:2*u},e)}},{key:"_updateParent",value:function(){!this._parentUpdated&&this.parentNode&&("static"===window.getComputedStyle(this.parentNode).getPropertyValue("position")&&(this.parentNode.style.position="relative"),this._parentUpdated=!0)}},{key:"_onTap",value:function(t){var e=this;this.disabled||t.ripple||(t.ripple=!0,this._updateParent(),this._rippleAnimation(t.gesture.srcEvent).then(function(){e._animator.fade(e._wave),e._animator.fade(e._background)}))}},{key:"_onHold",value:function(t){this.disabled||t.ripple||(t.ripple=!0,this._updateParent(),this._holding=this._rippleAnimation(t.gesture.srcEvent,2e3),document.addEventListener("release",this._onRelease))}},{key:"_onRelease",value:function(t){var e=this;this._holding&&!t.ripple&&(t.ripple=!0,this._holding.speed(300).then(function(){e._animator.stopAll({stopNext:!0}),e._animator.fade(e._wave),e._animator.fade(e._background)}),this._holding=!1),document.removeEventListener("release",this._onRelease)}},{key:"_onDragStart",value:function(t){if(this._holding)return this._onRelease(t);-1!=["left","right"].indexOf(t.gesture.direction)&&this._onTap(t)}},{key:"connectedCallback",value:function(){this._parentNode=this.parentNode,b.config.animationsDisabled?this.disabled=!0:(this._parentNode.addEventListener("tap",this._onTap),this._parentNode.addEventListener("hold",this._onHold),this._parentNode.addEventListener("dragstart",this._onDragStart))}},{key:"disconnectedCallback",value:function(){var t=this._parentNode||this.parentNode;t.removeEventListener("tap",this._onTap),t.removeEventListener("hold",this._onHold),t.removeEventListener("dragstart",this._onDragStart)}},{key:"attributeChangedCallback",value:function(t,e,n){var i=this;switch(t){case"class":W.restoreClass(this,"ripple",va);break;case"modifier":O.onModifierChanged(e,n,this,va);break;case"start-radius":this._minR=Math.max(0,parseFloat(n)||0);break;case"color":n&&xt(this,function(){i._wave.style.background=n,i.hasAttribute("background")||(i._background.style.background=n)});break;case"background":(n||e)&&xt(this,"none"===n?function(){i._background.setAttribute("disabled","disabled"),i._background.style.background="transparent"}:function(){i._background.hasAttribute("disabled")&&i._background.removeAttribute("disabled"),i._background.style.background=n});break;case"center":"center"===t&&(this._center=null!=n&&"false"!=n)}}},{key:"disabled",set:function(t){return W.toggleAttribute(this,"disabled",t)},get:function(){return this.hasAttribute("disabled")}}],[{key:"observedAttributes",get:function(){return["start-radius","color","background","center","class","modifier"]}}]),n}();i.Ripple=ba,customElements.define("ons-ripple",ba);var ya=function(t){function e(){return h(this,e),m(this,(e.__proto__||Object.getPrototypeOf(e)).apply(this,arguments))}return a(e,Zi),e}();i.Row=ya,customElements.define("ons-row",ya);var ka,wa="segment",Ea={"":"segment--*",".segment__item":"segment--*__item",".segment__input":"segment--*__input",".segment__button":"segment--*__button"},Ca=(ka=0,function(){return"ons-segment-gen-"+ka++}),Aa=function(t){function e(){h(this,e);var t=m(this,(e.__proto__||Object.getPrototypeOf(e)).call(this));return t._segmentId=Ca(),t._tabbar=null,t._onChange=t._onChange.bind(t),t._onTabbarPreChange=t._onTabbarPreChange.bind(t),xt(t,function(){t._compile(),setImmediate(function(){return t._lastActiveIndex=t._tabbar?t._tabbar.getActiveTabIndex():t.getActiveButtonIndex()})}),t}return a(e,Zi),d(e,[{key:"_compile",value:function(){P.prepare(this),this.classList.add(wa);for(var t=this.children.length-1;0<=t;t--){var e=this.children[t];e.classList.add("segment__item");var n=W.findChild(e,".segment__input")||W.create("input.segment__input");n.type="radio",n.value=t,n.name=n.name||this._segmentId,n.checked=!this.hasAttribute("tabbar-id")&&t===(parseInt(this.getAttribute("active-index"))||0);var i=W.findChild(e,".segment__button")||W.create(".segment__button");if(i.parentElement!==e)for(;e.firstChild;)i.appendChild(e.firstChild);e.appendChild(n),e.appendChild(i)}O.initModifier(this,Ea)}},{key:"connectedCallback",value:function(){var e=this;xt(this,function(){if(e.hasAttribute("tabbar-id")){var t=W.findParent(e,"ons-page");e._tabbar=t&&t.querySelector("#"+e.getAttribute("tabbar-id")),e._tabbar&&"ONS-TABBAR"===e._tabbar.tagName||W.throw("No tabbar with id "+e.getAttribute("tabbar-id")+" was found."),e._tabbar.setAttribute("hide-tabs",""),setImmediate(function(){return e._setChecked(e._tabbar.getActiveTabIndex())}),e._tabbar.addEventListener("prechange",e._onTabbarPreChange)}}),this.addEventListener("change",this._onChange)}},{key:"disconnectedCallback",value:function(){var t=this;xt(this,function(){t._tabbar&&(t._tabbar.removeEventListener("prechange",t._onTabbarPreChange),t._tabbar=null)}),this.removeEventListener("change",this._onChange)}},{key:"_setChecked",value:function(t){this.children[t].firstElementChild.checked=!0}},{key:"setActiveButton",value:function(t,e){return this._tabbar?this._tabbar.setActiveTab(t,e):(this._setChecked(t),this._postChange(t),Promise.resolve(t))}},{key:"getActiveButtonIndex",value:function(){for(var t=this.children.length-1;0<=t;t--)if(this.children[t].firstElementChild.checked)return t;return-1}},{key:"_onChange",value:function(t){t.stopPropagation(),this._tabbar?this._tabbar.setActiveTab(this.getActiveButtonIndex(),{reject:!1}):this._postChange(this.getActiveButtonIndex())}},{key:"_onTabbarPreChange",value:function(t){var e=this;setImmediate(function(){t.detail.canceled||(e._setChecked(t.index),e._postChange(t.index))})}},{key:"_postChange",value:function(t){W.triggerElementEvent(this,"postchange",{index:t,activeIndex:t,lastActiveIndex:this._lastActiveIndex,segmentItem:this.children[t]}),this._lastActiveIndex=t}},{key:"attributeChangedCallback",value:function(t,e,n){switch(t){case"class":W.restoreClass(this,wa,Ea);break;case"modifier":O.onModifierChanged(e,n,this,Ea)}}},{key:"disabled",set:function(t){return W.toggleAttribute(this,"disabled",t)},get:function(){return this.hasAttribute("disabled")}}],[{key:"observedAttributes",get:function(){return["class","modifier"]}},{key:"events",get:function(){return["postchange"]}}]),e}();i.Segment=Aa,customElements.define("ons-segment",Aa);var Sa={"":"select-* select--*",".select-input":"select-input--*"},Pa=["autofocus","disabled","form","multiple","name","required","size"],Oa=function(t){function e(){h(this,e);var t=m(this,(e.__proto__||Object.getPrototypeOf(e)).call(this));return xt(t,function(){return t._compile()}),t._deriveGetters(),t}return a(e,Zi),d(e,[{key:"attributeChangedCallback",value:function(t,e,n){var i=this;switch(t){case"class":W.restoreClass(this,"select",Sa);break;case"modifier":O.onModifierChanged(e,n,this,Sa)}0<=Pa.indexOf(t)&&xt(this,function(){return i._updateBoundAttributes()})}},{key:"_updateBoundAttributes",value:function(){var e=this;Pa.forEach(function(t){e.hasAttribute(t)?e._select.setAttribute(t,e.getAttribute(t)):e._select.removeAttribute(t)})}},{key:"_compile",value:function(){P.prepare(this),this.classList.add("select");var e=this._select||document.createElement("select");!e.id&&this.hasAttribute("select-id")&&(e.id=this.getAttribute("select-id")),e.classList.add("select-input"),this._select||(W.arrayFrom(this.childNodes).forEach(function(t){return e.appendChild(t)}),this.appendChild(e)),O.initModifier(this,Sa)}},{key:"_deriveGetters",value:function(){var n=this;["disabled","length","multiple","name","options","selectedIndex","size","value","form","type"].forEach(function(e){Object.defineProperty(n,e,{configurable:!0,enumerable:!0,get:function(){return n._select[e]},set:-1===["form","type"].indexOf(e)?function(t){return xt(n,function(){return n._select[e]=t})}:void 0})})}},{key:"add",value:function(t){var e=1<arguments.length&&void 0!==arguments[1]?arguments[1]:null;this._select.add(t,e)}},{key:"remove",value:function(t){this._select.remove(t)}},{key:"_select",get:function(){return this.querySelector("select")}}],[{key:"observedAttributes",get:function(){return["modifier","class"].concat(Pa)}}]),e}();i.Select=Oa,customElements.define("ons-select",Oa);var xa="fab fab--mini speed-dial__item",Ta={"":"fab--* speed-dial__item--*"},La=function(t){function e(){h(this,e);var t=m(this,(e.__proto__||Object.getPrototypeOf(e)).call(this));return t._compile(),t._boundOnClick=t._onClick.bind(t),t}return a(e,Zi),d(e,[{key:"attributeChangedCallback",value:function(t,e,n){switch(t){case"class":W.restoreClass(this,xa,Ta);break;case"modifier":O.onModifierChanged(e,n,this,Ta),W.addModifier(this,"mini");break;case"ripple":this._updateRipple()}}},{key:"connectedCallback",value:function(){this.addEventListener("click",this._boundOnClick,!1)}},{key:"disconnectedCallback",value:function(){this.removeEventListener("click",this._boundOnClick,!1)}},{key:"_updateRipple",value:function(){W.updateRipple(this)}},{key:"_onClick",value:function(t){t.stopPropagation()}},{key:"_compile",value:function(){var e=this;P.prepare(this),xa.split(/\s+/).forEach(function(t){return e.classList.add(t)}),W.addModifier(this,"mini"),this._updateRipple(),O.initModifier(this,Ta)}}],[{key:"observedAttributes",get:function(){return["modifier","ripple","class"]}}]),e}();i.SpeedDialItem=La,customElements.define("ons-speed-dial-item",La);var Ma="speed-dial",Da={"":"speed-dial--*"},Ia=function(t){function e(){h(this,e);var t=m(this,(e.__proto__||Object.getPrototypeOf(e)).call(this));return xt(t,function(){t._compile()}),t._itemShown=!1,t._boundOnClick=t._onClick.bind(t),t}return a(e,Zi),d(e,[{key:"_compile",value:function(){this.classList.add(Ma),P.prepare(this),this._updateRipple(),O.initModifier(this,Da),this.hasAttribute("direction")?this._updateDirection(this.getAttribute("direction")):this._updateDirection("up"),this._updatePosition()}},{key:"attributeChangedCallback",value:function(t,e,n){var i=this;switch(t){case"class":W.restoreClass(this,Ma,Da);break;case"modifier":O.onModifierChanged(e,n,this,Da);break;case"ripple":xt(this,function(){return i._updateRipple()});break;case"direction":xt(this,function(){return i._updateDirection(n)});break;case"position":xt(this,function(){return i._updatePosition()})}}},{key:"connectedCallback",value:function(){this.addEventListener("click",this._boundOnClick,!1)}},{key:"disconnectedCallback",value:function(){this.removeEventListener("click",this._boundOnClick,!1)}},{key:"_onClick",value:function(t){return this.onClick?(this.onClick.apply(this),Promise.resolve()):!this.disabled&&this.visible?this.toggleItems():void 0}},{key:"_show",value:function(){return this.inline?Promise.resolve():this.show()}},{key:"_hide",value:function(){var e=this;return new Promise(function(t){e.inline?t():setImmediate(function(){return e.hide().then(t)})})}},{key:"_updateRipple",value:function(){this._fab&&(this.hasAttribute("ripple")?this._fab.setAttribute("ripple",""):this._fab.removeAttribute("ripple"))}},{key:"_updateDirection",value:function(t){for(var e=this.items,n=0;n<e.length;n++)l(e[n],{transitionDelay:25*n+"ms",bottom:"auto",right:"auto",top:"auto",left:"auto"});switch(t){case"up":for(var i=0;i<e.length;i++)e[i].style.bottom=72+56*i+"px",e[i].style.right="8px";break;case"down":for(var o=0;o<e.length;o++)e[o].style.top=72+56*o+"px",e[o].style.left="8px";break;case"left":for(var r=0;r<e.length;r++)e[r].style.top="8px",e[r].style.right=72+56*r+"px";break;case"right":for(var a=0;a<e.length;a++)e[a].style.top="8px",e[a].style.left=72+56*a+"px";break;default:W.throw("Argument must be one of up, down, left or right.")}}},{key:"_updatePosition",value:function(){var t=this.getAttribute("position");switch(this.classList.remove("fab--top__left","fab--bottom__right","fab--bottom__left","fab--top__right","fab--top__center","fab--bottom__center"),t){case"top right":case"right top":this.classList.add("fab--top__right");break;case"top left":case"left top":this.classList.add("fab--top__left");break;case"bottom right":case"right bottom":this.classList.add("fab--bottom__right");break;case"bottom left":case"left bottom":this.classList.add("fab--bottom__left");break;case"center top":case"top center":this.classList.add("fab--top__center");break;case"center bottom":case"bottom center":this.classList.add("fab--bottom__center")}}},{key:"_getTranslate",value:function(){return 0<=(this.getAttribute("position")||"").indexOf("bottom")?"translate3d(0px, -"+(W.globals.fabOffset||0)+"px, 0px) ":""}},{key:"show",value:function(){return this._fab.show(),l(this,{transform:this._getTranslate}),Promise.resolve()}},{key:"hide",value:function(){var t=this;return this.hideItems().then(function(){return t._fab.hide()})}},{key:"showItems",value:function(){this.hasAttribute("direction")?this._updateDirection(this.getAttribute("direction")):this._updateDirection("up");var t=0;if(!this._itemShown){for(var e=this.items,n=0;n<e.length;n++){var i=25*n;t+=i,l(e[n],{transform:"scale(1)",transitionDelay:i+"ms"})}t+=50,this._itemShown=!0,W.triggerElementEvent(this,"open")}var o=W.defer();return setTimeout(o.resolve,t),o.promise}},{key:"hideItems",value:function(){var t=0;if(this._itemShown){for(var e=this.items,n=0;n<e.length;n++){var i=25*(e.length-n);t+=i,l(e[n],{transform:"scale(0)",transitionDelay:i+"ms"})}t+=50,this._itemShown=!1,W.triggerElementEvent(this,"close")}var o=W.defer();return setTimeout(o.resolve,t),o.promise}},{key:"isOpen",value:function(){return this._itemShown}},{key:"toggle",value:function(){return this.visible?this.hide():this.show()}},{key:"toggleItems",value:function(){return this.isOpen()?this.hideItems():this.showItems()}},{key:"items",get:function(){return W.arrayFrom(this.querySelectorAll("ons-speed-dial-item"))}},{key:"_fab",get:function(){return W.findChild(this,"ons-fab")}},{key:"disabled",set:function(e){return e&&this.hideItems(),W.arrayFrom(this.children).forEach(function(t){W.match(t,".fab")&&W.toggleAttribute(t,"disabled",e)}),W.toggleAttribute(this,"disabled",e)},get:function(){return this.hasAttribute("disabled")}},{key:"inline",get:function(){return this.hasAttribute("inline")}},{key:"visible",get:function(){return this._fab.visible&&"none"!==this.style.display}}],[{key:"observedAttributes",get:function(){return["class","modifier","ripple","direction","position"]}},{key:"events",get:function(){return["open","close"]}}]),e}();i.SpeedDial=Ia,customElements.define("ons-speed-dial",Ia);var Na={ready:function(t,e){setImmediate(e)}},Ba=function(t){function n(){h(this,n);var e=m(this,(n.__proto__||Object.getPrototypeOf(n)).call(this));return e._page=null,e._pageLoader=$t,xt(e,function(){Na.ready(e,function(){var t=e._getPageTarget();t&&e.load(t)})}),e}return a(n,Zi),d(n,[{key:"connectedCallback",value:function(){W.match(this.parentNode,"ons-splitter")||W.throw('"ons-splitter-content" must have "ons-splitter" as parent')}},{key:"_getPageTarget",value:function(){return this._page||this.getAttribute("page")}},{key:"disconnectedCallback",value:function(){}},{key:"attributeChangedCallback",value:function(t,e,n){}},{key:"load",value:function(t){var i=this,e=1<arguments.length&&void 0!==arguments[1]?arguments[1]:{};this._page=t;var o=e.callback||function(){};return new Promise(function(e){var n=i._content||null;i._pageLoader.load({page:t,parent:i},function(t){n&&(i._pageLoader.unload(n),n=null),setImmediate(function(){return i._show()}),o(t),e(t)})})}},{key:"_show",value:function(){this._content&&this._content._show()}},{key:"_hide",value:function(){this._content&&this._content._hide()}},{key:"_destroy",value:function(){this._content&&this._pageLoader.unload(this._content),this.remove()}},{key:"page",get:function(){return this._page},set:function(t){this._page=t}},{key:"_content",get:function(){return this.children[0]}},{key:"pageLoader",get:function(){return this._pageLoader},set:function(t){t instanceof Gt||W.throwPageLoader(),this._pageLoader=t}}],[{key:"observedAttributes",get:function(){return[]}},{key:"rewritables",get:function(){return Na}}]),n}();i.SplitterContent=Ba,customElements.define("ons-splitter-content",Ba);var ja=function(t){function e(){h(this,e);var t=m(this,(e.__proto__||Object.getPrototypeOf(e)).call(this));return t._boundOnClick=t._onClick.bind(t),xt(t,function(){t.parentNode._sides.every(function(t){return"split"===t.mode})&&t.setAttribute("style","display: none !important")}),t}return a(e,Zi),d(e,[{key:"_onClick",value:function(t){this.onClick instanceof Function?this.onClick():W.match(this.parentNode,"ons-splitter")&&this.parentNode._sides.forEach(function(t){return t.close("left").catch(function(){})}),t.stopPropagation()}},{key:"attributeChangedCallback",value:function(t,e,n){}},{key:"connectedCallback",value:function(){this.addEventListener("click",this._boundOnClick),W.iosMaskScrollFix(this,!0)}},{key:"disconnectedCallback",value:function(){this.removeEventListener("click",this._boundOnClick),W.iosMaskScrollFix(this,!1)}}],[{key:"observedAttributes",get:function(){return[]}}]),e}();i.SplitterMask=ja,customElements.define("ons-splitter-mask",ja);var Ha=function(t){function s(){var t=0<arguments.length&&void 0!==arguments[0]?arguments[0]:{},e=t.timing,n=void 0===e?"cubic-bezier(.1, .7, .1, 1)":e,i=t.duration,o=void 0===i?.3:i,r=t.delay,a=void 0===r?0:r;return h(this,s),m(this,(s.__proto__||Object.getPrototypeOf(s)).call(this,{timing:n,duration:o,delay:a}))}return a(s,no),d(s,[{key:"updateOptions",value:function(){var t=0<arguments.length&&void 0!==arguments[0]?arguments[0]:{};W.extend(this,{timing:this.timing,duration:this.duration,delay:this.delay},t)}},{key:"activate",value:function(t){var e=this,n=t.parentNode;xt(n,function(){e._side=t,e._oppositeSide=n.right!==t&&n.right||n.left!==t&&n.left,e._content=n.content,e._mask=n.mask})}},{key:"deactivate",value:function(){this.clearTransition(),this._mask&&this.clearMask(),this._content=this._side=this._oppositeSide=this._mask=null}},{key:"clearTransition",value:function(){var e=this;"side mask content".split(/\s+/).forEach(function(t){return e["_"+t]&&l.clear(e["_"+t],"transform transition")})}},{key:"clearMask",value:function(){this._oppositeSide&&"split"!==this._oppositeSide.mode&&this._oppositeSide.isOpen||(this._mask.style.opacity="",this._mask.style.display="none")}},{key:"translate",value:function(t){}},{key:"open",value:function(t){t()}},{key:"close",value:function(t){t()}},{key:"minus",get:function(){return"right"===this._side.side?"-":""}}]),s}(),Ra=function(t){function e(){return h(this,e),m(this,(e.__proto__||Object.getPrototypeOf(e)).apply(this,arguments))}return a(e,Ha),d(e,[{key:"translate",value:function(t){this._mask.style.display="block",it(this._side).queue({transform:"translate3d("+(this.minus+t)+"px, 0, 0)"}).play()}},{key:"open",value:function(e){it.runAll(it(this._side).wait(this.delay).queue({transform:"translate3d("+this.minus+"100%, 0, 0)"},this.def).queue(function(t){t(),e&&e()}),it(this._mask).wait(this.delay).queue({display:"block"}).queue({opacity:"1"},{duration:this.duration,timing:"linear"}))}},{key:"close",value:function(e){it.runAll(it(this._side).wait(this.delay).queue({transform:"translate3d(0, 0, 0)"},this.def).queue(function(t){e&&e(),t()}),it(this._mask).wait(this.delay).queue({opacity:"0"},{duration:this.duration,timing:"linear"}).queue({display:"none"}))}}]),e}(),Fa={default:Ra,overlay:Ra,push:function(t){function i(){return h(this,i),m(this,(i.__proto__||Object.getPrototypeOf(i)).apply(this,arguments))}return a(i,Ha),d(i,[{key:"_getSlidingElements",value:function(){var t=[this._side,this._content];return this._oppositeSide&&"split"===this._oppositeSide.mode&&t.push(this._oppositeSide),t}},{key:"translate",value:function(t){this._slidingElements||(this._slidingElements=this._getSlidingElements()),this._mask.style.display="block",it(this._slidingElements).queue({transform:"translate3d("+(this.minus+t)+"px, 0, 0)"}).play()}},{key:"open",value:function(e){var n=this,t=this._side.offsetWidth;this._slidingElements=this._getSlidingElements(),it.runAll(it(this._slidingElements).wait(this.delay).queue({transform:"translate3d("+(this.minus+t)+"px, 0, 0)"},this.def).queue(function(t){n._slidingElements=null,t(),e&&e()}),it(this._mask).wait(this.delay).queue({display:"block"}))}},{key:"close",value:function(e){var n=this;this._slidingElements=this._getSlidingElements(),it.runAll(it(this._slidingElements).wait(this.delay).queue({transform:"translate3d(0, 0, 0)"},this.def).queue(function(t){n._slidingElements=null,p(i.prototype.__proto__||Object.getPrototypeOf(i.prototype),"clearTransition",n).call(n),e&&e(),t()}),it(this._mask).wait(this.delay).queue({display:"none"}))}}]),i}(),reveal:function(t){function e(){return h(this,e),m(this,(e.__proto__||Object.getPrototypeOf(e)).apply(this,arguments))}return a(e,Ha),d(e,[{key:"_getSlidingElements",value:function(){var t=[this._content,this._mask];return this._oppositeSide&&"split"===this._oppositeSide.mode&&t.push(this._oppositeSide),t}},{key:"activate",value:function(t){p(e.prototype.__proto__||Object.getPrototypeOf(e.prototype),"activate",this).call(this,t),"collapse"===t.mode&&this._setStyles(t)}},{key:"deactivate",value:function(){this._side&&this._unsetStyles(this._side),p(e.prototype.__proto__||Object.getPrototypeOf(e.prototype),"deactivate",this).call(this)}},{key:"_setStyles",value:function(t){l(t,{left:"right"===t.side?"auto":0,right:"right"===t.side?0:"auto",zIndex:0,backgroundColor:"black",transform:this._generateBehindPageStyle(0).container.transform,display:"none"});var e=t.parentElement;xt(e,function(){return e.content&&l(e.content,{boxShadow:"0 0 12px 0 rgba(0, 0, 0, 0.2)"})})}},{key:"_unsetStyles",value:function(t){l.clear(t,"left right zIndex backgroundColor display"),t._content&&(t._content.style.opacity=""),this._oppositeSide&&"split"!==this._oppositeSide.mode||t.parentElement.content&&l.clear(t.parentElement.content,"boxShadow")}},{key:"_generateBehindPageStyle",value:function(t){var e=this.maxWidth,n=(t-e)/e*10;return{content:{opacity:1+(n=isNaN(n)?0:Math.max(Math.min(n,0),-10))/100},container:{transform:"translate3d("+(this.minus?-1:1)*n+"%, 0, 0)"}}}},{key:"translate",value:function(t){this._side.style.display="",this._side.style.zIndex=1,this.maxWidth=this.maxWidth||this._getMaxWidth();var e=this._generateBehindPageStyle(Math.min(t,this.maxWidth));this._slidingElements||(this._slidingElements=this._getSlidingElements()),this._mask.style.display="block",it.runAll(it(this._slidingElements).queue({transform:"translate3d("+(this.minus+t)+"px, 0, 0)"}),it(this._side._content).queue(e.content),it(this._side).queue(e.container))}},{key:"open",value:function(e){var n=this;this._side.style.display="",this._side.style.zIndex=1,this.maxWidth=this.maxWidth||this._getMaxWidth();var t=this._generateBehindPageStyle(this.maxWidth);this._slidingElements=this._getSlidingElements(),setTimeout(function(){it.runAll(it(n._slidingElements).wait(n.delay).queue({transform:"translate3d("+(n.minus+n.maxWidth)+"px, 0, 0)"},n.def),it(n._mask).wait(n.delay).queue({display:"block"}),it(n._side._content).wait(n.delay).queue(t.content,n.def),it(n._side).wait(n.delay).queue(t.container,n.def).queue(function(t){n._slidingElements=null,t(),e&&e()}))},1e3/60)}},{key:"close",value:function(e){var n=this,t=this._generateBehindPageStyle(0);this._slidingElements=this._getSlidingElements(),it.runAll(it(this._slidingElements).wait(this.delay).queue({transform:"translate3d(0, 0, 0)"},this.def),it(this._mask).wait(this.delay).queue({display:"none"}),it(this._side._content).wait(this.delay).queue(t.content,this.def),it(this._side).wait(this.delay).queue(t.container,this.def).queue(function(t){n._slidingElements=null,n._side.style.zIndex=0,n._side.style.display="none",n._side._content.style.opacity="",e&&e(),t()}))}},{key:"_getMaxWidth",value:function(){return this._side.offsetWidth}}]),e}()},qa=function(t){function e(){h(this,e);var t=m(this,(e.__proto__||Object.getPrototypeOf(e)).call(this));return t._onModeChange=t._onModeChange.bind(t),xt(t,function(){!t.mask&&t.appendChild(document.createElement("ons-splitter-mask")),t._layout()}),t}return a(e,Zi),d(e,[{key:"_getSide",value:function(e){return W.findChild(this,function(t){return W.match(t,"ons-splitter-side")&&t.getAttribute("side")===e})}},{key:"_onDeviceBackButton",value:function(t){this._sides.some(function(t){return!!t.isOpen&&t.close()})||t.callParentHandler()}},{key:"_onModeChange",value:function(t){var e=this;t.target.parentNode&&xt(this,function(){e._layout()})}},{key:"_layout",value:function(){var e=this;this._sides.forEach(function(t){e.content&&(e.content.style[t.side]="split"===t.mode?t.style.width:0)})}},{key:"left",get:function(){return this._getSide("left")}},{key:"right",get:function(){return this._getSide("right")}},{key:"side",get:function(){return W.findChild(this,"ons-splitter-side")}},{key:"_sides",get:function(){return[this.left,this.right].filter(function(t){return t})}},{key:"content",get:function(){return W.findChild(this,"ons-splitter-content")}},{key:"topPage",get:function(){return this.content._content}},{key:"mask",get:function(){return W.findChild(this,"ons-splitter-mask")}},{key:"onDeviceBackButton",get:function(){return this._backButtonHandler},set:function(t){this._backButtonHandler&&this._backButtonHandler.destroy(),this._backButtonHandler=M.createHandler(this,t)}}]),d(e,[{key:"connectedCallback",value:function(){this.onDeviceBackButton=this._onDeviceBackButton.bind(this),this.addEventListener("modechange",this._onModeChange,!1)}},{key:"disconnectedCallback",value:function(){this._backButtonHandler.destroy(),this._backButtonHandler=null,this.removeEventListener("modechange",this._onModeChange,!1)}},{key:"attributeChangedCallback",value:function(t,e,n){}},{key:"_show",value:function(){W.propagateAction(this,"_show")}},{key:"_hide",value:function(){W.propagateAction(this,"_hide")}},{key:"_destroy",value:function(){W.propagateAction(this,"_destroy"),this.remove()}}],[{key:"registerAnimator",value:function(t,e){e instanceof SplitterAnimator||W.throwAnimator("Splitter"),Fa[t]=e}},{key:"SplitterAnimator",get:function(){return SplitterAnimator}},{key:"animators",get:function(){return Fa}}]),e}();i.Splitter=qa,customElements.define("ons-splitter",qa);var za="split",Va="collapse",Wa="closed",Ua="changing",Xa={ready:function(t,e){setImmediate(e)}},Ya=function(){function n(t,e){h(this,n),this._element=t,this._onChange=this._onChange.bind(this),e&&this.changeTarget(e)}return d(n,[{key:"changeTarget",value:function(t){this.disable(),(this._target=t)&&(this._orientation=-1!==["portrait","landscape"].indexOf(t),this.activate())}},{key:"_match",value:function(t){return this._orientation?this._target===(t.isPortrait?"portrait":"landscape"):t.matches}},{key:"_onChange",value:function(t){this._element._updateMode(this._match(t)?Va:za)}},{key:"activate",value:function(){this._orientation?(Bt.on("change",this._onChange),this._onChange({isPortrait:Bt.isPortrait()})):(this._queryResult=window.matchMedia(this._target),this._queryResult.addListener(this._onChange),this._onChange(this._queryResult))}},{key:"disable",value:function(){this._orientation?Bt.off("change",this._onChange):this._queryResult&&(this._queryResult.removeListener(this._onChange),this._queryResult=null)}}]),n}(),Ga=function(t){function n(){h(this,n);var e=m(this,(n.__proto__||Object.getPrototypeOf(n)).call(this));return e._page=null,e._state=Wa,e._lock=new Wt,e._pageLoader=$t,e._collapseDetection=new Ya(e),e._animatorFactory=new y({animators:qa.animators,baseClass:Ha,baseClassName:"SplitterAnimator",defaultAnimation:e.getAttribute("animation")}),xt(e,function(){e.attributeChangedCallback("width"),e.hasAttribute("side")||e.setAttribute("side","left"),Xa.ready(e,function(){var t=e._page||e.getAttribute("page");t&&e.load(t)})}),e}return a(n,Zi),d(n,[{key:"connectedCallback",value:function(){var r=this;W.match(this.parentNode,"ons-splitter")||W.throw("Parent must be an ons-splitter element"),this._swipe=new Or({element:this,elementHandler:this.parentElement,swipeMax:function(){r._onSwipe&&r._onSwipe(1,r._animationOpt),r.open()},swipeMid:function(t,e){r._onSwipe&&r._onSwipe(t/e),r._animator.translate(t)},swipeMin:function(){r._onSwipe&&r._onSwipe(0,r._animationOpt),r.close()},getThreshold:function(){return Math.max(0,Math.min(1,parseFloat(r.getAttribute("open-threshold"))||.3))},getSide:function(){return r.side},isInitialState:function(){var t=r._state===Wa;return r._state=Ua,t},ignoreSwipe:function(t,e){var n,i=r.isOpen,o=Math.max(0,parseInt(r.getAttribute("swipe-target-width"),10)||0);return r._mode===za||r._lock.isLocked()||r._isOtherSideOpen()||(n=t.gesture.direction,!("left"===r.side?"left"===n&&i||"right"===n&&!i:"left"===n&&!i||"right"===n&&i))||!i&&0!==o&&o<e}}),this.attributeChangedCallback("swipeable"),xt(this,function(){r.constructor.observedAttributes.forEach(function(t){return r.attributeChangedCallback(t,null,r.getAttribute(t))})})}},{key:"disconnectedCallback",value:function(){this._swipe&&this._swipe.dispose(),this._animator=this._animationOpt=this._swipe=null}},{key:"attributeChangedCallback",value:function(t,e,n){switch(t){case"swipeable":this._swipe&&this._swipe.update();break;case"width":n=this.getAttribute("width"),this.style.width=/^\d+(px|%)$/.test(n)?n:"80%";break;default:this[W.camelize("_update-"+t)](n)}}},{key:"_emitEvent",value:function(t){if("pre"!==t.slice(0,3))return W.triggerElementEvent(this,t,{side:this});var e=!1;return W.triggerElementEvent(this,t,{side:this,cancel:function(){return e=!0}}),e}},{key:"_isOtherSideOpen",value:function(){var e=this;return!!W.findChild(this.parentElement,function(t){return t instanceof e.constructor&&t!==e&&t._mode===Va&&t.isOpen})}},{key:"_updateCollapse",value:function(){var t=0<arguments.length&&void 0!==arguments[0]?arguments[0]:this.getAttribute("collapse");return null===t||"split"===t?(this._collapseDetection.disable(),this._updateMode(za)):""===t||"collapse"===t?(this._collapseDetection.disable(),this._updateMode(Va)):void this._collapseDetection.changeTarget(t)}},{key:"_updateMode",value:function(t){t!==this._mode&&(this._mode=t,this.setAttribute("mode",t),t===za?(this._animator&&this._animator.deactivate(),this._state=Wa):(this._animator&&this._animator.activate(this),"open"===this._state&&this._animator.open()),W.triggerElementEvent(this,"modechange",{side:this,mode:t}))}},{key:"_updateAnimation",value:function(){var t=0<arguments.length&&void 0!==arguments[0]?arguments[0]:this.getAttribute("animation");this.parentNode&&(this._animator&&this._animator.deactivate(),this._animator=this._animatorFactory.newAnimator({animation:t}),this._animator.activate(this),this._animationOpt={timing:this._animator.duration,duration:this._animator.duration})}},{key:"_updateAnimationOptions",value:function(){var t=0<arguments.length&&void 0!==arguments[0]?arguments[0]:this.getAttribute("animation-options");this._animator.updateOptions(y.parseAnimationOptionsString(t))}},{key:"open",value:function(t){return this.toggle(t,!0)}},{key:"close",value:function(t){return this.toggle(t,!1)}},{key:"toggle",value:function(){var e=this,n=0<arguments.length&&void 0!==arguments[0]?arguments[0]:{},t=arguments[1],i="boolean"==typeof t?t:!this.isOpen,o=i?"open":"close",r=i?"open":Wa;if(this._mode===za)return Promise.resolve(!1);if(this._state===r)return Promise.resolve(this);if(this._lock.isLocked())return Promise.reject("Another splitter-side action is already running.");if(i&&this._isOtherSideOpen())return Promise.reject("Another menu is already open.");if(this._emitEvent("pre"+o))return Promise.reject("Canceled in pre"+o+" event.");var a=this._lock.lock();return this._state=Ua,n.animation&&this._updateAnimation(n.animation),new Promise(function(t){e._animator[o](function(){W.iosPageScrollFix(i),e._state=r,a(),e._emitEvent("post"+o),n.callback instanceof Function&&n.callback(e),t(e)})})}},{key:"load",value:function(t){var i=this,e=1<arguments.length&&void 0!==arguments[1]?arguments[1]:{};this._page=t;var o=e.callback||function(){};return new Promise(function(e){var n=i._content||null;i._pageLoader.load({page:t,parent:i},function(t){n&&(i._pageLoader.unload(n),n=null),setImmediate(function(){return i._show()}),o(t),e(t)})})}},{key:"_show",value:function(){this._content&&this._content._show()}},{key:"_hide",value:function(){this._content&&this._content._hide()}},{key:"_destroy",value:function(){this._content&&this._pageLoader.unload(this._content),this.remove()}},{key:"side",get:function(){return"right"===this.getAttribute("side")?"right":"left"}},{key:"page",get:function(){return this._page},set:function(t){this._page=t}},{key:"_content",get:function(){return this.children[0]}},{key:"pageLoader",get:function(){return this._pageLoader},set:function(t){t instanceof Gt||W.throwPageLoader(),this._pageLoader=t}},{key:"mode",get:function(){return this._mode}},{key:"onSwipe",get:function(){return this._onSwipe},set:function(t){!t||t instanceof Function||W.throw('"onSwipe" must be a function'),this._onSwipe=t}},{key:"isOpen",get:function(){return this._mode===Va&&this._state!==Wa}}],[{key:"observedAttributes",get:function(){return["animation","width","collapse","swipeable","animation-options"]}},{key:"events",get:function(){return["preopen","postopen","preclose","postclose","modechange"]}},{key:"rewritables",get:function(){return Xa}}]),n}();i.SplitterSide=Ga,customElements.define("ons-splitter-side",Ga);var $a={"":"switch--*",".switch__input":"switch--*__input",".switch__handle":"switch--*__handle",".switch__toggle":"switch--*__toggle"},Ka={ios:[1,21],material:[0,16]},Qa=function(t){function o(){h(this,o);var t=m(this,(o.__proto__||Object.getPrototypeOf(o)).call(this));return xt(t,function(){t.attributeChangedCallback("modifier",null,t.getAttribute("modifier"))}),t._onChange=t._onChange.bind(t),t._onRelease=t._onRelease.bind(t),t._lastTimeStamp=0,t}return a(o,gr),d(o,[{key:"_getPosition",value:function(t){var e=this._locations;return Math.min(e[1],Math.max(e[0],this._startX+t.gesture.deltaX))}},{key:"_emitChangeEvent",value:function(){W.triggerElementEvent(this,"change",{value:this.checked,switch:this,isInteractive:!0})}},{key:"_onChange",value:function(t){t&&t.stopPropagation&&t.stopPropagation(),this._emitChangeEvent()}},{key:"_onClick",value:function(t){(t.target.classList.contains(this.defaultElementClass+"__touch")||t.timeStamp-this._lastTimeStamp<50)&&t.preventDefault(),this._lastTimeStamp=t.timeStamp}},{key:"_onHold",value:function(t){this.disabled||(O.addModifier(this,"active"),document.addEventListener("release",this._onRelease))}},{key:"_onDragStart",value:function(t){this.disabled||-1===["left","right"].indexOf(t.gesture.direction)?O.removeModifier(this,"active"):(t.consumed=!0,O.addModifier(this,"active"),this._startX=this._locations[this.checked?1:0],this.addEventListener("drag",this._onDrag),document.addEventListener("release",this._onRelease))}},{key:"_onDrag",value:function(t){t.stopPropagation(),this._handle.style.left=this._getPosition(t)+"px"}},{key:"_onRelease",value:function(t){var e=this._locations,n=this._getPosition(t),i=this.checked;this.checked=n>=(e[0]+e[1])/2,this.checked!==i&&this._emitChangeEvent(),this.removeEventListener("drag",this._onDrag),document.removeEventListener("release",this._onRelease),this._handle.style.left="",O.removeModifier(this,"active")}},{key:"click",value:function(){var t=0<arguments.length&&void 0!==arguments[0]?arguments[0]:{};this.disabled||(this.checked=!this.checked,this._emitChangeEvent(),this._lastTimeStamp=t.timeStamp||0)}},{key:"connectedCallback",value:function(){var t=this;xt(this,function(){t._input.addEventListener("change",t._onChange)}),this.addEventListener("dragstart",this._onDragStart),this.addEventListener("hold",this._onHold),this.addEventListener("tap",this.click),this.addEventListener("click",this._onClick),this._gestureDetector=new ot(this,{dragMinDistance:1,holdTimeout:251,passive:!0})}},{key:"disconnectedCallback",value:function(){var t=this;xt(this,function(){t._input.removeEventListener("change",t._onChange)}),this.removeEventListener("dragstart",this._onDragStart),this.removeEventListener("hold",this._onHold),this.removeEventListener("tap",this.click),this.removeEventListener("click",this._onClick),this._gestureDetector&&this._gestureDetector.dispose()}},{key:"attributeChangedCallback",value:function(t,e,n){if("modifier"===t){var i=-1!==(n||"").indexOf("material");this._locations=Ka[i?"material":"ios"]}p(o.prototype.__proto__||Object.getPrototypeOf(o.prototype),"attributeChangedCallback",this).call(this,t,e,n)}},{key:"_scheme",get:function(){return $a}},{key:"_defaultClassName",get:function(){return"switch"}},{key:"_template",get:function(){return'\n      <input type="'+this.type+'" class="'+this._defaultClassName+'__input">\n      <div class="'+this._defaultClassName+'__toggle">\n        <div class="'+this._defaultClassName+'__handle">\n          <div class="'+this._defaultClassName+'__touch"></div>\n        </div>\n      </div>\n    '}},{key:"type",get:function(){return"checkbox"}},{key:"_handle",get:function(){return this.querySelector("."+this._defaultClassName+"__handle")}},{key:"checkbox",get:function(){return this._input}}],[{key:"observedAttributes",get:function(){return[].concat(_(p(o.__proto__||Object.getPrototypeOf(o),"observedAttributes",this)),["modifier"])}}]),o}();i.Switch=Qa,customElements.define("ons-switch",Qa);var Ja={".tabbar__content":"tabbar--*__content",".tabbar__border":"tabbar--*__border",".tabbar":"tabbar--*"},Za={ready:function(t,e){e()}},ts=function(t,e,n){return(1-n)*t+n*e},es=function(t){function e(){h(this,e);var t=m(this,(e.__proto__||Object.getPrototypeOf(e)).call(this));return t._loadInactive=W.defer(),xt(t,function(){return t._compile()}),t}return a(e,Zi),d(e,[{key:"connectedCallback",value:function(){var t=this;this._swiper||(this._swiper=new Do({getElement:function(){return t._contentElement},getInitialIndex:function(){return t.getAttribute("activeIndex")||t.getAttribute("active-index")},getAutoScrollRatio:this._getAutoScrollRatio.bind(this),getBubbleWidth:function(){return parseInt(t.getAttribute("ignore-edge-width")||25,10)},isAutoScrollable:function(){return!0},preChangeHook:this._onPreChange.bind(this),postChangeHook:this._onPostChange.bind(this),refreshHook:this._onRefresh.bind(this),scrollHook:this._onScroll.bind(this)}),xt(this,function(){t._tabbarBorder=W.findChild(t._tabbarElement,".tabbar__border"),t._swiper.init({swipeable:t.hasAttribute("swipeable")})})),xt(this,function(){t._updatePosition(),W.findParent(t,"ons-page",function(t){return t===document.body})||t._show()})}},{key:"disconnectedCallback",value:function(){this._swiper&&this._swiper.initialized&&(this._swiper.dispose(),this._swiper=null,this._tabbarBorder=null,this._tabsRect=null)}},{key:"_normalizeEvent",value:function(t){return f({},t,{index:t.activeIndex,tabItem:this.tabs[t.activeIndex]})}},{key:"_onPostChange",value:function(t){t=this._normalizeEvent(t),W.triggerElementEvent(this,"postchange",t);var e=t.tabItem.pageElement;e&&e._show()}},{key:"_onPreChange",value:function(t){if((t=this._normalizeEvent(t)).cancel=function(){return t.canceled=!0},W.triggerElementEvent(this,"prechange",t),!t.canceled){var e=t,n=e.activeIndex,i=e.lastActiveIndex,o=this.tabs;if(o[n].setActive(!0),0<=i){var r=o[i];r.setActive(!1),r.pageElement&&r.pageElement._hide()}}return t.canceled}},{key:"_onScroll",value:function(t){var e=1<arguments.length&&void 0!==arguments[1]?arguments[1]:{};if(this._tabbarBorder)if(this._tabbarBorder.style.transition="all "+(e.duration||0)+"s "+(e.timing||""),this._autogrow&&0<this._tabsRect.length){var n=Math.floor(t),i=Math.ceil(t),o=t%1;this._tabbarBorder.style.width=ts(this._tabsRect[n].width,this._tabsRect[i].width,o)+"px",this._tabbarBorder.style.transform="translate3d("+ts(this._tabsRect[n].left,this._tabsRect[i].left,o)+"px, 0, 0)"}else this._tabbarBorder.style.transform="translate3d("+100*t+"%, 0, 0)";this._onSwipe&&this._onSwipe(t,e)}},{key:"_onRefresh",value:function(){if(this._autogrow=W.hasModifier(this,"autogrow"),this._tabsRect=this.tabs.map(function(t){return t.getBoundingClientRect()}),this._tabbarBorder){this._tabbarBorder.style.display=this.hasAttribute("tab-border")||W.hasModifier(this,"material")?"block":"none";var t=this.getActiveTabIndex();0<this._tabsRect.length&&0<=t&&(this._tabbarBorder.style.width=this._tabsRect[t].width+"px")}}},{key:"_getAutoScrollRatio",value:function(t,e,n){var i=n/300*(t?-1:1);return Math.min(1,Math.max(0,.6+e*i))}},{key:"_compile",value:function(){P.prepare(this);var t=this._contentElement||W.create(".tabbar__content");t.classList.add("ons-tabbar__content");var e=this._tabbarElement||W.create(".tabbar");if(e.classList.add("ons-tabbar__footer"),!e.parentNode)for(;this.firstChild;)e.appendChild(this.firstChild);var n=Number(this.getAttribute("activeIndex"));e.children.length>n&&!W.findChild(e,"[active]")&&e.children[n].setAttribute("active",""),this._tabbarBorder=W.findChild(e,".tabbar__border")||W.create(".tabbar__border"),e.appendChild(this._tabbarBorder),e.classList.add("ons-swiper-tabbar"),!t.children[0]&&t.appendChild(document.createElement("div")),!t.children[1]&&t.appendChild(document.createElement("div")),t.appendChild=t.appendChild.bind(t.children[0]),t.insertBefore=t.insertBefore.bind(t.children[0]),this.appendChild(t),this.appendChild(e),O.initModifier(this,Ja)}},{key:"_updatePosition",value:function(){var i=this,t=0<arguments.length&&void 0!==arguments[0]?arguments[0]:this.getAttribute("position"),o=this._top="top"===t||"auto"===t&&W.hasModifier(this,"material"),r=o?W.addModifier:W.removeModifier;r(this,"top");var a=W.findParent(this,"ons-page");a&&xt(a,function(){var t=0;a.children[0]&&W.match(a.children[0],"ons-toolbar")&&(r(a.children[0],"noshadow"),t=1);var e=a._getContentElement(),n=window.getComputedStyle(a._getContentElement(),null);i.style.top=o?parseInt(n.getPropertyValue("padding-top"),10)-t+"px":"",e.style.top=n.top,e.style.top=""}),b.autoStatusBarFill(function(){var t=W.findParent(i,function(t){return t.hasAttribute("status-bar-fill")});W.toggleAttribute(i,"status-bar-fill",o&&!t)})}},{key:"setActiveTab",value:function(e){var n=this,i=1<arguments.length&&void 0!==arguments[1]?arguments[1]:{},t=this.getActiveTabIndex(),o=this.tabs[t],r=this.tabs[e];if(!r)return Promise.reject("Specified index does not match any tab.");if(e===t)return W.triggerElementEvent(this,"reactive",{index:e,activeIndex:e,tabItem:r}),Promise.resolve(r.pageElement);var a=r.pageElement;return(a?Promise.resolve(a):r.loaded).then(function(t){return n._swiper.setActiveIndex(e,f({reject:!0},i,{animation:o&&t?i.animation||n.getAttribute("animation"):"none",animationOptions:W.extend({duration:.3,timing:"cubic-bezier(.4, .7, .5, 1)"},n.hasAttribute("animation-options")?W.animationOptionsParse(n.getAttribute("animation-options")):{},i.animationOptions||{})})).then(function(){return i.callback instanceof Function&&i.callback(t),t})})}},{key:"setTabbarVisibility",value:function(t){var e=this;xt(this,function(){e._contentElement.style[e._top?"top":"bottom"]=t?"":"0px",e._tabbarElement.style.display=t?"":"none",t&&e._onRefresh()})}},{key:"show",value:function(){this.setTabbarVisibility(!0)}},{key:"hide",value:function(){this.setTabbarVisibility(!1)}},{key:"getActiveTabIndex",value:function(){for(var t=0<arguments.length&&void 0!==arguments[0]?arguments[0]:this.tabs,e=0;e<t.length;e++)if(t[e]&&"ONS-TAB"===t[e].tagName&&t[e].isActive())return e;return-1}},{key:"_show",value:function(){var n=this;this._swiper.show(),setImmediate(function(){var t=n.tabs,e=n.getActiveTabIndex(t);n._loadInactive.resolve(),0<t.length&&0<=e&&t[e].loaded.then(function(t){return t&&setImmediate(function(){return t._show()})})})}},{key:"_hide",value:function(){this._swiper.hide();var t=this.topPage;t&&t._hide()}},{key:"_destroy",value:function(){this.tabs.forEach(function(t){return t.remove()}),this.remove()}},{key:"attributeChangedCallback",value:function(t,e,n){if("modifier"===t){O.onModifierChanged(e,n,this,Ja);var i=function(t){return/(^|\s+)top($|\s+)/i.test(t)};i(e)!==i(n)&&this._updatePosition()}else"position"===t?W.isAttached(this)&&this._updatePosition():"swipeable"===t?this._swiper&&this._swiper.updateSwipeable(this.hasAttribute("swipeable")):"hide-tabs"===t&&this.setTabbarVisibility(!this.hasAttribute("hide-tabs")||"false"===n)}},{key:"_tabbarElement",get:function(){return W.findChild(this,".tabbar")}},{key:"_contentElement",get:function(){return W.findChild(this,".tabbar__content")}},{key:"_targetElement",get:function(){var t=this._contentElement;return t&&t.children[0]||null}},{key:"topPage",get:function(){var t=this.tabs,e=this.getActiveTabIndex();return t[e]&&(t[e].pageElement||this.pages[0])||null}},{key:"pages",get:function(){return W.arrayFrom(this._targetElement.children)}},{key:"tabs",get:function(){return Array.prototype.filter.call(this._tabbarElement.children,function(t){return"ONS-TAB"===t.tagName})}},{key:"visible",get:function(){return"none"!==this._tabbarElement.style.display}},{key:"swipeable",get:function(){return this.hasAttribute("swipeable")},set:function(t){return W.toggleAttribute(this,"swipeable",t)}},{key:"onSwipe",get:function(){return this._onSwipe},set:function(t){!t||t instanceof Function||W.throw('"onSwipe" must be a function'),this._onSwipe=t}}],[{key:"observedAttributes",get:function(){return["modifier","position","swipeable","tab-border","hide-tabs"]}},{key:"rewritables",get:function(){return Za}},{key:"events",get:function(){return["prechange","postchange","reactive"]}}]),e}();i.Tabbar=es,customElements.define("ons-tabbar",es);var ns="tabbar__item",is={"":"tabbar--*__item",".tabbar__button":"tabbar--*__button"},os=function(t){function e(){h(this,e);var t=m(this,(e.__proto__||Object.getPrototypeOf(e)).call(this));return["label","icon","badge"].some(t.hasAttribute.bind(t))?t._compile():xt(t,function(){return t._compile()}),t._pageLoader=$t,t._onClick=t._onClick.bind(t),t}return a(e,Zi),d(e,[{key:"_compile",value:function(){if(P.prepare(this),this.classList.add(ns),!this._button){for(var t=W.create("button.tabbar__button");this.childNodes[0];)t.appendChild(this.childNodes[0]);var e=W.create("input",{display:"none"});e.type="radio",this.appendChild(e),this.appendChild(t),this._updateButtonContent(),O.initModifier(this,is),this._updateRipple()}}},{key:"_updateRipple",value:function(){this._button&&W.updateRipple(this._button,this.hasAttribute("ripple"))}},{key:"_updateButtonContent",value:function(){var t,i=this,o=this._button,e=this._icon;if(this.hasAttribute("icon")){var n=(e=e||W.createElement('<div class="tabbar__icon"><ons-icon></ons-icon></div>')).children[0],r=(t=n.getAttribute("icon"),function(){return n.attributeChangedCallback("icon",t,i.getAttribute("icon"))});n.setAttribute("icon",this.getAttribute("icon")),e.parentElement!==o&&o.insertBefore(e,o.firstChild),n.attributeChangedCallback instanceof Function?r():setImmediate(function(){return n.attributeChangedCallback instanceof Function&&r()})}else e&&e.remove();["label","badge"].forEach(function(t,e){var n=i.querySelector(".tabbar__"+t);i.hasAttribute(t)?((n=n||W.create(".tabbar__"+t+("badge"===t?" notification":""))).textContent=i.getAttribute(t),n.parentElement!==o&&o.appendChild(n)):n&&n.remove()})}},{key:"_onClick",value:function(){this.onClick instanceof Function?this.onClick():this._tabbar.setActiveTab(this.index,{reject:!1})}},{key:"setActive",value:function(){var t=!(0<arguments.length&&void 0!==arguments[0])||arguments[0];this._input.checked=t,this.classList.toggle("active",t),W.toggleAttribute(this,"active",t),this.hasAttribute("icon")&&this.hasAttribute("active-icon")&&this._icon.children[0].setAttribute("icon",this.getAttribute(t?"active-icon":"icon"))}},{key:"_loadPageElement",value:function(n,t){var i=this;return this._hasLoaded=!0,new Promise(function(e){i._pageLoader.load({parent:n,page:t},function(t){n.replaceChild(t,n.children[i.index]),i._loadedPage=t,e(t)})})}},{key:"isActive",value:function(){return this.classList.contains("active")}},{key:"disconnectedCallback",value:function(){this.removeEventListener("click",this._onClick,!1),this._loadedPage&&(this._hasLoaded=!1,this.loaded=null)}},{key:"connectedCallback",value:function(){var a=this;if(this.addEventListener("click",this._onClick,!1),W.isAttached(this)&&!this.loaded){var s=W.defer();this.loaded=s.promise,xt(this,function(){var o=a.index,r=a._tabbar;r||W.throw("Tab elements must be children of Tabbar"),r.hasAttribute("modifier")&&W.addModifier(a,r.getAttribute("modifier")),a._hasLoaded||(a.hasAttribute("active")&&(a.setActive(!0),r.setAttribute("activeIndex",o)),o===r.tabs.length-1&&(r._onRefresh(),setImmediate(function(){return r._onRefresh()})),es.rewritables.ready(r,function(){var t=a.page||a.getAttribute("page");if(a.pageElement||!t)return s.resolve(a.pageElement);var e=r._targetElement,n=W.create("div",{height:"100%",width:"100%",visibility:"hidden"});e.insertBefore(n,e.children[o]);var i=function(){return a._loadPageElement(e,t).then(s.resolve)};return a.isActive()?i():r._loadInactive.promise.then(i)}))})}}},{key:"attributeChangedCallback",value:function(t,e,n){var i=this;switch(t){case"class":W.restoreClass(this,ns,is);break;case"modifier":xt(this,function(){return O.onModifierChanged(e,n,i,is)});break;case"ripple":xt(this,function(){return i._updateRipple()});break;case"icon":case"label":case"badge":xt(this,function(){return i._updateButtonContent()});break;case"page":this.page=n||""}}},{key:"pageLoader",set:function(t){t instanceof Gt||W.throwPageLoader(),this._pageLoader=t},get:function(){return this._pageLoader}},{key:"_input",get:function(){return W.findChild(this,"input")}},{key:"_button",get:function(){return W.findChild(this,".tabbar__button")}},{key:"_icon",get:function(){return this.querySelector(".tabbar__icon")}},{key:"_tabbar",get:function(){return W.findParent(this,"ons-tabbar")}},{key:"index",get:function(){return Array.prototype.indexOf.call(this.parentElement.children,this)}},{key:"pageElement",get:function(){if(this._loadedPage)return this._loadedPage;var t=this._tabbar;return t.pages.length===t.tabs.length?t.pages[this.index]:null}}],[{key:"observedAttributes",get:function(){return["modifier","ripple","icon","label","page","badge","class"]}}]),e}();i.Tab=os,customElements.define("ons-tab",os);var rs=function(t){function s(){var t=0<arguments.length&&void 0!==arguments[0]?arguments[0]:{},e=t.timing,n=void 0===e?"linear":e,i=t.delay,o=void 0===i?0:i,r=t.duration,a=void 0===r?.2:r;return h(this,s),m(this,(s.__proto__||Object.getPrototypeOf(s)).call(this,{timing:n,delay:o,duration:a}))}return a(s,no),d(s,[{key:"show",value:function(t,e){e()}},{key:"hide",value:function(t,e){e()}}]),s}(),as=function(t){function s(){var t=0<arguments.length&&void 0!==arguments[0]?arguments[0]:{},e=t.timing,n=void 0===e?"linear":e,i=t.delay,o=void 0===i?0:i,r=t.duration,a=void 0===r?.3:r;return h(this,s),m(this,(s.__proto__||Object.getPrototypeOf(s)).call(this,{timing:n,delay:o,duration:a}))}return a(s,rs),d(s,[{key:"show",value:function(t,e){e=e||function(){},it(t,this.def).default({opacity:0},{opacity:1}).queue(function(t){e(),t()}).play()}},{key:"hide",value:function(t,e){e=e||function(){},it(t,this.def).default({opacity:1},{opacity:0}).queue(function(t){e(),t()}).play()}}]),s}(),ss=function(t){function l(){var t=0<arguments.length&&void 0!==arguments[0]?arguments[0]:{},e=t.timing,n=void 0===e?"ease":e,i=t.delay,o=void 0===i?0:i,r=t.duration,a=void 0===r?.25:r;h(this,l);var s=m(this,(l.__proto__||Object.getPrototypeOf(l)).call(this,{timing:n,delay:o,duration:a}));return s.messageDelay=.4*s.duration+s.delay,c.isAndroid()?s.ascension=48:io.isIPhoneXPortraitPatchActive()?s.ascension=98:io.isIPhoneXLandscapePatchActive()?s.ascension=85:s.ascension=64,s}return a(l,rs),d(l,[{key:"show",value:function(t,e){t=t._toast,W.globals.fabOffset=this.ascension,it.runAll(it(t,this.def).default({transform:"translate3d(0, "+this.ascension+"px, 0)"},{transform:"translate3d(0, 0, 0)"}).queue(function(t){e&&e(),t()}),it(this._getFabs()).wait(this.delay).queue({transform:"translate3d(0, -"+this.ascension+"px, 0) scale(1)"},this.def),it(W.arrayFrom(t.children),this.def).default({opacity:0},{opacity:1}))}},{key:"hide",value:function(t,e){t=t._toast,W.globals.fabOffset=0,it.runAll(it(t,this.def).default({transform:"translate3d(0, 0, 0)"},{transform:"translate3d(0, "+this.ascension+"px, 0)"}).queue(function(t){e&&e(),t()}),it(this._getFabs(),this.def).wait(this.delay).queue({transform:"translate3d(0, 0, 0) scale(1)"},this.def),it(W.arrayFrom(t.children),this.def).default({opacity:1},{opacity:0}))}},{key:"_getFabs",value:function(){return W.arrayFrom(document.querySelectorAll("ons-fab[position~=bottom], ons-speed-dial[position~=bottom]")).filter(function(t){return t.visible})}}]),l}(),ls=function(t){function l(){var t=0<arguments.length&&void 0!==arguments[0]?arguments[0]:{},e=t.timing,n=void 0===e?"ease":e,i=t.delay,o=void 0===i?0:i,r=t.duration,a=void 0===r?.35:r;h(this,l);var s=m(this,(l.__proto__||Object.getPrototypeOf(l)).call(this,{timing:n,delay:o,duration:a}));return s.bodyHeight=document.body.clientHeight,io.isIPhoneXPortraitPatchActive()?s.liftAmount="calc(100% + 34px)":io.isIPhoneXLandscapePatchActive()?s.liftAmount="calc(100% + 21px)":s.liftAmount="100%",s}return a(l,rs),d(l,[{key:"show",value:function(t,e){t=t._toast,it.runAll(it(t,this.def).default({transform:"translate3d(0, "+this.liftAmount+", 0)",opacity:0},{transform:"translate3d(0, 0, 0)",opacity:1}).queue(function(t){e&&e(),t()}))}},{key:"hide",value:function(t,e){t=t._toast,it.runAll(it(t,this.def).default({transform:"translate3d(0, 0, 0)",opacity:1},{transform:"translate3d(0, "+this.liftAmount+", 0)",opacity:0}).queue(function(t){e&&e(),t()}))}},{key:"_updatePosition",value:function(t){0===parseInt(t.style.top,10)&&(t.style.top=t.style.bottom="")}}]),l}(),us=function(t){function l(){var t=0<arguments.length&&void 0!==arguments[0]?arguments[0]:{},e=t.timing,n=void 0===e?"ease":e,i=t.delay,o=void 0===i?0:i,r=t.duration,a=void 0===r?.35:r;h(this,l);var s=m(this,(l.__proto__||Object.getPrototypeOf(l)).call(this,{timing:n,delay:o,duration:a}));return io.isIPhoneXPortraitPatchActive()?s.fallAmount="calc(-100% - 44px)":s.fallAmount="-100%",s}return a(l,rs),d(l,[{key:"show",value:function(t,e){t=t._toast,this._updatePosition(t),it.runAll(it(t,this.def).default({transform:"translate3d(0, "+this.fallAmount+", 0)",opacity:0},{transform:"translate3d(0, 0, 0)",opacity:1}).queue(function(t){e&&e(),t()}))}},{key:"hide",value:function(e,n){var i=this;e=e._toast,this._updatePosition(e),it.runAll(it(e,this.def).default({transform:"translate3d(0, 0, 0)",opacity:1},{transform:"translate3d(0, "+this.fallAmount+", 0)",opacity:0}).queue(function(t){i._updatePosition(e,!0),n&&n(),t()}))}},{key:"_updatePosition",value:function(t,e){var n=void 0;n=io.isIPhoneXPortraitPatchActive()?"44px":"0",t.style.top!==n&&(t.style.top=n,t.style.bottom="initial")}}]),l}(),cs={".toast":"toast--*",".toast__message":"toast--*__message",".toast__button":"toast--*__button"},hs="toast",ds={default:c.isAndroid()?ss:ls,fade:as,ascend:ss,lift:ls,fall:us,none:rs},fs=function(t){function e(){h(this,e);var t=m(this,(e.__proto__||Object.getPrototypeOf(e)).call(this));return t._defaultDBB=null,xt(t,function(){return t._compile()}),t}return a(e,so),d(e,[{key:"_updateAnimatorFactory",value:function(){return this._toast&&(this._toast.style.top=this._toast.style.bottom=""),new y({animators:ds,baseClass:rs,baseClassName:"ToastAnimator",defaultAnimation:this.getAttribute("animation")})}},{key:"_compile",value:function(){P.prepare(this),this.style.display="none",this.style.zIndex=1e4;var t="toast__message",e="toast__button",n=W.findChild(this,"."+hs);if(!n)for((n=document.createElement("div")).classList.add(hs);this.childNodes[0];)n.appendChild(this.childNodes[0]);var i=W.findChild(n,"."+e);if(i||(i=W.findChild(n,function(t){return W.match(t,".button")||W.match(t,"button")}))&&(i.classList.remove("button"),i.classList.add(e),n.appendChild(i)),!W.findChild(n,"."+t)){var o=W.findChild(n,".message");if(!o){o=document.createElement("div");for(var r=n.childNodes.length-1;0<=r;r--)n.childNodes[r]!==i&&o.insertBefore(n.childNodes[r],o.firstChild)}o.classList.add(t),n.insertBefore(o,n.firstChild)}n.parentNode!==this&&this.appendChild(n),O.initModifier(this,this._scheme)}},{key:"_scheme",get:function(){return cs}},{key:"_toast",get:function(){return W.findChild(this,"."+hs)}}],[{key:"registerAnimator",value:function(t,e){e.prototype instanceof rs||W.throw('"Animator" param must inherit OnsToastElement.ToastAnimator'),ds[t]=e}},{key:"animators",get:function(){return ds}},{key:"ToastAnimator",get:function(){return rs}}]),e}();i.Toast=fs,customElements.define("ons-toast",fs);var ps,gs=function(t){function e(){return h(this,e),m(this,(e.__proto__||Object.getPrototypeOf(e)).apply(this,arguments))}return a(e,ho),d(e,[{key:"_scheme",get:function(){return{"":"toolbar-button--*"}}},{key:"_defaultClassName",get:function(){return"toolbar-button"}},{key:"_rippleOpt",get:function(){return[this,void 0,{center:"",size:"contain",background:"transparent"}]}}]),e}();return i.ToolbarButton=gs,customElements.define("ons-toolbar-button",gs),ps=Qt,window._onsLoaded&&ps._util.warn("Onsen UI is loaded more than once."),window._onsLoaded=!0,window.addEventListener("load",function(){ps.fastClick=ee.attach(document.body);var t="touch-action"in document.body.style;ps.platform._runOnActualPlatform(function(){ps.platform.isAndroid()?ps.fastClick.destroy():ps.platform.isIOS()&&t&&(ps.platform.isIOSSafari()||ps.platform.isWKWebView())&&ps.fastClick.destroy()})},!1),ps.ready(function(){ps.enableDeviceBackButtonHandler(),ps._defaultDeviceBackButtonHandler=ps._internal.dbbDispatcher.createHandler(window.document.body,function(){Object.hasOwnProperty.call(navigator,"app")?navigator.app.exitApp():console.warn("Could not close the app. Is 'cordova.js' included?\nError: 'window.navigator.app' is undefined.")}),document.body._gestureDetector=new ps.GestureDetector(document.body,{passive:!0}),ps.platform.isWebView()||document.body.addEventListener("keydown",function(t){27===t.keyCode&&ps.fireDeviceBackButtonEvent()}),ps._setupLoadingPlaceHolders()}),Viewport.setup(),window._superSecretOns=Qt});
\ No newline at end of file
diff --git a/node_modules/onsenui/js/webpack.github-deploy.js b/node_modules/onsenui/js/webpack.github-deploy.js
new file mode 100644
index 0000000..7211e2b
--- /dev/null
+++ b/node_modules/onsenui/js/webpack.github-deploy.js
@@ -0,0 +1,81 @@
+/**
+ * @author: tipe.io
+ */
+const fs = require('fs');
+const path = require('path');
+const helpers = require('./helpers');
+const ghDeploy = require('./github-deploy');
+const webpackMerge = require('webpack-merge'); // used to merge webpack configs
+
+/**
+ * Webpack Constants
+ */
+const GIT_REMOTE_NAME = 'origin';
+const COMMIT_MESSAGE = 'Updates';
+const GH_REPO_NAME = ghDeploy.getRepoName(GIT_REMOTE_NAME);
+
+module.exports = function(options) {
+  const webpackConfigFactory = ghDeploy.getWebpackConfigModule(options); // the settings that are common to prod and dev
+  const webpackConfig = webpackConfigFactory(options);
+
+  /**
+   * Replace the instance of HtmlWebpackPlugin with an updated one.
+   */
+  ghDeploy.replaceHtmlWebpackPlugin(webpackConfig.plugins, GH_REPO_NAME);
+
+  return webpackMerge(webpackConfig, {
+
+    output: {
+      /**
+       * The public path is set to the REPO name.
+       *
+       * `HtmlElementsPlugin` will add it to all resources url's created by it.
+       * `HtmlWebpackPlugin` will add it to all webpack bundels/chunks.
+       *
+       * In theory publicPath shouldn't be used since the browser should automatically prefix the
+       * `baseUrl` into all URLs, however this is not the case when the URL is absolute (start with /)
+       *
+       * It's important to prefix & suffix the repo name with a slash (/).
+       * Prefixing so every resource will be absolute (otherwise it will be url.com/repoName/repoName...
+       * Suffixing since chunks will not do it automatically (testes against about page)
+       */
+      publicPath: '/' + GH_REPO_NAME + '/' + ghDeploy.safeUrl(webpackConfig.output.publicPath)
+    },
+
+    plugins: [
+      function() {
+        this.plugin('done', function(stats) {
+          console.log('Starting deployment to GitHub.');
+
+          const logger = function(msg) {
+            console.log(msg);
+          };
+
+          const options = {
+            logger: logger,
+            remote: GIT_REMOTE_NAME,
+            message: COMMIT_MESSAGE,
+            dotfiles: true // for .nojekyll
+          };
+          /**
+           * Since GitHub moved to Jekyll 3.3, their server ignores the "node_modules" and "vendors" folder by default.
+           * but, as of now, it also ignores "vendors*" files.
+           * This means vendor.bundle.js or vendor.[chunk].bundle.js will return 404.
+           * this is the fix for now.
+           */
+          fs.writeFileSync(path.join(webpackConfig.output.path, '.nojekyll'), '');
+
+          const ghpages = require('gh-pages');
+          ghpages.publish(webpackConfig.output.path, options, function(err) {
+            if (err) {
+              console.log('GitHub deployment done. STATUS: ERROR.');
+              throw err;
+            } else {
+              console.log('GitHub deployment done. STATUS: SUCCESS.');
+            }
+          });
+        });
+      }
+    ]
+  });
+};
